{
  "version": 3,
  "sources": ["../../three/build/three.core.js", "../../three/build/three.webgpu.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '172';\nconst MOUSE = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2,\n  ROTATE: 0,\n  DOLLY: 1,\n  PAN: 2\n};\nconst TOUCH = {\n  ROTATE: 0,\n  PAN: 1,\n  DOLLY_PAN: 2,\n  DOLLY_ROTATE: 3\n};\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst ConstantColorFactor = 211;\nconst OneMinusConstantColorFactor = 212;\nconst ConstantAlphaFactor = 213;\nconst OneMinusConstantAlphaFactor = 214;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\nconst AgXToneMapping = 6;\nconst NeutralToneMapping = 7;\nconst AttachedBindMode = 'attached';\nconst DetachedBindMode = 'detached';\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedInt248Type = 1020;\nconst UnsignedInt5999Type = 35902;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBIntegerFormat = 1032;\nconst RGBAIntegerFormat = 1033;\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst RGB_BPTC_SIGNED_Format = 36494;\nconst RGB_BPTC_UNSIGNED_Format = 36495;\nconst RED_RGTC1_Format = 36283;\nconst SIGNED_RED_RGTC1_Format = 36284;\nconst RED_GREEN_RGTC2_Format = 36285;\nconst SIGNED_RED_GREEN_RGTC2_Format = 36286;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst RGBDepthPacking = 3202;\nconst RGDepthPacking = 3203;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nconst NoColorSpace = '';\nconst SRGBColorSpace = 'srgb';\nconst LinearSRGBColorSpace = 'srgb-linear';\nconst LinearTransfer = 'linear';\nconst SRGBTransfer = 'srgb';\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\nconst NeverCompare = 512;\nconst LessCompare = 513;\nconst EqualCompare = 514;\nconst LessEqualCompare = 515;\nconst GreaterCompare = 516;\nconst NotEqualCompare = 517;\nconst GreaterEqualCompare = 518;\nconst AlwaysCompare = 519;\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\nconst GLSL1 = '100';\nconst GLSL3 = '300 es';\nconst WebGLCoordinateSystem = 2000;\nconst WebGPUCoordinateSystem = 2001;\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n  addEventListener(type, listener) {\n    if (this._listeners === undefined) this._listeners = {};\n    const listeners = this._listeners;\n    if (listeners[type] === undefined) {\n      listeners[type] = [];\n    }\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n  }\n  hasEventListener(type, listener) {\n    if (this._listeners === undefined) return false;\n    const listeners = this._listeners;\n    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n  }\n  removeEventListener(type, listener) {\n    if (this._listeners === undefined) return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n    if (listenerArray !== undefined) {\n      const index = listenerArray.indexOf(listener);\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n  dispatchEvent(event) {\n    if (this._listeners === undefined) return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n    if (listenerArray !== undefined) {\n      event.target = this;\n\n      // Make a copy, in case listeners are removed while iterating.\n      const array = listenerArray.slice(0);\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n      event.target = null;\n    }\n  }\n}\nconst _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];\nlet _seed = 1234567;\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toLowerCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toLowerCase();\n}\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo(n, m) {\n  return (n % m + m) % m;\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear(x, a1, a2, b1, b2) {\n  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp(x, y, value) {\n  if (x !== y) {\n    return (value - x) / (y - x);\n  } else {\n    return 0;\n  }\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt));\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong(x, length = 1) {\n  return length - Math.abs(euclideanModulo(x, length * 2) - length);\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n  x = (x - min) / (max - min);\n  return x * x * (3 - 2 * x);\n}\nfunction smootherstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n  x = (x - min) / (max - min);\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\n// Random integer from <low, high> interval\nfunction randInt(low, high) {\n  return low + Math.floor(Math.random() * (high - low + 1));\n}\n\n// Random float from <low, high> interval\nfunction randFloat(low, high) {\n  return low + Math.random() * (high - low);\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread(range) {\n  return range * (0.5 - Math.random());\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom(s) {\n  if (s !== undefined) _seed = s;\n\n  // Mulberry32 generator\n\n  let t = _seed += 0x6D2B79F5;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction degToRad(degrees) {\n  return degrees * DEG2RAD;\n}\nfunction radToDeg(radians) {\n  return radians * RAD2DEG;\n}\nfunction isPowerOfTwo(value) {\n  return (value & value - 1) === 0 && value !== 0;\n}\nfunction ceilPowerOfTwo(value) {\n  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\nfunction floorPowerOfTwo(value) {\n  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\nfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n  // rotations are applied to the axes in the order specified by 'order'\n  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n  // angles are in radians\n\n  const cos = Math.cos;\n  const sin = Math.sin;\n  const c2 = cos(b / 2);\n  const s2 = sin(b / 2);\n  const c13 = cos((a + c) / 2);\n  const s13 = sin((a + c) / 2);\n  const c1_3 = cos((a - c) / 2);\n  const s1_3 = sin((a - c) / 2);\n  const c3_1 = cos((c - a) / 2);\n  const s3_1 = sin((c - a) / 2);\n  switch (order) {\n    case 'XYX':\n      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n      break;\n    case 'YZY':\n      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n      break;\n    case 'ZXZ':\n      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n      break;\n    case 'XZX':\n      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n      break;\n    case 'YXY':\n      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n      break;\n    case 'ZYZ':\n      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n      break;\n    default:\n      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);\n  }\n}\nfunction denormalize(value, array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return value;\n    case Uint32Array:\n      return value / 4294967295.0;\n    case Uint16Array:\n      return value / 65535.0;\n    case Uint8Array:\n      return value / 255.0;\n    case Int32Array:\n      return Math.max(value / 2147483647.0, -1.0);\n    case Int16Array:\n      return Math.max(value / 32767.0, -1.0);\n    case Int8Array:\n      return Math.max(value / 127.0, -1.0);\n    default:\n      throw new Error('Invalid component type.');\n  }\n}\nfunction normalize(value, array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return value;\n    case Uint32Array:\n      return Math.round(value * 4294967295.0);\n    case Uint16Array:\n      return Math.round(value * 65535.0);\n    case Uint8Array:\n      return Math.round(value * 255.0);\n    case Int32Array:\n      return Math.round(value * 2147483647.0);\n    case Int16Array:\n      return Math.round(value * 32767.0);\n    case Int8Array:\n      return Math.round(value * 127.0);\n    default:\n      throw new Error('Invalid component type.');\n  }\n}\nconst MathUtils = {\n  DEG2RAD: DEG2RAD,\n  RAD2DEG: RAD2DEG,\n  generateUUID: generateUUID,\n  clamp: clamp,\n  euclideanModulo: euclideanModulo,\n  mapLinear: mapLinear,\n  inverseLerp: inverseLerp,\n  lerp: lerp,\n  damp: damp,\n  pingpong: pingpong,\n  smoothstep: smoothstep,\n  smootherstep: smootherstep,\n  randInt: randInt,\n  randFloat: randFloat,\n  randFloatSpread: randFloatSpread,\n  seededRandom: seededRandom,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  isPowerOfTwo: isPowerOfTwo,\n  ceilPowerOfTwo: ceilPowerOfTwo,\n  floorPowerOfTwo: floorPowerOfTwo,\n  setQuaternionFromProperEuler: setQuaternionFromProperEuler,\n  normalize: normalize,\n  denormalize: denormalize\n};\nclass Vector2 {\n  constructor(x = 0, y = 0) {\n    Vector2.prototype.isVector2 = true;\n    this.x = x;\n    this.y = y;\n  }\n  get width() {\n    return this.x;\n  }\n  set width(value) {\n    this.x = value;\n  }\n  get height() {\n    return this.y;\n  }\n  set height(value) {\n    this.y = value;\n  }\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  applyMatrix3(m) {\n    const x = this.x,\n      y = this.y;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6];\n    this.y = e[1] * x + e[4] * y + e[7];\n    return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    return this;\n  }\n  clamp(min, max) {\n    // assumes min < max, componentwise\n\n    this.x = clamp(this.x, min.x, max.x);\n    this.y = clamp(this.y, min.y, max.y);\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = clamp(this.x, minVal, maxVal);\n    this.y = clamp(this.y, minVal, maxVal);\n    return this;\n  }\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = Math.trunc(this.y);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y;\n  }\n  cross(v) {\n    return this.x * v.y - this.y * v.x;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  angle() {\n    // computes the angle in radians with respect to the positive x-axis\n\n    const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n    return angle;\n  }\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if (denominator === 0) return Math.PI / 2;\n    const theta = this.dot(v) / denominator;\n\n    // clamp, to handle numerical problems\n\n    return Math.acos(clamp(theta, -1, 1));\n  }\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    const dx = this.x - v.x,\n      dy = this.y - v.y;\n    return dx * dx + dy * dy;\n  }\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    return this;\n  }\n  rotateAround(center, angle) {\n    const c = Math.cos(angle),\n      s = Math.sin(angle);\n    const x = this.x - center.x;\n    const y = this.y - center.y;\n    this.x = x * c - y * s + center.x;\n    this.y = x * s + y * c + center.y;\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n  }\n}\nclass Matrix3 {\n  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    Matrix3.prototype.isMatrix3 = true;\n    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    if (n11 !== undefined) {\n      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n    }\n  }\n  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    const te = this.elements;\n    te[0] = n11;\n    te[1] = n21;\n    te[2] = n31;\n    te[3] = n12;\n    te[4] = n22;\n    te[5] = n32;\n    te[6] = n13;\n    te[7] = n23;\n    te[8] = n33;\n    return this;\n  }\n  identity() {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    return this;\n  }\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrix3Column(this, 0);\n    yAxis.setFromMatrix3Column(this, 1);\n    zAxis.setFromMatrix3Column(this, 2);\n    return this;\n  }\n  setFromMatrix4(m) {\n    const me = m.elements;\n    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n    return this;\n  }\n  multiply(m) {\n    return this.multiplyMatrices(this, m);\n  }\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0],\n      a12 = ae[3],\n      a13 = ae[6];\n    const a21 = ae[1],\n      a22 = ae[4],\n      a23 = ae[7];\n    const a31 = ae[2],\n      a32 = ae[5],\n      a33 = ae[8];\n    const b11 = be[0],\n      b12 = be[3],\n      b13 = be[6];\n    const b21 = be[1],\n      b22 = be[4],\n      b23 = be[7];\n    const b31 = be[2],\n      b32 = be[5],\n      b33 = be[8];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n    te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n    te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n    te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n    te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n    return this;\n  }\n  determinant() {\n    const te = this.elements;\n    const a = te[0],\n      b = te[1],\n      c = te[2],\n      d = te[3],\n      e = te[4],\n      f = te[5],\n      g = te[6],\n      h = te[7],\n      i = te[8];\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n  }\n  invert() {\n    const te = this.elements,\n      n11 = te[0],\n      n21 = te[1],\n      n31 = te[2],\n      n12 = te[3],\n      n22 = te[4],\n      n32 = te[5],\n      n13 = te[6],\n      n23 = te[7],\n      n33 = te[8],\n      t11 = n33 * n22 - n32 * n23,\n      t12 = n32 * n13 - n33 * n12,\n      t13 = n23 * n12 - n22 * n13,\n      det = n11 * t11 + n21 * t12 + n31 * t13;\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n31 * n23 - n33 * n21) * detInv;\n    te[2] = (n32 * n21 - n31 * n22) * detInv;\n    te[3] = t12 * detInv;\n    te[4] = (n33 * n11 - n31 * n13) * detInv;\n    te[5] = (n31 * n12 - n32 * n11) * detInv;\n    te[6] = t13 * detInv;\n    te[7] = (n21 * n13 - n23 * n11) * detInv;\n    te[8] = (n22 * n11 - n21 * n12) * detInv;\n    return this;\n  }\n  transpose() {\n    let tmp;\n    const m = this.elements;\n    tmp = m[1];\n    m[1] = m[3];\n    m[3] = tmp;\n    tmp = m[2];\n    m[2] = m[6];\n    m[6] = tmp;\n    tmp = m[5];\n    m[5] = m[7];\n    m[7] = tmp;\n    return this;\n  }\n  getNormalMatrix(matrix4) {\n    return this.setFromMatrix4(matrix4).invert().transpose();\n  }\n  transposeIntoArray(r) {\n    const m = this.elements;\n    r[0] = m[0];\n    r[1] = m[3];\n    r[2] = m[6];\n    r[3] = m[1];\n    r[4] = m[4];\n    r[5] = m[7];\n    r[6] = m[2];\n    r[7] = m[5];\n    r[8] = m[8];\n    return this;\n  }\n  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\n    return this;\n  }\n\n  //\n\n  scale(sx, sy) {\n    this.premultiply(_m3.makeScale(sx, sy));\n    return this;\n  }\n  rotate(theta) {\n    this.premultiply(_m3.makeRotation(-theta));\n    return this;\n  }\n  translate(tx, ty) {\n    this.premultiply(_m3.makeTranslation(tx, ty));\n    return this;\n  }\n\n  // for 2D Transforms\n\n  makeTranslation(x, y) {\n    if (x.isVector2) {\n      this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);\n    } else {\n      this.set(1, 0, x, 0, 1, y, 0, 0, 1);\n    }\n    return this;\n  }\n  makeRotation(theta) {\n    // counterclockwise\n\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    this.set(c, -s, 0, s, c, 0, 0, 0, 1);\n    return this;\n  }\n  makeScale(x, y) {\n    this.set(x, 0, 0, 0, y, 0, 0, 0, 1);\n    return this;\n  }\n\n  //\n\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 9; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return true;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 9; i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    return array;\n  }\n  clone() {\n    return new this.constructor().fromArray(this.elements);\n  }\n}\nconst _m3 = /*@__PURE__*/new Matrix3();\nfunction arrayNeedsUint32(array) {\n  // assumes larger values usually on last\n\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n  }\n  return false;\n}\nconst TYPED_ARRAYS = {\n  Int8Array: Int8Array,\n  Uint8Array: Uint8Array,\n  Uint8ClampedArray: Uint8ClampedArray,\n  Int16Array: Int16Array,\n  Uint16Array: Uint16Array,\n  Int32Array: Int32Array,\n  Uint32Array: Uint32Array,\n  Float32Array: Float32Array,\n  Float64Array: Float64Array\n};\nfunction getTypedArray(type, buffer) {\n  return new TYPED_ARRAYS[type](buffer);\n}\nfunction createElementNS(name) {\n  return document.createElementNS('http://www.w3.org/1999/xhtml', name);\n}\nfunction createCanvasElement() {\n  const canvas = createElementNS('canvas');\n  canvas.style.display = 'block';\n  return canvas;\n}\nconst _cache = {};\nfunction warnOnce(message) {\n  if (message in _cache) return;\n  _cache[message] = true;\n  console.warn(message);\n}\nfunction probeAsync(gl, sync, interval) {\n  return new Promise(function (resolve, reject) {\n    function probe() {\n      switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {\n        case gl.WAIT_FAILED:\n          reject();\n          break;\n        case gl.TIMEOUT_EXPIRED:\n          setTimeout(probe, interval);\n          break;\n        default:\n          resolve();\n      }\n    }\n    setTimeout(probe, interval);\n  });\n}\nfunction toNormalizedProjectionMatrix(projectionMatrix) {\n  const m = projectionMatrix.elements;\n\n  // Convert [-1, 1] to [0, 1] projection matrix\n  m[2] = 0.5 * m[2] + 0.5 * m[3];\n  m[6] = 0.5 * m[6] + 0.5 * m[7];\n  m[10] = 0.5 * m[10] + 0.5 * m[11];\n  m[14] = 0.5 * m[14] + 0.5 * m[15];\n}\nfunction toReversedProjectionMatrix(projectionMatrix) {\n  const m = projectionMatrix.elements;\n  const isPerspectiveMatrix = m[11] === -1;\n\n  // Reverse [0, 1] projection matrix\n  if (isPerspectiveMatrix) {\n    m[10] = -m[10] - 1;\n    m[14] = -m[14];\n  } else {\n    m[10] = -m[10];\n    m[14] = -m[14] + 1;\n  }\n}\nconst LINEAR_REC709_TO_XYZ = /*@__PURE__*/new Matrix3().set(0.4123908, 0.3575843, 0.1804808, 0.2126390, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322);\nconst XYZ_TO_LINEAR_REC709 = /*@__PURE__*/new Matrix3().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.2039770, 1.0569715);\nfunction createColorManagement() {\n  const ColorManagement = {\n    enabled: true,\n    workingColorSpace: LinearSRGBColorSpace,\n    /**\n     * Implementations of supported color spaces.\n     *\n     * Required:\n     *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n     *\t- whitePoint: reference white [ x y ]\n     *\t- transfer: transfer function (pre-defined)\n     *\t- toXYZ: Matrix3 RGB to XYZ transform\n     *\t- fromXYZ: Matrix3 XYZ to RGB transform\n     *\t- luminanceCoefficients: RGB luminance coefficients\n     *\n     * Optional:\n     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n     *\n     * Reference:\n     * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n     */\n    spaces: {},\n    convert: function (color, sourceColorSpace, targetColorSpace) {\n      if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n        return color;\n      }\n      if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n        color.r = SRGBToLinear(color.r);\n        color.g = SRGBToLinear(color.g);\n        color.b = SRGBToLinear(color.b);\n      }\n      if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n        color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n        color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n      }\n      if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n        color.r = LinearToSRGB(color.r);\n        color.g = LinearToSRGB(color.g);\n        color.b = LinearToSRGB(color.b);\n      }\n      return color;\n    },\n    fromWorkingColorSpace: function (color, targetColorSpace) {\n      return this.convert(color, this.workingColorSpace, targetColorSpace);\n    },\n    toWorkingColorSpace: function (color, sourceColorSpace) {\n      return this.convert(color, sourceColorSpace, this.workingColorSpace);\n    },\n    getPrimaries: function (colorSpace) {\n      return this.spaces[colorSpace].primaries;\n    },\n    getTransfer: function (colorSpace) {\n      if (colorSpace === NoColorSpace) return LinearTransfer;\n      return this.spaces[colorSpace].transfer;\n    },\n    getLuminanceCoefficients: function (target, colorSpace = this.workingColorSpace) {\n      return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n    },\n    define: function (colorSpaces) {\n      Object.assign(this.spaces, colorSpaces);\n    },\n    // Internal APIs\n\n    _getMatrix: function (targetMatrix, sourceColorSpace, targetColorSpace) {\n      return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n    },\n    _getDrawingBufferColorSpace: function (colorSpace) {\n      return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n    },\n    _getUnpackColorSpace: function (colorSpace = this.workingColorSpace) {\n      return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n    }\n  };\n\n  /******************************************************************************\n   * sRGB definitions\n   */\n\n  const REC709_PRIMARIES = [0.640, 0.330, 0.300, 0.600, 0.150, 0.060];\n  const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\n  const D65 = [0.3127, 0.3290];\n  ColorManagement.define({\n    [LinearSRGBColorSpace]: {\n      primaries: REC709_PRIMARIES,\n      whitePoint: D65,\n      transfer: LinearTransfer,\n      toXYZ: LINEAR_REC709_TO_XYZ,\n      fromXYZ: XYZ_TO_LINEAR_REC709,\n      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n      workingColorSpaceConfig: {\n        unpackColorSpace: SRGBColorSpace\n      },\n      outputColorSpaceConfig: {\n        drawingBufferColorSpace: SRGBColorSpace\n      }\n    },\n    [SRGBColorSpace]: {\n      primaries: REC709_PRIMARIES,\n      whitePoint: D65,\n      transfer: SRGBTransfer,\n      toXYZ: LINEAR_REC709_TO_XYZ,\n      fromXYZ: XYZ_TO_LINEAR_REC709,\n      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n      outputColorSpaceConfig: {\n        drawingBufferColorSpace: SRGBColorSpace\n      }\n    }\n  });\n  return ColorManagement;\n}\nconst ColorManagement = /*@__PURE__*/createColorManagement();\nfunction SRGBToLinear(c) {\n  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n}\nfunction LinearToSRGB(c) {\n  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n}\nlet _canvas;\nclass ImageUtils {\n  static getDataURL(image) {\n    if (/^data:/i.test(image.src)) {\n      return image.src;\n    }\n    if (typeof HTMLCanvasElement === 'undefined') {\n      return image.src;\n    }\n    let canvas;\n    if (image instanceof HTMLCanvasElement) {\n      canvas = image;\n    } else {\n      if (_canvas === undefined) _canvas = createElementNS('canvas');\n      _canvas.width = image.width;\n      _canvas.height = image.height;\n      const context = _canvas.getContext('2d');\n      if (image instanceof ImageData) {\n        context.putImageData(image, 0, 0);\n      } else {\n        context.drawImage(image, 0, 0, image.width, image.height);\n      }\n      canvas = _canvas;\n    }\n    if (canvas.width > 2048 || canvas.height > 2048) {\n      console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);\n      return canvas.toDataURL('image/jpeg', 0.6);\n    } else {\n      return canvas.toDataURL('image/png');\n    }\n  }\n  static sRGBToLinear(image) {\n    if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n      const canvas = createElementNS('canvas');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, image.width, image.height);\n      const imageData = context.getImageData(0, 0, image.width, image.height);\n      const data = imageData.data;\n      for (let i = 0; i < data.length; i++) {\n        data[i] = SRGBToLinear(data[i] / 255) * 255;\n      }\n      context.putImageData(imageData, 0, 0);\n      return canvas;\n    } else if (image.data) {\n      const data = image.data.slice(0);\n      for (let i = 0; i < data.length; i++) {\n        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);\n        } else {\n          // assuming float\n\n          data[i] = SRGBToLinear(data[i]);\n        }\n      }\n      return {\n        data: data,\n        width: image.width,\n        height: image.height\n      };\n    } else {\n      console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');\n      return image;\n    }\n  }\n}\nlet _sourceId = 0;\nclass Source {\n  constructor(data = null) {\n    this.isSource = true;\n    Object.defineProperty(this, 'id', {\n      value: _sourceId++\n    });\n    this.uuid = generateUUID();\n    this.data = data;\n    this.dataReady = true;\n    this.version = 0;\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  toJSON(meta) {\n    const isRootObject = meta === undefined || typeof meta === 'string';\n    if (!isRootObject && meta.images[this.uuid] !== undefined) {\n      return meta.images[this.uuid];\n    }\n    const output = {\n      uuid: this.uuid,\n      url: ''\n    };\n    const data = this.data;\n    if (data !== null) {\n      let url;\n      if (Array.isArray(data)) {\n        // cube texture\n\n        url = [];\n        for (let i = 0, l = data.length; i < l; i++) {\n          if (data[i].isDataTexture) {\n            url.push(serializeImage(data[i].image));\n          } else {\n            url.push(serializeImage(data[i]));\n          }\n        }\n      } else {\n        // texture\n\n        url = serializeImage(data);\n      }\n      output.url = url;\n    }\n    if (!isRootObject) {\n      meta.images[this.uuid] = output;\n    }\n    return output;\n  }\n}\nfunction serializeImage(image) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    // default images\n\n    return ImageUtils.getDataURL(image);\n  } else {\n    if (image.data) {\n      // images of DataTexture\n\n      return {\n        data: Array.from(image.data),\n        width: image.width,\n        height: image.height,\n        type: image.data.constructor.name\n      };\n    } else {\n      console.warn('THREE.Texture: Unable to serialize Texture.');\n      return {};\n    }\n  }\n}\nlet _textureId = 0;\nclass Texture extends EventDispatcher {\n  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {\n    super();\n    this.isTexture = true;\n    Object.defineProperty(this, 'id', {\n      value: _textureId++\n    });\n    this.uuid = generateUUID();\n    this.name = '';\n    this.source = new Source(image);\n    this.mipmaps = [];\n    this.mapping = mapping;\n    this.channel = 0;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n    this.anisotropy = anisotropy;\n    this.format = format;\n    this.internalFormat = null;\n    this.type = type;\n    this.offset = new Vector2(0, 0);\n    this.repeat = new Vector2(1, 1);\n    this.center = new Vector2(0, 0);\n    this.rotation = 0;\n    this.matrixAutoUpdate = true;\n    this.matrix = new Matrix3();\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n    this.colorSpace = colorSpace;\n    this.userData = {};\n    this.version = 0;\n    this.onUpdate = null;\n    this.renderTarget = null; // assign texture to a render target\n    this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n    this.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n  }\n  get image() {\n    return this.source.data;\n  }\n  set image(value = null) {\n    this.source.data = value;\n  }\n  updateMatrix() {\n    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.name = source.name;\n    this.source = source.source;\n    this.mipmaps = source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    this.channel = source.channel;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.colorSpace = source.colorSpace;\n    this.renderTarget = source.renderTarget;\n    this.isRenderTargetTexture = source.isRenderTargetTexture;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    this.needsUpdate = true;\n    return this;\n  }\n  toJSON(meta) {\n    const isRootObject = meta === undefined || typeof meta === 'string';\n    if (!isRootObject && meta.textures[this.uuid] !== undefined) {\n      return meta.textures[this.uuid];\n    }\n    const output = {\n      metadata: {\n        version: 4.6,\n        type: 'Texture',\n        generator: 'Texture.toJSON'\n      },\n      uuid: this.uuid,\n      name: this.name,\n      image: this.source.toJSON(meta).uuid,\n      mapping: this.mapping,\n      channel: this.channel,\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: [this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: [this.wrapS, this.wrapT],\n      format: this.format,\n      internalFormat: this.internalFormat,\n      type: this.type,\n      colorSpace: this.colorSpace,\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: this.flipY,\n      generateMipmaps: this.generateMipmaps,\n      premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: this.unpackAlignment\n    };\n    if (Object.keys(this.userData).length > 0) output.userData = this.userData;\n    if (!isRootObject) {\n      meta.textures[this.uuid] = output;\n    }\n    return output;\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  transformUv(uv) {\n    if (this.mapping !== UVMapping) return uv;\n    uv.applyMatrix3(this.matrix);\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n        case ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n          break;\n      }\n    }\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n        case ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n          break;\n      }\n    }\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n    return uv;\n  }\n  set needsUpdate(value) {\n    if (value === true) {\n      this.version++;\n      this.source.needsUpdate = true;\n    }\n  }\n  set needsPMREMUpdate(value) {\n    if (value === true) {\n      this.pmremVersion++;\n    }\n  }\n}\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\nclass Vector4 {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    Vector4.prototype.isVector4 = true;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  get width() {\n    return this.z;\n  }\n  set width(value) {\n    this.z = value;\n  }\n  get height() {\n    return this.w;\n  }\n  set height(value) {\n    this.w = value;\n  }\n  set(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    this.w = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n  setW(w) {\n    this.w = w;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      case 3:\n        this.w = value;\n        break;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      case 3:\n        return this.w;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, this.z, this.w);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    this.w = v.w !== undefined ? v.w : 1;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    this.w += v.w;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    this.w += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    this.w = a.w + b.w;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    this.w += v.w * s;\n    return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= v.w;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    this.w -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    this.w = a.w - b.w;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    this.w *= v.w;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w *= scalar;\n    return this;\n  }\n  applyMatrix4(m) {\n    const x = this.x,\n      y = this.y,\n      z = this.z,\n      w = this.w;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n    return this;\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n    this.w /= v.w;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  setAxisAngleFromQuaternion(q) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n    // q is assumed to be normalized\n\n    this.w = 2 * Math.acos(q.w);\n    const s = Math.sqrt(1 - q.w * q.w);\n    if (s < 0.0001) {\n      this.x = 1;\n      this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n      this.y = q.y / s;\n      this.z = q.z / s;\n    }\n    return this;\n  }\n  setAxisAngleFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    let angle, x, y, z; // variables for result\n    const epsilon = 0.01,\n      // margin to allow for rounding errors\n      epsilon2 = 0.1,\n      // margin to distinguish between 0 and 180 degrees\n\n      te = m.elements,\n      m11 = te[0],\n      m12 = te[4],\n      m13 = te[8],\n      m21 = te[1],\n      m22 = te[5],\n      m23 = te[9],\n      m31 = te[2],\n      m32 = te[6],\n      m33 = te[10];\n    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n      // singularity found\n      // first check for identity matrix which must have +1 for all terms\n      // in leading diagonal and zero in other terms\n\n      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n        // this singularity is identity matrix so angle = 0\n\n        this.set(1, 0, 0, 0);\n        return this; // zero angle, arbitrary axis\n      }\n\n      // otherwise this singularity is angle = 180\n\n      angle = Math.PI;\n      const xx = (m11 + 1) / 2;\n      const yy = (m22 + 1) / 2;\n      const zz = (m33 + 1) / 2;\n      const xy = (m12 + m21) / 4;\n      const xz = (m13 + m31) / 4;\n      const yz = (m23 + m32) / 4;\n      if (xx > yy && xx > zz) {\n        // m11 is the largest diagonal term\n\n        if (xx < epsilon) {\n          x = 0;\n          y = 0.707106781;\n          z = 0.707106781;\n        } else {\n          x = Math.sqrt(xx);\n          y = xy / x;\n          z = xz / x;\n        }\n      } else if (yy > zz) {\n        // m22 is the largest diagonal term\n\n        if (yy < epsilon) {\n          x = 0.707106781;\n          y = 0;\n          z = 0.707106781;\n        } else {\n          y = Math.sqrt(yy);\n          x = xy / y;\n          z = yz / y;\n        }\n      } else {\n        // m33 is the largest diagonal term so base result on this\n\n        if (zz < epsilon) {\n          x = 0.707106781;\n          y = 0.707106781;\n          z = 0;\n        } else {\n          z = Math.sqrt(zz);\n          x = xz / z;\n          y = yz / z;\n        }\n      }\n      this.set(x, y, z, angle);\n      return this; // return 180 deg rotation\n    }\n\n    // as we have reached here there are no singularities so we can handle normally\n\n    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n    if (Math.abs(s) < 0.001) s = 1;\n\n    // prevent divide by zero, should not happen if matrix is orthogonal and should be\n    // caught by singularity test above, but I've left it in just in case\n\n    this.x = (m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / s;\n    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n    return this;\n  }\n  setFromMatrixPosition(m) {\n    const e = m.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n    this.w = e[15];\n    return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    this.w = Math.min(this.w, v.w);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    this.w = Math.max(this.w, v.w);\n    return this;\n  }\n  clamp(min, max) {\n    // assumes min < max, componentwise\n\n    this.x = clamp(this.x, min.x, max.x);\n    this.y = clamp(this.y, min.y, max.y);\n    this.z = clamp(this.z, min.z, max.z);\n    this.w = clamp(this.w, min.w, max.w);\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = clamp(this.x, minVal, maxVal);\n    this.y = clamp(this.y, minVal, maxVal);\n    this.z = clamp(this.z, minVal, maxVal);\n    this.w = clamp(this.w, minVal, maxVal);\n    return this;\n  }\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = Math.floor(this.w);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = Math.round(this.w);\n    return this;\n  }\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = Math.trunc(this.y);\n    this.z = Math.trunc(this.z);\n    this.w = Math.trunc(this.w);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    this.w = v1.w + (v2.w - v1.w) * alpha;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    array[offset + 3] = this.w;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    this.w = attribute.getW(index);\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    this.w = Math.random();\n    return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield this.z;\n    yield this.w;\n  }\n}\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass RenderTarget extends EventDispatcher {\n  constructor(width = 1, height = 1, options = {}) {\n    super();\n    this.isRenderTarget = true;\n    this.width = width;\n    this.height = height;\n    this.depth = 1;\n    this.scissor = new Vector4(0, 0, width, height);\n    this.scissorTest = false;\n    this.viewport = new Vector4(0, 0, width, height);\n    const image = {\n      width: width,\n      height: height,\n      depth: 1\n    };\n    options = Object.assign({\n      generateMipmaps: false,\n      internalFormat: null,\n      minFilter: LinearFilter,\n      depthBuffer: true,\n      stencilBuffer: false,\n      resolveDepthBuffer: true,\n      resolveStencilBuffer: true,\n      depthTexture: null,\n      samples: 0,\n      count: 1\n    }, options);\n    const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);\n    texture.flipY = false;\n    texture.generateMipmaps = options.generateMipmaps;\n    texture.internalFormat = options.internalFormat;\n    this.textures = [];\n    const count = options.count;\n    for (let i = 0; i < count; i++) {\n      this.textures[i] = texture.clone();\n      this.textures[i].isRenderTargetTexture = true;\n      this.textures[i].renderTarget = this;\n    }\n    this.depthBuffer = options.depthBuffer;\n    this.stencilBuffer = options.stencilBuffer;\n    this.resolveDepthBuffer = options.resolveDepthBuffer;\n    this.resolveStencilBuffer = options.resolveStencilBuffer;\n    this._depthTexture = null;\n    this.depthTexture = options.depthTexture;\n    this.samples = options.samples;\n  }\n  get texture() {\n    return this.textures[0];\n  }\n  set texture(value) {\n    this.textures[0] = value;\n  }\n  set depthTexture(current) {\n    if (this._depthTexture !== null) this._depthTexture.renderTarget = null;\n    if (current !== null) current.renderTarget = this;\n    this._depthTexture = current;\n  }\n  get depthTexture() {\n    return this._depthTexture;\n  }\n  setSize(width, height, depth = 1) {\n    if (this.width !== width || this.height !== height || this.depth !== depth) {\n      this.width = width;\n      this.height = height;\n      this.depth = depth;\n      for (let i = 0, il = this.textures.length; i < il; i++) {\n        this.textures[i].image.width = width;\n        this.textures[i].image.height = height;\n        this.textures[i].image.depth = depth;\n      }\n      this.dispose();\n    }\n    this.viewport.set(0, 0, width, height);\n    this.scissor.set(0, 0, width, height);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.width = source.width;\n    this.height = source.height;\n    this.depth = source.depth;\n    this.scissor.copy(source.scissor);\n    this.scissorTest = source.scissorTest;\n    this.viewport.copy(source.viewport);\n    this.textures.length = 0;\n    for (let i = 0, il = source.textures.length; i < il; i++) {\n      this.textures[i] = source.textures[i].clone();\n      this.textures[i].isRenderTargetTexture = true;\n      this.textures[i].renderTarget = this;\n    }\n\n    // ensure image object is not shared, see #20328\n\n    const image = Object.assign({}, source.texture.image);\n    this.texture.source = new Source(image);\n    this.depthBuffer = source.depthBuffer;\n    this.stencilBuffer = source.stencilBuffer;\n    this.resolveDepthBuffer = source.resolveDepthBuffer;\n    this.resolveStencilBuffer = source.resolveStencilBuffer;\n    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n    this.samples = source.samples;\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n}\nclass WebGLRenderTarget extends RenderTarget {\n  constructor(width = 1, height = 1, options = {}) {\n    super(width, height, options);\n    this.isWebGLRenderTarget = true;\n  }\n}\nclass DataArrayTexture extends Texture {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    super(null);\n    this.isDataArrayTexture = true;\n    this.image = {\n      data,\n      width,\n      height,\n      depth\n    };\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n    this.layerUpdates = new Set();\n  }\n  addLayerUpdate(layerIndex) {\n    this.layerUpdates.add(layerIndex);\n  }\n  clearLayerUpdates() {\n    this.layerUpdates.clear();\n  }\n}\nclass WebGLArrayRenderTarget extends WebGLRenderTarget {\n  constructor(width = 1, height = 1, depth = 1, options = {}) {\n    super(width, height, options);\n    this.isWebGLArrayRenderTarget = true;\n    this.depth = depth;\n    this.texture = new DataArrayTexture(null, width, height, depth);\n    this.texture.isRenderTargetTexture = true;\n  }\n}\nclass Data3DTexture extends Texture {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    // We're going to add .setXXX() methods for setting properties later.\n    // Users can still set in Data3DTexture directly.\n    //\n    //\tconst texture = new THREE.Data3DTexture( data, width, height, depth );\n    // \ttexture.anisotropy = 16;\n    //\n    // See #14839\n\n    super(null);\n    this.isData3DTexture = true;\n    this.image = {\n      data,\n      width,\n      height,\n      depth\n    };\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n  }\n}\nclass WebGL3DRenderTarget extends WebGLRenderTarget {\n  constructor(width = 1, height = 1, depth = 1, options = {}) {\n    super(width, height, options);\n    this.isWebGL3DRenderTarget = true;\n    this.depth = depth;\n    this.texture = new Data3DTexture(null, width, height, depth);\n    this.texture.isRenderTargetTexture = true;\n  }\n}\nclass Quaternion {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this.isQuaternion = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n    // fuzz-free, array-based Quaternion SLERP operation\n\n    let x0 = src0[srcOffset0 + 0],\n      y0 = src0[srcOffset0 + 1],\n      z0 = src0[srcOffset0 + 2],\n      w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1 + 0],\n      y1 = src1[srcOffset1 + 1],\n      z1 = src1[srcOffset1 + 2],\n      w1 = src1[srcOffset1 + 3];\n    if (t === 0) {\n      dst[dstOffset + 0] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n      return;\n    }\n    if (t === 1) {\n      dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset + 2] = z1;\n      dst[dstOffset + 3] = w1;\n      return;\n    }\n    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - t;\n      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n        dir = cos >= 0 ? 1 : -1,\n        sqrSin = 1 - cos * cos;\n\n      // Skip the Slerp for tiny steps to avoid numeric problems:\n      if (sqrSin > Number.EPSILON) {\n        const sin = Math.sqrt(sqrSin),\n          len = Math.atan2(sin, cos * dir);\n        s = Math.sin(s * len) / sin;\n        t = Math.sin(t * len) / sin;\n      }\n      const tDir = t * dir;\n      x0 = x0 * s + x1 * tDir;\n      y0 = y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w0 = w0 * s + w1 * tDir;\n\n      // Normalize in case we just did a lerp:\n      if (s === 1 - t) {\n        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n        x0 *= f;\n        y0 *= f;\n        z0 *= f;\n        w0 *= f;\n      }\n    }\n    dst[dstOffset] = x0;\n    dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + 3] = w0;\n  }\n  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n    const x0 = src0[srcOffset0];\n    const y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1];\n    const y1 = src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w1 = src1[srcOffset1 + 3];\n    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n    return dst;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get w() {\n    return this._w;\n  }\n  set w(value) {\n    this._w = value;\n    this._onChangeCallback();\n  }\n  set(x, y, z, w) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n    this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._w);\n  }\n  copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n    this._onChangeCallback();\n    return this;\n  }\n  setFromEuler(euler, update = true) {\n    const x = euler._x,\n      y = euler._y,\n      z = euler._z,\n      order = euler._order;\n\n    // http://www.mathworks.com/matlabcentral/fileexchange/\n    // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n    //\tcontent/SpinCalc.m\n\n    const cos = Math.cos;\n    const sin = Math.sin;\n    const c1 = cos(x / 2);\n    const c2 = cos(y / 2);\n    const c3 = cos(z / 2);\n    const s1 = sin(x / 2);\n    const s2 = sin(y / 2);\n    const s3 = sin(z / 2);\n    switch (order) {\n      case 'XYZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case 'YXZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      case 'ZXY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case 'ZYX':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      case 'YZX':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case 'XZY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      default:\n        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);\n    }\n    if (update === true) this._onChangeCallback();\n    return this;\n  }\n  setFromAxisAngle(axis, angle) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n    // assumes axis is normalized\n\n    const halfAngle = angle / 2,\n      s = Math.sin(halfAngle);\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Math.cos(halfAngle);\n    this._onChangeCallback();\n    return this;\n  }\n  setFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    const te = m.elements,\n      m11 = te[0],\n      m12 = te[4],\n      m13 = te[8],\n      m21 = te[1],\n      m22 = te[5],\n      m23 = te[9],\n      m31 = te[2],\n      m32 = te[6],\n      m33 = te[10],\n      trace = m11 + m22 + m33;\n    if (trace > 0) {\n      const s = 0.5 / Math.sqrt(trace + 1.0);\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n    } else {\n      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n    this._onChangeCallback();\n    return this;\n  }\n  setFromUnitVectors(vFrom, vTo) {\n    // assumes direction vectors vFrom and vTo are normalized\n\n    let r = vFrom.dot(vTo) + 1;\n    if (r < Number.EPSILON) {\n      // vFrom and vTo point in opposite directions\n\n      r = 0;\n      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n        this._x = -vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w = r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n        this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      this._w = r;\n    }\n    return this.normalize();\n  }\n  angleTo(q) {\n    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n  }\n  rotateTowards(q, step) {\n    const angle = this.angleTo(q);\n    if (angle === 0) return this;\n    const t = Math.min(1, step / angle);\n    this.slerp(q, t);\n    return this;\n  }\n  identity() {\n    return this.set(0, 0, 0, 1);\n  }\n  invert() {\n    // quaternion is assumed to have unit length\n\n    return this.conjugate();\n  }\n  conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n    this._onChangeCallback();\n    return this;\n  }\n  dot(v) {\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n  lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n  }\n  length() {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  }\n  normalize() {\n    let l = this.length();\n    if (l === 0) {\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    } else {\n      l = 1 / l;\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    }\n    this._onChangeCallback();\n    return this;\n  }\n  multiply(q) {\n    return this.multiplyQuaternions(this, q);\n  }\n  premultiply(q) {\n    return this.multiplyQuaternions(q, this);\n  }\n  multiplyQuaternions(a, b) {\n    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n    const qax = a._x,\n      qay = a._y,\n      qaz = a._z,\n      qaw = a._w;\n    const qbx = b._x,\n      qby = b._y,\n      qbz = b._z,\n      qbw = b._w;\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n    this._onChangeCallback();\n    return this;\n  }\n  slerp(qb, t) {\n    if (t === 0) return this;\n    if (t === 1) return this.copy(qb);\n    const x = this._x,\n      y = this._y,\n      z = this._z,\n      w = this._w;\n\n    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n    if (cosHalfTheta < 0) {\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      this.copy(qb);\n    }\n    if (cosHalfTheta >= 1.0) {\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      return this;\n    }\n    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n    if (sqrSinHalfTheta <= Number.EPSILON) {\n      const s = 1 - t;\n      this._w = s * w + t * this._w;\n      this._x = s * x + t * this._x;\n      this._y = s * y + t * this._y;\n      this._z = s * z + t * this._z;\n      this.normalize(); // normalize calls _onChangeCallback()\n\n      return this;\n    }\n    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n      ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n    this._onChangeCallback();\n    return this;\n  }\n  slerpQuaternions(qa, qb, t) {\n    return this.copy(qa).slerp(qb, t);\n  }\n  random() {\n    // sets this quaternion to a uniform random unit quaternnion\n\n    // Ken Shoemake\n    // Uniform random rotations\n    // D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.\n\n    const theta1 = 2 * Math.PI * Math.random();\n    const theta2 = 2 * Math.PI * Math.random();\n    const x0 = Math.random();\n    const r1 = Math.sqrt(1 - x0);\n    const r2 = Math.sqrt(x0);\n    return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2));\n  }\n  equals(quaternion) {\n    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n  }\n  fromArray(array, offset = 0) {\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n    this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this._x = attribute.getX(index);\n    this._y = attribute.getY(index);\n    this._z = attribute.getZ(index);\n    this._w = attribute.getW(index);\n    this._onChangeCallback();\n    return this;\n  }\n  toJSON() {\n    return this.toArray();\n  }\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n  _onChangeCallback() {}\n  *[Symbol.iterator]() {\n    yield this._x;\n    yield this._y;\n    yield this._z;\n    yield this._w;\n  }\n}\nclass Vector3 {\n  constructor(x = 0, y = 0, z = 0) {\n    Vector3.prototype.isVector3 = true;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  set(x, y, z) {\n    if (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  }\n  multiplyVectors(a, b) {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n    return this;\n  }\n  applyEuler(euler) {\n    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n  }\n  applyAxisAngle(axis, angle) {\n    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n  }\n  applyMatrix3(m) {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n    return this;\n  }\n  applyNormalMatrix(m) {\n    return this.applyMatrix3(m).normalize();\n  }\n  applyMatrix4(m) {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n    return this;\n  }\n  applyQuaternion(q) {\n    // quaternion q is assumed to have unit length\n\n    const vx = this.x,\n      vy = this.y,\n      vz = this.z;\n    const qx = q.x,\n      qy = q.y,\n      qz = q.z,\n      qw = q.w;\n\n    // t = 2 * cross( q.xyz, v );\n    const tx = 2 * (qy * vz - qz * vy);\n    const ty = 2 * (qz * vx - qx * vz);\n    const tz = 2 * (qx * vy - qy * vx);\n\n    // v + q.w * t + cross( q.xyz, t );\n    this.x = vx + qw * tx + qy * tz - qz * ty;\n    this.y = vy + qw * ty + qz * tx - qx * tz;\n    this.z = vz + qw * tz + qx * ty - qy * tx;\n    return this;\n  }\n  project(camera) {\n    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n  }\n  unproject(camera) {\n    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n  }\n  transformDirection(m) {\n    // input: THREE.Matrix4 affine matrix\n    // vector interpreted as a direction\n\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n    return this.normalize();\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    return this;\n  }\n  clamp(min, max) {\n    // assumes min < max, componentwise\n\n    this.x = clamp(this.x, min.x, max.x);\n    this.y = clamp(this.y, min.y, max.y);\n    this.z = clamp(this.z, min.z, max.z);\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = clamp(this.x, minVal, maxVal);\n    this.y = clamp(this.y, minVal, maxVal);\n    this.z = clamp(this.z, minVal, maxVal);\n    return this;\n  }\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  }\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = Math.trunc(this.y);\n    this.z = Math.trunc(this.z);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  }\n\n  // TODO lengthSquared?\n\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    return this;\n  }\n  cross(v) {\n    return this.crossVectors(this, v);\n  }\n  crossVectors(a, b) {\n    const ax = a.x,\n      ay = a.y,\n      az = a.z;\n    const bx = b.x,\n      by = b.y,\n      bz = b.z;\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return this;\n  }\n  projectOnVector(v) {\n    const denominator = v.lengthSq();\n    if (denominator === 0) return this.set(0, 0, 0);\n    const scalar = v.dot(this) / denominator;\n    return this.copy(v).multiplyScalar(scalar);\n  }\n  projectOnPlane(planeNormal) {\n    _vector$c.copy(this).projectOnVector(planeNormal);\n    return this.sub(_vector$c);\n  }\n  reflect(normal) {\n    // reflect incident vector off plane orthogonal to normal\n    // normal is assumed to have unit length\n\n    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n  }\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if (denominator === 0) return Math.PI / 2;\n    const theta = this.dot(v) / denominator;\n\n    // clamp, to handle numerical problems\n\n    return Math.acos(clamp(theta, -1, 1));\n  }\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    const dx = this.x - v.x,\n      dy = this.y - v.y,\n      dz = this.z - v.z;\n    return dx * dx + dy * dy + dz * dz;\n  }\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n  }\n  setFromSpherical(s) {\n    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n  }\n  setFromSphericalCoords(radius, phi, theta) {\n    const sinPhiRadius = Math.sin(phi) * radius;\n    this.x = sinPhiRadius * Math.sin(theta);\n    this.y = Math.cos(phi) * radius;\n    this.z = sinPhiRadius * Math.cos(theta);\n    return this;\n  }\n  setFromCylindrical(c) {\n    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n  }\n  setFromCylindricalCoords(radius, theta, y) {\n    this.x = radius * Math.sin(theta);\n    this.y = y;\n    this.z = radius * Math.cos(theta);\n    return this;\n  }\n  setFromMatrixPosition(m) {\n    const e = m.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n    return this;\n  }\n  setFromMatrixScale(m) {\n    const sx = this.setFromMatrixColumn(m, 0).length();\n    const sy = this.setFromMatrixColumn(m, 1).length();\n    const sz = this.setFromMatrixColumn(m, 2).length();\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n    return this;\n  }\n  setFromMatrixColumn(m, index) {\n    return this.fromArray(m.elements, index * 4);\n  }\n  setFromMatrix3Column(m, index) {\n    return this.fromArray(m.elements, index * 3);\n  }\n  setFromEuler(e) {\n    this.x = e._x;\n    this.y = e._y;\n    this.z = e._z;\n    return this;\n  }\n  setFromColor(c) {\n    this.x = c.r;\n    this.y = c.g;\n    this.z = c.b;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    return this;\n  }\n  randomDirection() {\n    // https://mathworld.wolfram.com/SpherePointPicking.html\n\n    const theta = Math.random() * Math.PI * 2;\n    const u = Math.random() * 2 - 1;\n    const c = Math.sqrt(1 - u * u);\n    this.x = c * Math.cos(theta);\n    this.y = u;\n    this.z = c * Math.sin(theta);\n    return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield this.z;\n  }\n}\nconst _vector$c = /*@__PURE__*/new Vector3();\nconst _quaternion$4 = /*@__PURE__*/new Quaternion();\nclass Box3 {\n  constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {\n    this.isBox3 = true;\n    this.min = min;\n    this.max = max;\n  }\n  set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n    return this;\n  }\n  setFromArray(array) {\n    this.makeEmpty();\n    for (let i = 0, il = array.length; i < il; i += 3) {\n      this.expandByPoint(_vector$b.fromArray(array, i));\n    }\n    return this;\n  }\n  setFromBufferAttribute(attribute) {\n    this.makeEmpty();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));\n    }\n    return this;\n  }\n  setFromPoints(points) {\n    this.makeEmpty();\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n    return this;\n  }\n  setFromCenterAndSize(center, size) {\n    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n    return this;\n  }\n  setFromObject(object, precise = false) {\n    this.makeEmpty();\n    return this.expandByObject(object, precise);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n  makeEmpty() {\n    this.min.x = this.min.y = this.min.z = +Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  }\n  isEmpty() {\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  }\n  getCenter(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n  getSize(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n  }\n  expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  }\n  expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n  expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  }\n  expandByObject(object, precise = false) {\n    // Computes the world-axis-aligned bounding box of an object (including its children),\n    // accounting for both the object's, and children's, world transforms\n\n    object.updateWorldMatrix(false, false);\n    const geometry = object.geometry;\n    if (geometry !== undefined) {\n      const positionAttribute = geometry.getAttribute('position');\n\n      // precise AABB computation based on vertex data requires at least a position attribute.\n      // instancing isn't supported so far and uses the normal (conservative) code path.\n\n      if (precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true) {\n        for (let i = 0, l = positionAttribute.count; i < l; i++) {\n          if (object.isMesh === true) {\n            object.getVertexPosition(i, _vector$b);\n          } else {\n            _vector$b.fromBufferAttribute(positionAttribute, i);\n          }\n          _vector$b.applyMatrix4(object.matrixWorld);\n          this.expandByPoint(_vector$b);\n        }\n      } else {\n        if (object.boundingBox !== undefined) {\n          // object-level bounding box\n\n          if (object.boundingBox === null) {\n            object.computeBoundingBox();\n          }\n          _box$4.copy(object.boundingBox);\n        } else {\n          // geometry-level bounding box\n\n          if (geometry.boundingBox === null) {\n            geometry.computeBoundingBox();\n          }\n          _box$4.copy(geometry.boundingBox);\n        }\n        _box$4.applyMatrix4(object.matrixWorld);\n        this.union(_box$4);\n      }\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      this.expandByObject(children[i], precise);\n    }\n    return this;\n  }\n  containsPoint(point) {\n    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n  }\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n  }\n  getParameter(point, target) {\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n\n    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n  }\n  intersectsBox(box) {\n    // using 6 splitting planes to rule out intersections.\n    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n  }\n  intersectsSphere(sphere) {\n    // Find the point on the AABB closest to the sphere center.\n    this.clampPoint(sphere.center, _vector$b);\n\n    // If that point is inside the sphere, the AABB and sphere intersect.\n    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  intersectsPlane(plane) {\n    // We compute the minimum and maximum dot product values. If those values\n    // are on the same side (back or front) of the plane, then there is no intersection.\n\n    let min, max;\n    if (plane.normal.x > 0) {\n      min = plane.normal.x * this.min.x;\n      max = plane.normal.x * this.max.x;\n    } else {\n      min = plane.normal.x * this.max.x;\n      max = plane.normal.x * this.min.x;\n    }\n    if (plane.normal.y > 0) {\n      min += plane.normal.y * this.min.y;\n      max += plane.normal.y * this.max.y;\n    } else {\n      min += plane.normal.y * this.max.y;\n      max += plane.normal.y * this.min.y;\n    }\n    if (plane.normal.z > 0) {\n      min += plane.normal.z * this.min.z;\n      max += plane.normal.z * this.max.z;\n    } else {\n      min += plane.normal.z * this.max.z;\n      max += plane.normal.z * this.min.z;\n    }\n    return min <= -plane.constant && max >= -plane.constant;\n  }\n  intersectsTriangle(triangle) {\n    if (this.isEmpty()) {\n      return false;\n    }\n\n    // compute box center and extents\n    this.getCenter(_center);\n    _extents.subVectors(this.max, _center);\n\n    // translate triangle to aabb origin\n    _v0$2.subVectors(triangle.a, _center);\n    _v1$7.subVectors(triangle.b, _center);\n    _v2$4.subVectors(triangle.c, _center);\n\n    // compute edge vectors for triangle\n    _f0.subVectors(_v1$7, _v0$2);\n    _f1.subVectors(_v2$4, _v1$7);\n    _f2.subVectors(_v0$2, _v2$4);\n\n    // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];\n    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n      return false;\n    }\n\n    // test 3 face normals from the aabb\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n      return false;\n    }\n\n    // finally testing the face normal of the triangle\n    // use already existing triangle edge vectors here\n    _triangleNormal.crossVectors(_f0, _f1);\n    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\n  }\n  clampPoint(point, target) {\n    return target.copy(point).clamp(this.min, this.max);\n  }\n  distanceToPoint(point) {\n    return this.clampPoint(point, _vector$b).distanceTo(point);\n  }\n  getBoundingSphere(target) {\n    if (this.isEmpty()) {\n      target.makeEmpty();\n    } else {\n      this.getCenter(target.center);\n      target.radius = this.getSize(_vector$b).length() * 0.5;\n    }\n    return target;\n  }\n  intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n\n    // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n    if (this.isEmpty()) this.makeEmpty();\n    return this;\n  }\n  union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  }\n  applyMatrix4(matrix) {\n    // transform of empty box is an empty box.\n    if (this.isEmpty()) return this;\n\n    // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n    this.setFromPoints(_points);\n    return this;\n  }\n  translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  }\n  equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}\nconst _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];\nconst _vector$b = /*@__PURE__*/new Vector3();\nconst _box$4 = /*@__PURE__*/new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/new Vector3();\nconst _v1$7 = /*@__PURE__*/new Vector3();\nconst _v2$4 = /*@__PURE__*/new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/new Vector3();\nconst _f1 = /*@__PURE__*/new Vector3();\nconst _f2 = /*@__PURE__*/new Vector3();\nconst _center = /*@__PURE__*/new Vector3();\nconst _extents = /*@__PURE__*/new Vector3();\nconst _triangleNormal = /*@__PURE__*/new Vector3();\nconst _testAxis = /*@__PURE__*/new Vector3();\nfunction satForAxes(axes, v0, v1, v2, extents) {\n  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n    _testAxis.fromArray(axes, i);\n    // project the aabb onto the separating axis\n    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n    // project all 3 vertices of the triangle onto the separating axis\n    const p0 = v0.dot(_testAxis);\n    const p1 = v1.dot(_testAxis);\n    const p2 = v2.dot(_testAxis);\n    // actual test, basically see if either of the most extreme of the triangle points intersects r\n    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      // points of the projected triangle are outside the projected half-length of the aabb\n      // the axis is separating and we can exit\n      return false;\n    }\n  }\n  return true;\n}\nconst _box$3 = /*@__PURE__*/new Box3();\nconst _v1$6 = /*@__PURE__*/new Vector3();\nconst _v2$3 = /*@__PURE__*/new Vector3();\nclass Sphere {\n  constructor(center = new Vector3(), radius = -1) {\n    this.isSphere = true;\n    this.center = center;\n    this.radius = radius;\n  }\n  set(center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n  setFromPoints(points, optionalCenter) {\n    const center = this.center;\n    if (optionalCenter !== undefined) {\n      center.copy(optionalCenter);\n    } else {\n      _box$3.setFromPoints(points).getCenter(center);\n    }\n    let maxRadiusSq = 0;\n    for (let i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n    this.radius = Math.sqrt(maxRadiusSq);\n    return this;\n  }\n  copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  }\n  isEmpty() {\n    return this.radius < 0;\n  }\n  makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n    return this;\n  }\n  containsPoint(point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n  distanceToPoint(point) {\n    return point.distanceTo(this.center) - this.radius;\n  }\n  intersectsSphere(sphere) {\n    const radiusSum = this.radius + sphere.radius;\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n  intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n  intersectsPlane(plane) {\n    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n  clampPoint(point, target) {\n    const deltaLengthSq = this.center.distanceToSquared(point);\n    target.copy(point);\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n    return target;\n  }\n  getBoundingBox(target) {\n    if (this.isEmpty()) {\n      // Empty sphere produces empty bounding box\n      target.makeEmpty();\n      return target;\n    }\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  }\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  }\n  translate(offset) {\n    this.center.add(offset);\n    return this;\n  }\n  expandByPoint(point) {\n    if (this.isEmpty()) {\n      this.center.copy(point);\n      this.radius = 0;\n      return this;\n    }\n    _v1$6.subVectors(point, this.center);\n    const lengthSq = _v1$6.lengthSq();\n    if (lengthSq > this.radius * this.radius) {\n      // calculate the minimal sphere\n\n      const length = Math.sqrt(lengthSq);\n      const delta = (length - this.radius) * 0.5;\n      this.center.addScaledVector(_v1$6, delta / length);\n      this.radius += delta;\n    }\n    return this;\n  }\n  union(sphere) {\n    if (sphere.isEmpty()) {\n      return this;\n    }\n    if (this.isEmpty()) {\n      this.copy(sphere);\n      return this;\n    }\n    if (this.center.equals(sphere.center) === true) {\n      this.radius = Math.max(this.radius, sphere.radius);\n    } else {\n      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);\n      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));\n      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));\n    }\n    return this;\n  }\n  equals(sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _vector$a = /*@__PURE__*/new Vector3();\nconst _segCenter = /*@__PURE__*/new Vector3();\nconst _segDir = /*@__PURE__*/new Vector3();\nconst _diff = /*@__PURE__*/new Vector3();\nconst _edge1 = /*@__PURE__*/new Vector3();\nconst _edge2 = /*@__PURE__*/new Vector3();\nconst _normal$1 = /*@__PURE__*/new Vector3();\nclass Ray {\n  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n    this.origin = origin;\n    this.direction = direction;\n  }\n  set(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n    return this;\n  }\n  copy(ray) {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n    return this;\n  }\n  at(t, target) {\n    return target.copy(this.origin).addScaledVector(this.direction, t);\n  }\n  lookAt(v) {\n    this.direction.copy(v).sub(this.origin).normalize();\n    return this;\n  }\n  recast(t) {\n    this.origin.copy(this.at(t, _vector$a));\n    return this;\n  }\n  closestPointToPoint(point, target) {\n    target.subVectors(point, this.origin);\n    const directionDistance = target.dot(this.direction);\n    if (directionDistance < 0) {\n      return target.copy(this.origin);\n    }\n    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);\n  }\n  distanceToPoint(point) {\n    return Math.sqrt(this.distanceSqToPoint(point));\n  }\n  distanceSqToPoint(point) {\n    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);\n\n    // point behind the ray\n\n    if (directionDistance < 0) {\n      return this.origin.distanceToSquared(point);\n    }\n    _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);\n    return _vector$a.distanceToSquared(point);\n  }\n  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n    // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n    // It returns the min distance between the ray and the segment\n    // defined by v0 and v1\n    // It can also set two optional targets :\n    // - The closest point on the ray\n    // - The closest point on the segment\n\n    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n    _segDir.copy(v1).sub(v0).normalize();\n    _diff.copy(this.origin).sub(_segCenter);\n    const segExtent = v0.distanceTo(v1) * 0.5;\n    const a01 = -this.direction.dot(_segDir);\n    const b0 = _diff.dot(this.direction);\n    const b1 = -_diff.dot(_segDir);\n    const c = _diff.lengthSq();\n    const det = Math.abs(1 - a01 * a01);\n    let s0, s1, sqrDist, extDet;\n    if (det > 0) {\n      // The ray and segment are not parallel.\n\n      s0 = a01 * b1 - b0;\n      s1 = a01 * b0 - b1;\n      extDet = segExtent * det;\n      if (s0 >= 0) {\n        if (s1 >= -extDet) {\n          if (s1 <= extDet) {\n            // region 0\n            // Minimum at interior points of ray and segment.\n\n            const invDet = 1 / det;\n            s0 *= invDet;\n            s1 *= invDet;\n            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n          } else {\n            // region 1\n\n            s1 = segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          // region 5\n\n          s1 = -segExtent;\n          s0 = Math.max(0, -(a01 * s1 + b0));\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      } else {\n        if (s1 <= -extDet) {\n          // region 4\n\n          s0 = Math.max(0, -(-a01 * segExtent + b0));\n          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        } else if (s1 <= extDet) {\n          // region 3\n\n          s0 = 0;\n          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = s1 * (s1 + 2 * b1) + c;\n        } else {\n          // region 2\n\n          s0 = Math.max(0, -(a01 * segExtent + b0));\n          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      }\n    } else {\n      // Ray and segment are parallel.\n\n      s1 = a01 > 0 ? -segExtent : segExtent;\n      s0 = Math.max(0, -(a01 * s1 + b0));\n      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n    }\n    if (optionalPointOnRay) {\n      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n    }\n    if (optionalPointOnSegment) {\n      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);\n    }\n    return sqrDist;\n  }\n  intersectSphere(sphere, target) {\n    _vector$a.subVectors(sphere.center, this.origin);\n    const tca = _vector$a.dot(this.direction);\n    const d2 = _vector$a.dot(_vector$a) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2) return null;\n    const thc = Math.sqrt(radius2 - d2);\n\n    // t0 = first intersect point - entrance on front of sphere\n    const t0 = tca - thc;\n\n    // t1 = second intersect point - exit point on back of sphere\n    const t1 = tca + thc;\n\n    // test to see if t1 is behind the ray - if so, return null\n    if (t1 < 0) return null;\n\n    // test to see if t0 is behind the ray:\n    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n    // in order to always return an intersect point that is in front of the ray.\n    if (t0 < 0) return this.at(t1, target);\n\n    // else t0 is in front of the ray, so return the first collision point scaled by t0\n    return this.at(t0, target);\n  }\n  intersectsSphere(sphere) {\n    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  distanceToPlane(plane) {\n    const denominator = plane.normal.dot(this.direction);\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n      }\n\n      // Null is preferable to undefined since undefined means.... it is undefined\n\n      return null;\n    }\n    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n\n    // Return if the ray never intersects the plane\n\n    return t >= 0 ? t : null;\n  }\n  intersectPlane(plane, target) {\n    const t = this.distanceToPlane(plane);\n    if (t === null) {\n      return null;\n    }\n    return this.at(t, target);\n  }\n  intersectsPlane(plane) {\n    // check if the ray lies on the plane first\n\n    const distToPoint = plane.distanceToPoint(this.origin);\n    if (distToPoint === 0) {\n      return true;\n    }\n    const denominator = plane.normal.dot(this.direction);\n    if (denominator * distToPoint < 0) {\n      return true;\n    }\n\n    // ray origin is behind the plane (and is pointing behind it)\n\n    return false;\n  }\n  intersectBox(box, target) {\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / this.direction.x,\n      invdiry = 1 / this.direction.y,\n      invdirz = 1 / this.direction.z;\n    const origin = this.origin;\n    if (invdirx >= 0) {\n      tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n    if (invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = (box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * invdiry;\n    }\n    if (tmin > tymax || tymin > tmax) return null;\n    if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n    if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n    if (invdirz >= 0) {\n      tzmin = (box.min.z - origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    } else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = (box.min.z - origin.z) * invdirz;\n    }\n    if (tmin > tzmax || tzmin > tmax) return null;\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n\n    //return point closest to the ray (positive side)\n\n    if (tmax < 0) return null;\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n  intersectsBox(box) {\n    return this.intersectBox(box, _vector$a) !== null;\n  }\n  intersectTriangle(a, b, c, backfaceCulling, target) {\n    // Compute the offset origin, edges, and normal.\n\n    // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n    _edge1.subVectors(b, a);\n    _edge2.subVectors(c, a);\n    _normal$1.crossVectors(_edge1, _edge2);\n\n    // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n    let DdN = this.direction.dot(_normal$1);\n    let sign;\n    if (DdN > 0) {\n      if (backfaceCulling) return null;\n      sign = 1;\n    } else if (DdN < 0) {\n      sign = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    }\n    _diff.subVectors(this.origin, a);\n    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n\n    // b1 < 0, no intersection\n    if (DdQxE2 < 0) {\n      return null;\n    }\n    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n\n    // b2 < 0, no intersection\n    if (DdE1xQ < 0) {\n      return null;\n    }\n\n    // b1+b2 > 1, no intersection\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n    }\n\n    // Line intersects triangle, check if ray does.\n    const QdN = -sign * _diff.dot(_normal$1);\n\n    // t < 0, no intersection\n    if (QdN < 0) {\n      return null;\n    }\n\n    // Ray intersects triangle.\n    return this.at(QdN / DdN, target);\n  }\n  applyMatrix4(matrix4) {\n    this.origin.applyMatrix4(matrix4);\n    this.direction.transformDirection(matrix4);\n    return this;\n  }\n  equals(ray) {\n    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nclass Matrix4 {\n  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n    Matrix4.prototype.isMatrix4 = true;\n    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    if (n11 !== undefined) {\n      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n    }\n  }\n  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n    const te = this.elements;\n    te[0] = n11;\n    te[4] = n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = n42;\n    te[11] = n43;\n    te[15] = n44;\n    return this;\n  }\n  identity() {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n  clone() {\n    return new Matrix4().fromArray(this.elements);\n  }\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    te[9] = me[9];\n    te[10] = me[10];\n    te[11] = me[11];\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    te[15] = me[15];\n    return this;\n  }\n  copyPosition(m) {\n    const te = this.elements,\n      me = m.elements;\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    return this;\n  }\n  setFromMatrix3(m) {\n    const me = m.elements;\n    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrixColumn(this, 0);\n    yAxis.setFromMatrixColumn(this, 1);\n    zAxis.setFromMatrixColumn(this, 2);\n    return this;\n  }\n  makeBasis(xAxis, yAxis, zAxis) {\n    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n    return this;\n  }\n  extractRotation(m) {\n    // this method does not support reflection matrices\n\n    const te = this.elements;\n    const me = m.elements;\n    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n    te[0] = me[0] * scaleX;\n    te[1] = me[1] * scaleX;\n    te[2] = me[2] * scaleX;\n    te[3] = 0;\n    te[4] = me[4] * scaleY;\n    te[5] = me[5] * scaleY;\n    te[6] = me[6] * scaleY;\n    te[7] = 0;\n    te[8] = me[8] * scaleZ;\n    te[9] = me[9] * scaleZ;\n    te[10] = me[10] * scaleZ;\n    te[11] = 0;\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  makeRotationFromEuler(euler) {\n    const te = this.elements;\n    const x = euler.x,\n      y = euler.y,\n      z = euler.z;\n    const a = Math.cos(x),\n      b = Math.sin(x);\n    const c = Math.cos(y),\n      d = Math.sin(y);\n    const e = Math.cos(z),\n      f = Math.sin(z);\n    if (euler.order === 'XYZ') {\n      const ae = a * e,\n        af = a * f,\n        be = b * e,\n        bf = b * f;\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n    } else if (euler.order === 'YXZ') {\n      const ce = c * e,\n        cf = c * f,\n        de = d * e,\n        df = d * f;\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a * d;\n      te[1] = a * f;\n      te[5] = a * e;\n      te[9] = -b;\n      te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZXY') {\n      const ce = c * e,\n        cf = c * f,\n        de = d * e,\n        df = d * f;\n      te[0] = ce - df * b;\n      te[4] = -a * f;\n      te[8] = de + cf * b;\n      te[1] = cf + de * b;\n      te[5] = a * e;\n      te[9] = df - ce * b;\n      te[2] = -a * d;\n      te[6] = b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZYX') {\n      const ae = a * e,\n        af = a * f,\n        be = b * e,\n        bf = b * f;\n      te[0] = c * e;\n      te[4] = be * d - af;\n      te[8] = ae * d + bf;\n      te[1] = c * f;\n      te[5] = bf * d + ae;\n      te[9] = af * d - be;\n      te[2] = -d;\n      te[6] = b * c;\n      te[10] = a * c;\n    } else if (euler.order === 'YZX') {\n      const ac = a * c,\n        ad = a * d,\n        bc = b * c,\n        bd = b * d;\n      te[0] = c * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + ad;\n      te[1] = f;\n      te[5] = a * e;\n      te[9] = -b * e;\n      te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    } else if (euler.order === 'XZY') {\n      const ac = a * c,\n        ad = a * d,\n        bc = b * c,\n        bd = b * d;\n      te[0] = c * e;\n      te[4] = -f;\n      te[8] = d * e;\n      te[1] = ac * f + bd;\n      te[5] = a * e;\n      te[9] = ad * f - bc;\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      te[10] = bd * f + ac;\n    }\n\n    // bottom row\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n\n    // last column\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  makeRotationFromQuaternion(q) {\n    return this.compose(_zero, q, _one);\n  }\n  lookAt(eye, target, up) {\n    const te = this.elements;\n    _z.subVectors(eye, target);\n    if (_z.lengthSq() === 0) {\n      // eye and target are in the same position\n\n      _z.z = 1;\n    }\n    _z.normalize();\n    _x.crossVectors(up, _z);\n    if (_x.lengthSq() === 0) {\n      // up and z are parallel\n\n      if (Math.abs(up.z) === 1) {\n        _z.x += 0.0001;\n      } else {\n        _z.z += 0.0001;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n    }\n    _x.normalize();\n    _y.crossVectors(_z, _x);\n    te[0] = _x.x;\n    te[4] = _y.x;\n    te[8] = _z.x;\n    te[1] = _x.y;\n    te[5] = _y.y;\n    te[9] = _z.y;\n    te[2] = _x.z;\n    te[6] = _y.z;\n    te[10] = _z.z;\n    return this;\n  }\n  multiply(m) {\n    return this.multiplyMatrices(this, m);\n  }\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0],\n      a12 = ae[4],\n      a13 = ae[8],\n      a14 = ae[12];\n    const a21 = ae[1],\n      a22 = ae[5],\n      a23 = ae[9],\n      a24 = ae[13];\n    const a31 = ae[2],\n      a32 = ae[6],\n      a33 = ae[10],\n      a34 = ae[14];\n    const a41 = ae[3],\n      a42 = ae[7],\n      a43 = ae[11],\n      a44 = ae[15];\n    const b11 = be[0],\n      b12 = be[4],\n      b13 = be[8],\n      b14 = be[12];\n    const b21 = be[1],\n      b22 = be[5],\n      b23 = be[9],\n      b24 = be[13];\n    const b31 = be[2],\n      b32 = be[6],\n      b33 = be[10],\n      b34 = be[14];\n    const b41 = be[3],\n      b42 = be[7],\n      b43 = be[11],\n      b44 = be[15];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] *= s;\n    te[15] *= s;\n    return this;\n  }\n  determinant() {\n    const te = this.elements;\n    const n11 = te[0],\n      n12 = te[4],\n      n13 = te[8],\n      n14 = te[12];\n    const n21 = te[1],\n      n22 = te[5],\n      n23 = te[9],\n      n24 = te[13];\n    const n31 = te[2],\n      n32 = te[6],\n      n33 = te[10],\n      n34 = te[14];\n    const n41 = te[3],\n      n42 = te[7],\n      n43 = te[11],\n      n44 = te[15];\n\n    //TODO: make this more efficient\n    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n  }\n  transpose() {\n    const te = this.elements;\n    let tmp;\n    tmp = te[1];\n    te[1] = te[4];\n    te[4] = tmp;\n    tmp = te[2];\n    te[2] = te[8];\n    te[8] = tmp;\n    tmp = te[6];\n    te[6] = te[9];\n    te[9] = tmp;\n    tmp = te[3];\n    te[3] = te[12];\n    te[12] = tmp;\n    tmp = te[7];\n    te[7] = te[13];\n    te[13] = tmp;\n    tmp = te[11];\n    te[11] = te[14];\n    te[14] = tmp;\n    return this;\n  }\n  setPosition(x, y, z) {\n    const te = this.elements;\n    if (x.isVector3) {\n      te[12] = x.x;\n      te[13] = x.y;\n      te[14] = x.z;\n    } else {\n      te[12] = x;\n      te[13] = y;\n      te[14] = z;\n    }\n    return this;\n  }\n  invert() {\n    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    const te = this.elements,\n      n11 = te[0],\n      n21 = te[1],\n      n31 = te[2],\n      n41 = te[3],\n      n12 = te[4],\n      n22 = te[5],\n      n32 = te[6],\n      n42 = te[7],\n      n13 = te[8],\n      n23 = te[9],\n      n33 = te[10],\n      n43 = te[11],\n      n14 = te[12],\n      n24 = te[13],\n      n34 = te[14],\n      n44 = te[15],\n      t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n      t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n      t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n      t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n    te[4] = t12 * detInv;\n    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n    te[8] = t13 * detInv;\n    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n    te[12] = t14 * detInv;\n    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n    return this;\n  }\n  scale(v) {\n    const te = this.elements;\n    const x = v.x,\n      y = v.y,\n      z = v.z;\n    te[0] *= x;\n    te[4] *= y;\n    te[8] *= z;\n    te[1] *= x;\n    te[5] *= y;\n    te[9] *= z;\n    te[2] *= x;\n    te[6] *= y;\n    te[10] *= z;\n    te[3] *= x;\n    te[7] *= y;\n    te[11] *= z;\n    return this;\n  }\n  getMaxScaleOnAxis() {\n    const te = this.elements;\n    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n  }\n  makeTranslation(x, y, z) {\n    if (x.isVector3) {\n      this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);\n    } else {\n      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n    }\n    return this;\n  }\n  makeRotationX(theta) {\n    const c = Math.cos(theta),\n      s = Math.sin(theta);\n    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationY(theta) {\n    const c = Math.cos(theta),\n      s = Math.sin(theta);\n    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationZ(theta) {\n    const c = Math.cos(theta),\n      s = Math.sin(theta);\n    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationAxis(axis, angle) {\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    const t = 1 - c;\n    const x = axis.x,\n      y = axis.y,\n      z = axis.z;\n    const tx = t * x,\n      ty = t * y;\n    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeScale(x, y, z) {\n    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeShear(xy, xz, yx, yz, zx, zy) {\n    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n  compose(position, quaternion, scale) {\n    const te = this.elements;\n    const x = quaternion._x,\n      y = quaternion._y,\n      z = quaternion._z,\n      w = quaternion._w;\n    const x2 = x + x,\n      y2 = y + y,\n      z2 = z + z;\n    const xx = x * x2,\n      xy = x * y2,\n      xz = x * z2;\n    const yy = y * y2,\n      yz = y * z2,\n      zz = z * z2;\n    const wx = w * x2,\n      wy = w * y2,\n      wz = w * z2;\n    const sx = scale.x,\n      sy = scale.y,\n      sz = scale.z;\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = position.x;\n    te[13] = position.y;\n    te[14] = position.z;\n    te[15] = 1;\n    return this;\n  }\n  decompose(position, quaternion, scale) {\n    const te = this.elements;\n    let sx = _v1$5.set(te[0], te[1], te[2]).length();\n    const sy = _v1$5.set(te[4], te[5], te[6]).length();\n    const sz = _v1$5.set(te[8], te[9], te[10]).length();\n\n    // if determine is negative, we need to invert one scale\n    const det = this.determinant();\n    if (det < 0) sx = -sx;\n    position.x = te[12];\n    position.y = te[13];\n    position.z = te[14];\n\n    // scale the rotation part\n    _m1$2.copy(this);\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    _m1$2.elements[0] *= invSX;\n    _m1$2.elements[1] *= invSX;\n    _m1$2.elements[2] *= invSX;\n    _m1$2.elements[4] *= invSY;\n    _m1$2.elements[5] *= invSY;\n    _m1$2.elements[6] *= invSY;\n    _m1$2.elements[8] *= invSZ;\n    _m1$2.elements[9] *= invSZ;\n    _m1$2.elements[10] *= invSZ;\n    quaternion.setFromRotationMatrix(_m1$2);\n    scale.x = sx;\n    scale.y = sy;\n    scale.z = sz;\n    return this;\n  }\n  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n    const te = this.elements;\n    const x = 2 * near / (right - left);\n    const y = 2 * near / (top - bottom);\n    const a = (right + left) / (right - left);\n    const b = (top + bottom) / (top - bottom);\n    let c, d;\n    if (coordinateSystem === WebGLCoordinateSystem) {\n      c = -(far + near) / (far - near);\n      d = -2 * far * near / (far - near);\n    } else if (coordinateSystem === WebGPUCoordinateSystem) {\n      c = -far / (far - near);\n      d = -far * near / (far - near);\n    } else {\n      throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);\n    }\n    te[0] = x;\n    te[4] = 0;\n    te[8] = a;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y;\n    te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n    return this;\n  }\n  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n    const te = this.elements;\n    const w = 1.0 / (right - left);\n    const h = 1.0 / (top - bottom);\n    const p = 1.0 / (far - near);\n    const x = (right + left) * w;\n    const y = (top + bottom) * h;\n    let z, zInv;\n    if (coordinateSystem === WebGLCoordinateSystem) {\n      z = (far + near) * p;\n      zInv = -2 * p;\n    } else if (coordinateSystem === WebGPUCoordinateSystem) {\n      z = near * p;\n      zInv = -1 * p;\n    } else {\n      throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);\n    }\n    te[0] = 2 * w;\n    te[4] = 0;\n    te[8] = 0;\n    te[12] = -x;\n    te[1] = 0;\n    te[5] = 2 * h;\n    te[9] = 0;\n    te[13] = -y;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = zInv;\n    te[14] = -z;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = 1;\n    return this;\n  }\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 16; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return true;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 16; i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n    array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n    return array;\n  }\n}\nconst _v1$5 = /*@__PURE__*/new Vector3();\nconst _m1$2 = /*@__PURE__*/new Matrix4();\nconst _zero = /*@__PURE__*/new Vector3(0, 0, 0);\nconst _one = /*@__PURE__*/new Vector3(1, 1, 1);\nconst _x = /*@__PURE__*/new Vector3();\nconst _y = /*@__PURE__*/new Vector3();\nconst _z = /*@__PURE__*/new Vector3();\nconst _matrix$2 = /*@__PURE__*/new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/new Quaternion();\nclass Euler {\n  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n    this.isEuler = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get order() {\n    return this._order;\n  }\n  set order(value) {\n    this._order = value;\n    this._onChangeCallback();\n  }\n  set(x, y, z, order = this._order) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n    this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._order);\n  }\n  copy(euler) {\n    this._x = euler._x;\n    this._y = euler._y;\n    this._z = euler._z;\n    this._order = euler._order;\n    this._onChangeCallback();\n    return this;\n  }\n  setFromRotationMatrix(m, order = this._order, update = true) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    const te = m.elements;\n    const m11 = te[0],\n      m12 = te[4],\n      m13 = te[8];\n    const m21 = te[1],\n      m22 = te[5],\n      m23 = te[9];\n    const m31 = te[2],\n      m32 = te[6],\n      m33 = te[10];\n    switch (order) {\n      case 'XYZ':\n        this._y = Math.asin(clamp(m13, -1, 1));\n        if (Math.abs(m13) < 0.9999999) {\n          this._x = Math.atan2(-m23, m33);\n          this._z = Math.atan2(-m12, m11);\n        } else {\n          this._x = Math.atan2(m32, m22);\n          this._z = 0;\n        }\n        break;\n      case 'YXZ':\n        this._x = Math.asin(-clamp(m23, -1, 1));\n        if (Math.abs(m23) < 0.9999999) {\n          this._y = Math.atan2(m13, m33);\n          this._z = Math.atan2(m21, m22);\n        } else {\n          this._y = Math.atan2(-m31, m11);\n          this._z = 0;\n        }\n        break;\n      case 'ZXY':\n        this._x = Math.asin(clamp(m32, -1, 1));\n        if (Math.abs(m32) < 0.9999999) {\n          this._y = Math.atan2(-m31, m33);\n          this._z = Math.atan2(-m12, m22);\n        } else {\n          this._y = 0;\n          this._z = Math.atan2(m21, m11);\n        }\n        break;\n      case 'ZYX':\n        this._y = Math.asin(-clamp(m31, -1, 1));\n        if (Math.abs(m31) < 0.9999999) {\n          this._x = Math.atan2(m32, m33);\n          this._z = Math.atan2(m21, m11);\n        } else {\n          this._x = 0;\n          this._z = Math.atan2(-m12, m22);\n        }\n        break;\n      case 'YZX':\n        this._z = Math.asin(clamp(m21, -1, 1));\n        if (Math.abs(m21) < 0.9999999) {\n          this._x = Math.atan2(-m23, m22);\n          this._y = Math.atan2(-m31, m11);\n        } else {\n          this._x = 0;\n          this._y = Math.atan2(m13, m33);\n        }\n        break;\n      case 'XZY':\n        this._z = Math.asin(-clamp(m12, -1, 1));\n        if (Math.abs(m12) < 0.9999999) {\n          this._x = Math.atan2(m32, m22);\n          this._y = Math.atan2(m13, m11);\n        } else {\n          this._x = Math.atan2(-m23, m33);\n          this._y = 0;\n        }\n        break;\n      default:\n        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);\n    }\n    this._order = order;\n    if (update === true) this._onChangeCallback();\n    return this;\n  }\n  setFromQuaternion(q, order, update) {\n    _matrix$2.makeRotationFromQuaternion(q);\n    return this.setFromRotationMatrix(_matrix$2, order, update);\n  }\n  setFromVector3(v, order = this._order) {\n    return this.set(v.x, v.y, v.z, order);\n  }\n  reorder(newOrder) {\n    // WARNING: this discards revolution information -bhouston\n\n    _quaternion$3.setFromEuler(this);\n    return this.setFromQuaternion(_quaternion$3, newOrder);\n  }\n  equals(euler) {\n    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n  }\n  fromArray(array) {\n    this._x = array[0];\n    this._y = array[1];\n    this._z = array[2];\n    if (array[3] !== undefined) this._order = array[3];\n    this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._order;\n    return array;\n  }\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n  _onChangeCallback() {}\n  *[Symbol.iterator]() {\n    yield this._x;\n    yield this._y;\n    yield this._z;\n    yield this._order;\n  }\n}\nEuler.DEFAULT_ORDER = 'XYZ';\nclass Layers {\n  constructor() {\n    this.mask = 1 | 0;\n  }\n  set(channel) {\n    this.mask = (1 << channel | 0) >>> 0;\n  }\n  enable(channel) {\n    this.mask |= 1 << channel | 0;\n  }\n  enableAll() {\n    this.mask = 0xffffffff | 0;\n  }\n  toggle(channel) {\n    this.mask ^= 1 << channel | 0;\n  }\n  disable(channel) {\n    this.mask &= ~(1 << channel | 0);\n  }\n  disableAll() {\n    this.mask = 0;\n  }\n  test(layers) {\n    return (this.mask & layers.mask) !== 0;\n  }\n  isEnabled(channel) {\n    return (this.mask & (1 << channel | 0)) !== 0;\n  }\n}\nlet _object3DId = 0;\nconst _v1$4 = /*@__PURE__*/new Vector3();\nconst _q1 = /*@__PURE__*/new Quaternion();\nconst _m1$1 = /*@__PURE__*/new Matrix4();\nconst _target = /*@__PURE__*/new Vector3();\nconst _position$3 = /*@__PURE__*/new Vector3();\nconst _scale$2 = /*@__PURE__*/new Vector3();\nconst _quaternion$2 = /*@__PURE__*/new Quaternion();\nconst _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);\nconst _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);\nconst _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);\nconst _addedEvent = {\n  type: 'added'\n};\nconst _removedEvent = {\n  type: 'removed'\n};\nconst _childaddedEvent = {\n  type: 'childadded',\n  child: null\n};\nconst _childremovedEvent = {\n  type: 'childremoved',\n  child: null\n};\nclass Object3D extends EventDispatcher {\n  constructor() {\n    super();\n    this.isObject3D = true;\n    Object.defineProperty(this, 'id', {\n      value: _object3DId++\n    });\n    this.uuid = generateUUID();\n    this.name = '';\n    this.type = 'Object3D';\n    this.parent = null;\n    this.children = [];\n    this.up = Object3D.DEFAULT_UP.clone();\n    const position = new Vector3();\n    const rotation = new Euler();\n    const quaternion = new Quaternion();\n    const scale = new Vector3(1, 1, 1);\n    function onRotationChange() {\n      quaternion.setFromEuler(rotation, false);\n    }\n    function onQuaternionChange() {\n      rotation.setFromQuaternion(quaternion, undefined, false);\n    }\n    rotation._onChange(onRotationChange);\n    quaternion._onChange(onQuaternionChange);\n    Object.defineProperties(this, {\n      position: {\n        configurable: true,\n        enumerable: true,\n        value: position\n      },\n      rotation: {\n        configurable: true,\n        enumerable: true,\n        value: rotation\n      },\n      quaternion: {\n        configurable: true,\n        enumerable: true,\n        value: quaternion\n      },\n      scale: {\n        configurable: true,\n        enumerable: true,\n        value: scale\n      },\n      modelViewMatrix: {\n        value: new Matrix4()\n      },\n      normalMatrix: {\n        value: new Matrix3()\n      }\n    });\n    this.matrix = new Matrix4();\n    this.matrixWorld = new Matrix4();\n    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\n    this.matrixWorldNeedsUpdate = false;\n    this.layers = new Layers();\n    this.visible = true;\n    this.castShadow = false;\n    this.receiveShadow = false;\n    this.frustumCulled = true;\n    this.renderOrder = 0;\n    this.animations = [];\n    this.userData = {};\n  }\n  onBeforeShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}\n  onAfterShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}\n  onBeforeRender(/* renderer, scene, camera, geometry, material, group */) {}\n  onAfterRender(/* renderer, scene, camera, geometry, material, group */) {}\n  applyMatrix4(matrix) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n    this.matrix.premultiply(matrix);\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n  }\n  applyQuaternion(q) {\n    this.quaternion.premultiply(q);\n    return this;\n  }\n  setRotationFromAxisAngle(axis, angle) {\n    // assumes axis is normalized\n\n    this.quaternion.setFromAxisAngle(axis, angle);\n  }\n  setRotationFromEuler(euler) {\n    this.quaternion.setFromEuler(euler, true);\n  }\n  setRotationFromMatrix(m) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    this.quaternion.setFromRotationMatrix(m);\n  }\n  setRotationFromQuaternion(q) {\n    // assumes q is normalized\n\n    this.quaternion.copy(q);\n  }\n  rotateOnAxis(axis, angle) {\n    // rotate object on axis in object space\n    // axis is assumed to be normalized\n\n    _q1.setFromAxisAngle(axis, angle);\n    this.quaternion.multiply(_q1);\n    return this;\n  }\n  rotateOnWorldAxis(axis, angle) {\n    // rotate object on axis in world space\n    // axis is assumed to be normalized\n    // method assumes no rotated parent\n\n    _q1.setFromAxisAngle(axis, angle);\n    this.quaternion.premultiply(_q1);\n    return this;\n  }\n  rotateX(angle) {\n    return this.rotateOnAxis(_xAxis, angle);\n  }\n  rotateY(angle) {\n    return this.rotateOnAxis(_yAxis, angle);\n  }\n  rotateZ(angle) {\n    return this.rotateOnAxis(_zAxis, angle);\n  }\n  translateOnAxis(axis, distance) {\n    // translate object by distance along axis in object space\n    // axis is assumed to be normalized\n\n    _v1$4.copy(axis).applyQuaternion(this.quaternion);\n    this.position.add(_v1$4.multiplyScalar(distance));\n    return this;\n  }\n  translateX(distance) {\n    return this.translateOnAxis(_xAxis, distance);\n  }\n  translateY(distance) {\n    return this.translateOnAxis(_yAxis, distance);\n  }\n  translateZ(distance) {\n    return this.translateOnAxis(_zAxis, distance);\n  }\n  localToWorld(vector) {\n    this.updateWorldMatrix(true, false);\n    return vector.applyMatrix4(this.matrixWorld);\n  }\n  worldToLocal(vector) {\n    this.updateWorldMatrix(true, false);\n    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n  }\n  lookAt(x, y, z) {\n    // This method does not support objects having non-uniformly-scaled parent(s)\n\n    if (x.isVector3) {\n      _target.copy(x);\n    } else {\n      _target.set(x, y, z);\n    }\n    const parent = this.parent;\n    this.updateWorldMatrix(true, false);\n    _position$3.setFromMatrixPosition(this.matrixWorld);\n    if (this.isCamera || this.isLight) {\n      _m1$1.lookAt(_position$3, _target, this.up);\n    } else {\n      _m1$1.lookAt(_target, _position$3, this.up);\n    }\n    this.quaternion.setFromRotationMatrix(_m1$1);\n    if (parent) {\n      _m1$1.extractRotation(parent.matrixWorld);\n      _q1.setFromRotationMatrix(_m1$1);\n      this.quaternion.premultiply(_q1.invert());\n    }\n  }\n  add(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n      return this;\n    }\n    if (object === this) {\n      console.error('THREE.Object3D.add: object can\\'t be added as a child of itself.', object);\n      return this;\n    }\n    if (object && object.isObject3D) {\n      object.removeFromParent();\n      object.parent = this;\n      this.children.push(object);\n      object.dispatchEvent(_addedEvent);\n      _childaddedEvent.child = object;\n      this.dispatchEvent(_childaddedEvent);\n      _childaddedEvent.child = null;\n    } else {\n      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);\n    }\n    return this;\n  }\n  remove(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n      return this;\n    }\n    const index = this.children.indexOf(object);\n    if (index !== -1) {\n      object.parent = null;\n      this.children.splice(index, 1);\n      object.dispatchEvent(_removedEvent);\n      _childremovedEvent.child = object;\n      this.dispatchEvent(_childremovedEvent);\n      _childremovedEvent.child = null;\n    }\n    return this;\n  }\n  removeFromParent() {\n    const parent = this.parent;\n    if (parent !== null) {\n      parent.remove(this);\n    }\n    return this;\n  }\n  clear() {\n    return this.remove(...this.children);\n  }\n  attach(object) {\n    // adds object as a child of this, while maintaining the object's world transform\n\n    // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n\n    this.updateWorldMatrix(true, false);\n    _m1$1.copy(this.matrixWorld).invert();\n    if (object.parent !== null) {\n      object.parent.updateWorldMatrix(true, false);\n      _m1$1.multiply(object.parent.matrixWorld);\n    }\n    object.applyMatrix4(_m1$1);\n    object.removeFromParent();\n    object.parent = this;\n    this.children.push(object);\n    object.updateWorldMatrix(false, true);\n    object.dispatchEvent(_addedEvent);\n    _childaddedEvent.child = object;\n    this.dispatchEvent(_childaddedEvent);\n    _childaddedEvent.child = null;\n    return this;\n  }\n  getObjectById(id) {\n    return this.getObjectByProperty('id', id);\n  }\n  getObjectByName(name) {\n    return this.getObjectByProperty('name', name);\n  }\n  getObjectByProperty(name, value) {\n    if (this[name] === value) return this;\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      const child = this.children[i];\n      const object = child.getObjectByProperty(name, value);\n      if (object !== undefined) {\n        return object;\n      }\n    }\n    return undefined;\n  }\n  getObjectsByProperty(name, value, result = []) {\n    if (this[name] === value) result.push(this);\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].getObjectsByProperty(name, value, result);\n    }\n    return result;\n  }\n  getWorldPosition(target) {\n    this.updateWorldMatrix(true, false);\n    return target.setFromMatrixPosition(this.matrixWorld);\n  }\n  getWorldQuaternion(target) {\n    this.updateWorldMatrix(true, false);\n    this.matrixWorld.decompose(_position$3, target, _scale$2);\n    return target;\n  }\n  getWorldScale(target) {\n    this.updateWorldMatrix(true, false);\n    this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n    return target;\n  }\n  getWorldDirection(target) {\n    this.updateWorldMatrix(true, false);\n    const e = this.matrixWorld.elements;\n    return target.set(e[8], e[9], e[10]).normalize();\n  }\n  raycast(/* raycaster, intersects */) {}\n  traverse(callback) {\n    callback(this);\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverse(callback);\n    }\n  }\n  traverseVisible(callback) {\n    if (this.visible === false) return;\n    callback(this);\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverseVisible(callback);\n    }\n  }\n  traverseAncestors(callback) {\n    const parent = this.parent;\n    if (parent !== null) {\n      callback(parent);\n      parent.traverseAncestors(callback);\n    }\n  }\n  updateMatrix() {\n    this.matrix.compose(this.position, this.quaternion, this.scale);\n    this.matrixWorldNeedsUpdate = true;\n  }\n  updateMatrixWorld(force) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) {\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n      }\n      this.matrixWorldNeedsUpdate = false;\n      force = true;\n    }\n\n    // make sure descendants are updated if required\n\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      const child = children[i];\n      child.updateMatrixWorld(force);\n    }\n  }\n  updateWorldMatrix(updateParents, updateChildren) {\n    const parent = this.parent;\n    if (updateParents === true && parent !== null) {\n      parent.updateWorldMatrix(true, false);\n    }\n    if (this.matrixAutoUpdate) this.updateMatrix();\n    if (this.matrixWorldAutoUpdate === true) {\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n    }\n\n    // make sure descendants are updated\n\n    if (updateChildren === true) {\n      const children = this.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        const child = children[i];\n        child.updateWorldMatrix(false, true);\n      }\n    }\n  }\n  toJSON(meta) {\n    // meta is a string when called from JSON.stringify\n    const isRootObject = meta === undefined || typeof meta === 'string';\n    const output = {};\n\n    // meta is a hash used to collect geometries, materials.\n    // not providing it implies that this is the root object\n    // being serialized.\n    if (isRootObject) {\n      // initialize meta obj\n      meta = {\n        geometries: {},\n        materials: {},\n        textures: {},\n        images: {},\n        shapes: {},\n        skeletons: {},\n        animations: {},\n        nodes: {}\n      };\n      output.metadata = {\n        version: 4.6,\n        type: 'Object',\n        generator: 'Object3D.toJSON'\n      };\n    }\n\n    // standard Object3D serialization\n\n    const object = {};\n    object.uuid = this.uuid;\n    object.type = this.type;\n    if (this.name !== '') object.name = this.name;\n    if (this.castShadow === true) object.castShadow = true;\n    if (this.receiveShadow === true) object.receiveShadow = true;\n    if (this.visible === false) object.visible = false;\n    if (this.frustumCulled === false) object.frustumCulled = false;\n    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n    if (Object.keys(this.userData).length > 0) object.userData = this.userData;\n    object.layers = this.layers.mask;\n    object.matrix = this.matrix.toArray();\n    object.up = this.up.toArray();\n    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n\n    // object specific properties\n\n    if (this.isInstancedMesh) {\n      object.type = 'InstancedMesh';\n      object.count = this.count;\n      object.instanceMatrix = this.instanceMatrix.toJSON();\n      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n    }\n    if (this.isBatchedMesh) {\n      object.type = 'BatchedMesh';\n      object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n      object.sortObjects = this.sortObjects;\n      object.drawRanges = this._drawRanges;\n      object.reservedRanges = this._reservedRanges;\n      object.visibility = this._visibility;\n      object.active = this._active;\n      object.bounds = this._bounds.map(bound => ({\n        boxInitialized: bound.boxInitialized,\n        boxMin: bound.box.min.toArray(),\n        boxMax: bound.box.max.toArray(),\n        sphereInitialized: bound.sphereInitialized,\n        sphereRadius: bound.sphere.radius,\n        sphereCenter: bound.sphere.center.toArray()\n      }));\n      object.maxInstanceCount = this._maxInstanceCount;\n      object.maxVertexCount = this._maxVertexCount;\n      object.maxIndexCount = this._maxIndexCount;\n      object.geometryInitialized = this._geometryInitialized;\n      object.geometryCount = this._geometryCount;\n      object.matricesTexture = this._matricesTexture.toJSON(meta);\n      if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);\n      if (this.boundingSphere !== null) {\n        object.boundingSphere = {\n          center: object.boundingSphere.center.toArray(),\n          radius: object.boundingSphere.radius\n        };\n      }\n      if (this.boundingBox !== null) {\n        object.boundingBox = {\n          min: object.boundingBox.min.toArray(),\n          max: object.boundingBox.max.toArray()\n        };\n      }\n    }\n\n    //\n\n    function serialize(library, element) {\n      if (library[element.uuid] === undefined) {\n        library[element.uuid] = element.toJSON(meta);\n      }\n      return element.uuid;\n    }\n    if (this.isScene) {\n      if (this.background) {\n        if (this.background.isColor) {\n          object.background = this.background.toJSON();\n        } else if (this.background.isTexture) {\n          object.background = this.background.toJSON(meta).uuid;\n        }\n      }\n      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {\n        object.environment = this.environment.toJSON(meta).uuid;\n      }\n    } else if (this.isMesh || this.isLine || this.isPoints) {\n      object.geometry = serialize(meta.geometries, this.geometry);\n      const parameters = this.geometry.parameters;\n      if (parameters !== undefined && parameters.shapes !== undefined) {\n        const shapes = parameters.shapes;\n        if (Array.isArray(shapes)) {\n          for (let i = 0, l = shapes.length; i < l; i++) {\n            const shape = shapes[i];\n            serialize(meta.shapes, shape);\n          }\n        } else {\n          serialize(meta.shapes, shapes);\n        }\n      }\n    }\n    if (this.isSkinnedMesh) {\n      object.bindMode = this.bindMode;\n      object.bindMatrix = this.bindMatrix.toArray();\n      if (this.skeleton !== undefined) {\n        serialize(meta.skeletons, this.skeleton);\n        object.skeleton = this.skeleton.uuid;\n      }\n    }\n    if (this.material !== undefined) {\n      if (Array.isArray(this.material)) {\n        const uuids = [];\n        for (let i = 0, l = this.material.length; i < l; i++) {\n          uuids.push(serialize(meta.materials, this.material[i]));\n        }\n        object.material = uuids;\n      } else {\n        object.material = serialize(meta.materials, this.material);\n      }\n    }\n\n    //\n\n    if (this.children.length > 0) {\n      object.children = [];\n      for (let i = 0; i < this.children.length; i++) {\n        object.children.push(this.children[i].toJSON(meta).object);\n      }\n    }\n\n    //\n\n    if (this.animations.length > 0) {\n      object.animations = [];\n      for (let i = 0; i < this.animations.length; i++) {\n        const animation = this.animations[i];\n        object.animations.push(serialize(meta.animations, animation));\n      }\n    }\n    if (isRootObject) {\n      const geometries = extractFromCache(meta.geometries);\n      const materials = extractFromCache(meta.materials);\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const shapes = extractFromCache(meta.shapes);\n      const skeletons = extractFromCache(meta.skeletons);\n      const animations = extractFromCache(meta.animations);\n      const nodes = extractFromCache(meta.nodes);\n      if (geometries.length > 0) output.geometries = geometries;\n      if (materials.length > 0) output.materials = materials;\n      if (textures.length > 0) output.textures = textures;\n      if (images.length > 0) output.images = images;\n      if (shapes.length > 0) output.shapes = shapes;\n      if (skeletons.length > 0) output.skeletons = skeletons;\n      if (animations.length > 0) output.animations = animations;\n      if (nodes.length > 0) output.nodes = nodes;\n    }\n    output.object = object;\n    return output;\n\n    // extract data from the cache hash\n    // remove metadata on each item\n    // and return as array\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n  }\n  clone(recursive) {\n    return new this.constructor().copy(this, recursive);\n  }\n  copy(source, recursive = true) {\n    this.name = source.name;\n    this.up.copy(source.up);\n    this.position.copy(source.position);\n    this.rotation.order = source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    this.scale.copy(source.scale);\n    this.matrix.copy(source.matrix);\n    this.matrixWorld.copy(source.matrixWorld);\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n    this.layers.mask = source.layers.mask;\n    this.visible = source.visible;\n    this.castShadow = source.castShadow;\n    this.receiveShadow = source.receiveShadow;\n    this.frustumCulled = source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n    this.animations = source.animations.slice();\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    if (recursive === true) {\n      for (let i = 0; i < source.children.length; i++) {\n        const child = source.children[i];\n        this.add(child.clone());\n      }\n    }\n    return this;\n  }\n}\nObject3D.DEFAULT_UP = /*@__PURE__*/new Vector3(0, 1, 0);\nObject3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\nObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\nconst _v0$1 = /*@__PURE__*/new Vector3();\nconst _v1$3 = /*@__PURE__*/new Vector3();\nconst _v2$2 = /*@__PURE__*/new Vector3();\nconst _v3$2 = /*@__PURE__*/new Vector3();\nconst _vab = /*@__PURE__*/new Vector3();\nconst _vac = /*@__PURE__*/new Vector3();\nconst _vbc = /*@__PURE__*/new Vector3();\nconst _vap = /*@__PURE__*/new Vector3();\nconst _vbp = /*@__PURE__*/new Vector3();\nconst _vcp = /*@__PURE__*/new Vector3();\nconst _v40 = /*@__PURE__*/new Vector4();\nconst _v41 = /*@__PURE__*/new Vector4();\nconst _v42 = /*@__PURE__*/new Vector4();\nclass Triangle {\n  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n  static getNormal(a, b, c, target) {\n    target.subVectors(c, b);\n    _v0$1.subVectors(a, b);\n    target.cross(_v0$1);\n    const targetLengthSq = target.lengthSq();\n    if (targetLengthSq > 0) {\n      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n    }\n    return target.set(0, 0, 0);\n  }\n\n  // static/instance method to calculate barycentric coordinates\n  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n  static getBarycoord(point, a, b, c, target) {\n    _v0$1.subVectors(c, a);\n    _v1$3.subVectors(b, a);\n    _v2$2.subVectors(point, a);\n    const dot00 = _v0$1.dot(_v0$1);\n    const dot01 = _v0$1.dot(_v1$3);\n    const dot02 = _v0$1.dot(_v2$2);\n    const dot11 = _v1$3.dot(_v1$3);\n    const dot12 = _v1$3.dot(_v2$2);\n    const denom = dot00 * dot11 - dot01 * dot01;\n\n    // collinear or singular triangle\n    if (denom === 0) {\n      target.set(0, 0, 0);\n      return null;\n    }\n    const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // barycentric coordinates must always sum to 1\n    return target.set(1 - u - v, v, u);\n  }\n  static containsPoint(point, a, b, c) {\n    // if the triangle is degenerate then we can't contain a point\n    if (this.getBarycoord(point, a, b, c, _v3$2) === null) {\n      return false;\n    }\n    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;\n  }\n  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {\n    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {\n      target.x = 0;\n      target.y = 0;\n      if ('z' in target) target.z = 0;\n      if ('w' in target) target.w = 0;\n      return null;\n    }\n    target.setScalar(0);\n    target.addScaledVector(v1, _v3$2.x);\n    target.addScaledVector(v2, _v3$2.y);\n    target.addScaledVector(v3, _v3$2.z);\n    return target;\n  }\n  static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {\n    _v40.setScalar(0);\n    _v41.setScalar(0);\n    _v42.setScalar(0);\n    _v40.fromBufferAttribute(attr, i1);\n    _v41.fromBufferAttribute(attr, i2);\n    _v42.fromBufferAttribute(attr, i3);\n    target.setScalar(0);\n    target.addScaledVector(_v40, barycoord.x);\n    target.addScaledVector(_v41, barycoord.y);\n    target.addScaledVector(_v42, barycoord.z);\n    return target;\n  }\n  static isFrontFacing(a, b, c, direction) {\n    _v0$1.subVectors(c, b);\n    _v1$3.subVectors(a, b);\n\n    // strictly front facing\n    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n  }\n  set(a, b, c) {\n    this.a.copy(a);\n    this.b.copy(b);\n    this.c.copy(c);\n    return this;\n  }\n  setFromPointsAndIndices(points, i0, i1, i2) {\n    this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    this.c.copy(points[i2]);\n    return this;\n  }\n  setFromAttributeAndIndices(attribute, i0, i1, i2) {\n    this.a.fromBufferAttribute(attribute, i0);\n    this.b.fromBufferAttribute(attribute, i1);\n    this.c.fromBufferAttribute(attribute, i2);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(triangle) {\n    this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    this.c.copy(triangle.c);\n    return this;\n  }\n  getArea() {\n    _v0$1.subVectors(this.c, this.b);\n    _v1$3.subVectors(this.a, this.b);\n    return _v0$1.cross(_v1$3).length() * 0.5;\n  }\n  getMidpoint(target) {\n    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n  }\n  getNormal(target) {\n    return Triangle.getNormal(this.a, this.b, this.c, target);\n  }\n  getPlane(target) {\n    return target.setFromCoplanarPoints(this.a, this.b, this.c);\n  }\n  getBarycoord(point, target) {\n    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n  }\n  getInterpolation(point, v1, v2, v3, target) {\n    return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);\n  }\n  containsPoint(point) {\n    return Triangle.containsPoint(point, this.a, this.b, this.c);\n  }\n  isFrontFacing(direction) {\n    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n  }\n  intersectsBox(box) {\n    return box.intersectsTriangle(this);\n  }\n  closestPointToPoint(p, target) {\n    const a = this.a,\n      b = this.b,\n      c = this.c;\n    let v, w;\n\n    // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n    // under the accompanying license; see chapter 5.1.5 for detailed explanation.\n    // basically, we're distinguishing which of the voronoi regions of the triangle\n    // the point lies in with the minimum amount of redundant computation.\n\n    _vab.subVectors(b, a);\n    _vac.subVectors(c, a);\n    _vap.subVectors(p, a);\n    const d1 = _vab.dot(_vap);\n    const d2 = _vac.dot(_vap);\n    if (d1 <= 0 && d2 <= 0) {\n      // vertex region of A; barycentric coords (1, 0, 0)\n      return target.copy(a);\n    }\n    _vbp.subVectors(p, b);\n    const d3 = _vab.dot(_vbp);\n    const d4 = _vac.dot(_vbp);\n    if (d3 >= 0 && d4 <= d3) {\n      // vertex region of B; barycentric coords (0, 1, 0)\n      return target.copy(b);\n    }\n    const vc = d1 * d4 - d3 * d2;\n    if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n      v = d1 / (d1 - d3);\n      // edge region of AB; barycentric coords (1-v, v, 0)\n      return target.copy(a).addScaledVector(_vab, v);\n    }\n    _vcp.subVectors(p, c);\n    const d5 = _vab.dot(_vcp);\n    const d6 = _vac.dot(_vcp);\n    if (d6 >= 0 && d5 <= d6) {\n      // vertex region of C; barycentric coords (0, 0, 1)\n      return target.copy(c);\n    }\n    const vb = d5 * d2 - d1 * d6;\n    if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n      w = d2 / (d2 - d6);\n      // edge region of AC; barycentric coords (1-w, 0, w)\n      return target.copy(a).addScaledVector(_vac, w);\n    }\n    const va = d3 * d6 - d5 * d4;\n    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n      _vbc.subVectors(c, b);\n      w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n      // edge region of BC; barycentric coords (0, 1-w, w)\n      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC\n    }\n\n    // face region\n    const denom = 1 / (va + vb + vc);\n    // u = va * denom\n    v = vb * denom;\n    w = vc * denom;\n    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n  }\n  equals(triangle) {\n    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n  }\n}\nconst _colorKeywords = {\n  'aliceblue': 0xF0F8FF,\n  'antiquewhite': 0xFAEBD7,\n  'aqua': 0x00FFFF,\n  'aquamarine': 0x7FFFD4,\n  'azure': 0xF0FFFF,\n  'beige': 0xF5F5DC,\n  'bisque': 0xFFE4C4,\n  'black': 0x000000,\n  'blanchedalmond': 0xFFEBCD,\n  'blue': 0x0000FF,\n  'blueviolet': 0x8A2BE2,\n  'brown': 0xA52A2A,\n  'burlywood': 0xDEB887,\n  'cadetblue': 0x5F9EA0,\n  'chartreuse': 0x7FFF00,\n  'chocolate': 0xD2691E,\n  'coral': 0xFF7F50,\n  'cornflowerblue': 0x6495ED,\n  'cornsilk': 0xFFF8DC,\n  'crimson': 0xDC143C,\n  'cyan': 0x00FFFF,\n  'darkblue': 0x00008B,\n  'darkcyan': 0x008B8B,\n  'darkgoldenrod': 0xB8860B,\n  'darkgray': 0xA9A9A9,\n  'darkgreen': 0x006400,\n  'darkgrey': 0xA9A9A9,\n  'darkkhaki': 0xBDB76B,\n  'darkmagenta': 0x8B008B,\n  'darkolivegreen': 0x556B2F,\n  'darkorange': 0xFF8C00,\n  'darkorchid': 0x9932CC,\n  'darkred': 0x8B0000,\n  'darksalmon': 0xE9967A,\n  'darkseagreen': 0x8FBC8F,\n  'darkslateblue': 0x483D8B,\n  'darkslategray': 0x2F4F4F,\n  'darkslategrey': 0x2F4F4F,\n  'darkturquoise': 0x00CED1,\n  'darkviolet': 0x9400D3,\n  'deeppink': 0xFF1493,\n  'deepskyblue': 0x00BFFF,\n  'dimgray': 0x696969,\n  'dimgrey': 0x696969,\n  'dodgerblue': 0x1E90FF,\n  'firebrick': 0xB22222,\n  'floralwhite': 0xFFFAF0,\n  'forestgreen': 0x228B22,\n  'fuchsia': 0xFF00FF,\n  'gainsboro': 0xDCDCDC,\n  'ghostwhite': 0xF8F8FF,\n  'gold': 0xFFD700,\n  'goldenrod': 0xDAA520,\n  'gray': 0x808080,\n  'green': 0x008000,\n  'greenyellow': 0xADFF2F,\n  'grey': 0x808080,\n  'honeydew': 0xF0FFF0,\n  'hotpink': 0xFF69B4,\n  'indianred': 0xCD5C5C,\n  'indigo': 0x4B0082,\n  'ivory': 0xFFFFF0,\n  'khaki': 0xF0E68C,\n  'lavender': 0xE6E6FA,\n  'lavenderblush': 0xFFF0F5,\n  'lawngreen': 0x7CFC00,\n  'lemonchiffon': 0xFFFACD,\n  'lightblue': 0xADD8E6,\n  'lightcoral': 0xF08080,\n  'lightcyan': 0xE0FFFF,\n  'lightgoldenrodyellow': 0xFAFAD2,\n  'lightgray': 0xD3D3D3,\n  'lightgreen': 0x90EE90,\n  'lightgrey': 0xD3D3D3,\n  'lightpink': 0xFFB6C1,\n  'lightsalmon': 0xFFA07A,\n  'lightseagreen': 0x20B2AA,\n  'lightskyblue': 0x87CEFA,\n  'lightslategray': 0x778899,\n  'lightslategrey': 0x778899,\n  'lightsteelblue': 0xB0C4DE,\n  'lightyellow': 0xFFFFE0,\n  'lime': 0x00FF00,\n  'limegreen': 0x32CD32,\n  'linen': 0xFAF0E6,\n  'magenta': 0xFF00FF,\n  'maroon': 0x800000,\n  'mediumaquamarine': 0x66CDAA,\n  'mediumblue': 0x0000CD,\n  'mediumorchid': 0xBA55D3,\n  'mediumpurple': 0x9370DB,\n  'mediumseagreen': 0x3CB371,\n  'mediumslateblue': 0x7B68EE,\n  'mediumspringgreen': 0x00FA9A,\n  'mediumturquoise': 0x48D1CC,\n  'mediumvioletred': 0xC71585,\n  'midnightblue': 0x191970,\n  'mintcream': 0xF5FFFA,\n  'mistyrose': 0xFFE4E1,\n  'moccasin': 0xFFE4B5,\n  'navajowhite': 0xFFDEAD,\n  'navy': 0x000080,\n  'oldlace': 0xFDF5E6,\n  'olive': 0x808000,\n  'olivedrab': 0x6B8E23,\n  'orange': 0xFFA500,\n  'orangered': 0xFF4500,\n  'orchid': 0xDA70D6,\n  'palegoldenrod': 0xEEE8AA,\n  'palegreen': 0x98FB98,\n  'paleturquoise': 0xAFEEEE,\n  'palevioletred': 0xDB7093,\n  'papayawhip': 0xFFEFD5,\n  'peachpuff': 0xFFDAB9,\n  'peru': 0xCD853F,\n  'pink': 0xFFC0CB,\n  'plum': 0xDDA0DD,\n  'powderblue': 0xB0E0E6,\n  'purple': 0x800080,\n  'rebeccapurple': 0x663399,\n  'red': 0xFF0000,\n  'rosybrown': 0xBC8F8F,\n  'royalblue': 0x4169E1,\n  'saddlebrown': 0x8B4513,\n  'salmon': 0xFA8072,\n  'sandybrown': 0xF4A460,\n  'seagreen': 0x2E8B57,\n  'seashell': 0xFFF5EE,\n  'sienna': 0xA0522D,\n  'silver': 0xC0C0C0,\n  'skyblue': 0x87CEEB,\n  'slateblue': 0x6A5ACD,\n  'slategray': 0x708090,\n  'slategrey': 0x708090,\n  'snow': 0xFFFAFA,\n  'springgreen': 0x00FF7F,\n  'steelblue': 0x4682B4,\n  'tan': 0xD2B48C,\n  'teal': 0x008080,\n  'thistle': 0xD8BFD8,\n  'tomato': 0xFF6347,\n  'turquoise': 0x40E0D0,\n  'violet': 0xEE82EE,\n  'wheat': 0xF5DEB3,\n  'white': 0xFFFFFF,\n  'whitesmoke': 0xF5F5F5,\n  'yellow': 0xFFFF00,\n  'yellowgreen': 0x9ACD32\n};\nconst _hslA = {\n  h: 0,\n  s: 0,\n  l: 0\n};\nconst _hslB = {\n  h: 0,\n  s: 0,\n  l: 0\n};\nfunction hue2rgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n  return p;\n}\nclass Color {\n  constructor(r, g, b) {\n    this.isColor = true;\n    this.r = 1;\n    this.g = 1;\n    this.b = 1;\n    return this.set(r, g, b);\n  }\n  set(r, g, b) {\n    if (g === undefined && b === undefined) {\n      // r is THREE.Color, hex or string\n\n      const value = r;\n      if (value && value.isColor) {\n        this.copy(value);\n      } else if (typeof value === 'number') {\n        this.setHex(value);\n      } else if (typeof value === 'string') {\n        this.setStyle(value);\n      }\n    } else {\n      this.setRGB(r, g, b);\n    }\n    return this;\n  }\n  setScalar(scalar) {\n    this.r = scalar;\n    this.g = scalar;\n    this.b = scalar;\n    return this;\n  }\n  setHex(hex, colorSpace = SRGBColorSpace) {\n    hex = Math.floor(hex);\n    this.r = (hex >> 16 & 255) / 255;\n    this.g = (hex >> 8 & 255) / 255;\n    this.b = (hex & 255) / 255;\n    ColorManagement.toWorkingColorSpace(this, colorSpace);\n    return this;\n  }\n  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    ColorManagement.toWorkingColorSpace(this, colorSpace);\n    return this;\n  }\n  setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n    // h,s,l ranges are in 0.0 - 1.0\n    h = euclideanModulo(h, 1);\n    s = clamp(s, 0, 1);\n    l = clamp(l, 0, 1);\n    if (s === 0) {\n      this.r = this.g = this.b = l;\n    } else {\n      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n      const q = 2 * l - p;\n      this.r = hue2rgb(q, p, h + 1 / 3);\n      this.g = hue2rgb(q, p, h);\n      this.b = hue2rgb(q, p, h - 1 / 3);\n    }\n    ColorManagement.toWorkingColorSpace(this, colorSpace);\n    return this;\n  }\n  setStyle(style, colorSpace = SRGBColorSpace) {\n    function handleAlpha(string) {\n      if (string === undefined) return;\n      if (parseFloat(string) < 1) {\n        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');\n      }\n    }\n    let m;\n    if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n      // rgb / hsl\n\n      let color;\n      const name = m[1];\n      const components = m[2];\n      switch (name) {\n        case 'rgb':\n        case 'rgba':\n          if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            // rgb(255,0,0) rgba(255,0,0,0.5)\n\n            handleAlpha(color[4]);\n            return this.setRGB(Math.min(255, parseInt(color[1], 10)) / 255, Math.min(255, parseInt(color[2], 10)) / 255, Math.min(255, parseInt(color[3], 10)) / 255, colorSpace);\n          }\n          if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\n            handleAlpha(color[4]);\n            return this.setRGB(Math.min(100, parseInt(color[1], 10)) / 100, Math.min(100, parseInt(color[2], 10)) / 100, Math.min(100, parseInt(color[3], 10)) / 100, colorSpace);\n          }\n          break;\n        case 'hsl':\n        case 'hsla':\n          if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\n            handleAlpha(color[4]);\n            return this.setHSL(parseFloat(color[1]) / 360, parseFloat(color[2]) / 100, parseFloat(color[3]) / 100, colorSpace);\n          }\n          break;\n        default:\n          console.warn('THREE.Color: Unknown color model ' + style);\n      }\n    } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n      // hex color\n\n      const hex = m[1];\n      const size = hex.length;\n      if (size === 3) {\n        // #ff0\n        return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace);\n      } else if (size === 6) {\n        // #ff0000\n        return this.setHex(parseInt(hex, 16), colorSpace);\n      } else {\n        console.warn('THREE.Color: Invalid hex color ' + style);\n      }\n    } else if (style && style.length > 0) {\n      return this.setColorName(style, colorSpace);\n    }\n    return this;\n  }\n  setColorName(style, colorSpace = SRGBColorSpace) {\n    // color keywords\n    const hex = _colorKeywords[style.toLowerCase()];\n    if (hex !== undefined) {\n      // red\n      this.setHex(hex, colorSpace);\n    } else {\n      // unknown color\n      console.warn('THREE.Color: Unknown color ' + style);\n    }\n    return this;\n  }\n  clone() {\n    return new this.constructor(this.r, this.g, this.b);\n  }\n  copy(color) {\n    this.r = color.r;\n    this.g = color.g;\n    this.b = color.b;\n    return this;\n  }\n  copySRGBToLinear(color) {\n    this.r = SRGBToLinear(color.r);\n    this.g = SRGBToLinear(color.g);\n    this.b = SRGBToLinear(color.b);\n    return this;\n  }\n  copyLinearToSRGB(color) {\n    this.r = LinearToSRGB(color.r);\n    this.g = LinearToSRGB(color.g);\n    this.b = LinearToSRGB(color.b);\n    return this;\n  }\n  convertSRGBToLinear() {\n    this.copySRGBToLinear(this);\n    return this;\n  }\n  convertLinearToSRGB() {\n    this.copyLinearToSRGB(this);\n    return this;\n  }\n  getHex(colorSpace = SRGBColorSpace) {\n    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n    return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\n  }\n  getHexString(colorSpace = SRGBColorSpace) {\n    return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);\n  }\n  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n    // h,s,l ranges are in 0.0 - 1.0\n\n    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n    const r = _color.r,\n      g = _color.g,\n      b = _color.b;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let hue, saturation;\n    const lightness = (min + max) / 2.0;\n    if (min === max) {\n      hue = 0;\n      saturation = 0;\n    } else {\n      const delta = max - min;\n      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n      switch (max) {\n        case r:\n          hue = (g - b) / delta + (g < b ? 6 : 0);\n          break;\n        case g:\n          hue = (b - r) / delta + 2;\n          break;\n        case b:\n          hue = (r - g) / delta + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    target.h = hue;\n    target.s = saturation;\n    target.l = lightness;\n    return target;\n  }\n  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n    target.r = _color.r;\n    target.g = _color.g;\n    target.b = _color.b;\n    return target;\n  }\n  getStyle(colorSpace = SRGBColorSpace) {\n    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n    const r = _color.r,\n      g = _color.g,\n      b = _color.b;\n    if (colorSpace !== SRGBColorSpace) {\n      // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\n    }\n    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n  }\n  offsetHSL(h, s, l) {\n    this.getHSL(_hslA);\n    return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n  }\n  add(color) {\n    this.r += color.r;\n    this.g += color.g;\n    this.b += color.b;\n    return this;\n  }\n  addColors(color1, color2) {\n    this.r = color1.r + color2.r;\n    this.g = color1.g + color2.g;\n    this.b = color1.b + color2.b;\n    return this;\n  }\n  addScalar(s) {\n    this.r += s;\n    this.g += s;\n    this.b += s;\n    return this;\n  }\n  sub(color) {\n    this.r = Math.max(0, this.r - color.r);\n    this.g = Math.max(0, this.g - color.g);\n    this.b = Math.max(0, this.b - color.b);\n    return this;\n  }\n  multiply(color) {\n    this.r *= color.r;\n    this.g *= color.g;\n    this.b *= color.b;\n    return this;\n  }\n  multiplyScalar(s) {\n    this.r *= s;\n    this.g *= s;\n    this.b *= s;\n    return this;\n  }\n  lerp(color, alpha) {\n    this.r += (color.r - this.r) * alpha;\n    this.g += (color.g - this.g) * alpha;\n    this.b += (color.b - this.b) * alpha;\n    return this;\n  }\n  lerpColors(color1, color2, alpha) {\n    this.r = color1.r + (color2.r - color1.r) * alpha;\n    this.g = color1.g + (color2.g - color1.g) * alpha;\n    this.b = color1.b + (color2.b - color1.b) * alpha;\n    return this;\n  }\n  lerpHSL(color, alpha) {\n    this.getHSL(_hslA);\n    color.getHSL(_hslB);\n    const h = lerp(_hslA.h, _hslB.h, alpha);\n    const s = lerp(_hslA.s, _hslB.s, alpha);\n    const l = lerp(_hslA.l, _hslB.l, alpha);\n    this.setHSL(h, s, l);\n    return this;\n  }\n  setFromVector3(v) {\n    this.r = v.x;\n    this.g = v.y;\n    this.b = v.z;\n    return this;\n  }\n  applyMatrix3(m) {\n    const r = this.r,\n      g = this.g,\n      b = this.b;\n    const e = m.elements;\n    this.r = e[0] * r + e[3] * g + e[6] * b;\n    this.g = e[1] * r + e[4] * g + e[7] * b;\n    this.b = e[2] * r + e[5] * g + e[8] * b;\n    return this;\n  }\n  equals(c) {\n    return c.r === this.r && c.g === this.g && c.b === this.b;\n  }\n  fromArray(array, offset = 0) {\n    this.r = array[offset];\n    this.g = array[offset + 1];\n    this.b = array[offset + 2];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.r;\n    array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.r = attribute.getX(index);\n    this.g = attribute.getY(index);\n    this.b = attribute.getZ(index);\n    return this;\n  }\n  toJSON() {\n    return this.getHex();\n  }\n  *[Symbol.iterator]() {\n    yield this.r;\n    yield this.g;\n    yield this.b;\n  }\n}\nconst _color = /*@__PURE__*/new Color();\nColor.NAMES = _colorKeywords;\nlet _materialId = 0;\nclass Material extends EventDispatcher {\n  constructor() {\n    super();\n    this.isMaterial = true;\n    Object.defineProperty(this, 'id', {\n      value: _materialId++\n    });\n    this.uuid = generateUUID();\n    this.name = '';\n    this.type = 'Material';\n    this.blending = NormalBlending;\n    this.side = FrontSide;\n    this.vertexColors = false;\n    this.opacity = 1;\n    this.transparent = false;\n    this.alphaHash = false;\n    this.blendSrc = SrcAlphaFactor;\n    this.blendDst = OneMinusSrcAlphaFactor;\n    this.blendEquation = AddEquation;\n    this.blendSrcAlpha = null;\n    this.blendDstAlpha = null;\n    this.blendEquationAlpha = null;\n    this.blendColor = new Color(0, 0, 0);\n    this.blendAlpha = 0;\n    this.depthFunc = LessEqualDepth;\n    this.depthTest = true;\n    this.depthWrite = true;\n    this.stencilWriteMask = 0xff;\n    this.stencilFunc = AlwaysStencilFunc;\n    this.stencilRef = 0;\n    this.stencilFuncMask = 0xff;\n    this.stencilFail = KeepStencilOp;\n    this.stencilZFail = KeepStencilOp;\n    this.stencilZPass = KeepStencilOp;\n    this.stencilWrite = false;\n    this.clippingPlanes = null;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n    this.shadowSide = null;\n    this.colorWrite = true;\n    this.precision = null; // override the renderer's default precision for this material\n\n    this.polygonOffset = false;\n    this.polygonOffsetFactor = 0;\n    this.polygonOffsetUnits = 0;\n    this.dithering = false;\n    this.alphaToCoverage = false;\n    this.premultipliedAlpha = false;\n    this.forceSinglePass = false;\n    this.visible = true;\n    this.toneMapped = true;\n    this.userData = {};\n    this.version = 0;\n    this._alphaTest = 0;\n  }\n  get alphaTest() {\n    return this._alphaTest;\n  }\n  set alphaTest(value) {\n    if (this._alphaTest > 0 !== value > 0) {\n      this.version++;\n    }\n    this._alphaTest = value;\n  }\n\n  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n\n  onBeforeRender(/* renderer, scene, camera, geometry, object, group */) {}\n  onBeforeCompile(/* shaderobject, renderer */) {}\n  customProgramCacheKey() {\n    return this.onBeforeCompile.toString();\n  }\n  setValues(values) {\n    if (values === undefined) return;\n    for (const key in values) {\n      const newValue = values[key];\n      if (newValue === undefined) {\n        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);\n        continue;\n      }\n      const currentValue = this[key];\n      if (currentValue === undefined) {\n        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);\n        continue;\n      }\n      if (currentValue && currentValue.isColor) {\n        currentValue.set(newValue);\n      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {\n        currentValue.copy(newValue);\n      } else {\n        this[key] = newValue;\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRootObject = meta === undefined || typeof meta === 'string';\n    if (isRootObject) {\n      meta = {\n        textures: {},\n        images: {}\n      };\n    }\n    const data = {\n      metadata: {\n        version: 4.6,\n        type: 'Material',\n        generator: 'Material.toJSON'\n      }\n    };\n\n    // standard Material serialization\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (this.color && this.color.isColor) data.color = this.color.getHex();\n    if (this.roughness !== undefined) data.roughness = this.roughness;\n    if (this.metalness !== undefined) data.metalness = this.metalness;\n    if (this.sheen !== undefined) data.sheen = this.sheen;\n    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n    if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;\n    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n    if (this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n    if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;\n    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n    if (this.shininess !== undefined) data.shininess = this.shininess;\n    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;\n    if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;\n    if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n    }\n    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n    }\n    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n    }\n    if (this.dispersion !== undefined) data.dispersion = this.dispersion;\n    if (this.iridescence !== undefined) data.iridescence = this.iridescence;\n    if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;\n    if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n    if (this.iridescenceMap && this.iridescenceMap.isTexture) {\n      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;\n    }\n    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;\n    }\n    if (this.anisotropy !== undefined) data.anisotropy = this.anisotropy;\n    if (this.anisotropyRotation !== undefined) data.anisotropyRotation = this.anisotropyRotation;\n    if (this.anisotropyMap && this.anisotropyMap.isTexture) {\n      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;\n    }\n    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n    if (this.lightMap && this.lightMap.isTexture) {\n      data.lightMap = this.lightMap.toJSON(meta).uuid;\n      data.lightMapIntensity = this.lightMapIntensity;\n    }\n    if (this.aoMap && this.aoMap.isTexture) {\n      data.aoMap = this.aoMap.toJSON(meta).uuid;\n      data.aoMapIntensity = this.aoMapIntensity;\n    }\n    if (this.bumpMap && this.bumpMap.isTexture) {\n      data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n      data.bumpScale = this.bumpScale;\n    }\n    if (this.normalMap && this.normalMap.isTexture) {\n      data.normalMap = this.normalMap.toJSON(meta).uuid;\n      data.normalMapType = this.normalMapType;\n      data.normalScale = this.normalScale.toArray();\n    }\n    if (this.displacementMap && this.displacementMap.isTexture) {\n      data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n      data.displacementScale = this.displacementScale;\n      data.displacementBias = this.displacementBias;\n    }\n    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n    if (this.envMap && this.envMap.isTexture) {\n      data.envMap = this.envMap.toJSON(meta).uuid;\n      if (this.combine !== undefined) data.combine = this.combine;\n    }\n    if (this.envMapRotation !== undefined) data.envMapRotation = this.envMapRotation.toArray();\n    if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;\n    if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;\n    if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;\n    if (this.gradientMap && this.gradientMap.isTexture) {\n      data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n    }\n    if (this.transmission !== undefined) data.transmission = this.transmission;\n    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n    if (this.thickness !== undefined) data.thickness = this.thickness;\n    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n    if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;\n    if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();\n    if (this.size !== undefined) data.size = this.size;\n    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;\n    if (this.blending !== NormalBlending) data.blending = this.blending;\n    if (this.side !== FrontSide) data.side = this.side;\n    if (this.vertexColors === true) data.vertexColors = true;\n    if (this.opacity < 1) data.opacity = this.opacity;\n    if (this.transparent === true) data.transparent = true;\n    if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;\n    if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;\n    if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;\n    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;\n    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;\n    if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;\n    if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();\n    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;\n    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;\n    if (this.depthTest === false) data.depthTest = this.depthTest;\n    if (this.depthWrite === false) data.depthWrite = this.depthWrite;\n    if (this.colorWrite === false) data.colorWrite = this.colorWrite;\n    if (this.stencilWriteMask !== 0xff) data.stencilWriteMask = this.stencilWriteMask;\n    if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;\n    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n    if (this.stencilFuncMask !== 0xff) data.stencilFuncMask = this.stencilFuncMask;\n    if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;\n    if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;\n    if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;\n    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n\n    // rotation (SpriteMaterial)\n    if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;\n    if (this.polygonOffset === true) data.polygonOffset = true;\n    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n    if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;\n    if (this.dashSize !== undefined) data.dashSize = this.dashSize;\n    if (this.gapSize !== undefined) data.gapSize = this.gapSize;\n    if (this.scale !== undefined) data.scale = this.scale;\n    if (this.dithering === true) data.dithering = true;\n    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n    if (this.alphaHash === true) data.alphaHash = true;\n    if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n    if (this.forceSinglePass === true) data.forceSinglePass = true;\n    if (this.wireframe === true) data.wireframe = true;\n    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;\n    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;\n    if (this.flatShading === true) data.flatShading = true;\n    if (this.visible === false) data.visible = false;\n    if (this.toneMapped === false) data.toneMapped = false;\n    if (this.fog === false) data.fog = false;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRootObject) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n    }\n    return data;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.name = source.name;\n    this.blending = source.blending;\n    this.side = source.side;\n    this.vertexColors = source.vertexColors;\n    this.opacity = source.opacity;\n    this.transparent = source.transparent;\n    this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    this.blendEquationAlpha = source.blendEquationAlpha;\n    this.blendColor.copy(source.blendColor);\n    this.blendAlpha = source.blendAlpha;\n    this.depthFunc = source.depthFunc;\n    this.depthTest = source.depthTest;\n    this.depthWrite = source.depthWrite;\n    this.stencilWriteMask = source.stencilWriteMask;\n    this.stencilFunc = source.stencilFunc;\n    this.stencilRef = source.stencilRef;\n    this.stencilFuncMask = source.stencilFuncMask;\n    this.stencilFail = source.stencilFail;\n    this.stencilZFail = source.stencilZFail;\n    this.stencilZPass = source.stencilZPass;\n    this.stencilWrite = source.stencilWrite;\n    const srcPlanes = source.clippingPlanes;\n    let dstPlanes = null;\n    if (srcPlanes !== null) {\n      const n = srcPlanes.length;\n      dstPlanes = new Array(n);\n      for (let i = 0; i !== n; ++i) {\n        dstPlanes[i] = srcPlanes[i].clone();\n      }\n    }\n    this.clippingPlanes = dstPlanes;\n    this.clipIntersection = source.clipIntersection;\n    this.clipShadows = source.clipShadows;\n    this.shadowSide = source.shadowSide;\n    this.colorWrite = source.colorWrite;\n    this.precision = source.precision;\n    this.polygonOffset = source.polygonOffset;\n    this.polygonOffsetFactor = source.polygonOffsetFactor;\n    this.polygonOffsetUnits = source.polygonOffsetUnits;\n    this.dithering = source.dithering;\n    this.alphaTest = source.alphaTest;\n    this.alphaHash = source.alphaHash;\n    this.alphaToCoverage = source.alphaToCoverage;\n    this.premultipliedAlpha = source.premultipliedAlpha;\n    this.forceSinglePass = source.forceSinglePass;\n    this.visible = source.visible;\n    this.toneMapped = source.toneMapped;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  onBuild(/* shaderobject, renderer */\n  ) {\n    console.warn('Material: onBuild() has been removed.'); // @deprecated, r166\n  }\n}\nclass MeshBasicMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isMeshBasicMaterial = true;\n    this.type = 'MeshBasicMaterial';\n    this.color = new Color(0xffffff); // emissive\n\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new Euler();\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.fog = source.fog;\n    return this;\n  }\n}\n\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst _tables = /*@__PURE__*/_generateTables();\nfunction _generateTables() {\n  // float32 to float16 helpers\n\n  const buffer = new ArrayBuffer(4);\n  const floatView = new Float32Array(buffer);\n  const uint32View = new Uint32Array(buffer);\n  const baseTable = new Uint32Array(512);\n  const shiftTable = new Uint32Array(512);\n  for (let i = 0; i < 256; ++i) {\n    const e = i - 127;\n\n    // very small number (0, -0)\n\n    if (e < -27) {\n      baseTable[i] = 0x0000;\n      baseTable[i | 0x100] = 0x8000;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n\n      // small number (denorm)\n    } else if (e < -14) {\n      baseTable[i] = 0x0400 >> -e - 14;\n      baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;\n      shiftTable[i] = -e - 1;\n      shiftTable[i | 0x100] = -e - 1;\n\n      // normal number\n    } else if (e <= 15) {\n      baseTable[i] = e + 15 << 10;\n      baseTable[i | 0x100] = e + 15 << 10 | 0x8000;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n\n      // large number (Infinity, -Infinity)\n    } else if (e < 128) {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n\n      // stay (NaN, Infinity, -Infinity)\n    } else {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n    }\n  }\n\n  // float16 to float32 helpers\n\n  const mantissaTable = new Uint32Array(2048);\n  const exponentTable = new Uint32Array(64);\n  const offsetTable = new Uint32Array(64);\n  for (let i = 1; i < 1024; ++i) {\n    let m = i << 13; // zero pad mantissa bits\n    let e = 0; // zero exponent\n\n    // normalized\n    while ((m & 0x00800000) === 0) {\n      m <<= 1;\n      e -= 0x00800000; // decrement exponent\n    }\n    m &= ~0x00800000; // clear leading 1 bit\n    e += 0x38800000; // adjust bias\n\n    mantissaTable[i] = m | e;\n  }\n  for (let i = 1024; i < 2048; ++i) {\n    mantissaTable[i] = 0x38000000 + (i - 1024 << 13);\n  }\n  for (let i = 1; i < 31; ++i) {\n    exponentTable[i] = i << 23;\n  }\n  exponentTable[31] = 0x47800000;\n  exponentTable[32] = 0x80000000;\n  for (let i = 33; i < 63; ++i) {\n    exponentTable[i] = 0x80000000 + (i - 32 << 23);\n  }\n  exponentTable[63] = 0xc7800000;\n  for (let i = 1; i < 64; ++i) {\n    if (i !== 32) {\n      offsetTable[i] = 1024;\n    }\n  }\n  return {\n    floatView: floatView,\n    uint32View: uint32View,\n    baseTable: baseTable,\n    shiftTable: shiftTable,\n    mantissaTable: mantissaTable,\n    exponentTable: exponentTable,\n    offsetTable: offsetTable\n  };\n}\n\n// float32 to float16\n\nfunction toHalfFloat(val) {\n  if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');\n  val = clamp(val, -65504, 65504);\n  _tables.floatView[0] = val;\n  const f = _tables.uint32View[0];\n  const e = f >> 23 & 0x1ff;\n  return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);\n}\n\n// float16 to float32\n\nfunction fromHalfFloat(val) {\n  const m = val >> 10;\n  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];\n  return _tables.floatView[0];\n}\nconst DataUtils = {\n  toHalfFloat: toHalfFloat,\n  fromHalfFloat: fromHalfFloat\n};\nconst _vector$9 = /*@__PURE__*/new Vector3();\nconst _vector2$1 = /*@__PURE__*/new Vector2();\nclass BufferAttribute {\n  constructor(array, itemSize, normalized = false) {\n    if (Array.isArray(array)) {\n      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n    }\n    this.isBufferAttribute = true;\n    this.name = '';\n    this.array = array;\n    this.itemSize = itemSize;\n    this.count = array !== undefined ? array.length / itemSize : 0;\n    this.normalized = normalized;\n    this.usage = StaticDrawUsage;\n    this.updateRanges = [];\n    this.gpuType = FloatType;\n    this.version = 0;\n  }\n  onUploadCallback() {}\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n  addUpdateRange(start, count) {\n    this.updateRanges.push({\n      start,\n      count\n    });\n  }\n  clearUpdateRanges() {\n    this.updateRanges.length = 0;\n  }\n  copy(source) {\n    this.name = source.name;\n    this.array = new source.array.constructor(source.array);\n    this.itemSize = source.itemSize;\n    this.count = source.count;\n    this.normalized = source.normalized;\n    this.usage = source.usage;\n    this.gpuType = source.gpuType;\n    return this;\n  }\n  copyAt(index1, attribute, index2) {\n    index1 *= this.itemSize;\n    index2 *= attribute.itemSize;\n    for (let i = 0, l = this.itemSize; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n    return this;\n  }\n  copyArray(array) {\n    this.array.set(array);\n    return this;\n  }\n  applyMatrix3(m) {\n    if (this.itemSize === 2) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector2$1.fromBufferAttribute(this, i);\n        _vector2$1.applyMatrix3(m);\n        this.setXY(i, _vector2$1.x, _vector2$1.y);\n      }\n    } else if (this.itemSize === 3) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector$9.fromBufferAttribute(this, i);\n        _vector$9.applyMatrix3(m);\n        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n    }\n    return this;\n  }\n  applyMatrix4(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.fromBufferAttribute(this, i);\n      _vector$9.applyMatrix4(m);\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.fromBufferAttribute(this, i);\n      _vector$9.applyNormalMatrix(m);\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.fromBufferAttribute(this, i);\n      _vector$9.transformDirection(m);\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  set(value, offset = 0) {\n    // Matching BufferAttribute constructor, do not normalize the array.\n    this.array.set(value, offset);\n    return this;\n  }\n  getComponent(index, component) {\n    let value = this.array[index * this.itemSize + component];\n    if (this.normalized) value = denormalize(value, this.array);\n    return value;\n  }\n  setComponent(index, component, value) {\n    if (this.normalized) value = normalize(value, this.array);\n    this.array[index * this.itemSize + component] = value;\n    return this;\n  }\n  getX(index) {\n    let x = this.array[index * this.itemSize];\n    if (this.normalized) x = denormalize(x, this.array);\n    return x;\n  }\n  setX(index, x) {\n    if (this.normalized) x = normalize(x, this.array);\n    this.array[index * this.itemSize] = x;\n    return this;\n  }\n  getY(index) {\n    let y = this.array[index * this.itemSize + 1];\n    if (this.normalized) y = denormalize(y, this.array);\n    return y;\n  }\n  setY(index, y) {\n    if (this.normalized) y = normalize(y, this.array);\n    this.array[index * this.itemSize + 1] = y;\n    return this;\n  }\n  getZ(index) {\n    let z = this.array[index * this.itemSize + 2];\n    if (this.normalized) z = denormalize(z, this.array);\n    return z;\n  }\n  setZ(index, z) {\n    if (this.normalized) z = normalize(z, this.array);\n    this.array[index * this.itemSize + 2] = z;\n    return this;\n  }\n  getW(index) {\n    let w = this.array[index * this.itemSize + 3];\n    if (this.normalized) w = denormalize(w, this.array);\n    return w;\n  }\n  setW(index, w) {\n    if (this.normalized) w = normalize(w, this.array);\n    this.array[index * this.itemSize + 3] = w;\n    return this;\n  }\n  setXY(index, x, y) {\n    index *= this.itemSize;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n    }\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    return this;\n  }\n  setXYZ(index, x, y, z) {\n    index *= this.itemSize;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n    }\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    return this;\n  }\n  setXYZW(index, x, y, z, w) {\n    index *= this.itemSize;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n      w = normalize(w, this.array);\n    }\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    this.array[index + 3] = w;\n    return this;\n  }\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n    return this;\n  }\n  clone() {\n    return new this.constructor(this.array, this.itemSize).copy(this);\n  }\n  toJSON() {\n    const data = {\n      itemSize: this.itemSize,\n      type: this.array.constructor.name,\n      array: Array.from(this.array),\n      normalized: this.normalized\n    };\n    if (this.name !== '') data.name = this.name;\n    if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n    return data;\n  }\n}\n\n//\n\nclass Int8BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Int8Array(array), itemSize, normalized);\n  }\n}\nclass Uint8BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint8Array(array), itemSize, normalized);\n  }\n}\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint8ClampedArray(array), itemSize, normalized);\n  }\n}\nclass Int16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Int16Array(array), itemSize, normalized);\n  }\n}\nclass Uint16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, normalized);\n  }\n}\nclass Int32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Int32Array(array), itemSize, normalized);\n  }\n}\nclass Uint32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint32Array(array), itemSize, normalized);\n  }\n}\nclass Float16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, normalized);\n    this.isFloat16BufferAttribute = true;\n  }\n  getX(index) {\n    let x = fromHalfFloat(this.array[index * this.itemSize]);\n    if (this.normalized) x = denormalize(x, this.array);\n    return x;\n  }\n  setX(index, x) {\n    if (this.normalized) x = normalize(x, this.array);\n    this.array[index * this.itemSize] = toHalfFloat(x);\n    return this;\n  }\n  getY(index) {\n    let y = fromHalfFloat(this.array[index * this.itemSize + 1]);\n    if (this.normalized) y = denormalize(y, this.array);\n    return y;\n  }\n  setY(index, y) {\n    if (this.normalized) y = normalize(y, this.array);\n    this.array[index * this.itemSize + 1] = toHalfFloat(y);\n    return this;\n  }\n  getZ(index) {\n    let z = fromHalfFloat(this.array[index * this.itemSize + 2]);\n    if (this.normalized) z = denormalize(z, this.array);\n    return z;\n  }\n  setZ(index, z) {\n    if (this.normalized) z = normalize(z, this.array);\n    this.array[index * this.itemSize + 2] = toHalfFloat(z);\n    return this;\n  }\n  getW(index) {\n    let w = fromHalfFloat(this.array[index * this.itemSize + 3]);\n    if (this.normalized) w = denormalize(w, this.array);\n    return w;\n  }\n  setW(index, w) {\n    if (this.normalized) w = normalize(w, this.array);\n    this.array[index * this.itemSize + 3] = toHalfFloat(w);\n    return this;\n  }\n  setXY(index, x, y) {\n    index *= this.itemSize;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n    }\n    this.array[index + 0] = toHalfFloat(x);\n    this.array[index + 1] = toHalfFloat(y);\n    return this;\n  }\n  setXYZ(index, x, y, z) {\n    index *= this.itemSize;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n    }\n    this.array[index + 0] = toHalfFloat(x);\n    this.array[index + 1] = toHalfFloat(y);\n    this.array[index + 2] = toHalfFloat(z);\n    return this;\n  }\n  setXYZW(index, x, y, z, w) {\n    index *= this.itemSize;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n      w = normalize(w, this.array);\n    }\n    this.array[index + 0] = toHalfFloat(x);\n    this.array[index + 1] = toHalfFloat(y);\n    this.array[index + 2] = toHalfFloat(z);\n    this.array[index + 3] = toHalfFloat(w);\n    return this;\n  }\n}\nclass Float32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Float32Array(array), itemSize, normalized);\n  }\n}\nlet _id$1 = 0;\nconst _m1 = /*@__PURE__*/new Matrix4();\nconst _obj = /*@__PURE__*/new Object3D();\nconst _offset = /*@__PURE__*/new Vector3();\nconst _box$2 = /*@__PURE__*/new Box3();\nconst _boxMorphTargets = /*@__PURE__*/new Box3();\nconst _vector$8 = /*@__PURE__*/new Vector3();\nclass BufferGeometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isBufferGeometry = true;\n    Object.defineProperty(this, 'id', {\n      value: _id$1++\n    });\n    this.uuid = generateUUID();\n    this.name = '';\n    this.type = 'BufferGeometry';\n    this.index = null;\n    this.indirect = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.morphTargetsRelative = false;\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.drawRange = {\n      start: 0,\n      count: Infinity\n    };\n    this.userData = {};\n  }\n  getIndex() {\n    return this.index;\n  }\n  setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n    return this;\n  }\n  setIndirect(indirect) {\n    this.indirect = indirect;\n    return this;\n  }\n  getIndirect() {\n    return this.indirect;\n  }\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  }\n  deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  }\n  hasAttribute(name) {\n    return this.attributes[name] !== undefined;\n  }\n  addGroup(start, count, materialIndex = 0) {\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex\n    });\n  }\n  clearGroups() {\n    this.groups = [];\n  }\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n  applyMatrix4(matrix) {\n    const position = this.attributes.position;\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n    const normal = this.attributes.normal;\n    if (normal !== undefined) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n    const tangent = this.attributes.tangent;\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  applyQuaternion(q) {\n    _m1.makeRotationFromQuaternion(q);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    // translate geometry\n\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    // scale geometry\n\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  setFromPoints(points) {\n    const positionAttribute = this.getAttribute('position');\n    if (positionAttribute === undefined) {\n      const position = [];\n      for (let i = 0, l = points.length; i < l; i++) {\n        const point = points[i];\n        position.push(point.x, point.y, point.z || 0);\n      }\n      this.setAttribute('position', new Float32BufferAttribute(position, 3));\n    } else {\n      const l = Math.min(points.length, positionAttribute.count); // make sure data do not exceed buffer size\n\n      for (let i = 0; i < l; i++) {\n        const point = points[i];\n        positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);\n      }\n      if (points.length > positionAttribute.count) {\n        console.warn('THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.');\n      }\n      positionAttribute.needsUpdate = true;\n    }\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this);\n      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n      return;\n    }\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _box$2.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(this.boundingBox.min, _box$2.min);\n            this.boundingBox.expandByPoint(_vector$8);\n            _vector$8.addVectors(this.boundingBox.max, _box$2.max);\n            this.boundingBox.expandByPoint(_vector$8);\n          } else {\n            this.boundingBox.expandByPoint(_box$2.min);\n            this.boundingBox.expandByPoint(_box$2.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this);\n      this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n    if (position) {\n      // first, find the center of the bounding sphere\n\n      const center = this.boundingSphere.center;\n      _box$2.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);\n            _box$2.expandByPoint(_vector$8);\n            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);\n            _box$2.expandByPoint(_vector$8);\n          } else {\n            _box$2.expandByPoint(_boxMorphTargets.min);\n            _box$2.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n      _box$2.getCenter(center);\n\n      // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n      let maxRadiusSq = 0;\n      for (let i = 0, il = position.count; i < il; i++) {\n        _vector$8.fromBufferAttribute(position, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n      }\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector$8.fromBufferAttribute(morphAttribute, j);\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n              _vector$8.add(_offset);\n            }\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n          }\n        }\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  }\n  computeTangents() {\n    const index = this.index;\n    const attributes = this.attributes;\n\n    // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n      return;\n    }\n    const positionAttribute = attributes.position;\n    const normalAttribute = attributes.normal;\n    const uvAttribute = attributes.uv;\n    if (this.hasAttribute('tangent') === false) {\n      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));\n    }\n    const tangentAttribute = this.getAttribute('tangent');\n    const tan1 = [],\n      tan2 = [];\n    for (let i = 0; i < positionAttribute.count; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n    const vA = new Vector3(),\n      vB = new Vector3(),\n      vC = new Vector3(),\n      uvA = new Vector2(),\n      uvB = new Vector2(),\n      uvC = new Vector2(),\n      sdir = new Vector3(),\n      tdir = new Vector3();\n    function handleTriangle(a, b, c) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n      uvA.fromBufferAttribute(uvAttribute, a);\n      uvB.fromBufferAttribute(uvAttribute, b);\n      uvC.fromBufferAttribute(uvAttribute, c);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);\n\n      // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n    let groups = this.groups;\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: index.count\n      }];\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));\n      }\n    }\n    const tmp = new Vector3(),\n      tmp2 = new Vector3();\n    const n = new Vector3(),\n      n2 = new Vector3();\n    function handleVertex(v) {\n      n.fromBufferAttribute(normalAttribute, v);\n      n2.copy(n);\n      const t = tan1[v];\n\n      // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n      // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      const test = tmp2.dot(tan2[v]);\n      const w = test < 0.0 ? -1.0 : 1.0;\n      tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(index.getX(j + 0));\n        handleVertex(index.getX(j + 1));\n        handleVertex(index.getX(j + 2));\n      }\n    }\n  }\n  computeVertexNormals() {\n    const index = this.index;\n    const positionAttribute = this.getAttribute('position');\n    if (positionAttribute !== undefined) {\n      let normalAttribute = this.getAttribute('normal');\n      if (normalAttribute === undefined) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute('normal', normalAttribute);\n      } else {\n        // reset existing normals to zero\n\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n      const pA = new Vector3(),\n        pB = new Vector3(),\n        pC = new Vector3();\n      const nA = new Vector3(),\n        nB = new Vector3(),\n        nC = new Vector3();\n      const cb = new Vector3(),\n        ab = new Vector3();\n\n      // indexed elements\n\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n      this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  }\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector$8.fromBufferAttribute(normals, i);\n      _vector$8.normalize();\n      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);\n    }\n  }\n  toNonIndexed() {\n    function convertBufferAttribute(attribute, indices) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const normalized = attribute.normalized;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n        index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        if (attribute.isInterleavedBufferAttribute) {\n          index = indices[i] * attribute.data.stride + attribute.offset;\n        } else {\n          index = indices[i] * itemSize;\n        }\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new BufferAttribute(array2, itemSize, normalized);\n    }\n\n    //\n\n    if (this.index === null) {\n      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');\n      return this;\n    }\n    const geometry2 = new BufferGeometry();\n    const indices = this.index.array;\n    const attributes = this.attributes;\n\n    // attributes\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    }\n\n    // morph attributes\n\n    const morphAttributes = this.morphAttributes;\n    for (const name in morphAttributes) {\n      const morphArray = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n      geometry2.morphAttributes[name] = morphArray;\n    }\n    geometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n    // groups\n\n    const groups = this.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n    return geometry2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.6,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    };\n\n    // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n      for (const key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n      return data;\n    }\n\n    // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n    data.data = {\n      attributes: {}\n    };\n    const index = this.index;\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n    const attributes = this.attributes;\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      data.data.attributes[key] = attribute.toJSON(data.data);\n    }\n    const morphAttributes = {};\n    let hasMorphAttributes = false;\n    for (const key in this.morphAttributes) {\n      const attributeArray = this.morphAttributes[key];\n      const array = [];\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n        const attribute = attributeArray[i];\n        array.push(attribute.toJSON(data.data));\n      }\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n    const groups = this.groups;\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n    const boundingSphere = this.boundingSphere;\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n    return data;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    // reset\n\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    // used for storing cloned, shared data\n\n    const data = {};\n\n    // name\n\n    this.name = source.name;\n\n    // index\n\n    const index = source.index;\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    }\n\n    // attributes\n\n    const attributes = source.attributes;\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    }\n\n    // morph attributes\n\n    const morphAttributes = source.morphAttributes;\n    for (const name in morphAttributes) {\n      const array = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n      this.morphAttributes[name] = array;\n    }\n    this.morphTargetsRelative = source.morphTargetsRelative;\n\n    // groups\n\n    const groups = source.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    // bounding box\n\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n\n    // bounding sphere\n\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n\n    // draw range\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count;\n\n    // user data\n\n    this.userData = source.userData;\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n}\nconst _inverseMatrix$3 = /*@__PURE__*/new Matrix4();\nconst _ray$3 = /*@__PURE__*/new Ray();\nconst _sphere$6 = /*@__PURE__*/new Sphere();\nconst _sphereHitAt = /*@__PURE__*/new Vector3();\nconst _vA$1 = /*@__PURE__*/new Vector3();\nconst _vB$1 = /*@__PURE__*/new Vector3();\nconst _vC$1 = /*@__PURE__*/new Vector3();\nconst _tempA = /*@__PURE__*/new Vector3();\nconst _morphA = /*@__PURE__*/new Vector3();\nconst _intersectionPoint = /*@__PURE__*/new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/new Vector3();\nclass Mesh extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n    super();\n    this.isMesh = true;\n    this.type = 'Mesh';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.morphTargetInfluences !== undefined) {\n      this.morphTargetInfluences = source.morphTargetInfluences.slice();\n    }\n    if (source.morphTargetDictionary !== undefined) {\n      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n    }\n    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== undefined) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || String(m);\n          this.morphTargetInfluences.push(0);\n          this.morphTargetDictionary[name] = m;\n        }\n      }\n    }\n  }\n  getVertexPosition(index, target) {\n    const geometry = this.geometry;\n    const position = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    target.fromBufferAttribute(position, index);\n    const morphInfluences = this.morphTargetInfluences;\n    if (morphPosition && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      for (let i = 0, il = morphPosition.length; i < il; i++) {\n        const influence = morphInfluences[i];\n        const morphAttribute = morphPosition[i];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morphAttribute, index);\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(target), influence);\n        }\n      }\n      target.add(_morphA);\n    }\n    return target;\n  }\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === undefined) return;\n\n    // test with bounding sphere in world space\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    _sphere$6.copy(geometry.boundingSphere);\n    _sphere$6.applyMatrix4(matrixWorld);\n\n    // check distance from ray origin to bounding sphere\n\n    _ray$3.copy(raycaster.ray).recast(raycaster.near);\n    if (_sphere$6.containsPoint(_ray$3.origin) === false) {\n      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;\n      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;\n    }\n\n    // convert ray to local space of mesh\n\n    _inverseMatrix$3.copy(matrixWorld).invert();\n    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);\n\n    // test with bounding box in local space\n\n    if (geometry.boundingBox !== null) {\n      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;\n    }\n\n    // test for intersections with geometry\n\n    this._computeIntersections(raycaster, intersects, _ray$3);\n  }\n  _computeIntersections(raycaster, intersects, rayLocalSpace) {\n    let intersection;\n    const geometry = this.geometry;\n    const material = this.material;\n    const index = geometry.index;\n    const position = geometry.attributes.position;\n    const uv = geometry.attributes.uv;\n    const uv1 = geometry.attributes.uv1;\n    const normal = geometry.attributes.normal;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    if (index !== null) {\n      // indexed buffer geometry\n\n      if (Array.isArray(material)) {\n        for (let i = 0, il = groups.length; i < il; i++) {\n          const group = groups[i];\n          const groupMaterial = material[group.materialIndex];\n          const start = Math.max(group.start, drawRange.start);\n          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n          for (let j = start, jl = end; j < jl; j += 3) {\n            const a = index.getX(j);\n            const b = index.getX(j + 1);\n            const c = index.getX(j + 2);\n            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n              intersection.face.materialIndex = group.materialIndex;\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n        for (let i = start, il = end; i < il; i += 3) {\n          const a = index.getX(i);\n          const b = index.getX(i + 1);\n          const c = index.getX(i + 2);\n          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n          if (intersection) {\n            intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n            intersects.push(intersection);\n          }\n        }\n      }\n    } else if (position !== undefined) {\n      // non-indexed buffer geometry\n\n      if (Array.isArray(material)) {\n        for (let i = 0, il = groups.length; i < il; i++) {\n          const group = groups[i];\n          const groupMaterial = material[group.materialIndex];\n          const start = Math.max(group.start, drawRange.start);\n          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n          for (let j = start, jl = end; j < jl; j += 3) {\n            const a = j;\n            const b = j + 1;\n            const c = j + 2;\n            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n              intersection.face.materialIndex = group.materialIndex;\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(position.count, drawRange.start + drawRange.count);\n        for (let i = start, il = end; i < il; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n          if (intersection) {\n            intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n            intersects.push(intersection);\n          }\n        }\n      }\n    }\n  }\n}\nfunction checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {\n  let intersect;\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);\n  }\n  if (intersect === null) return null;\n  _intersectionPointWorld.copy(point);\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object\n  };\n}\nfunction checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {\n  object.getVertexPosition(a, _vA$1);\n  object.getVertexPosition(b, _vB$1);\n  object.getVertexPosition(c, _vC$1);\n  const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n  if (intersection) {\n    const barycoord = new Vector3();\n    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);\n    if (uv) {\n      intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());\n    }\n    if (uv1) {\n      intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());\n    }\n    if (normal) {\n      intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());\n      if (intersection.normal.dot(ray.direction) > 0) {\n        intersection.normal.multiplyScalar(-1);\n      }\n    }\n    const face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n    intersection.face = face;\n    intersection.barycoord = barycoord;\n  }\n  return intersection;\n}\nclass BoxGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n    super();\n    this.type = 'BoxGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n    const scope = this;\n\n    // segments\n\n    widthSegments = Math.floor(widthSegments);\n    heightSegments = Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    let numberOfVertices = 0;\n    let groupStart = 0;\n\n    // build each side of the box geometry\n\n    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n      const segmentWidth = width / gridX;\n      const segmentHeight = height / gridY;\n      const widthHalf = width / 2;\n      const heightHalf = height / 2;\n      const depthHalf = depth / 2;\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      let vertexCounter = 0;\n      let groupCount = 0;\n      const vector = new Vector3();\n\n      // generate vertices, normals and uvs\n\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segmentHeight - heightHalf;\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x = ix * segmentWidth - widthHalf;\n\n          // set values to correct vector component\n\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf;\n\n          // now apply vector to vertex buffer\n\n          vertices.push(vector.x, vector.y, vector.z);\n\n          // set values to correct vector component\n\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth > 0 ? 1 : -1;\n\n          // now apply vector to normal buffer\n\n          normals.push(vector.x, vector.y, vector.z);\n\n          // uvs\n\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n\n          // counters\n\n          vertexCounter += 1;\n        }\n      }\n\n      // indices\n\n      // 1. you need three indices to draw a single face\n      // 2. a single segment consists of two faces\n      // 3. so we need to generate six (2*3) indices per segment\n\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = numberOfVertices + ix + gridX1 * iy;\n          const b = numberOfVertices + ix + gridX1 * (iy + 1);\n          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n          const d = numberOfVertices + (ix + 1) + gridX1 * iy;\n\n          // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n\n          // increase counter\n\n          groupCount += 6;\n        }\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup(groupStart, groupCount, materialIndex);\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n\n      // update total number of vertices\n\n      numberOfVertices += vertexCounter;\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n  }\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms(src) {\n  const dst = {};\n  for (const u in src) {\n    dst[u] = {};\n    for (const p in src[u]) {\n      const property = src[u][p];\n      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n        if (property.isRenderTargetTexture) {\n          console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().');\n          dst[u][p] = null;\n        } else {\n          dst[u][p] = property.clone();\n        }\n      } else if (Array.isArray(property)) {\n        dst[u][p] = property.slice();\n      } else {\n        dst[u][p] = property;\n      }\n    }\n  }\n  return dst;\n}\nfunction mergeUniforms(uniforms) {\n  const merged = {};\n  for (let u = 0; u < uniforms.length; u++) {\n    const tmp = cloneUniforms(uniforms[u]);\n    for (const p in tmp) {\n      merged[p] = tmp[p];\n    }\n  }\n  return merged;\n}\nfunction cloneUniformsGroups(src) {\n  const dst = [];\n  for (let u = 0; u < src.length; u++) {\n    dst.push(src[u].clone());\n  }\n  return dst;\n}\nfunction getUnlitUniformColorSpace(renderer) {\n  const currentRenderTarget = renderer.getRenderTarget();\n  if (currentRenderTarget === null) {\n    // https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398\n    return renderer.outputColorSpace;\n  }\n\n  // https://github.com/mrdoob/three.js/issues/27868\n  if (currentRenderTarget.isXRRenderTarget === true) {\n    return currentRenderTarget.texture.colorSpace;\n  }\n  return ColorManagement.workingColorSpace;\n}\n\n// Legacy\n\nconst UniformsUtils = {\n  clone: cloneUniforms,\n  merge: mergeUniforms\n};\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\nclass ShaderMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isShaderMaterial = true;\n    this.type = 'ShaderMaterial';\n    this.defines = {};\n    this.uniforms = {};\n    this.uniformsGroups = [];\n    this.vertexShader = default_vertex;\n    this.fragmentShader = default_fragment;\n    this.linewidth = 1;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false; // set to use scene fog\n    this.lights = false; // set to use scene lights\n    this.clipping = false; // set to use user-defined clipping planes\n\n    this.forceSinglePass = true;\n    this.extensions = {\n      clipCullDistance: false,\n      // set to use vertex shader clipping\n      multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID\n    };\n\n    // When rendered geometry doesn't include these attributes but the material does,\n    // use these default values in WebGL. This avoids errors when buffer data is missing.\n    this.defaultAttributeValues = {\n      'color': [1, 1, 1],\n      'uv': [0, 0],\n      'uv1': [0, 0]\n    };\n    this.index0AttributeName = undefined;\n    this.uniformsNeedUpdate = false;\n    this.glslVersion = null;\n    if (parameters !== undefined) {\n      this.setValues(parameters);\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.fragmentShader = source.fragmentShader;\n    this.vertexShader = source.vertexShader;\n    this.uniforms = cloneUniforms(source.uniforms);\n    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);\n    this.defines = Object.assign({}, source.defines);\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.fog = source.fog;\n    this.lights = source.lights;\n    this.clipping = source.clipping;\n    this.extensions = Object.assign({}, source.extensions);\n    this.glslVersion = source.glslVersion;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.glslVersion = this.glslVersion;\n    data.uniforms = {};\n    for (const name in this.uniforms) {\n      const uniform = this.uniforms[name];\n      const value = uniform.value;\n      if (value && value.isTexture) {\n        data.uniforms[name] = {\n          type: 't',\n          value: value.toJSON(meta).uuid\n        };\n      } else if (value && value.isColor) {\n        data.uniforms[name] = {\n          type: 'c',\n          value: value.getHex()\n        };\n      } else if (value && value.isVector2) {\n        data.uniforms[name] = {\n          type: 'v2',\n          value: value.toArray()\n        };\n      } else if (value && value.isVector3) {\n        data.uniforms[name] = {\n          type: 'v3',\n          value: value.toArray()\n        };\n      } else if (value && value.isVector4) {\n        data.uniforms[name] = {\n          type: 'v4',\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix3) {\n        data.uniforms[name] = {\n          type: 'm3',\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix4) {\n        data.uniforms[name] = {\n          type: 'm4',\n          value: value.toArray()\n        };\n      } else {\n        data.uniforms[name] = {\n          value: value\n        };\n\n        // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n      }\n    }\n    if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n    data.vertexShader = this.vertexShader;\n    data.fragmentShader = this.fragmentShader;\n    data.lights = this.lights;\n    data.clipping = this.clipping;\n    const extensions = {};\n    for (const key in this.extensions) {\n      if (this.extensions[key] === true) extensions[key] = true;\n    }\n    if (Object.keys(extensions).length > 0) data.extensions = extensions;\n    return data;\n  }\n}\nclass Camera extends Object3D {\n  constructor() {\n    super();\n    this.isCamera = true;\n    this.type = 'Camera';\n    this.matrixWorldInverse = new Matrix4();\n    this.projectionMatrix = new Matrix4();\n    this.projectionMatrixInverse = new Matrix4();\n    this.coordinateSystem = WebGLCoordinateSystem;\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.matrixWorldInverse.copy(source.matrixWorldInverse);\n    this.projectionMatrix.copy(source.projectionMatrix);\n    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n    this.coordinateSystem = source.coordinateSystem;\n    return this;\n  }\n  getWorldDirection(target) {\n    return super.getWorldDirection(target).negate();\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  updateWorldMatrix(updateParents, updateChildren) {\n    super.updateWorldMatrix(updateParents, updateChildren);\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _v3$1 = /*@__PURE__*/new Vector3();\nconst _minTarget = /*@__PURE__*/new Vector2();\nconst _maxTarget = /*@__PURE__*/new Vector2();\nclass PerspectiveCamera extends Camera {\n  constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {\n    super();\n    this.isPerspectiveCamera = true;\n    this.type = 'PerspectiveCamera';\n    this.fov = fov;\n    this.zoom = 1;\n    this.near = near;\n    this.far = far;\n    this.focus = 10;\n    this.aspect = aspect;\n    this.view = null;\n    this.filmGauge = 35; // width of the film (default in millimeters)\n    this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n    this.updateProjectionMatrix();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n    return this;\n  }\n\n  /**\n   * Sets the FOV by focal length in respect to the current .filmGauge.\n   *\n   * The default film gauge is 35, so that the focal length can be specified for\n   * a 35mm (full frame) camera.\n   *\n   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.\n   */\n  setFocalLength(focalLength) {\n    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  }\n\n  /**\n   * Calculates the focal length from the current .fov and .filmGauge.\n   *\n   * @returns {number}\n   */\n  getFocalLength() {\n    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n    return 0.5 * this.getFilmHeight() / vExtentSlope;\n  }\n  getEffectiveFOV() {\n    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);\n  }\n  getFilmWidth() {\n    // film not completely covered in portrait format (aspect < 1)\n    return this.filmGauge * Math.min(this.aspect, 1);\n  }\n  getFilmHeight() {\n    // film not completely covered in landscape format (aspect > 1)\n    return this.filmGauge / Math.max(this.aspect, 1);\n  }\n\n  /**\n   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.\n   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.\n   *\n   * @param {number} distance\n   * @param {Vector2} minTarget\n   * @param {Vector2} maxTarget\n   */\n  getViewBounds(distance, minTarget, maxTarget) {\n    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);\n    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);\n    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);\n    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);\n  }\n\n  /**\n   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.\n   *\n   * @param {number} distance\n   * @param {Vector2} target - Vector2 target used to store result where x is width and y is height.\n   * @returns {Vector2}\n   */\n  getViewSize(distance, target) {\n    this.getViewBounds(distance, _minTarget, _maxTarget);\n    return target.subVectors(_maxTarget, _minTarget);\n  }\n\n  /**\n   * Sets an offset in a larger frustum. This is useful for multi-window or\n   * multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n   * the monitors are in grid like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   +---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then for each monitor you would call it like this\n   *\n   *   const w = 1920;\n   *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   --C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no reason monitors have to be the same size or in a grid.\n   *\n   * @param {number} fullWidth\n   * @param {number} fullHeight\n   * @param {number} x\n   * @param {number} y\n   * @param {number} width\n   * @param {number} height\n   */\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    this.aspect = fullWidth / fullHeight;\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n    this.updateProjectionMatrix();\n  }\n  updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n    let width = this.aspect * height;\n    let left = -0.5 * width;\n    const view = this.view;\n    if (this.view !== null && this.view.enabled) {\n      const fullWidth = view.fullWidth,\n        fullHeight = view.fullHeight;\n      left += view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n    const skew = this.filmOffset;\n    if (skew !== 0) left += near * skew / this.getFilmWidth();\n    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.fov = this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    data.object.focus = this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = this.filmOffset;\n    return data;\n  }\n}\nconst fov = -90; // negative fov is not an error\nconst aspect = 1;\nclass CubeCamera extends Object3D {\n  constructor(near, far, renderTarget) {\n    super();\n    this.type = 'CubeCamera';\n    this.renderTarget = renderTarget;\n    this.coordinateSystem = null;\n    this.activeMipmapLevel = 0;\n    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPX.layers = this.layers;\n    this.add(cameraPX);\n    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNX.layers = this.layers;\n    this.add(cameraNX);\n    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPY.layers = this.layers;\n    this.add(cameraPY);\n    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNY.layers = this.layers;\n    this.add(cameraNY);\n    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPZ.layers = this.layers;\n    this.add(cameraPZ);\n    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNZ.layers = this.layers;\n    this.add(cameraNZ);\n  }\n  updateCoordinateSystem() {\n    const coordinateSystem = this.coordinateSystem;\n    const cameras = this.children.concat();\n    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;\n    for (const camera of cameras) this.remove(camera);\n    if (coordinateSystem === WebGLCoordinateSystem) {\n      cameraPX.up.set(0, 1, 0);\n      cameraPX.lookAt(1, 0, 0);\n      cameraNX.up.set(0, 1, 0);\n      cameraNX.lookAt(-1, 0, 0);\n      cameraPY.up.set(0, 0, -1);\n      cameraPY.lookAt(0, 1, 0);\n      cameraNY.up.set(0, 0, 1);\n      cameraNY.lookAt(0, -1, 0);\n      cameraPZ.up.set(0, 1, 0);\n      cameraPZ.lookAt(0, 0, 1);\n      cameraNZ.up.set(0, 1, 0);\n      cameraNZ.lookAt(0, 0, -1);\n    } else if (coordinateSystem === WebGPUCoordinateSystem) {\n      cameraPX.up.set(0, -1, 0);\n      cameraPX.lookAt(-1, 0, 0);\n      cameraNX.up.set(0, -1, 0);\n      cameraNX.lookAt(1, 0, 0);\n      cameraPY.up.set(0, 0, 1);\n      cameraPY.lookAt(0, 1, 0);\n      cameraNY.up.set(0, 0, -1);\n      cameraNY.lookAt(0, -1, 0);\n      cameraPZ.up.set(0, -1, 0);\n      cameraPZ.lookAt(0, 0, 1);\n      cameraNZ.up.set(0, -1, 0);\n      cameraNZ.lookAt(0, 0, -1);\n    } else {\n      throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem);\n    }\n    for (const camera of cameras) {\n      this.add(camera);\n      camera.updateMatrixWorld();\n    }\n  }\n  update(renderer, scene) {\n    if (this.parent === null) this.updateMatrixWorld();\n    const {\n      renderTarget,\n      activeMipmapLevel\n    } = this;\n    if (this.coordinateSystem !== renderer.coordinateSystem) {\n      this.coordinateSystem = renderer.coordinateSystem;\n      this.updateCoordinateSystem();\n    }\n    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentActiveCubeFace = renderer.getActiveCubeFace();\n    const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();\n    const currentXrEnabled = renderer.xr.enabled;\n    renderer.xr.enabled = false;\n    const generateMipmaps = renderTarget.texture.generateMipmaps;\n    renderTarget.texture.generateMipmaps = false;\n    renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);\n    renderer.render(scene, cameraPX);\n    renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);\n    renderer.render(scene, cameraNX);\n    renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);\n    renderer.render(scene, cameraPY);\n    renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);\n    renderer.render(scene, cameraNY);\n    renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);\n    renderer.render(scene, cameraPZ);\n\n    // mipmaps are generated during the last call of render()\n    // at this point, all sides of the cube render target are defined\n\n    renderTarget.texture.generateMipmaps = generateMipmaps;\n    renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);\n    renderer.render(scene, cameraNZ);\n    renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);\n    renderer.xr.enabled = currentXrEnabled;\n    renderTarget.texture.needsPMREMUpdate = true;\n  }\n}\nclass CubeTexture extends Texture {\n  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {\n    images = images !== undefined ? images : [];\n    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n    this.isCubeTexture = true;\n    this.flipY = false;\n  }\n  get images() {\n    return this.image;\n  }\n  set images(value) {\n    this.image = value;\n  }\n}\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n  constructor(size = 1, options = {}) {\n    super(size, size, options);\n    this.isWebGLCubeRenderTarget = true;\n    const image = {\n      width: size,\n      height: size,\n      depth: 1\n    };\n    const images = [image, image, image, image, image, image];\n    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);\n\n    // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n    this.texture.isRenderTargetTexture = true;\n    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n  }\n  fromEquirectangularTexture(renderer, texture) {\n    this.texture.type = texture.type;\n    this.texture.colorSpace = texture.colorSpace;\n    this.texture.generateMipmaps = texture.generateMipmaps;\n    this.texture.minFilter = texture.minFilter;\n    this.texture.magFilter = texture.magFilter;\n    const shader = {\n      uniforms: {\n        tEquirect: {\n          value: null\n        }\n      },\n      vertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n    };\n    const geometry = new BoxGeometry(5, 5, 5);\n    const material = new ShaderMaterial({\n      name: 'CubemapFromEquirect',\n      uniforms: cloneUniforms(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      side: BackSide,\n      blending: NoBlending\n    });\n    material.uniforms.tEquirect.value = texture;\n    const mesh = new Mesh(geometry, material);\n    const currentMinFilter = texture.minFilter;\n\n    // Avoid blurred poles\n    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n    const camera = new CubeCamera(1, 10, this);\n    camera.update(renderer, mesh);\n    texture.minFilter = currentMinFilter;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n  clear(renderer, color, depth, stencil) {\n    const currentRenderTarget = renderer.getRenderTarget();\n    for (let i = 0; i < 6; i++) {\n      renderer.setRenderTarget(this, i);\n      renderer.clear(color, depth, stencil);\n    }\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n}\nclass FogExp2 {\n  constructor(color, density = 0.00025) {\n    this.isFogExp2 = true;\n    this.name = '';\n    this.color = new Color(color);\n    this.density = density;\n  }\n  clone() {\n    return new FogExp2(this.color, this.density);\n  }\n  toJSON(/* meta */\n  ) {\n    return {\n      type: 'FogExp2',\n      name: this.name,\n      color: this.color.getHex(),\n      density: this.density\n    };\n  }\n}\nclass Fog {\n  constructor(color, near = 1, far = 1000) {\n    this.isFog = true;\n    this.name = '';\n    this.color = new Color(color);\n    this.near = near;\n    this.far = far;\n  }\n  clone() {\n    return new Fog(this.color, this.near, this.far);\n  }\n  toJSON(/* meta */\n  ) {\n    return {\n      type: 'Fog',\n      name: this.name,\n      color: this.color.getHex(),\n      near: this.near,\n      far: this.far\n    };\n  }\n}\nclass Scene extends Object3D {\n  constructor() {\n    super();\n    this.isScene = true;\n    this.type = 'Scene';\n    this.background = null;\n    this.environment = null;\n    this.fog = null;\n    this.backgroundBlurriness = 0;\n    this.backgroundIntensity = 1;\n    this.backgroundRotation = new Euler();\n    this.environmentIntensity = 1;\n    this.environmentRotation = new Euler();\n    this.overrideMaterial = null;\n    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n        detail: this\n      }));\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.background !== null) this.background = source.background.clone();\n    if (source.environment !== null) this.environment = source.environment.clone();\n    if (source.fog !== null) this.fog = source.fog.clone();\n    this.backgroundBlurriness = source.backgroundBlurriness;\n    this.backgroundIntensity = source.backgroundIntensity;\n    this.backgroundRotation.copy(source.backgroundRotation);\n    this.environmentIntensity = source.environmentIntensity;\n    this.environmentRotation.copy(source.environmentRotation);\n    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    if (this.fog !== null) data.object.fog = this.fog.toJSON();\n    if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;\n    if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;\n    data.object.backgroundRotation = this.backgroundRotation.toArray();\n    if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;\n    data.object.environmentRotation = this.environmentRotation.toArray();\n    return data;\n  }\n}\nclass InterleavedBuffer {\n  constructor(array, stride) {\n    this.isInterleavedBuffer = true;\n    this.array = array;\n    this.stride = stride;\n    this.count = array !== undefined ? array.length / stride : 0;\n    this.usage = StaticDrawUsage;\n    this.updateRanges = [];\n    this.version = 0;\n    this.uuid = generateUUID();\n  }\n  onUploadCallback() {}\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n  addUpdateRange(start, count) {\n    this.updateRanges.push({\n      start,\n      count\n    });\n  }\n  clearUpdateRanges() {\n    this.updateRanges.length = 0;\n  }\n  copy(source) {\n    this.array = new source.array.constructor(source.array);\n    this.count = source.count;\n    this.stride = source.stride;\n    this.usage = source.usage;\n    return this;\n  }\n  copyAt(index1, attribute, index2) {\n    index1 *= this.stride;\n    index2 *= attribute.stride;\n    for (let i = 0, l = this.stride; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n    return this;\n  }\n  set(value, offset = 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n  clone(data) {\n    if (data.arrayBuffers === undefined) {\n      data.arrayBuffers = {};\n    }\n    if (this.array.buffer._uuid === undefined) {\n      this.array.buffer._uuid = generateUUID();\n    }\n    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n    }\n    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n    const ib = new this.constructor(array, this.stride);\n    ib.setUsage(this.usage);\n    return ib;\n  }\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n    return this;\n  }\n  toJSON(data) {\n    if (data.arrayBuffers === undefined) {\n      data.arrayBuffers = {};\n    }\n\n    // generate UUID for array buffer if necessary\n\n    if (this.array.buffer._uuid === undefined) {\n      this.array.buffer._uuid = generateUUID();\n    }\n    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n      data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));\n    }\n\n    //\n\n    return {\n      uuid: this.uuid,\n      buffer: this.array.buffer._uuid,\n      type: this.array.constructor.name,\n      stride: this.stride\n    };\n  }\n}\nconst _vector$7 = /*@__PURE__*/new Vector3();\nclass InterleavedBufferAttribute {\n  constructor(interleavedBuffer, itemSize, offset, normalized = false) {\n    this.isInterleavedBufferAttribute = true;\n    this.name = '';\n    this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    this.offset = offset;\n    this.normalized = normalized;\n  }\n  get count() {\n    return this.data.count;\n  }\n  get array() {\n    return this.data.array;\n  }\n  set needsUpdate(value) {\n    this.data.needsUpdate = value;\n  }\n  applyMatrix4(m) {\n    for (let i = 0, l = this.data.count; i < l; i++) {\n      _vector$7.fromBufferAttribute(this, i);\n      _vector$7.applyMatrix4(m);\n      this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);\n    }\n    return this;\n  }\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$7.fromBufferAttribute(this, i);\n      _vector$7.applyNormalMatrix(m);\n      this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);\n    }\n    return this;\n  }\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$7.fromBufferAttribute(this, i);\n      _vector$7.transformDirection(m);\n      this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);\n    }\n    return this;\n  }\n  getComponent(index, component) {\n    let value = this.array[index * this.data.stride + this.offset + component];\n    if (this.normalized) value = denormalize(value, this.array);\n    return value;\n  }\n  setComponent(index, component, value) {\n    if (this.normalized) value = normalize(value, this.array);\n    this.data.array[index * this.data.stride + this.offset + component] = value;\n    return this;\n  }\n  setX(index, x) {\n    if (this.normalized) x = normalize(x, this.array);\n    this.data.array[index * this.data.stride + this.offset] = x;\n    return this;\n  }\n  setY(index, y) {\n    if (this.normalized) y = normalize(y, this.array);\n    this.data.array[index * this.data.stride + this.offset + 1] = y;\n    return this;\n  }\n  setZ(index, z) {\n    if (this.normalized) z = normalize(z, this.array);\n    this.data.array[index * this.data.stride + this.offset + 2] = z;\n    return this;\n  }\n  setW(index, w) {\n    if (this.normalized) w = normalize(w, this.array);\n    this.data.array[index * this.data.stride + this.offset + 3] = w;\n    return this;\n  }\n  getX(index) {\n    let x = this.data.array[index * this.data.stride + this.offset];\n    if (this.normalized) x = denormalize(x, this.array);\n    return x;\n  }\n  getY(index) {\n    let y = this.data.array[index * this.data.stride + this.offset + 1];\n    if (this.normalized) y = denormalize(y, this.array);\n    return y;\n  }\n  getZ(index) {\n    let z = this.data.array[index * this.data.stride + this.offset + 2];\n    if (this.normalized) z = denormalize(z, this.array);\n    return z;\n  }\n  getW(index) {\n    let w = this.data.array[index * this.data.stride + this.offset + 3];\n    if (this.normalized) w = denormalize(w, this.array);\n    return w;\n  }\n  setXY(index, x, y) {\n    index = index * this.data.stride + this.offset;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n    }\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    return this;\n  }\n  setXYZ(index, x, y, z) {\n    index = index * this.data.stride + this.offset;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n    }\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    return this;\n  }\n  setXYZW(index, x, y, z, w) {\n    index = index * this.data.stride + this.offset;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n      w = normalize(w, this.array);\n    }\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    this.data.array[index + 3] = w;\n    return this;\n  }\n  clone(data) {\n    if (data === undefined) {\n      console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.');\n      const array = [];\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n    } else {\n      if (data.interleavedBuffers === undefined) {\n        data.interleavedBuffers = {};\n      }\n      if (data.interleavedBuffers[this.data.uuid] === undefined) {\n        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n      }\n      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);\n    }\n  }\n  toJSON(data) {\n    if (data === undefined) {\n      console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.');\n      const array = [];\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n\n      // de-interleave data and save it as an ordinary buffer attribute for now\n\n      return {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: array,\n        normalized: this.normalized\n      };\n    } else {\n      // save as true interleaved attribute\n\n      if (data.interleavedBuffers === undefined) {\n        data.interleavedBuffers = {};\n      }\n      if (data.interleavedBuffers[this.data.uuid] === undefined) {\n        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n      }\n      return {\n        isInterleavedBufferAttribute: true,\n        itemSize: this.itemSize,\n        data: this.data.uuid,\n        offset: this.offset,\n        normalized: this.normalized\n      };\n    }\n  }\n}\nclass SpriteMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isSpriteMaterial = true;\n    this.type = 'SpriteMaterial';\n    this.color = new Color(0xffffff);\n    this.map = null;\n    this.alphaMap = null;\n    this.rotation = 0;\n    this.sizeAttenuation = true;\n    this.transparent = true;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.rotation = source.rotation;\n    this.sizeAttenuation = source.sizeAttenuation;\n    this.fog = source.fog;\n    return this;\n  }\n}\nlet _geometry;\nconst _intersectPoint = /*@__PURE__*/new Vector3();\nconst _worldScale = /*@__PURE__*/new Vector3();\nconst _mvPosition = /*@__PURE__*/new Vector3();\nconst _alignedPosition = /*@__PURE__*/new Vector2();\nconst _rotatedPosition = /*@__PURE__*/new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/new Matrix4();\nconst _vA = /*@__PURE__*/new Vector3();\nconst _vB = /*@__PURE__*/new Vector3();\nconst _vC = /*@__PURE__*/new Vector3();\nconst _uvA = /*@__PURE__*/new Vector2();\nconst _uvB = /*@__PURE__*/new Vector2();\nconst _uvC = /*@__PURE__*/new Vector2();\nclass Sprite extends Object3D {\n  constructor(material = new SpriteMaterial()) {\n    super();\n    this.isSprite = true;\n    this.type = 'Sprite';\n    if (_geometry === undefined) {\n      _geometry = new BufferGeometry();\n      const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);\n      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n      _geometry.setIndex([0, 1, 2, 0, 2, 3]);\n      _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n      _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n    }\n    this.geometry = _geometry;\n    this.material = material;\n    this.center = new Vector2(0.5, 0.5);\n  }\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.');\n    }\n    _worldScale.setFromMatrixScale(this.matrixWorld);\n    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);\n    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\n      _worldScale.multiplyScalar(-_mvPosition.z);\n    }\n    const rotation = this.material.rotation;\n    let sin, cos;\n    if (rotation !== 0) {\n      cos = Math.cos(rotation);\n      sin = Math.sin(rotation);\n    }\n    const center = this.center;\n    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    _uvA.set(0, 0);\n    _uvB.set(1, 0);\n    _uvC.set(1, 1);\n\n    // check first triangle\n    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);\n    if (intersect === null) {\n      // check second triangle\n      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n      _uvB.set(0, 1);\n      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);\n      if (intersect === null) {\n        return;\n      }\n    }\n    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      point: _intersectPoint.clone(),\n      uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),\n      face: null,\n      object: this\n    });\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.center !== undefined) this.center.copy(source.center);\n    this.material = source.material;\n    return this;\n  }\n}\nfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n  // compute position in camera space\n  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);\n\n  // to check if rotation is not zero\n  if (sin !== undefined) {\n    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n  } else {\n    _rotatedPosition.copy(_alignedPosition);\n  }\n  vertexPosition.copy(mvPosition);\n  vertexPosition.x += _rotatedPosition.x;\n  vertexPosition.y += _rotatedPosition.y;\n\n  // transform to world space\n  vertexPosition.applyMatrix4(_viewWorldMatrix);\n}\nconst _v1$2 = /*@__PURE__*/new Vector3();\nconst _v2$1 = /*@__PURE__*/new Vector3();\nclass LOD extends Object3D {\n  constructor() {\n    super();\n    this._currentLevel = 0;\n    this.type = 'LOD';\n    Object.defineProperties(this, {\n      levels: {\n        enumerable: true,\n        value: []\n      },\n      isLOD: {\n        value: true\n      }\n    });\n    this.autoUpdate = true;\n  }\n  copy(source) {\n    super.copy(source, false);\n    const levels = source.levels;\n    for (let i = 0, l = levels.length; i < l; i++) {\n      const level = levels[i];\n      this.addLevel(level.object.clone(), level.distance, level.hysteresis);\n    }\n    this.autoUpdate = source.autoUpdate;\n    return this;\n  }\n  addLevel(object, distance = 0, hysteresis = 0) {\n    distance = Math.abs(distance);\n    const levels = this.levels;\n    let l;\n    for (l = 0; l < levels.length; l++) {\n      if (distance < levels[l].distance) {\n        break;\n      }\n    }\n    levels.splice(l, 0, {\n      distance: distance,\n      hysteresis: hysteresis,\n      object: object\n    });\n    this.add(object);\n    return this;\n  }\n  removeLevel(distance) {\n    const levels = this.levels;\n    for (let i = 0; i < levels.length; i++) {\n      if (levels[i].distance === distance) {\n        const removedElements = levels.splice(i, 1);\n        this.remove(removedElements[0].object);\n        return true;\n      }\n    }\n    return false;\n  }\n  getCurrentLevel() {\n    return this._currentLevel;\n  }\n  getObjectForDistance(distance) {\n    const levels = this.levels;\n    if (levels.length > 0) {\n      let i, l;\n      for (i = 1, l = levels.length; i < l; i++) {\n        let levelDistance = levels[i].distance;\n        if (levels[i].object.visible) {\n          levelDistance -= levelDistance * levels[i].hysteresis;\n        }\n        if (distance < levelDistance) {\n          break;\n        }\n      }\n      return levels[i - 1].object;\n    }\n    return null;\n  }\n  raycast(raycaster, intersects) {\n    const levels = this.levels;\n    if (levels.length > 0) {\n      _v1$2.setFromMatrixPosition(this.matrixWorld);\n      const distance = raycaster.ray.origin.distanceTo(_v1$2);\n      this.getObjectForDistance(distance).raycast(raycaster, intersects);\n    }\n  }\n  update(camera) {\n    const levels = this.levels;\n    if (levels.length > 1) {\n      _v1$2.setFromMatrixPosition(camera.matrixWorld);\n      _v2$1.setFromMatrixPosition(this.matrixWorld);\n      const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;\n      levels[0].object.visible = true;\n      let i, l;\n      for (i = 1, l = levels.length; i < l; i++) {\n        let levelDistance = levels[i].distance;\n        if (levels[i].object.visible) {\n          levelDistance -= levelDistance * levels[i].hysteresis;\n        }\n        if (distance >= levelDistance) {\n          levels[i - 1].object.visible = false;\n          levels[i].object.visible = true;\n        } else {\n          break;\n        }\n      }\n      this._currentLevel = i - 1;\n      for (; i < l; i++) {\n        levels[i].object.visible = false;\n      }\n    }\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    if (this.autoUpdate === false) data.object.autoUpdate = false;\n    data.object.levels = [];\n    const levels = this.levels;\n    for (let i = 0, l = levels.length; i < l; i++) {\n      const level = levels[i];\n      data.object.levels.push({\n        object: level.object.uuid,\n        distance: level.distance,\n        hysteresis: level.hysteresis\n      });\n    }\n    return data;\n  }\n}\nconst _basePosition = /*@__PURE__*/new Vector3();\nconst _skinIndex = /*@__PURE__*/new Vector4();\nconst _skinWeight = /*@__PURE__*/new Vector4();\nconst _vector3 = /*@__PURE__*/new Vector3();\nconst _matrix4 = /*@__PURE__*/new Matrix4();\nconst _vertex = /*@__PURE__*/new Vector3();\nconst _sphere$5 = /*@__PURE__*/new Sphere();\nconst _inverseMatrix$2 = /*@__PURE__*/new Matrix4();\nconst _ray$2 = /*@__PURE__*/new Ray();\nclass SkinnedMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isSkinnedMesh = true;\n    this.type = 'SkinnedMesh';\n    this.bindMode = AttachedBindMode;\n    this.bindMatrix = new Matrix4();\n    this.bindMatrixInverse = new Matrix4();\n    this.boundingBox = null;\n    this.boundingSphere = null;\n  }\n  computeBoundingBox() {\n    const geometry = this.geometry;\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    this.boundingBox.makeEmpty();\n    const positionAttribute = geometry.getAttribute('position');\n    for (let i = 0; i < positionAttribute.count; i++) {\n      this.getVertexPosition(i, _vertex);\n      this.boundingBox.expandByPoint(_vertex);\n    }\n  }\n  computeBoundingSphere() {\n    const geometry = this.geometry;\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    this.boundingSphere.makeEmpty();\n    const positionAttribute = geometry.getAttribute('position');\n    for (let i = 0; i < positionAttribute.count; i++) {\n      this.getVertexPosition(i, _vertex);\n      this.boundingSphere.expandByPoint(_vertex);\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.bindMode = source.bindMode;\n    this.bindMatrix.copy(source.bindMatrix);\n    this.bindMatrixInverse.copy(source.bindMatrixInverse);\n    this.skeleton = source.skeleton;\n    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();\n    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === undefined) return;\n\n    // test with bounding sphere in world space\n\n    if (this.boundingSphere === null) this.computeBoundingSphere();\n    _sphere$5.copy(this.boundingSphere);\n    _sphere$5.applyMatrix4(matrixWorld);\n    if (raycaster.ray.intersectsSphere(_sphere$5) === false) return;\n\n    // convert ray to local space of skinned mesh\n\n    _inverseMatrix$2.copy(matrixWorld).invert();\n    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);\n\n    // test with bounding box in local space\n\n    if (this.boundingBox !== null) {\n      if (_ray$2.intersectsBox(this.boundingBox) === false) return;\n    }\n\n    // test for intersections with geometry\n\n    this._computeIntersections(raycaster, intersects, _ray$2);\n  }\n  getVertexPosition(index, target) {\n    super.getVertexPosition(index, target);\n    this.applyBoneTransform(index, target);\n    return target;\n  }\n  bind(skeleton, bindMatrix) {\n    this.skeleton = skeleton;\n    if (bindMatrix === undefined) {\n      this.updateMatrixWorld(true);\n      this.skeleton.calculateInverses();\n      bindMatrix = this.matrixWorld;\n    }\n    this.bindMatrix.copy(bindMatrix);\n    this.bindMatrixInverse.copy(bindMatrix).invert();\n  }\n  pose() {\n    this.skeleton.pose();\n  }\n  normalizeSkinWeights() {\n    const vector = new Vector4();\n    const skinWeight = this.geometry.attributes.skinWeight;\n    for (let i = 0, l = skinWeight.count; i < l; i++) {\n      vector.fromBufferAttribute(skinWeight, i);\n      const scale = 1.0 / vector.manhattanLength();\n      if (scale !== Infinity) {\n        vector.multiplyScalar(scale);\n      } else {\n        vector.set(1, 0, 0, 0); // do something reasonable\n      }\n      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n    }\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.bindMode === AttachedBindMode) {\n      this.bindMatrixInverse.copy(this.matrixWorld).invert();\n    } else if (this.bindMode === DetachedBindMode) {\n      this.bindMatrixInverse.copy(this.bindMatrix).invert();\n    } else {\n      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);\n    }\n  }\n  applyBoneTransform(index, vector) {\n    const skeleton = this.skeleton;\n    const geometry = this.geometry;\n    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n    _basePosition.copy(vector).applyMatrix4(this.bindMatrix);\n    vector.set(0, 0, 0);\n    for (let i = 0; i < 4; i++) {\n      const weight = _skinWeight.getComponent(i);\n      if (weight !== 0) {\n        const boneIndex = _skinIndex.getComponent(i);\n        _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n        vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);\n      }\n    }\n    return vector.applyMatrix4(this.bindMatrixInverse);\n  }\n}\nclass Bone extends Object3D {\n  constructor() {\n    super();\n    this.isBone = true;\n    this.type = 'Bone';\n  }\n}\nclass DataTexture extends Texture {\n  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n    this.isDataTexture = true;\n    this.image = {\n      data: data,\n      width: width,\n      height: height\n    };\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n  }\n}\nconst _offsetMatrix = /*@__PURE__*/new Matrix4();\nconst _identityMatrix = /*@__PURE__*/new Matrix4();\nclass Skeleton {\n  constructor(bones = [], boneInverses = []) {\n    this.uuid = generateUUID();\n    this.bones = bones.slice(0);\n    this.boneInverses = boneInverses;\n    this.boneMatrices = null;\n    this.boneTexture = null;\n    this.init();\n  }\n  init() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    this.boneMatrices = new Float32Array(bones.length * 16);\n\n    // calculate inverse bone matrices if necessary\n\n    if (boneInverses.length === 0) {\n      this.calculateInverses();\n    } else {\n      // handle special case\n\n      if (bones.length !== boneInverses.length) {\n        console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');\n        this.boneInverses = [];\n        for (let i = 0, il = this.bones.length; i < il; i++) {\n          this.boneInverses.push(new Matrix4());\n        }\n      }\n    }\n  }\n  calculateInverses() {\n    this.boneInverses.length = 0;\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const inverse = new Matrix4();\n      if (this.bones[i]) {\n        inverse.copy(this.bones[i].matrixWorld).invert();\n      }\n      this.boneInverses.push(inverse);\n    }\n  }\n  pose() {\n    // recover the bind-time world matrices\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone) {\n        bone.matrixWorld.copy(this.boneInverses[i]).invert();\n      }\n    }\n\n    // compute the local matrices, positions, rotations and scales\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone) {\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(bone.matrixWorld);\n        } else {\n          bone.matrix.copy(bone.matrixWorld);\n        }\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      }\n    }\n  }\n  update() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    const boneMatrices = this.boneMatrices;\n    const boneTexture = this.boneTexture;\n\n    // flatten bone matrices to array\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      // compute the offset between the current and the original transform\n\n      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n      _offsetMatrix.toArray(boneMatrices, i * 16);\n    }\n    if (boneTexture !== null) {\n      boneTexture.needsUpdate = true;\n    }\n  }\n  clone() {\n    return new Skeleton(this.bones, this.boneInverses);\n  }\n  computeBoneTexture() {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n    let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n    size = Math.ceil(size / 4) * 4;\n    size = Math.max(size, 4);\n    const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n    boneMatrices.set(this.boneMatrices); // copy current values\n\n    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n    boneTexture.needsUpdate = true;\n    this.boneMatrices = boneMatrices;\n    this.boneTexture = boneTexture;\n    return this;\n  }\n  getBoneByName(name) {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone.name === name) {\n        return bone;\n      }\n    }\n    return undefined;\n  }\n  dispose() {\n    if (this.boneTexture !== null) {\n      this.boneTexture.dispose();\n      this.boneTexture = null;\n    }\n  }\n  fromJSON(json, bones) {\n    this.uuid = json.uuid;\n    for (let i = 0, l = json.bones.length; i < l; i++) {\n      const uuid = json.bones[i];\n      let bone = bones[uuid];\n      if (bone === undefined) {\n        console.warn('THREE.Skeleton: No bone found with UUID:', uuid);\n        bone = new Bone();\n      }\n      this.bones.push(bone);\n      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n    }\n    this.init();\n    return this;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.6,\n        type: 'Skeleton',\n        generator: 'Skeleton.toJSON'\n      },\n      bones: [],\n      boneInverses: []\n    };\n    data.uuid = this.uuid;\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    for (let i = 0, l = bones.length; i < l; i++) {\n      const bone = bones[i];\n      data.bones.push(bone.uuid);\n      const boneInverse = boneInverses[i];\n      data.boneInverses.push(boneInverse.toArray());\n    }\n    return data;\n  }\n}\nclass InstancedBufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized, meshPerAttribute = 1) {\n    super(array, itemSize, normalized);\n    this.isInstancedBufferAttribute = true;\n    this.meshPerAttribute = meshPerAttribute;\n  }\n  copy(source) {\n    super.copy(source);\n    this.meshPerAttribute = source.meshPerAttribute;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.meshPerAttribute = this.meshPerAttribute;\n    data.isInstancedBufferAttribute = true;\n    return data;\n  }\n}\nconst _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\nconst _instanceIntersects = [];\nconst _box3 = /*@__PURE__*/new Box3();\nconst _identity = /*@__PURE__*/new Matrix4();\nconst _mesh$1 = /*@__PURE__*/new Mesh();\nconst _sphere$4 = /*@__PURE__*/new Sphere();\nclass InstancedMesh extends Mesh {\n  constructor(geometry, material, count) {\n    super(geometry, material);\n    this.isInstancedMesh = true;\n    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);\n    this.instanceColor = null;\n    this.morphTexture = null;\n    this.count = count;\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    for (let i = 0; i < count; i++) {\n      this.setMatrixAt(i, _identity);\n    }\n  }\n  computeBoundingBox() {\n    const geometry = this.geometry;\n    const count = this.count;\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    this.boundingBox.makeEmpty();\n    for (let i = 0; i < count; i++) {\n      this.getMatrixAt(i, _instanceLocalMatrix);\n      _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);\n      this.boundingBox.union(_box3);\n    }\n  }\n  computeBoundingSphere() {\n    const geometry = this.geometry;\n    const count = this.count;\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    this.boundingSphere.makeEmpty();\n    for (let i = 0; i < count; i++) {\n      this.getMatrixAt(i, _instanceLocalMatrix);\n      _sphere$4.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);\n      this.boundingSphere.union(_sphere$4);\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.instanceMatrix.copy(source.instanceMatrix);\n    if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();\n    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n    this.count = source.count;\n    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();\n    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();\n    return this;\n  }\n  getColorAt(index, color) {\n    color.fromArray(this.instanceColor.array, index * 3);\n  }\n  getMatrixAt(index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  }\n  getMorphAt(index, object) {\n    const objectInfluences = object.morphTargetInfluences;\n    const array = this.morphTexture.source.data.data;\n    const len = objectInfluences.length + 1; // All influences + the baseInfluenceSum\n\n    const dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning\n\n    for (let i = 0; i < objectInfluences.length; i++) {\n      objectInfluences[i] = array[dataIndex + i];\n    }\n  }\n  raycast(raycaster, intersects) {\n    const matrixWorld = this.matrixWorld;\n    const raycastTimes = this.count;\n    _mesh$1.geometry = this.geometry;\n    _mesh$1.material = this.material;\n    if (_mesh$1.material === undefined) return;\n\n    // test with bounding sphere first\n\n    if (this.boundingSphere === null) this.computeBoundingSphere();\n    _sphere$4.copy(this.boundingSphere);\n    _sphere$4.applyMatrix4(matrixWorld);\n    if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;\n\n    // now test each instance\n\n    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      // calculate the world matrix for each instance\n\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);\n\n      // the mesh represents this single instance\n\n      _mesh$1.matrixWorld = _instanceWorldMatrix;\n      _mesh$1.raycast(raycaster, _instanceIntersects);\n\n      // process the result of raycast\n\n      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n        const intersect = _instanceIntersects[i];\n        intersect.instanceId = instanceId;\n        intersect.object = this;\n        intersects.push(intersect);\n      }\n      _instanceIntersects.length = 0;\n    }\n  }\n  setColorAt(index, color) {\n    if (this.instanceColor === null) {\n      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);\n    }\n    color.toArray(this.instanceColor.array, index * 3);\n  }\n  setMatrixAt(index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  }\n  setMorphAt(index, object) {\n    const objectInfluences = object.morphTargetInfluences;\n    const len = objectInfluences.length + 1; // morphBaseInfluence + all influences\n\n    if (this.morphTexture === null) {\n      this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);\n    }\n    const array = this.morphTexture.source.data.data;\n    let morphInfluencesSum = 0;\n    for (let i = 0; i < objectInfluences.length; i++) {\n      morphInfluencesSum += objectInfluences[i];\n    }\n    const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n    const dataIndex = len * index;\n    array[dataIndex] = morphBaseInfluence;\n    array.set(objectInfluences, dataIndex + 1);\n  }\n  updateMorphTargets() {}\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n    if (this.morphTexture !== null) {\n      this.morphTexture.dispose();\n      this.morphTexture = null;\n    }\n    return this;\n  }\n}\nconst _vector1 = /*@__PURE__*/new Vector3();\nconst _vector2 = /*@__PURE__*/new Vector3();\nconst _normalMatrix = /*@__PURE__*/new Matrix3();\nclass Plane {\n  constructor(normal = new Vector3(1, 0, 0), constant = 0) {\n    this.isPlane = true;\n\n    // normal is assumed to be normalized\n\n    this.normal = normal;\n    this.constant = constant;\n  }\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  }\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  }\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  }\n  setFromCoplanarPoints(a, b, c) {\n    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();\n\n    // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  }\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  }\n  normalize() {\n    // Note: will lead to a divide by zero if the plane is invalid.\n\n    const inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  }\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n  projectPoint(point, target) {\n    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));\n  }\n  intersectLine(line, target) {\n    const direction = line.delta(_vector1);\n    const denominator = this.normal.dot(direction);\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      }\n\n      // Unsure if this is the correct method to handle this case.\n      return null;\n    }\n    const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n    if (t < 0 || t > 1) {\n      return null;\n    }\n    return target.copy(line.start).addScaledVector(direction, t);\n  }\n  intersectsLine(line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  }\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n  coplanarPoint(target) {\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  }\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  }\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _sphere$3 = /*@__PURE__*/new Sphere();\nconst _vector$6 = /*@__PURE__*/new Vector3();\nclass Frustum {\n  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n  set(p0, p1, p2, p3, p4, p5) {\n    const planes = this.planes;\n    planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n    return this;\n  }\n  copy(frustum) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; i++) {\n      planes[i].copy(frustum.planes[i]);\n    }\n    return this;\n  }\n  setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {\n    const planes = this.planes;\n    const me = m.elements;\n    const me0 = me[0],\n      me1 = me[1],\n      me2 = me[2],\n      me3 = me[3];\n    const me4 = me[4],\n      me5 = me[5],\n      me6 = me[6],\n      me7 = me[7];\n    const me8 = me[8],\n      me9 = me[9],\n      me10 = me[10],\n      me11 = me[11];\n    const me12 = me[12],\n      me13 = me[13],\n      me14 = me[14],\n      me15 = me[15];\n    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n    if (coordinateSystem === WebGLCoordinateSystem) {\n      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n    } else if (coordinateSystem === WebGPUCoordinateSystem) {\n      planes[5].setComponents(me2, me6, me10, me14).normalize();\n    } else {\n      throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem);\n    }\n    return this;\n  }\n  intersectsObject(object) {\n    if (object.boundingSphere !== undefined) {\n      if (object.boundingSphere === null) object.computeBoundingSphere();\n      _sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);\n    } else {\n      const geometry = object.geometry;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      _sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n    }\n    return this.intersectsSphere(_sphere$3);\n  }\n  intersectsSprite(sprite) {\n    _sphere$3.center.set(0, 0, 0);\n    _sphere$3.radius = 0.7071067811865476;\n    _sphere$3.applyMatrix4(sprite.matrixWorld);\n    return this.intersectsSphere(_sphere$3);\n  }\n  intersectsSphere(sphere) {\n    const planes = this.planes;\n    const center = sphere.center;\n    const negRadius = -sphere.radius;\n    for (let i = 0; i < 6; i++) {\n      const distance = planes[i].distanceToPoint(center);\n      if (distance < negRadius) {\n        return false;\n      }\n    }\n    return true;\n  }\n  intersectsBox(box) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; i++) {\n      const plane = planes[i];\n\n      // corner at max distance\n\n      _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n      _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n      _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n      if (plane.distanceToPoint(_vector$6) < 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  containsPoint(point) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; i++) {\n      if (planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nfunction ascIdSort(a, b) {\n  return a - b;\n}\nfunction sortOpaque(a, b) {\n  return a.z - b.z;\n}\nfunction sortTransparent(a, b) {\n  return b.z - a.z;\n}\nclass MultiDrawRenderList {\n  constructor() {\n    this.index = 0;\n    this.pool = [];\n    this.list = [];\n  }\n  push(start, count, z, index) {\n    const pool = this.pool;\n    const list = this.list;\n    if (this.index >= pool.length) {\n      pool.push({\n        start: -1,\n        count: -1,\n        z: -1,\n        index: -1\n      });\n    }\n    const item = pool[this.index];\n    list.push(item);\n    this.index++;\n    item.start = start;\n    item.count = count;\n    item.z = z;\n    item.index = index;\n  }\n  reset() {\n    this.list.length = 0;\n    this.index = 0;\n  }\n}\nconst _matrix$1 = /*@__PURE__*/new Matrix4();\nconst _whiteColor = /*@__PURE__*/new Color(1, 1, 1);\nconst _frustum = /*@__PURE__*/new Frustum();\nconst _box$1 = /*@__PURE__*/new Box3();\nconst _sphere$2 = /*@__PURE__*/new Sphere();\nconst _vector$5 = /*@__PURE__*/new Vector3();\nconst _forward = /*@__PURE__*/new Vector3();\nconst _temp = /*@__PURE__*/new Vector3();\nconst _renderList = /*@__PURE__*/new MultiDrawRenderList();\nconst _mesh = /*@__PURE__*/new Mesh();\nconst _batchIntersects = [];\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData(src, target, targetOffset = 0) {\n  const itemSize = target.itemSize;\n  if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {\n    // use the component getters and setters if the array data cannot\n    // be copied directly\n    const vertexCount = src.count;\n    for (let i = 0; i < vertexCount; i++) {\n      for (let c = 0; c < itemSize; c++) {\n        target.setComponent(i + targetOffset, c, src.getComponent(i, c));\n      }\n    }\n  } else {\n    // faster copy approach using typed array set function\n    target.array.set(src.array, targetOffset * itemSize);\n  }\n  target.needsUpdate = true;\n}\n\n// safely copies array contents to a potentially smaller array\nfunction copyArrayContents(src, target) {\n  if (src.constructor !== target.constructor) {\n    // if arrays are of a different type (eg due to index size increasing) then data must be per-element copied\n    const len = Math.min(src.length, target.length);\n    for (let i = 0; i < len; i++) {\n      target[i] = src[i];\n    }\n  } else {\n    // if the arrays use the same data layout we can use a fast block copy\n    const len = Math.min(src.length, target.length);\n    target.set(new src.constructor(src.buffer, 0, len));\n  }\n}\nclass BatchedMesh extends Mesh {\n  get maxInstanceCount() {\n    return this._maxInstanceCount;\n  }\n  get instanceCount() {\n    return this._instanceInfo.length - this._availableInstanceIds.length;\n  }\n  get unusedVertexCount() {\n    return this._maxVertexCount - this._nextVertexStart;\n  }\n  get unusedIndexCount() {\n    return this._maxIndexCount - this._nextIndexStart;\n  }\n  constructor(maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {\n    super(new BufferGeometry(), material);\n    this.isBatchedMesh = true;\n    this.perObjectFrustumCulled = true;\n    this.sortObjects = true;\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.customSort = null;\n\n    // stores visible, active, and geometry id per instance and reserved buffer ranges for geometries\n    this._instanceInfo = [];\n    this._geometryInfo = [];\n\n    // instance, geometry ids that have been set as inactive, and are available to be overwritten\n    this._availableInstanceIds = [];\n    this._availableGeometryIds = [];\n\n    // used to track where the next point is that geometry should be inserted\n    this._nextIndexStart = 0;\n    this._nextVertexStart = 0;\n    this._geometryCount = 0;\n\n    // flags\n    this._visibilityChanged = true;\n    this._geometryInitialized = false;\n\n    // cached user options\n    this._maxInstanceCount = maxInstanceCount;\n    this._maxVertexCount = maxVertexCount;\n    this._maxIndexCount = maxIndexCount;\n\n    // buffers for multi draw\n    this._multiDrawCounts = new Int32Array(maxInstanceCount);\n    this._multiDrawStarts = new Int32Array(maxInstanceCount);\n    this._multiDrawCount = 0;\n    this._multiDrawInstances = null;\n\n    // Local matrix per geometry by using data texture\n    this._matricesTexture = null;\n    this._indirectTexture = null;\n    this._colorsTexture = null;\n    this._initMatricesTexture();\n    this._initIndirectTexture();\n  }\n  _initMatricesTexture() {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n    let size = Math.sqrt(this._maxInstanceCount * 4); // 4 pixels needed for 1 matrix\n    size = Math.ceil(size / 4) * 4;\n    size = Math.max(size, 4);\n    const matricesArray = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);\n    this._matricesTexture = matricesTexture;\n  }\n  _initIndirectTexture() {\n    let size = Math.sqrt(this._maxInstanceCount);\n    size = Math.ceil(size);\n    const indirectArray = new Uint32Array(size * size);\n    const indirectTexture = new DataTexture(indirectArray, size, size, RedIntegerFormat, UnsignedIntType);\n    this._indirectTexture = indirectTexture;\n  }\n  _initColorsTexture() {\n    let size = Math.sqrt(this._maxInstanceCount);\n    size = Math.ceil(size);\n\n    // 4 floats per RGBA pixel initialized to white\n    const colorsArray = new Float32Array(size * size * 4).fill(1);\n    const colorsTexture = new DataTexture(colorsArray, size, size, RGBAFormat, FloatType);\n    colorsTexture.colorSpace = ColorManagement.workingColorSpace;\n    this._colorsTexture = colorsTexture;\n  }\n  _initializeGeometry(reference) {\n    const geometry = this.geometry;\n    const maxVertexCount = this._maxVertexCount;\n    const maxIndexCount = this._maxIndexCount;\n    if (this._geometryInitialized === false) {\n      for (const attributeName in reference.attributes) {\n        const srcAttribute = reference.getAttribute(attributeName);\n        const {\n          array,\n          itemSize,\n          normalized\n        } = srcAttribute;\n        const dstArray = new array.constructor(maxVertexCount * itemSize);\n        const dstAttribute = new BufferAttribute(dstArray, itemSize, normalized);\n        geometry.setAttribute(attributeName, dstAttribute);\n      }\n      if (reference.getIndex() !== null) {\n        // Reserve last u16 index for primitive restart.\n        const indexArray = maxVertexCount > 65535 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);\n        geometry.setIndex(new BufferAttribute(indexArray, 1));\n      }\n      this._geometryInitialized = true;\n    }\n  }\n\n  // Make sure the geometry is compatible with the existing combined geometry attributes\n  _validateGeometry(geometry) {\n    // check to ensure the geometries are using consistent attributes and indices\n    const batchGeometry = this.geometry;\n    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {\n      throw new Error('THREE.BatchedMesh: All geometries must consistently have \"index\".');\n    }\n    for (const attributeName in batchGeometry.attributes) {\n      if (!geometry.hasAttribute(attributeName)) {\n        throw new Error(`THREE.BatchedMesh: Added geometry missing \"${attributeName}\". All geometries must have consistent attributes.`);\n      }\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {\n        throw new Error('THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.');\n      }\n    }\n  }\n  validateInstanceId(instanceId) {\n    const instanceInfo = this._instanceInfo;\n    if (instanceId < 0 || instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {\n      throw new Error(`THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.`);\n    }\n  }\n  validateGeometryId(geometryId) {\n    const geometryInfoList = this._geometryInfo;\n    if (geometryId < 0 || geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {\n      throw new Error(`THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.`);\n    }\n  }\n  setCustomSort(func) {\n    this.customSort = func;\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const boundingBox = this.boundingBox;\n    const instanceInfo = this._instanceInfo;\n    boundingBox.makeEmpty();\n    for (let i = 0, l = instanceInfo.length; i < l; i++) {\n      if (instanceInfo[i].active === false) continue;\n      const geometryId = instanceInfo[i].geometryIndex;\n      this.getMatrixAt(i, _matrix$1);\n      this.getBoundingBoxAt(geometryId, _box$1).applyMatrix4(_matrix$1);\n      boundingBox.union(_box$1);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    const boundingSphere = this.boundingSphere;\n    const instanceInfo = this._instanceInfo;\n    boundingSphere.makeEmpty();\n    for (let i = 0, l = instanceInfo.length; i < l; i++) {\n      if (instanceInfo[i].active === false) continue;\n      const geometryId = instanceInfo[i].geometryIndex;\n      this.getMatrixAt(i, _matrix$1);\n      this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);\n      boundingSphere.union(_sphere$2);\n    }\n  }\n  addInstance(geometryId) {\n    const atCapacity = this._instanceInfo.length >= this.maxInstanceCount;\n\n    // ensure we're not over geometry\n    if (atCapacity && this._availableInstanceIds.length === 0) {\n      throw new Error('THREE.BatchedMesh: Maximum item count reached.');\n    }\n    const instanceInfo = {\n      visible: true,\n      active: true,\n      geometryIndex: geometryId\n    };\n    let drawId = null;\n\n    // Prioritize using previously freed instance ids\n    if (this._availableInstanceIds.length > 0) {\n      this._availableInstanceIds.sort(ascIdSort);\n      drawId = this._availableInstanceIds.shift();\n      this._instanceInfo[drawId] = instanceInfo;\n    } else {\n      drawId = this._instanceInfo.length;\n      this._instanceInfo.push(instanceInfo);\n    }\n    const matricesTexture = this._matricesTexture;\n    _matrix$1.identity().toArray(matricesTexture.image.data, drawId * 16);\n    matricesTexture.needsUpdate = true;\n    const colorsTexture = this._colorsTexture;\n    if (colorsTexture) {\n      _whiteColor.toArray(colorsTexture.image.data, drawId * 4);\n      colorsTexture.needsUpdate = true;\n    }\n    this._visibilityChanged = true;\n    return drawId;\n  }\n  addGeometry(geometry, reservedVertexCount = -1, reservedIndexCount = -1) {\n    this._initializeGeometry(geometry);\n    this._validateGeometry(geometry);\n    const geometryInfo = {\n      // geometry information\n      vertexStart: -1,\n      vertexCount: -1,\n      reservedVertexCount: -1,\n      indexStart: -1,\n      indexCount: -1,\n      reservedIndexCount: -1,\n      // draw range information\n      start: -1,\n      count: -1,\n      // state\n      boundingBox: null,\n      boundingSphere: null,\n      active: true\n    };\n    const geometryInfoList = this._geometryInfo;\n    geometryInfo.vertexStart = this._nextVertexStart;\n    geometryInfo.reservedVertexCount = reservedVertexCount === -1 ? geometry.getAttribute('position').count : reservedVertexCount;\n    const index = geometry.getIndex();\n    const hasIndex = index !== null;\n    if (hasIndex) {\n      geometryInfo.indexStart = this._nextIndexStart;\n      geometryInfo.reservedIndexCount = reservedIndexCount === -1 ? index.count : reservedIndexCount;\n    }\n    if (geometryInfo.indexStart !== -1 && geometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount || geometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount) {\n      throw new Error('THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.');\n    }\n\n    // update id\n    let geometryId;\n    if (this._availableGeometryIds.length > 0) {\n      this._availableGeometryIds.sort(ascIdSort);\n      geometryId = this._availableGeometryIds.shift();\n      geometryInfoList[geometryId] = geometryInfo;\n    } else {\n      geometryId = this._geometryCount;\n      this._geometryCount++;\n      geometryInfoList.push(geometryInfo);\n    }\n\n    // update the geometry\n    this.setGeometryAt(geometryId, geometry);\n\n    // increment the next geometry position\n    this._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;\n    this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n    return geometryId;\n  }\n  setGeometryAt(geometryId, geometry) {\n    if (geometryId >= this._geometryCount) {\n      throw new Error('THREE.BatchedMesh: Maximum geometry count reached.');\n    }\n    this._validateGeometry(geometry);\n    const batchGeometry = this.geometry;\n    const hasIndex = batchGeometry.getIndex() !== null;\n    const dstIndex = batchGeometry.getIndex();\n    const srcIndex = geometry.getIndex();\n    const geometryInfo = this._geometryInfo[geometryId];\n    if (hasIndex && srcIndex.count > geometryInfo.reservedIndexCount || geometry.attributes.position.count > geometryInfo.reservedVertexCount) {\n      throw new Error('THREE.BatchedMesh: Reserved space not large enough for provided geometry.');\n    }\n\n    // copy geometry buffer data over\n    const vertexStart = geometryInfo.vertexStart;\n    const reservedVertexCount = geometryInfo.reservedVertexCount;\n    geometryInfo.vertexCount = geometry.getAttribute('position').count;\n    for (const attributeName in batchGeometry.attributes) {\n      // copy attribute data\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      copyAttributeData(srcAttribute, dstAttribute, vertexStart);\n\n      // fill the rest in with zeroes\n      const itemSize = srcAttribute.itemSize;\n      for (let i = srcAttribute.count, l = reservedVertexCount; i < l; i++) {\n        const index = vertexStart + i;\n        for (let c = 0; c < itemSize; c++) {\n          dstAttribute.setComponent(index, c, 0);\n        }\n      }\n      dstAttribute.needsUpdate = true;\n      dstAttribute.addUpdateRange(vertexStart * itemSize, reservedVertexCount * itemSize);\n    }\n\n    // copy index\n    if (hasIndex) {\n      const indexStart = geometryInfo.indexStart;\n      const reservedIndexCount = geometryInfo.reservedIndexCount;\n      geometryInfo.indexCount = geometry.getIndex().count;\n\n      // copy index data over\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));\n      }\n\n      // fill the rest in with zeroes\n      for (let i = srcIndex.count, l = reservedIndexCount; i < l; i++) {\n        dstIndex.setX(indexStart + i, vertexStart);\n      }\n      dstIndex.needsUpdate = true;\n      dstIndex.addUpdateRange(indexStart, geometryInfo.reservedIndexCount);\n    }\n\n    // update the draw range\n    geometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;\n    geometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;\n\n    // store the bounding boxes\n    geometryInfo.boundingBox = null;\n    if (geometry.boundingBox !== null) {\n      geometryInfo.boundingBox = geometry.boundingBox.clone();\n    }\n    geometryInfo.boundingSphere = null;\n    if (geometry.boundingSphere !== null) {\n      geometryInfo.boundingSphere = geometry.boundingSphere.clone();\n    }\n    this._visibilityChanged = true;\n    return geometryId;\n  }\n  deleteGeometry(geometryId) {\n    const geometryInfoList = this._geometryInfo;\n    if (geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {\n      return this;\n    }\n\n    // delete any instances associated with this geometry\n    const instanceInfo = this._instanceInfo;\n    for (let i = 0, l = instanceInfo.length; i < l; i++) {\n      if (instanceInfo[i].geometryIndex === geometryId) {\n        this.deleteInstance(i);\n      }\n    }\n    geometryInfoList[geometryId].active = false;\n    this._availableGeometryIds.push(geometryId);\n    this._visibilityChanged = true;\n    return this;\n  }\n  deleteInstance(instanceId) {\n    this.validateInstanceId(instanceId);\n    this._instanceInfo[instanceId].active = false;\n    this._availableInstanceIds.push(instanceId);\n    this._visibilityChanged = true;\n    return this;\n  }\n  optimize() {\n    // track the next indices to copy data to\n    let nextVertexStart = 0;\n    let nextIndexStart = 0;\n\n    // Iterate over all geometry ranges in order sorted from earliest in the geometry buffer to latest\n    // in the geometry buffer. Because draw range objects can be reused there is no guarantee of their order.\n    const geometryInfoList = this._geometryInfo;\n    const indices = geometryInfoList.map((e, i) => i).sort((a, b) => {\n      return geometryInfoList[a].vertexStart - geometryInfoList[b].vertexStart;\n    });\n    const geometry = this.geometry;\n    for (let i = 0, l = geometryInfoList.length; i < l; i++) {\n      // if a geometry range is inactive then don't copy anything\n      const index = indices[i];\n      const geometryInfo = geometryInfoList[index];\n      if (geometryInfo.active === false) {\n        continue;\n      }\n\n      // if a geometry contains an index buffer then shift it, as well\n      if (geometry.index !== null) {\n        if (geometryInfo.indexStart !== nextIndexStart) {\n          const {\n            indexStart,\n            vertexStart,\n            reservedIndexCount\n          } = geometryInfo;\n          const index = geometry.index;\n          const array = index.array;\n\n          // shift the index pointers based on how the vertex data will shift\n          // adjusting the index must happen first so the original vertex start value is available\n          const elementDelta = nextVertexStart - vertexStart;\n          for (let j = indexStart; j < indexStart + reservedIndexCount; j++) {\n            array[j] = array[j] + elementDelta;\n          }\n          index.array.copyWithin(nextIndexStart, indexStart, indexStart + reservedIndexCount);\n          index.addUpdateRange(nextIndexStart, reservedIndexCount);\n          geometryInfo.indexStart = nextIndexStart;\n        }\n        nextIndexStart += geometryInfo.reservedIndexCount;\n      }\n\n      // if a geometry needs to be moved then copy attribute data to overwrite unused space\n      if (geometryInfo.vertexStart !== nextVertexStart) {\n        const {\n          vertexStart,\n          reservedVertexCount\n        } = geometryInfo;\n        const attributes = geometry.attributes;\n        for (const key in attributes) {\n          const attribute = attributes[key];\n          const {\n            array,\n            itemSize\n          } = attribute;\n          array.copyWithin(nextVertexStart * itemSize, vertexStart * itemSize, (vertexStart + reservedVertexCount) * itemSize);\n          attribute.addUpdateRange(nextVertexStart * itemSize, reservedVertexCount * itemSize);\n        }\n        geometryInfo.vertexStart = nextVertexStart;\n      }\n      nextVertexStart += geometryInfo.reservedVertexCount;\n      geometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;\n\n      // step the next geometry points to the shifted position\n      this._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;\n      this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n    }\n    return this;\n  }\n\n  // get bounding box and compute it if it doesn't exist\n  getBoundingBoxAt(geometryId, target) {\n    if (geometryId >= this._geometryCount) {\n      return null;\n    }\n\n    // compute bounding box\n    const geometry = this.geometry;\n    const geometryInfo = this._geometryInfo[geometryId];\n    if (geometryInfo.boundingBox === null) {\n      const box = new Box3();\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      for (let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i++) {\n        let iv = i;\n        if (index) {\n          iv = index.getX(iv);\n        }\n        box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));\n      }\n      geometryInfo.boundingBox = box;\n    }\n    target.copy(geometryInfo.boundingBox);\n    return target;\n  }\n\n  // get bounding sphere and compute it if it doesn't exist\n  getBoundingSphereAt(geometryId, target) {\n    if (geometryId >= this._geometryCount) {\n      return null;\n    }\n\n    // compute bounding sphere\n    const geometry = this.geometry;\n    const geometryInfo = this._geometryInfo[geometryId];\n    if (geometryInfo.boundingSphere === null) {\n      const sphere = new Sphere();\n      this.getBoundingBoxAt(geometryId, _box$1);\n      _box$1.getCenter(sphere.center);\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      let maxRadiusSq = 0;\n      for (let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i++) {\n        let iv = i;\n        if (index) {\n          iv = index.getX(iv);\n        }\n        _vector$5.fromBufferAttribute(position, iv);\n        maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5));\n      }\n      sphere.radius = Math.sqrt(maxRadiusSq);\n      geometryInfo.boundingSphere = sphere;\n    }\n    target.copy(geometryInfo.boundingSphere);\n    return target;\n  }\n  setMatrixAt(instanceId, matrix) {\n    this.validateInstanceId(instanceId);\n    const matricesTexture = this._matricesTexture;\n    const matricesArray = this._matricesTexture.image.data;\n    matrix.toArray(matricesArray, instanceId * 16);\n    matricesTexture.needsUpdate = true;\n    return this;\n  }\n  getMatrixAt(instanceId, matrix) {\n    this.validateInstanceId(instanceId);\n    return matrix.fromArray(this._matricesTexture.image.data, instanceId * 16);\n  }\n  setColorAt(instanceId, color) {\n    this.validateInstanceId(instanceId);\n    if (this._colorsTexture === null) {\n      this._initColorsTexture();\n    }\n    color.toArray(this._colorsTexture.image.data, instanceId * 4);\n    this._colorsTexture.needsUpdate = true;\n    return this;\n  }\n  getColorAt(instanceId, color) {\n    this.validateInstanceId(instanceId);\n    return color.fromArray(this._colorsTexture.image.data, instanceId * 4);\n  }\n  setVisibleAt(instanceId, value) {\n    this.validateInstanceId(instanceId);\n    if (this._instanceInfo[instanceId].visible === value) {\n      return this;\n    }\n    this._instanceInfo[instanceId].visible = value;\n    this._visibilityChanged = true;\n    return this;\n  }\n  getVisibleAt(instanceId) {\n    this.validateInstanceId(instanceId);\n    return this._instanceInfo[instanceId].visible;\n  }\n  setGeometryIdAt(instanceId, geometryId) {\n    this.validateInstanceId(instanceId);\n    this.validateGeometryId(geometryId);\n    this._instanceInfo[instanceId].geometryIndex = geometryId;\n    return this;\n  }\n  getGeometryIdAt(instanceId) {\n    this.validateInstanceId(instanceId);\n    return this._instanceInfo[instanceId].geometryIndex;\n  }\n  getGeometryRangeAt(geometryId, target = {}) {\n    this.validateGeometryId(geometryId);\n    const geometryInfo = this._geometryInfo[geometryId];\n    target.vertexStart = geometryInfo.vertexStart;\n    target.vertexCount = geometryInfo.vertexCount;\n    target.reservedVertexCount = geometryInfo.reservedVertexCount;\n    target.indexStart = geometryInfo.indexStart;\n    target.indexCount = geometryInfo.indexCount;\n    target.reservedIndexCount = geometryInfo.reservedIndexCount;\n    target.start = geometryInfo.start;\n    target.count = geometryInfo.count;\n    return target;\n  }\n  setInstanceCount(maxInstanceCount) {\n    // shrink the available instances as much as possible\n    const availableInstanceIds = this._availableInstanceIds;\n    const instanceInfo = this._instanceInfo;\n    availableInstanceIds.sort(ascIdSort);\n    while (availableInstanceIds[availableInstanceIds.length - 1] === instanceInfo.length) {\n      instanceInfo.pop();\n      availableInstanceIds.pop();\n    }\n\n    // throw an error if it can't be shrunk to the desired size\n    if (maxInstanceCount < instanceInfo.length) {\n      throw new Error(`BatchedMesh: Instance ids outside the range ${maxInstanceCount} are being used. Cannot shrink instance count.`);\n    }\n\n    // copy the multi draw counts\n    const multiDrawCounts = new Int32Array(maxInstanceCount);\n    const multiDrawStarts = new Int32Array(maxInstanceCount);\n    copyArrayContents(this._multiDrawCounts, multiDrawCounts);\n    copyArrayContents(this._multiDrawStarts, multiDrawStarts);\n    this._multiDrawCounts = multiDrawCounts;\n    this._multiDrawStarts = multiDrawStarts;\n    this._maxInstanceCount = maxInstanceCount;\n\n    // update texture data for instance sampling\n    const indirectTexture = this._indirectTexture;\n    const matricesTexture = this._matricesTexture;\n    const colorsTexture = this._colorsTexture;\n    indirectTexture.dispose();\n    this._initIndirectTexture();\n    copyArrayContents(indirectTexture.image.data, this._indirectTexture.image.data);\n    matricesTexture.dispose();\n    this._initMatricesTexture();\n    copyArrayContents(matricesTexture.image.data, this._matricesTexture.image.data);\n    if (colorsTexture) {\n      colorsTexture.dispose();\n      this._initColorsTexture();\n      copyArrayContents(colorsTexture.image.data, this._colorsTexture.image.data);\n    }\n  }\n  setGeometrySize(maxVertexCount, maxIndexCount) {\n    // Check if we can shrink to the requested vertex attribute size\n    const validRanges = [...this._geometryInfo].filter(info => info.active);\n    const requiredVertexLength = Math.max(...validRanges.map(range => range.vertexStart + range.reservedVertexCount));\n    if (requiredVertexLength > maxVertexCount) {\n      throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);\n    }\n\n    // Check if we can shrink to the requested index attribute size\n    if (this.geometry.index) {\n      const requiredIndexLength = Math.max(...validRanges.map(range => range.indexStart + range.reservedIndexCount));\n      if (requiredIndexLength > maxIndexCount) {\n        throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);\n      }\n    }\n\n    //\n\n    // dispose of the previous geometry\n    const oldGeometry = this.geometry;\n    oldGeometry.dispose();\n\n    // recreate the geometry needed based on the previous variant\n    this._maxVertexCount = maxVertexCount;\n    this._maxIndexCount = maxIndexCount;\n    if (this._geometryInitialized) {\n      this._geometryInitialized = false;\n      this.geometry = new BufferGeometry();\n      this._initializeGeometry(oldGeometry);\n    }\n\n    // copy data from the previous geometry\n    const geometry = this.geometry;\n    if (oldGeometry.index) {\n      copyArrayContents(oldGeometry.index.array, geometry.index.array);\n    }\n    for (const key in oldGeometry.attributes) {\n      copyArrayContents(oldGeometry.attributes[key].array, geometry.attributes[key].array);\n    }\n  }\n  raycast(raycaster, intersects) {\n    const instanceInfo = this._instanceInfo;\n    const geometryInfoList = this._geometryInfo;\n    const matrixWorld = this.matrixWorld;\n    const batchGeometry = this.geometry;\n\n    // iterate over each geometry\n    _mesh.material = this.material;\n    _mesh.geometry.index = batchGeometry.index;\n    _mesh.geometry.attributes = batchGeometry.attributes;\n    if (_mesh.geometry.boundingBox === null) {\n      _mesh.geometry.boundingBox = new Box3();\n    }\n    if (_mesh.geometry.boundingSphere === null) {\n      _mesh.geometry.boundingSphere = new Sphere();\n    }\n    for (let i = 0, l = instanceInfo.length; i < l; i++) {\n      if (!instanceInfo[i].visible || !instanceInfo[i].active) {\n        continue;\n      }\n      const geometryId = instanceInfo[i].geometryIndex;\n      const geometryInfo = geometryInfoList[geometryId];\n      _mesh.geometry.setDrawRange(geometryInfo.start, geometryInfo.count);\n\n      // get the intersects\n      this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);\n      this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);\n      this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);\n      _mesh.raycast(raycaster, _batchIntersects);\n\n      // add batch id to the intersects\n      for (let j = 0, l = _batchIntersects.length; j < l; j++) {\n        const intersect = _batchIntersects[j];\n        intersect.object = this;\n        intersect.batchId = i;\n        intersects.push(intersect);\n      }\n      _batchIntersects.length = 0;\n    }\n    _mesh.material = null;\n    _mesh.geometry.index = null;\n    _mesh.geometry.attributes = {};\n    _mesh.geometry.setDrawRange(0, Infinity);\n  }\n  copy(source) {\n    super.copy(source);\n    this.geometry = source.geometry.clone();\n    this.perObjectFrustumCulled = source.perObjectFrustumCulled;\n    this.sortObjects = source.sortObjects;\n    this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;\n    this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;\n    this._geometryInfo = source._geometryInfo.map(info => ({\n      ...info,\n      boundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,\n      boundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null\n    }));\n    this._instanceInfo = source._instanceInfo.map(info => ({\n      ...info\n    }));\n    this._maxInstanceCount = source._maxInstanceCount;\n    this._maxVertexCount = source._maxVertexCount;\n    this._maxIndexCount = source._maxIndexCount;\n    this._geometryInitialized = source._geometryInitialized;\n    this._geometryCount = source._geometryCount;\n    this._multiDrawCounts = source._multiDrawCounts.slice();\n    this._multiDrawStarts = source._multiDrawStarts.slice();\n    this._matricesTexture = source._matricesTexture.clone();\n    this._matricesTexture.image.data = this._matricesTexture.image.data.slice();\n    if (this._colorsTexture !== null) {\n      this._colorsTexture = source._colorsTexture.clone();\n      this._colorsTexture.image.data = this._colorsTexture.image.data.slice();\n    }\n    return this;\n  }\n  dispose() {\n    // Assuming the geometry is not shared with other meshes\n    this.geometry.dispose();\n    this._matricesTexture.dispose();\n    this._matricesTexture = null;\n    this._indirectTexture.dispose();\n    this._indirectTexture = null;\n    if (this._colorsTexture !== null) {\n      this._colorsTexture.dispose();\n      this._colorsTexture = null;\n    }\n    return this;\n  }\n  onBeforeRender(renderer, scene, camera, geometry, material /*, _group*/) {\n    // if visibility has not changed and frustum culling and object sorting is not required\n    // then skip iterating over all items\n    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) {\n      return;\n    }\n\n    // the indexed version of the multi draw function requires specifying the start\n    // offset in bytes.\n    const index = geometry.getIndex();\n    const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;\n    const instanceInfo = this._instanceInfo;\n    const multiDrawStarts = this._multiDrawStarts;\n    const multiDrawCounts = this._multiDrawCounts;\n    const geometryInfoList = this._geometryInfo;\n    const perObjectFrustumCulled = this.perObjectFrustumCulled;\n    const indirectTexture = this._indirectTexture;\n    const indirectArray = indirectTexture.image.data;\n\n    // prepare the frustum in the local frame\n    if (perObjectFrustumCulled) {\n      _matrix$1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse).multiply(this.matrixWorld);\n      _frustum.setFromProjectionMatrix(_matrix$1, renderer.coordinateSystem);\n    }\n    let multiDrawCount = 0;\n    if (this.sortObjects) {\n      // get the camera position in the local frame\n      _matrix$1.copy(this.matrixWorld).invert();\n      _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_matrix$1);\n      _forward.set(0, 0, -1).transformDirection(camera.matrixWorld).transformDirection(_matrix$1);\n      for (let i = 0, l = instanceInfo.length; i < l; i++) {\n        if (instanceInfo[i].visible && instanceInfo[i].active) {\n          const geometryId = instanceInfo[i].geometryIndex;\n\n          // get the bounds in world space\n          this.getMatrixAt(i, _matrix$1);\n          this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);\n\n          // determine whether the batched geometry is within the frustum\n          let culled = false;\n          if (perObjectFrustumCulled) {\n            culled = !_frustum.intersectsSphere(_sphere$2);\n          }\n          if (!culled) {\n            // get the distance from camera used for sorting\n            const geometryInfo = geometryInfoList[geometryId];\n            const z = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);\n            _renderList.push(geometryInfo.start, geometryInfo.count, z, i);\n          }\n        }\n      }\n\n      // Sort the draw ranges and prep for rendering\n      const list = _renderList.list;\n      const customSort = this.customSort;\n      if (customSort === null) {\n        list.sort(material.transparent ? sortTransparent : sortOpaque);\n      } else {\n        customSort.call(this, list, camera);\n      }\n      for (let i = 0, l = list.length; i < l; i++) {\n        const item = list[i];\n        multiDrawStarts[multiDrawCount] = item.start * bytesPerElement;\n        multiDrawCounts[multiDrawCount] = item.count;\n        indirectArray[multiDrawCount] = item.index;\n        multiDrawCount++;\n      }\n      _renderList.reset();\n    } else {\n      for (let i = 0, l = instanceInfo.length; i < l; i++) {\n        if (instanceInfo[i].visible && instanceInfo[i].active) {\n          const geometryId = instanceInfo[i].geometryIndex;\n\n          // determine whether the batched geometry is within the frustum\n          let culled = false;\n          if (perObjectFrustumCulled) {\n            // get the bounds in world space\n            this.getMatrixAt(i, _matrix$1);\n            this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);\n            culled = !_frustum.intersectsSphere(_sphere$2);\n          }\n          if (!culled) {\n            const geometryInfo = geometryInfoList[geometryId];\n            multiDrawStarts[multiDrawCount] = geometryInfo.start * bytesPerElement;\n            multiDrawCounts[multiDrawCount] = geometryInfo.count;\n            indirectArray[multiDrawCount] = i;\n            multiDrawCount++;\n          }\n        }\n      }\n    }\n    indirectTexture.needsUpdate = true;\n    this._multiDrawCount = multiDrawCount;\n    this._visibilityChanged = false;\n  }\n  onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial /* , group */) {\n    this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);\n  }\n}\nclass LineBasicMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isLineBasicMaterial = true;\n    this.type = 'LineBasicMaterial';\n    this.color = new Color(0xffffff);\n    this.map = null;\n    this.linewidth = 1;\n    this.linecap = 'round';\n    this.linejoin = 'round';\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.linewidth = source.linewidth;\n    this.linecap = source.linecap;\n    this.linejoin = source.linejoin;\n    this.fog = source.fog;\n    return this;\n  }\n}\nconst _vStart = /*@__PURE__*/new Vector3();\nconst _vEnd = /*@__PURE__*/new Vector3();\nconst _inverseMatrix$1 = /*@__PURE__*/new Matrix4();\nconst _ray$1 = /*@__PURE__*/new Ray();\nconst _sphere$1 = /*@__PURE__*/new Sphere();\nconst _intersectPointOnRay = /*@__PURE__*/new Vector3();\nconst _intersectPointOnSegment = /*@__PURE__*/new Vector3();\nclass Line extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {\n    super();\n    this.isLine = true;\n    this.type = 'Line';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  computeLineDistances() {\n    const geometry = this.geometry;\n\n    // we assume non-indexed geometry\n\n    if (geometry.index === null) {\n      const positionAttribute = geometry.attributes.position;\n      const lineDistances = [0];\n      for (let i = 1, l = positionAttribute.count; i < l; i++) {\n        _vStart.fromBufferAttribute(positionAttribute, i - 1);\n        _vEnd.fromBufferAttribute(positionAttribute, i);\n        lineDistances[i] = lineDistances[i - 1];\n        lineDistances[i] += _vStart.distanceTo(_vEnd);\n      }\n      geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n    } else {\n      console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n    }\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Line.threshold;\n    const drawRange = geometry.drawRange;\n\n    // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    _sphere$1.copy(geometry.boundingSphere);\n    _sphere$1.applyMatrix4(matrixWorld);\n    _sphere$1.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;\n\n    //\n\n    _inverseMatrix$1.copy(matrixWorld).invert();\n    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const step = this.isLineSegments ? 2 : 1;\n    const index = geometry.index;\n    const attributes = geometry.attributes;\n    const positionAttribute = attributes.position;\n    if (index !== null) {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (let i = start, l = end - 1; i < l; i += step) {\n        const a = index.getX(i);\n        const b = index.getX(i + 1);\n        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);\n        if (intersect) {\n          intersects.push(intersect);\n        }\n      }\n      if (this.isLineLoop) {\n        const a = index.getX(end - 1);\n        const b = index.getX(start);\n        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);\n        if (intersect) {\n          intersects.push(intersect);\n        }\n      }\n    } else {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (let i = start, l = end - 1; i < l; i += step) {\n        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i, i + 1);\n        if (intersect) {\n          intersects.push(intersect);\n        }\n      }\n      if (this.isLineLoop) {\n        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start);\n        if (intersect) {\n          intersects.push(intersect);\n        }\n      }\n    }\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== undefined) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || String(m);\n          this.morphTargetInfluences.push(0);\n          this.morphTargetDictionary[name] = m;\n        }\n      }\n    }\n  }\n}\nfunction checkIntersection(object, raycaster, ray, thresholdSq, a, b) {\n  const positionAttribute = object.geometry.attributes.position;\n  _vStart.fromBufferAttribute(positionAttribute, a);\n  _vEnd.fromBufferAttribute(positionAttribute, b);\n  const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);\n  if (distSq > thresholdSq) return;\n  _intersectPointOnRay.applyMatrix4(object.matrixWorld); // Move back to world space for distance calculation\n\n  const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);\n  if (distance < raycaster.near || distance > raycaster.far) return;\n  return {\n    distance: distance,\n    // What do we want? intersection point on the ray or on the segment??\n    // point: raycaster.ray.at( distance ),\n    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),\n    index: a,\n    face: null,\n    faceIndex: null,\n    barycoord: null,\n    object: object\n  };\n}\nconst _start = /*@__PURE__*/new Vector3();\nconst _end = /*@__PURE__*/new Vector3();\nclass LineSegments extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isLineSegments = true;\n    this.type = 'LineSegments';\n  }\n  computeLineDistances() {\n    const geometry = this.geometry;\n\n    // we assume non-indexed geometry\n\n    if (geometry.index === null) {\n      const positionAttribute = geometry.attributes.position;\n      const lineDistances = [];\n      for (let i = 0, l = positionAttribute.count; i < l; i += 2) {\n        _start.fromBufferAttribute(positionAttribute, i);\n        _end.fromBufferAttribute(positionAttribute, i + 1);\n        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n        lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n      }\n      geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n    } else {\n      console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n    }\n    return this;\n  }\n}\nclass LineLoop extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isLineLoop = true;\n    this.type = 'LineLoop';\n  }\n}\nclass PointsMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isPointsMaterial = true;\n    this.type = 'PointsMaterial';\n    this.color = new Color(0xffffff);\n    this.map = null;\n    this.alphaMap = null;\n    this.size = 1;\n    this.sizeAttenuation = true;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.size = source.size;\n    this.sizeAttenuation = source.sizeAttenuation;\n    this.fog = source.fog;\n    return this;\n  }\n}\nconst _inverseMatrix = /*@__PURE__*/new Matrix4();\nconst _ray = /*@__PURE__*/new Ray();\nconst _sphere = /*@__PURE__*/new Sphere();\nconst _position$2 = /*@__PURE__*/new Vector3();\nclass Points extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {\n    super();\n    this.isPoints = true;\n    this.type = 'Points';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Points.threshold;\n    const drawRange = geometry.drawRange;\n\n    // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    _sphere.copy(geometry.boundingSphere);\n    _sphere.applyMatrix4(matrixWorld);\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n    //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const index = geometry.index;\n    const attributes = geometry.attributes;\n    const positionAttribute = attributes.position;\n    if (index !== null) {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (let i = start, il = end; i < il; i++) {\n        const a = index.getX(i);\n        _position$2.fromBufferAttribute(positionAttribute, a);\n        testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n      }\n    } else {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (let i = start, l = end; i < l; i++) {\n        _position$2.fromBufferAttribute(positionAttribute, i);\n        testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n      }\n    }\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== undefined) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || String(m);\n          this.morphTargetInfluences.push(0);\n          this.morphTargetDictionary[name] = m;\n        }\n      }\n    }\n  }\n}\nfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n  const rayPointDistanceSq = _ray.distanceSqToPoint(point);\n  if (rayPointDistanceSq < localThresholdSq) {\n    const intersectPoint = new Vector3();\n    _ray.closestPointToPoint(point, intersectPoint);\n    intersectPoint.applyMatrix4(matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index: index,\n      face: null,\n      faceIndex: null,\n      barycoord: null,\n      object: object\n    });\n  }\n}\nclass Group extends Object3D {\n  constructor() {\n    super();\n    this.isGroup = true;\n    this.type = 'Group';\n  }\n}\nclass VideoTexture extends Texture {\n  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.isVideoTexture = true;\n    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n    this.generateMipmaps = false;\n    const scope = this;\n    function updateVideo() {\n      scope.needsUpdate = true;\n      video.requestVideoFrameCallback(updateVideo);\n    }\n    if ('requestVideoFrameCallback' in video) {\n      video.requestVideoFrameCallback(updateVideo);\n    }\n  }\n  clone() {\n    return new this.constructor(this.image).copy(this);\n  }\n  update() {\n    const video = this.image;\n    const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {\n      this.needsUpdate = true;\n    }\n  }\n}\nclass FramebufferTexture extends Texture {\n  constructor(width, height) {\n    super({\n      width,\n      height\n    });\n    this.isFramebufferTexture = true;\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.generateMipmaps = false;\n    this.needsUpdate = true;\n  }\n}\nclass CompressedTexture extends Texture {\n  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n    this.isCompressedTexture = true;\n    this.image = {\n      width: width,\n      height: height\n    };\n    this.mipmaps = mipmaps;\n\n    // no flipping for cube textures\n    // (also flipping doesn't work for compressed textures )\n\n    this.flipY = false;\n\n    // can't generate mipmaps for compressed textures\n    // mips must be embedded in DDS files\n\n    this.generateMipmaps = false;\n  }\n}\nclass CompressedArrayTexture extends CompressedTexture {\n  constructor(mipmaps, width, height, depth, format, type) {\n    super(mipmaps, width, height, format, type);\n    this.isCompressedArrayTexture = true;\n    this.image.depth = depth;\n    this.wrapR = ClampToEdgeWrapping;\n    this.layerUpdates = new Set();\n  }\n  addLayerUpdate(layerIndex) {\n    this.layerUpdates.add(layerIndex);\n  }\n  clearLayerUpdates() {\n    this.layerUpdates.clear();\n  }\n}\nclass CompressedCubeTexture extends CompressedTexture {\n  constructor(images, format, type) {\n    super(undefined, images[0].width, images[0].height, format, type, CubeReflectionMapping);\n    this.isCompressedCubeTexture = true;\n    this.isCubeTexture = true;\n    this.image = images;\n  }\n}\nclass CanvasTexture extends Texture {\n  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.isCanvasTexture = true;\n    this.needsUpdate = true;\n  }\n}\nclass DepthTexture extends Texture {\n  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {\n    if (format !== DepthFormat && format !== DepthStencilFormat) {\n      throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');\n    }\n    if (type === undefined && format === DepthFormat) type = UnsignedIntType;\n    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.isDepthTexture = true;\n    this.image = {\n      width: width,\n      height: height\n    };\n    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n    this.flipY = false;\n    this.generateMipmaps = false;\n    this.compareFunction = null;\n  }\n  copy(source) {\n    super.copy(source);\n    this.compareFunction = source.compareFunction;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    if (this.compareFunction !== null) data.compareFunction = this.compareFunction;\n    return data;\n  }\n}\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n  constructor() {\n    this.type = 'Curve';\n    this.arcLengthDivisions = 200;\n  }\n\n  // Virtual base class method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n\n  getPoint(/* t, optionalTarget */\n  ) {\n    console.warn('THREE.Curve: .getPoint() not implemented.');\n    return null;\n  }\n\n  // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n\n  getPointAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getPoint(t, optionalTarget);\n  }\n\n  // Get sequence of points using getPoint( t )\n\n  getPoints(divisions = 5) {\n    const points = [];\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n    return points;\n  }\n\n  // Get sequence of points using getPointAt( u )\n\n  getSpacedPoints(divisions = 5) {\n    const points = [];\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPointAt(d / divisions));\n    }\n    return points;\n  }\n\n  // Get total curve arc length\n\n  getLength() {\n    const lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  }\n\n  // Get list of cumulative segment lengths\n\n  getLengths(divisions = this.arcLengthDivisions) {\n    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n    this.needsUpdate = false;\n    const cache = [];\n    let current,\n      last = this.getPoint(0);\n    let sum = 0;\n    cache.push(0);\n    for (let p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      cache.push(sum);\n      last = current;\n    }\n    this.cacheArcLengths = cache;\n    return cache; // { sums: cache, sum: sum }; Sum is in the last element.\n  }\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.getLengths();\n  }\n\n  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n  getUtoTmapping(u, distance) {\n    const arcLengths = this.getLengths();\n    let i = 0;\n    const il = arcLengths.length;\n    let targetArcLength; // The targeted u distance value to get\n\n    if (distance) {\n      targetArcLength = distance;\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    }\n\n    // binary search for the index with largest value smaller than target u distance\n\n    let low = 0,\n      high = il - 1,\n      comparison;\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n      comparison = arcLengths[i] - targetArcLength;\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break;\n\n        // DONE\n      }\n    }\n    i = high;\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    }\n\n    // we could get finer grain at lengths, or use simple interpolation between two points\n\n    const lengthBefore = arcLengths[i];\n    const lengthAfter = arcLengths[i + 1];\n    const segmentLength = lengthAfter - lengthBefore;\n\n    // determine where we are between the 'before' and 'after' points\n\n    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\n\n    // add that fractional amount to t\n\n    const t = (i + segmentFraction) / (il - 1);\n    return t;\n  }\n\n  // Returns a unit vector tangent at t\n  // In case any sub curve does not implement its tangent derivation,\n  // 2 points a small delta apart will be used to find its gradient\n  // which seems to give a reasonable approximation\n\n  getTangent(t, optionalTarget) {\n    const delta = 0.0001;\n    let t1 = t - delta;\n    let t2 = t + delta;\n\n    // Capping in case of danger\n\n    if (t1 < 0) t1 = 0;\n    if (t2 > 1) t2 = 1;\n    const pt1 = this.getPoint(t1);\n    const pt2 = this.getPoint(t2);\n    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n    tangent.copy(pt2).sub(pt1).normalize();\n    return tangent;\n  }\n  getTangentAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getTangent(t, optionalTarget);\n  }\n  computeFrenetFrames(segments, closed) {\n    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n    const normal = new Vector3();\n    const tangents = [];\n    const normals = [];\n    const binormals = [];\n    const vec = new Vector3();\n    const mat = new Matrix4();\n\n    // compute the tangent vectors for each segment on the curve\n\n    for (let i = 0; i <= segments; i++) {\n      const u = i / segments;\n      tangents[i] = this.getTangentAt(u, new Vector3());\n    }\n\n    // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the minimum tangent xyz component\n\n    normals[0] = new Vector3();\n    binormals[0] = new Vector3();\n    let min = Number.MAX_VALUE;\n    const tx = Math.abs(tangents[0].x);\n    const ty = Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n    if (tx <= min) {\n      min = tx;\n      normal.set(1, 0, 0);\n    }\n    if (ty <= min) {\n      min = ty;\n      normal.set(0, 1, 0);\n    }\n    if (tz <= min) {\n      normal.set(0, 0, 1);\n    }\n    vec.crossVectors(tangents[0], normal).normalize();\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]);\n\n    // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n    for (let i = 1; i <= segments; i++) {\n      normals[i] = normals[i - 1].clone();\n      binormals[i] = binormals[i - 1].clone();\n      vec.crossVectors(tangents[i - 1], tangents[i]);\n      if (vec.length() > Number.EPSILON) {\n        vec.normalize();\n        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n      binormals[i].crossVectors(tangents[i], normals[i]);\n    }\n\n    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n    if (closed === true) {\n      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));\n      theta /= segments;\n      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n        theta = -theta;\n      }\n      for (let i = 1; i <= segments; i++) {\n        // twist a little...\n        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n        binormals[i].crossVectors(tangents[i], normals[i]);\n      }\n    }\n    return {\n      tangents: tangents,\n      normals: normals,\n      binormals: binormals\n    };\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.arcLengthDivisions = source.arcLengthDivisions;\n    return this;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.6,\n        type: 'Curve',\n        generator: 'Curve.toJSON'\n      }\n    };\n    data.arcLengthDivisions = this.arcLengthDivisions;\n    data.type = this.type;\n    return data;\n  }\n  fromJSON(json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n    return this;\n  }\n}\nclass EllipseCurve extends Curve {\n  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {\n    super();\n    this.isEllipseCurve = true;\n    this.type = 'EllipseCurve';\n    this.aX = aX;\n    this.aY = aY;\n    this.xRadius = xRadius;\n    this.yRadius = yRadius;\n    this.aStartAngle = aStartAngle;\n    this.aEndAngle = aEndAngle;\n    this.aClockwise = aClockwise;\n    this.aRotation = aRotation;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const twoPi = Math.PI * 2;\n    let deltaAngle = this.aEndAngle - this.aStartAngle;\n    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\n\n    // ensures that deltaAngle is 0 .. 2 PI\n    while (deltaAngle < 0) deltaAngle += twoPi;\n    while (deltaAngle > twoPi) deltaAngle -= twoPi;\n    if (deltaAngle < Number.EPSILON) {\n      if (samePoints) {\n        deltaAngle = 0;\n      } else {\n        deltaAngle = twoPi;\n      }\n    }\n    if (this.aClockwise === true && !samePoints) {\n      if (deltaAngle === twoPi) {\n        deltaAngle = -twoPi;\n      } else {\n        deltaAngle = deltaAngle - twoPi;\n      }\n    }\n    const angle = this.aStartAngle + t * deltaAngle;\n    let x = this.aX + this.xRadius * Math.cos(angle);\n    let y = this.aY + this.yRadius * Math.sin(angle);\n    if (this.aRotation !== 0) {\n      const cos = Math.cos(this.aRotation);\n      const sin = Math.sin(this.aRotation);\n      const tx = x - this.aX;\n      const ty = y - this.aY;\n\n      // Rotate the point about the center of the ellipse.\n      x = tx * cos - ty * sin + this.aX;\n      y = tx * sin + ty * cos + this.aY;\n    }\n    return point.set(x, y);\n  }\n  copy(source) {\n    super.copy(source);\n    this.aX = source.aX;\n    this.aY = source.aY;\n    this.xRadius = source.xRadius;\n    this.yRadius = source.yRadius;\n    this.aStartAngle = source.aStartAngle;\n    this.aEndAngle = source.aEndAngle;\n    this.aClockwise = source.aClockwise;\n    this.aRotation = source.aRotation;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.aX = this.aX;\n    data.aY = this.aY;\n    data.xRadius = this.xRadius;\n    data.yRadius = this.yRadius;\n    data.aStartAngle = this.aStartAngle;\n    data.aEndAngle = this.aEndAngle;\n    data.aClockwise = this.aClockwise;\n    data.aRotation = this.aRotation;\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.aX = json.aX;\n    this.aY = json.aY;\n    this.xRadius = json.xRadius;\n    this.yRadius = json.yRadius;\n    this.aStartAngle = json.aStartAngle;\n    this.aEndAngle = json.aEndAngle;\n    this.aClockwise = json.aClockwise;\n    this.aRotation = json.aRotation;\n    return this;\n  }\n}\nclass ArcCurve extends EllipseCurve {\n  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n    this.isArcCurve = true;\n    this.type = 'ArcCurve';\n  }\n}\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n  let c0 = 0,\n    c1 = 0,\n    c2 = 0,\n    c3 = 0;\n\n  /*\n   * Compute coefficients for a cubic polynomial\n   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n   * such that\n   *   p(0) = x0, p(1) = x1\n   *  and\n   *   p'(0) = t0, p'(1) = t1.\n   */\n  function init(x0, x1, t0, t1) {\n    c0 = x0;\n    c1 = t0;\n    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n    c3 = 2 * x0 - 2 * x1 + t0 + t1;\n  }\n  return {\n    initCatmullRom: function (x0, x1, x2, x3, tension) {\n      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n    },\n    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {\n      // compute tangents when parameterized in [t1,t2]\n      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;\n\n      // rescale tangents for parametrization in [0,1]\n      t1 *= dt1;\n      t2 *= dt1;\n      init(x1, x2, t1, t2);\n    },\n    calc: function (t) {\n      const t2 = t * t;\n      const t3 = t2 * t;\n      return c0 + c1 * t + c2 * t2 + c3 * t3;\n    }\n  };\n}\n\n//\n\nconst tmp = /*@__PURE__*/new Vector3();\nconst px = /*@__PURE__*/new CubicPoly();\nconst py = /*@__PURE__*/new CubicPoly();\nconst pz = /*@__PURE__*/new CubicPoly();\nclass CatmullRomCurve3 extends Curve {\n  constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {\n    super();\n    this.isCatmullRomCurve3 = true;\n    this.type = 'CatmullRomCurve3';\n    this.points = points;\n    this.closed = closed;\n    this.curveType = curveType;\n    this.tension = tension;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const points = this.points;\n    const l = points.length;\n    const p = (l - (this.closed ? 0 : 1)) * t;\n    let intPoint = Math.floor(p);\n    let weight = p - intPoint;\n    if (this.closed) {\n      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\n    } else if (weight === 0 && intPoint === l - 1) {\n      intPoint = l - 2;\n      weight = 1;\n    }\n    let p0, p3; // 4 points (p1 & p2 defined below)\n\n    if (this.closed || intPoint > 0) {\n      p0 = points[(intPoint - 1) % l];\n    } else {\n      // extrapolate first point\n      tmp.subVectors(points[0], points[1]).add(points[0]);\n      p0 = tmp;\n    }\n    const p1 = points[intPoint % l];\n    const p2 = points[(intPoint + 1) % l];\n    if (this.closed || intPoint + 2 < l) {\n      p3 = points[(intPoint + 2) % l];\n    } else {\n      // extrapolate last point\n      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\n      p3 = tmp;\n    }\n    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {\n      // init Centripetal / Chordal Catmull-Rom\n      const pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);\n\n      // safety check for repeated points\n      if (dt1 < 1e-4) dt1 = 1.0;\n      if (dt0 < 1e-4) dt0 = dt1;\n      if (dt2 < 1e-4) dt2 = dt1;\n      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n    } else if (this.curveType === 'catmullrom') {\n      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\n      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\n      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\n    }\n    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.points = [];\n    for (let i = 0, l = source.points.length; i < l; i++) {\n      const point = source.points[i];\n      this.points.push(point.clone());\n    }\n    this.closed = source.closed;\n    this.curveType = source.curveType;\n    this.tension = source.tension;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.points = [];\n    for (let i = 0, l = this.points.length; i < l; i++) {\n      const point = this.points[i];\n      data.points.push(point.toArray());\n    }\n    data.closed = this.closed;\n    data.curveType = this.curveType;\n    data.tension = this.tension;\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.points = [];\n    for (let i = 0, l = json.points.length; i < l; i++) {\n      const point = json.points[i];\n      this.points.push(new Vector3().fromArray(point));\n    }\n    this.closed = json.closed;\n    this.curveType = json.curveType;\n    this.tension = json.tension;\n    return this;\n  }\n}\n\n/**\n * Bezier Curves formulas obtained from\n * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n */\n\nfunction CatmullRom(t, p0, p1, p2, p3) {\n  const v0 = (p2 - p0) * 0.5;\n  const v1 = (p3 - p1) * 0.5;\n  const t2 = t * t;\n  const t3 = t * t2;\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\n//\n\nfunction QuadraticBezierP0(t, p) {\n  const k = 1 - t;\n  return k * k * p;\n}\nfunction QuadraticBezierP1(t, p) {\n  return 2 * (1 - t) * t * p;\n}\nfunction QuadraticBezierP2(t, p) {\n  return t * t * p;\n}\nfunction QuadraticBezier(t, p0, p1, p2) {\n  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);\n}\n\n//\n\nfunction CubicBezierP0(t, p) {\n  const k = 1 - t;\n  return k * k * k * p;\n}\nfunction CubicBezierP1(t, p) {\n  const k = 1 - t;\n  return 3 * k * k * t * p;\n}\nfunction CubicBezierP2(t, p) {\n  return 3 * (1 - t) * t * t * p;\n}\nfunction CubicBezierP3(t, p) {\n  return t * t * t * p;\n}\nfunction CubicBezier(t, p0, p1, p2, p3) {\n  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\n}\nclass CubicBezierCurve extends Curve {\n  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {\n    super();\n    this.isCubicBezierCurve = true;\n    this.type = 'CubicBezierCurve';\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const v0 = this.v0,\n      v1 = this.v1,\n      v2 = this.v2,\n      v3 = this.v3;\n    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    this.v3.copy(source.v3);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = this.v3.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    this.v3.fromArray(json.v3);\n    return this;\n  }\n}\nclass CubicBezierCurve3 extends Curve {\n  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {\n    super();\n    this.isCubicBezierCurve3 = true;\n    this.type = 'CubicBezierCurve3';\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const v0 = this.v0,\n      v1 = this.v1,\n      v2 = this.v2,\n      v3 = this.v3;\n    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    this.v3.copy(source.v3);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = this.v3.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    this.v3.fromArray(json.v3);\n    return this;\n  }\n}\nclass LineCurve extends Curve {\n  constructor(v1 = new Vector2(), v2 = new Vector2()) {\n    super();\n    this.isLineCurve = true;\n    this.type = 'LineCurve';\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    if (t === 1) {\n      point.copy(this.v2);\n    } else {\n      point.copy(this.v2).sub(this.v1);\n      point.multiplyScalar(t).add(this.v1);\n    }\n    return point;\n  }\n\n  // Line curve is linear, so we can overwrite default getPointAt\n  getPointAt(u, optionalTarget) {\n    return this.getPoint(u, optionalTarget);\n  }\n  getTangent(t, optionalTarget = new Vector2()) {\n    return optionalTarget.subVectors(this.v2, this.v1).normalize();\n  }\n  getTangentAt(u, optionalTarget) {\n    return this.getTangent(u, optionalTarget);\n  }\n  copy(source) {\n    super.copy(source);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n}\nclass LineCurve3 extends Curve {\n  constructor(v1 = new Vector3(), v2 = new Vector3()) {\n    super();\n    this.isLineCurve3 = true;\n    this.type = 'LineCurve3';\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    if (t === 1) {\n      point.copy(this.v2);\n    } else {\n      point.copy(this.v2).sub(this.v1);\n      point.multiplyScalar(t).add(this.v1);\n    }\n    return point;\n  }\n\n  // Line curve is linear, so we can overwrite default getPointAt\n  getPointAt(u, optionalTarget) {\n    return this.getPoint(u, optionalTarget);\n  }\n  getTangent(t, optionalTarget = new Vector3()) {\n    return optionalTarget.subVectors(this.v2, this.v1).normalize();\n  }\n  getTangentAt(u, optionalTarget) {\n    return this.getTangent(u, optionalTarget);\n  }\n  copy(source) {\n    super.copy(source);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n}\nclass QuadraticBezierCurve extends Curve {\n  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {\n    super();\n    this.isQuadraticBezierCurve = true;\n    this.type = 'QuadraticBezierCurve';\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const v0 = this.v0,\n      v1 = this.v1,\n      v2 = this.v2;\n    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n}\nclass QuadraticBezierCurve3 extends Curve {\n  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {\n    super();\n    this.isQuadraticBezierCurve3 = true;\n    this.type = 'QuadraticBezierCurve3';\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const v0 = this.v0,\n      v1 = this.v1,\n      v2 = this.v2;\n    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n}\nclass SplineCurve extends Curve {\n  constructor(points = []) {\n    super();\n    this.isSplineCurve = true;\n    this.type = 'SplineCurve';\n    this.points = points;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const points = this.points;\n    const p = (points.length - 1) * t;\n    const intPoint = Math.floor(p);\n    const weight = p - intPoint;\n    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n    const p1 = points[intPoint];\n    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.points = [];\n    for (let i = 0, l = source.points.length; i < l; i++) {\n      const point = source.points[i];\n      this.points.push(point.clone());\n    }\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.points = [];\n    for (let i = 0, l = this.points.length; i < l; i++) {\n      const point = this.points[i];\n      data.points.push(point.toArray());\n    }\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.points = [];\n    for (let i = 0, l = json.points.length; i < l; i++) {\n      const point = json.points[i];\n      this.points.push(new Vector2().fromArray(point));\n    }\n    return this;\n  }\n}\nvar Curves = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArcCurve: ArcCurve,\n  CatmullRomCurve3: CatmullRomCurve3,\n  CubicBezierCurve: CubicBezierCurve,\n  CubicBezierCurve3: CubicBezierCurve3,\n  EllipseCurve: EllipseCurve,\n  LineCurve: LineCurve,\n  LineCurve3: LineCurve3,\n  QuadraticBezierCurve: QuadraticBezierCurve,\n  QuadraticBezierCurve3: QuadraticBezierCurve3,\n  SplineCurve: SplineCurve\n});\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n  constructor() {\n    super();\n    this.type = 'CurvePath';\n    this.curves = [];\n    this.autoClose = false; // Automatically closes the path\n  }\n  add(curve) {\n    this.curves.push(curve);\n  }\n  closePath() {\n    // Add a line curve if start and end of lines are not connected\n    const startPoint = this.curves[0].getPoint(0);\n    const endPoint = this.curves[this.curves.length - 1].getPoint(1);\n    if (!startPoint.equals(endPoint)) {\n      const lineType = startPoint.isVector2 === true ? 'LineCurve' : 'LineCurve3';\n      this.curves.push(new Curves[lineType](endPoint, startPoint));\n    }\n    return this;\n  }\n\n  // To get accurate point with reference to\n  // entire path distance at time t,\n  // following has to be done:\n\n  // 1. Length of each sub path have to be known\n  // 2. Locate and identify type of curve\n  // 3. Get t for the curve\n  // 4. Return curve.getPointAt(t')\n\n  getPoint(t, optionalTarget) {\n    const d = t * this.getLength();\n    const curveLengths = this.getCurveLengths();\n    let i = 0;\n\n    // To think about boundaries points.\n\n    while (i < curveLengths.length) {\n      if (curveLengths[i] >= d) {\n        const diff = curveLengths[i] - d;\n        const curve = this.curves[i];\n        const segmentLength = curve.getLength();\n        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n        return curve.getPointAt(u, optionalTarget);\n      }\n      i++;\n    }\n    return null;\n\n    // loop where sum != 0, sum > d , sum+1 <d\n  }\n\n  // We cannot use the default THREE.Curve getPoint() with getLength() because in\n  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n  // getPoint() depends on getLength\n\n  getLength() {\n    const lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n  }\n\n  // cacheLengths must be recalculated.\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.cacheLengths = null;\n    this.getCurveLengths();\n  }\n\n  // Compute lengths and cache them\n  // We cannot overwrite getLengths() because UtoT mapping uses it.\n\n  getCurveLengths() {\n    // We use cache values if curves and cache array are same length\n\n    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n      return this.cacheLengths;\n    }\n\n    // Get length of sub-curve\n    // Push sums into cached array\n\n    const lengths = [];\n    let sums = 0;\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      sums += this.curves[i].getLength();\n      lengths.push(sums);\n    }\n    this.cacheLengths = lengths;\n    return lengths;\n  }\n  getSpacedPoints(divisions = 40) {\n    const points = [];\n    for (let i = 0; i <= divisions; i++) {\n      points.push(this.getPoint(i / divisions));\n    }\n    if (this.autoClose) {\n      points.push(points[0]);\n    }\n    return points;\n  }\n  getPoints(divisions = 12) {\n    const points = [];\n    let last;\n    for (let i = 0, curves = this.curves; i < curves.length; i++) {\n      const curve = curves[i];\n      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;\n      const pts = curve.getPoints(resolution);\n      for (let j = 0; j < pts.length; j++) {\n        const point = pts[j];\n        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n        points.push(point);\n        last = point;\n      }\n    }\n    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n      points.push(points[0]);\n    }\n    return points;\n  }\n  copy(source) {\n    super.copy(source);\n    this.curves = [];\n    for (let i = 0, l = source.curves.length; i < l; i++) {\n      const curve = source.curves[i];\n      this.curves.push(curve.clone());\n    }\n    this.autoClose = source.autoClose;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.autoClose = this.autoClose;\n    data.curves = [];\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      const curve = this.curves[i];\n      data.curves.push(curve.toJSON());\n    }\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.autoClose = json.autoClose;\n    this.curves = [];\n    for (let i = 0, l = json.curves.length; i < l; i++) {\n      const curve = json.curves[i];\n      this.curves.push(new Curves[curve.type]().fromJSON(curve));\n    }\n    return this;\n  }\n}\nclass Path extends CurvePath {\n  constructor(points) {\n    super();\n    this.type = 'Path';\n    this.currentPoint = new Vector2();\n    if (points) {\n      this.setFromPoints(points);\n    }\n  }\n  setFromPoints(points) {\n    this.moveTo(points[0].x, points[0].y);\n    for (let i = 1, l = points.length; i < l; i++) {\n      this.lineTo(points[i].x, points[i].y);\n    }\n    return this;\n  }\n  moveTo(x, y) {\n    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\n    return this;\n  }\n  lineTo(x, y) {\n    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n    this.curves.push(curve);\n    this.currentPoint.set(x, y);\n    return this;\n  }\n  quadraticCurveTo(aCPx, aCPy, aX, aY) {\n    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n    this.curves.push(curve);\n    this.currentPoint.set(aX, aY);\n    return this;\n  }\n  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n    this.curves.push(curve);\n    this.currentPoint.set(aX, aY);\n    return this;\n  }\n  splineThru(pts /*Array of Vector*/) {\n    const npts = [this.currentPoint.clone()].concat(pts);\n    const curve = new SplineCurve(npts);\n    this.curves.push(curve);\n    this.currentPoint.copy(pts[pts.length - 1]);\n    return this;\n  }\n  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    const x0 = this.currentPoint.x;\n    const y0 = this.currentPoint.y;\n    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n    return this;\n  }\n  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n    return this;\n  }\n  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n    const x0 = this.currentPoint.x;\n    const y0 = this.currentPoint.y;\n    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n    return this;\n  }\n  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n    if (this.curves.length > 0) {\n      // if a previous curve is present, attempt to join\n      const firstPoint = curve.getPoint(0);\n      if (!firstPoint.equals(this.currentPoint)) {\n        this.lineTo(firstPoint.x, firstPoint.y);\n      }\n    }\n    this.curves.push(curve);\n    const lastPoint = curve.getPoint(1);\n    this.currentPoint.copy(lastPoint);\n    return this;\n  }\n  copy(source) {\n    super.copy(source);\n    this.currentPoint.copy(source.currentPoint);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.currentPoint = this.currentPoint.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.currentPoint.fromArray(json.currentPoint);\n    return this;\n  }\n}\nclass LatheGeometry extends BufferGeometry {\n  constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {\n    super();\n    this.type = 'LatheGeometry';\n    this.parameters = {\n      points: points,\n      segments: segments,\n      phiStart: phiStart,\n      phiLength: phiLength\n    };\n    segments = Math.floor(segments);\n\n    // clamp phiLength so it's in range of [ 0, 2PI ]\n\n    phiLength = clamp(phiLength, 0, Math.PI * 2);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const uvs = [];\n    const initNormals = [];\n    const normals = [];\n\n    // helper variables\n\n    const inverseSegments = 1.0 / segments;\n    const vertex = new Vector3();\n    const uv = new Vector2();\n    const normal = new Vector3();\n    const curNormal = new Vector3();\n    const prevNormal = new Vector3();\n    let dx = 0;\n    let dy = 0;\n\n    // pre-compute normals for initial \"meridian\"\n\n    for (let j = 0; j <= points.length - 1; j++) {\n      switch (j) {\n        case 0:\n          // special handling for 1st vertex on path\n\n          dx = points[j + 1].x - points[j].x;\n          dy = points[j + 1].y - points[j].y;\n          normal.x = dy * 1.0;\n          normal.y = -dx;\n          normal.z = dy * 0.0;\n          prevNormal.copy(normal);\n          normal.normalize();\n          initNormals.push(normal.x, normal.y, normal.z);\n          break;\n        case points.length - 1:\n          // special handling for last Vertex on path\n\n          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);\n          break;\n        default:\n          // default handling for all vertices in between\n\n          dx = points[j + 1].x - points[j].x;\n          dy = points[j + 1].y - points[j].y;\n          normal.x = dy * 1.0;\n          normal.y = -dx;\n          normal.z = dy * 0.0;\n          curNormal.copy(normal);\n          normal.x += prevNormal.x;\n          normal.y += prevNormal.y;\n          normal.z += prevNormal.z;\n          normal.normalize();\n          initNormals.push(normal.x, normal.y, normal.z);\n          prevNormal.copy(curNormal);\n      }\n    }\n\n    // generate vertices, uvs and normals\n\n    for (let i = 0; i <= segments; i++) {\n      const phi = phiStart + i * inverseSegments * phiLength;\n      const sin = Math.sin(phi);\n      const cos = Math.cos(phi);\n      for (let j = 0; j <= points.length - 1; j++) {\n        // vertex\n\n        vertex.x = points[j].x * sin;\n        vertex.y = points[j].y;\n        vertex.z = points[j].x * cos;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // uv\n\n        uv.x = i / segments;\n        uv.y = j / (points.length - 1);\n        uvs.push(uv.x, uv.y);\n\n        // normal\n\n        const x = initNormals[3 * j + 0] * sin;\n        const y = initNormals[3 * j + 1];\n        const z = initNormals[3 * j + 0] * cos;\n        normals.push(x, y, z);\n      }\n    }\n\n    // indices\n\n    for (let i = 0; i < segments; i++) {\n      for (let j = 0; j < points.length - 1; j++) {\n        const base = j + i * points.length;\n        const a = base;\n        const b = base + points.length;\n        const c = base + points.length + 1;\n        const d = base + 1;\n\n        // faces\n\n        indices.push(a, b, d);\n        indices.push(c, d, b);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);\n  }\n}\nclass CapsuleGeometry extends LatheGeometry {\n  constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {\n    const path = new Path();\n    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);\n    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);\n    super(path.getPoints(capSegments), radialSegments);\n    this.type = 'CapsuleGeometry';\n    this.parameters = {\n      radius: radius,\n      length: length,\n      capSegments: capSegments,\n      radialSegments: radialSegments\n    };\n  }\n  static fromJSON(data) {\n    return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);\n  }\n}\nclass CircleGeometry extends BufferGeometry {\n  constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = 'CircleGeometry';\n    this.parameters = {\n      radius: radius,\n      segments: segments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    segments = Math.max(3, segments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    const vertex = new Vector3();\n    const uv = new Vector2();\n\n    // center point\n\n    vertices.push(0, 0, 0);\n    normals.push(0, 0, 1);\n    uvs.push(0.5, 0.5);\n    for (let s = 0, i = 3; s <= segments; s++, i += 3) {\n      const segment = thetaStart + s / segments * thetaLength;\n\n      // vertex\n\n      vertex.x = radius * Math.cos(segment);\n      vertex.y = radius * Math.sin(segment);\n      vertices.push(vertex.x, vertex.y, vertex.z);\n\n      // normal\n\n      normals.push(0, 0, 1);\n\n      // uvs\n\n      uv.x = (vertices[i] / radius + 1) / 2;\n      uv.y = (vertices[i + 1] / radius + 1) / 2;\n      uvs.push(uv.x, uv.y);\n    }\n\n    // indices\n\n    for (let i = 1; i <= segments; i++) {\n      indices.push(i, i + 1, 0);\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);\n  }\n}\nclass CylinderGeometry extends BufferGeometry {\n  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = 'CylinderGeometry';\n    this.parameters = {\n      radiusTop: radiusTop,\n      radiusBottom: radiusBottom,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    const scope = this;\n    radialSegments = Math.floor(radialSegments);\n    heightSegments = Math.floor(heightSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    let index = 0;\n    const indexArray = [];\n    const halfHeight = height / 2;\n    let groupStart = 0;\n\n    // generate geometry\n\n    generateTorso();\n    if (openEnded === false) {\n      if (radiusTop > 0) generateCap(true);\n      if (radiusBottom > 0) generateCap(false);\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    function generateTorso() {\n      const normal = new Vector3();\n      const vertex = new Vector3();\n      let groupCount = 0;\n\n      // this will be used to calculate the normal\n      const slope = (radiusBottom - radiusTop) / height;\n\n      // generate vertices, normals and uvs\n\n      for (let y = 0; y <= heightSegments; y++) {\n        const indexRow = [];\n        const v = y / heightSegments;\n\n        // calculate the radius of the current row\n\n        const radius = v * (radiusBottom - radiusTop) + radiusTop;\n        for (let x = 0; x <= radialSegments; x++) {\n          const u = x / radialSegments;\n          const theta = u * thetaLength + thetaStart;\n          const sinTheta = Math.sin(theta);\n          const cosTheta = Math.cos(theta);\n\n          // vertex\n\n          vertex.x = radius * sinTheta;\n          vertex.y = -v * height + halfHeight;\n          vertex.z = radius * cosTheta;\n          vertices.push(vertex.x, vertex.y, vertex.z);\n\n          // normal\n\n          normal.set(sinTheta, slope, cosTheta).normalize();\n          normals.push(normal.x, normal.y, normal.z);\n\n          // uv\n\n          uvs.push(u, 1 - v);\n\n          // save index of vertex in respective row\n\n          indexRow.push(index++);\n        }\n\n        // now save vertices of the row in our index array\n\n        indexArray.push(indexRow);\n      }\n\n      // generate indices\n\n      for (let x = 0; x < radialSegments; x++) {\n        for (let y = 0; y < heightSegments; y++) {\n          // we use the index array to access the correct indices\n\n          const a = indexArray[y][x];\n          const b = indexArray[y + 1][x];\n          const c = indexArray[y + 1][x + 1];\n          const d = indexArray[y][x + 1];\n\n          // faces\n\n          if (radiusTop > 0 || y !== 0) {\n            indices.push(a, b, d);\n            groupCount += 3;\n          }\n          if (radiusBottom > 0 || y !== heightSegments - 1) {\n            indices.push(b, c, d);\n            groupCount += 3;\n          }\n        }\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup(groupStart, groupCount, 0);\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n    function generateCap(top) {\n      // save the index of the first center vertex\n      const centerIndexStart = index;\n      const uv = new Vector2();\n      const vertex = new Vector3();\n      let groupCount = 0;\n      const radius = top === true ? radiusTop : radiusBottom;\n      const sign = top === true ? 1 : -1;\n\n      // first we generate the center vertex data of the cap.\n      // because the geometry needs one set of uvs per face,\n      // we must generate a center vertex per face/segment\n\n      for (let x = 1; x <= radialSegments; x++) {\n        // vertex\n\n        vertices.push(0, halfHeight * sign, 0);\n\n        // normal\n\n        normals.push(0, sign, 0);\n\n        // uv\n\n        uvs.push(0.5, 0.5);\n\n        // increase index\n\n        index++;\n      }\n\n      // save the index of the last center vertex\n      const centerIndexEnd = index;\n\n      // now we generate the surrounding vertices, normals and uvs\n\n      for (let x = 0; x <= radialSegments; x++) {\n        const u = x / radialSegments;\n        const theta = u * thetaLength + thetaStart;\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta);\n\n        // vertex\n\n        vertex.x = radius * sinTheta;\n        vertex.y = halfHeight * sign;\n        vertex.z = radius * cosTheta;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // normal\n\n        normals.push(0, sign, 0);\n\n        // uv\n\n        uv.x = cosTheta * 0.5 + 0.5;\n        uv.y = sinTheta * 0.5 * sign + 0.5;\n        uvs.push(uv.x, uv.y);\n\n        // increase index\n\n        index++;\n      }\n\n      // generate indices\n\n      for (let x = 0; x < radialSegments; x++) {\n        const c = centerIndexStart + x;\n        const i = centerIndexEnd + x;\n        if (top === true) {\n          // face top\n\n          indices.push(i, i + 1, c);\n        } else {\n          // face bottom\n\n          indices.push(i + 1, i, c);\n        }\n        groupCount += 3;\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n  }\n}\nclass ConeGeometry extends CylinderGeometry {\n  constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);\n    this.type = 'ConeGeometry';\n    this.parameters = {\n      radius: radius,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n  }\n  static fromJSON(data) {\n    return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n  }\n}\nclass PolyhedronGeometry extends BufferGeometry {\n  constructor(vertices = [], indices = [], radius = 1, detail = 0) {\n    super();\n    this.type = 'PolyhedronGeometry';\n    this.parameters = {\n      vertices: vertices,\n      indices: indices,\n      radius: radius,\n      detail: detail\n    };\n\n    // default buffer data\n\n    const vertexBuffer = [];\n    const uvBuffer = [];\n\n    // the subdivision creates the vertex buffer data\n\n    subdivide(detail);\n\n    // all vertices should lie on a conceptual sphere with a given radius\n\n    applyRadius(radius);\n\n    // finally, create the uv data\n\n    generateUVs();\n\n    // build non-indexed geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n    if (detail === 0) {\n      this.computeVertexNormals(); // flat normals\n    } else {\n      this.normalizeNormals(); // smooth normals\n    }\n\n    // helper functions\n\n    function subdivide(detail) {\n      const a = new Vector3();\n      const b = new Vector3();\n      const c = new Vector3();\n\n      // iterate over all faces and apply a subdivision with the given detail value\n\n      for (let i = 0; i < indices.length; i += 3) {\n        // get the vertices of the face\n\n        getVertexByIndex(indices[i + 0], a);\n        getVertexByIndex(indices[i + 1], b);\n        getVertexByIndex(indices[i + 2], c);\n\n        // perform subdivision\n\n        subdivideFace(a, b, c, detail);\n      }\n    }\n    function subdivideFace(a, b, c, detail) {\n      const cols = detail + 1;\n\n      // we use this multidimensional array as a data structure for creating the subdivision\n\n      const v = [];\n\n      // construct all of the vertices for this subdivision\n\n      for (let i = 0; i <= cols; i++) {\n        v[i] = [];\n        const aj = a.clone().lerp(c, i / cols);\n        const bj = b.clone().lerp(c, i / cols);\n        const rows = cols - i;\n        for (let j = 0; j <= rows; j++) {\n          if (j === 0 && i === cols) {\n            v[i][j] = aj;\n          } else {\n            v[i][j] = aj.clone().lerp(bj, j / rows);\n          }\n        }\n      }\n\n      // construct all of the faces\n\n      for (let i = 0; i < cols; i++) {\n        for (let j = 0; j < 2 * (cols - i) - 1; j++) {\n          const k = Math.floor(j / 2);\n          if (j % 2 === 0) {\n            pushVertex(v[i][k + 1]);\n            pushVertex(v[i + 1][k]);\n            pushVertex(v[i][k]);\n          } else {\n            pushVertex(v[i][k + 1]);\n            pushVertex(v[i + 1][k + 1]);\n            pushVertex(v[i + 1][k]);\n          }\n        }\n      }\n    }\n    function applyRadius(radius) {\n      const vertex = new Vector3();\n\n      // iterate over the entire buffer and apply the radius to each vertex\n\n      for (let i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        vertex.normalize().multiplyScalar(radius);\n        vertexBuffer[i + 0] = vertex.x;\n        vertexBuffer[i + 1] = vertex.y;\n        vertexBuffer[i + 2] = vertex.z;\n      }\n    }\n    function generateUVs() {\n      const vertex = new Vector3();\n      for (let i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        const u = azimuth(vertex) / 2 / Math.PI + 0.5;\n        const v = inclination(vertex) / Math.PI + 0.5;\n        uvBuffer.push(u, 1 - v);\n      }\n      correctUVs();\n      correctSeam();\n    }\n    function correctSeam() {\n      // handle case when face straddles the seam, see #3269\n\n      for (let i = 0; i < uvBuffer.length; i += 6) {\n        // uv data of a single face\n\n        const x0 = uvBuffer[i + 0];\n        const x1 = uvBuffer[i + 2];\n        const x2 = uvBuffer[i + 4];\n        const max = Math.max(x0, x1, x2);\n        const min = Math.min(x0, x1, x2);\n\n        // 0.9 is somewhat arbitrary\n\n        if (max > 0.9 && min < 0.1) {\n          if (x0 < 0.2) uvBuffer[i + 0] += 1;\n          if (x1 < 0.2) uvBuffer[i + 2] += 1;\n          if (x2 < 0.2) uvBuffer[i + 4] += 1;\n        }\n      }\n    }\n    function pushVertex(vertex) {\n      vertexBuffer.push(vertex.x, vertex.y, vertex.z);\n    }\n    function getVertexByIndex(index, vertex) {\n      const stride = index * 3;\n      vertex.x = vertices[stride + 0];\n      vertex.y = vertices[stride + 1];\n      vertex.z = vertices[stride + 2];\n    }\n    function correctUVs() {\n      const a = new Vector3();\n      const b = new Vector3();\n      const c = new Vector3();\n      const centroid = new Vector3();\n      const uvA = new Vector2();\n      const uvB = new Vector2();\n      const uvC = new Vector2();\n      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n        centroid.copy(a).add(b).add(c).divideScalar(3);\n        const azi = azimuth(centroid);\n        correctUV(uvA, j + 0, a, azi);\n        correctUV(uvB, j + 2, b, azi);\n        correctUV(uvC, j + 4, c, azi);\n      }\n    }\n    function correctUV(uv, stride, vector, azimuth) {\n      if (azimuth < 0 && uv.x === 1) {\n        uvBuffer[stride] = uv.x - 1;\n      }\n      if (vector.x === 0 && vector.z === 0) {\n        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n      }\n    }\n\n    // Angle around the Y axis, counter-clockwise when looking from above.\n\n    function azimuth(vector) {\n      return Math.atan2(vector.z, -vector.x);\n    }\n\n    // Angle above the XZ plane.\n\n    function inclination(vector) {\n      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);\n  }\n}\nclass DodecahedronGeometry extends PolyhedronGeometry {\n  constructor(radius = 1, detail = 0) {\n    const t = (1 + Math.sqrt(5)) / 2;\n    const r = 1 / t;\n    const vertices = [\n    // (\u00B11, \u00B11, \u00B11)\n    -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,\n    // (0, \u00B11/\u03C6, \u00B1\u03C6)\n    0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t,\n    // (\u00B11/\u03C6, \u00B1\u03C6, 0)\n    -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0,\n    // (\u00B1\u03C6, 0, \u00B11/\u03C6)\n    -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];\n    const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];\n    super(vertices, indices, radius, detail);\n    this.type = 'DodecahedronGeometry';\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n  }\n  static fromJSON(data) {\n    return new DodecahedronGeometry(data.radius, data.detail);\n  }\n}\nconst _v0 = /*@__PURE__*/new Vector3();\nconst _v1$1 = /*@__PURE__*/new Vector3();\nconst _normal = /*@__PURE__*/new Vector3();\nconst _triangle = /*@__PURE__*/new Triangle();\nclass EdgesGeometry extends BufferGeometry {\n  constructor(geometry = null, thresholdAngle = 1) {\n    super();\n    this.type = 'EdgesGeometry';\n    this.parameters = {\n      geometry: geometry,\n      thresholdAngle: thresholdAngle\n    };\n    if (geometry !== null) {\n      const precisionPoints = 4;\n      const precision = Math.pow(10, precisionPoints);\n      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);\n      const indexAttr = geometry.getIndex();\n      const positionAttr = geometry.getAttribute('position');\n      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n      const indexArr = [0, 0, 0];\n      const vertKeys = ['a', 'b', 'c'];\n      const hashes = new Array(3);\n      const edgeData = {};\n      const vertices = [];\n      for (let i = 0; i < indexCount; i += 3) {\n        if (indexAttr) {\n          indexArr[0] = indexAttr.getX(i);\n          indexArr[1] = indexAttr.getX(i + 1);\n          indexArr[2] = indexAttr.getX(i + 2);\n        } else {\n          indexArr[0] = i;\n          indexArr[1] = i + 1;\n          indexArr[2] = i + 2;\n        }\n        const {\n          a,\n          b,\n          c\n        } = _triangle;\n        a.fromBufferAttribute(positionAttr, indexArr[0]);\n        b.fromBufferAttribute(positionAttr, indexArr[1]);\n        c.fromBufferAttribute(positionAttr, indexArr[2]);\n        _triangle.getNormal(_normal);\n\n        // create hashes for the edge from the vertices\n        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;\n        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;\n        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;\n\n        // skip degenerate triangles\n        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n          continue;\n        }\n\n        // iterate over every edge\n        for (let j = 0; j < 3; j++) {\n          // get the first and next vertex making up the edge\n          const jNext = (j + 1) % 3;\n          const vecHash0 = hashes[j];\n          const vecHash1 = hashes[jNext];\n          const v0 = _triangle[vertKeys[j]];\n          const v1 = _triangle[vertKeys[jNext]];\n          const hash = `${vecHash0}_${vecHash1}`;\n          const reverseHash = `${vecHash1}_${vecHash0}`;\n          if (reverseHash in edgeData && edgeData[reverseHash]) {\n            // if we found a sibling edge add it into the vertex array if\n            // it meets the angle threshold and delete the edge from the map.\n            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n              vertices.push(v0.x, v0.y, v0.z);\n              vertices.push(v1.x, v1.y, v1.z);\n            }\n            edgeData[reverseHash] = null;\n          } else if (!(hash in edgeData)) {\n            // if we've already got an edge here then skip adding a new one\n            edgeData[hash] = {\n              index0: indexArr[j],\n              index1: indexArr[jNext],\n              normal: _normal.clone()\n            };\n          }\n        }\n      }\n\n      // iterate over all remaining, unmatched edges and add them to the vertex array\n      for (const key in edgeData) {\n        if (edgeData[key]) {\n          const {\n            index0,\n            index1\n          } = edgeData[key];\n          _v0.fromBufferAttribute(positionAttr, index0);\n          _v1$1.fromBufferAttribute(positionAttr, index1);\n          vertices.push(_v0.x, _v0.y, _v0.z);\n          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);\n        }\n      }\n      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n}\nclass Shape extends Path {\n  constructor(points) {\n    super(points);\n    this.uuid = generateUUID();\n    this.type = 'Shape';\n    this.holes = [];\n  }\n  getPointsHoles(divisions) {\n    const holesPts = [];\n    for (let i = 0, l = this.holes.length; i < l; i++) {\n      holesPts[i] = this.holes[i].getPoints(divisions);\n    }\n    return holesPts;\n  }\n\n  // get points of shape and holes (keypoints based on segments parameter)\n\n  extractPoints(divisions) {\n    return {\n      shape: this.getPoints(divisions),\n      holes: this.getPointsHoles(divisions)\n    };\n  }\n  copy(source) {\n    super.copy(source);\n    this.holes = [];\n    for (let i = 0, l = source.holes.length; i < l; i++) {\n      const hole = source.holes[i];\n      this.holes.push(hole.clone());\n    }\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.uuid = this.uuid;\n    data.holes = [];\n    for (let i = 0, l = this.holes.length; i < l; i++) {\n      const hole = this.holes[i];\n      data.holes.push(hole.toJSON());\n    }\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.uuid = json.uuid;\n    this.holes = [];\n    for (let i = 0, l = json.holes.length; i < l; i++) {\n      const hole = json.holes[i];\n      this.holes.push(new Path().fromJSON(hole));\n    }\n    return this;\n  }\n}\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.4)\n */\n\nconst Earcut = {\n  triangulate: function (data, holeIndices, dim = 2) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    let minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n      minX = maxX = data[0];\n      minY = maxY = data[1];\n      for (let i = dim; i < outerLen; i += dim) {\n        x = data[i];\n        y = data[i + 1];\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n      }\n\n      // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n      invSize = Math.max(maxX - minX, maxY - minY);\n      invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n  }\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n  let i, last;\n  if (clockwise === signedArea(data, start, end, dim) > 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n  }\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n  return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  let p = start,\n    again;\n  do {\n    again = false;\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n  return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n\n  // interlink polygon nodes in z-order\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  let stop = ear,\n    prev,\n    next;\n\n  // iterate through ears, slicing them one by one\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push(prev.i / dim | 0);\n      triangles.push(ear.i / dim | 0);\n      triangles.push(next.i / dim | 0);\n      removeNode(ear);\n\n      // skipping the next vertex leads to less sliver triangles\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n    ear = next;\n\n    // if we looped through the whole remaining polygon and can't find any more ears\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n        // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n        // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n      break;\n    }\n  }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n  const a = ear.prev,\n    b = ear,\n    c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // now make sure we don't have other points inside the potential ear\n  const ax = a.x,\n    bx = b.x,\n    cx = c.x,\n    ay = a.y,\n    by = b.y,\n    cy = c.y;\n\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,\n    y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,\n    x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,\n    y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n  let p = c.next;\n  while (p !== a) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n  return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev,\n    b = ear,\n    c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  const ax = a.x,\n    bx = b.x,\n    cx = c.x,\n    ay = a.y,\n    by = b.y,\n    cy = c.y;\n\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,\n    y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,\n    x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,\n    y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n\n  // z-order range for the current triangle bbox;\n  const minZ = zOrder(x0, y0, minX, minY, invSize),\n    maxZ = zOrder(x1, y1, minX, minY, invSize);\n  let p = ear.prevZ,\n    n = ear.nextZ;\n\n  // look for points inside the triangle in both directions\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  // look for remaining points in decreasing z-order\n  while (p && p.z >= minZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  }\n\n  // look for remaining points in increasing z-order\n  while (n && n.z <= maxZ) {\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n  return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev,\n      b = p.next.next;\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim | 0);\n      triangles.push(p.i / dim | 0);\n      triangles.push(b.i / dim | 0);\n\n      // remove two nodes involved\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n  return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b);\n\n        // filter colinear points around the cuts\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n\n        // run earcut on each half\n        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  const queue = [];\n  let i, len, start, end, list;\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n  queue.sort(compareX);\n\n  // process holes from left to right\n  for (i = 0; i < queue.length; i++) {\n    outerNode = eliminateHole(queue[i], outerNode);\n  }\n  return outerNode;\n}\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole(hole, outerNode) {\n  const bridge = findHoleBridge(hole, outerNode);\n  if (!bridge) {\n    return outerNode;\n  }\n  const bridgeReverse = splitPolygon(bridge, hole);\n\n  // filter collinear points around the cuts\n  filterPoints(bridgeReverse, bridgeReverse.next);\n  return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode,\n    qx = -Infinity,\n    m;\n  const hx = hole.x,\n    hy = hole.y;\n\n  // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        m = p.x < p.next.x ? p : p.next;\n        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n      }\n    }\n    p = p.next;\n  } while (p !== outerNode);\n  if (!m) return null;\n\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  const stop = m,\n    mx = m.x,\n    my = m.y;\n  let tanMin = Infinity,\n    tan;\n  p = m;\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n    p = p.next;\n  } while (p !== stop);\n  return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n  let i,\n    p,\n    q,\n    e,\n    tail,\n    numMerges,\n    pSize,\n    qSize,\n    inSize = 1;\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n      qSize = inSize;\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n      p = q;\n    }\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n  return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = (x - minX) * invSize | 0;\n  y = (y - minY) * invSize | 0;\n  x = (x | x << 8) & 0x00FF00FF;\n  x = (x | x << 4) & 0x0F0F0F0F;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00FF00FF;\n  y = (y | y << 4) & 0x0F0F0F0F;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n  let p = start,\n    leftmost = start;\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n  return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (\n  // doesn't intersect other edges\n  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (\n  // locally visible\n  area(a.prev, a, b.prev) || area(a, b.prev, b)) ||\n  // does not create opposite-facing sectors\n  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n  return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n  let p = a,\n    inside = false;\n  const px = (a.x + b.x) / 2,\n    py = (a.y + b.y) / 2;\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n  return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n  const a2 = new Node(a.i, a.x, a.y),\n    b2 = new Node(b.i, b.x, b.y),\n    an = a.next,\n    bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n  const p = new Node(i, x, y);\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction Node(i, x, y) {\n  // vertex index in coordinates array\n  this.i = i;\n\n  // vertex coordinates\n  this.x = x;\n  this.y = y;\n\n  // previous and next vertex nodes in a polygon ring\n  this.prev = null;\n  this.next = null;\n\n  // z-order curve value\n  this.z = 0;\n\n  // previous and next nodes in z-order\n  this.prevZ = null;\n  this.nextZ = null;\n\n  // indicates whether this is a steiner point\n  this.steiner = false;\n}\nfunction signedArea(data, start, end, dim) {\n  let sum = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n    j = i;\n  }\n  return sum;\n}\nclass ShapeUtils {\n  // calculate area of the contour polygon\n\n  static area(contour) {\n    const n = contour.length;\n    let a = 0.0;\n    for (let p = n - 1, q = 0; q < n; p = q++) {\n      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n    }\n    return a * 0.5;\n  }\n  static isClockWise(pts) {\n    return ShapeUtils.area(pts) < 0;\n  }\n  static triangulateShape(contour, holes) {\n    const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n    const holeIndices = []; // array of hole indices\n    const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n    removeDupEndPts(contour);\n    addContour(vertices, contour);\n\n    //\n\n    let holeIndex = contour.length;\n    holes.forEach(removeDupEndPts);\n    for (let i = 0; i < holes.length; i++) {\n      holeIndices.push(holeIndex);\n      holeIndex += holes[i].length;\n      addContour(vertices, holes[i]);\n    }\n\n    //\n\n    const triangles = Earcut.triangulate(vertices, holeIndices);\n\n    //\n\n    for (let i = 0; i < triangles.length; i += 3) {\n      faces.push(triangles.slice(i, i + 3));\n    }\n    return faces;\n  }\n}\nfunction removeDupEndPts(points) {\n  const l = points.length;\n  if (l > 2 && points[l - 1].equals(points[0])) {\n    points.pop();\n  }\n}\nfunction addContour(vertices, contour) {\n  for (let i = 0; i < contour.length; i++) {\n    vertices.push(contour[i].x);\n    vertices.push(contour[i].y);\n  }\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\nclass ExtrudeGeometry extends BufferGeometry {\n  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {\n    super();\n    this.type = 'ExtrudeGeometry';\n    this.parameters = {\n      shapes: shapes,\n      options: options\n    };\n    shapes = Array.isArray(shapes) ? shapes : [shapes];\n    const scope = this;\n    const verticesArray = [];\n    const uvArray = [];\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      addShape(shape);\n    }\n\n    // build geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n    this.computeVertexNormals();\n\n    // functions\n\n    function addShape(shape) {\n      const placeholder = [];\n\n      // options\n\n      const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n      const steps = options.steps !== undefined ? options.steps : 1;\n      const depth = options.depth !== undefined ? options.depth : 1;\n      let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n      let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n      let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n      let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n      let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n      const extrudePath = options.extrudePath;\n      const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n      //\n\n      let extrudePts,\n        extrudeByPath = false;\n      let splineTube, binormal, normal, position2;\n      if (extrudePath) {\n        extrudePts = extrudePath.getSpacedPoints(steps);\n        extrudeByPath = true;\n        bevelEnabled = false; // bevels not supported for path extrusion\n\n        // SETUP TNB variables\n\n        // TODO1 - have a .isClosed in spline?\n\n        splineTube = extrudePath.computeFrenetFrames(steps, false);\n\n        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n        binormal = new Vector3();\n        normal = new Vector3();\n        position2 = new Vector3();\n      }\n\n      // Safeguards if bevels are not enabled\n\n      if (!bevelEnabled) {\n        bevelSegments = 0;\n        bevelThickness = 0;\n        bevelSize = 0;\n        bevelOffset = 0;\n      }\n\n      // Variables initialization\n\n      const shapePoints = shape.extractPoints(curveSegments);\n      let vertices = shapePoints.shape;\n      const holes = shapePoints.holes;\n      const reverse = !ShapeUtils.isClockWise(vertices);\n      if (reverse) {\n        vertices = vertices.reverse();\n\n        // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          if (ShapeUtils.isClockWise(ahole)) {\n            holes[h] = ahole.reverse();\n          }\n        }\n      }\n      const faces = ShapeUtils.triangulateShape(vertices, holes);\n\n      /* Vertices */\n\n      const contour = vertices; // vertices has all points but contour has only points of circumference\n\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        vertices = vertices.concat(ahole);\n      }\n      function scalePt2(pt, vec, size) {\n        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');\n        return pt.clone().addScaledVector(vec, size);\n      }\n      const vlen = vertices.length,\n        flen = faces.length;\n\n      // Find directions for point movement\n\n      function getBevelVec(inPt, inPrev, inNext) {\n        // computes for inPt the corresponding point inPt' on a new contour\n        //   shifted by 1 unit (length of normalized vector) to the left\n        // if we walk along contour clockwise, this new contour is outside the old one\n        //\n        // inPt' is the intersection of the two lines parallel to the two\n        //  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n        // good reading for geometry algorithms (here: line-line intersection)\n        // http://geomalgorithms.com/a05-_intersect-1.html\n\n        const v_prev_x = inPt.x - inPrev.x,\n          v_prev_y = inPt.y - inPrev.y;\n        const v_next_x = inNext.x - inPt.x,\n          v_next_y = inNext.y - inPt.y;\n        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;\n\n        // check for collinear edges\n        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n        if (Math.abs(collinear0) > Number.EPSILON) {\n          // not collinear\n\n          // length of vectors for normalizing\n\n          const v_prev_len = Math.sqrt(v_prev_lensq);\n          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);\n\n          // shift adjacent points by unit vectors to the left\n\n          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n          const ptNextShift_x = inNext.x - v_next_y / v_next_len;\n          const ptNextShift_y = inNext.y + v_next_x / v_next_len;\n\n          // scaling factor for v_prev to intersection point\n\n          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);\n\n          // vector from inPt to intersection point\n\n          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;\n\n          // Don't normalize!, otherwise sharp corners become ugly\n          //  but prevent crazy spikes\n          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n          if (v_trans_lensq <= 2) {\n            return new Vector2(v_trans_x, v_trans_y);\n          } else {\n            shrink_by = Math.sqrt(v_trans_lensq / 2);\n          }\n        } else {\n          // handle special case of collinear edges\n\n          let direction_eq = false; // assumes: opposite\n\n          if (v_prev_x > Number.EPSILON) {\n            if (v_next_x > Number.EPSILON) {\n              direction_eq = true;\n            }\n          } else {\n            if (v_prev_x < -Number.EPSILON) {\n              if (v_next_x < -Number.EPSILON) {\n                direction_eq = true;\n              }\n            } else {\n              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n                direction_eq = true;\n              }\n            }\n          }\n          if (direction_eq) {\n            // console.log(\"Warning: lines are a straight sequence\");\n            v_trans_x = -v_prev_y;\n            v_trans_y = v_prev_x;\n            shrink_by = Math.sqrt(v_prev_lensq);\n          } else {\n            // console.log(\"Warning: lines are a straight spike\");\n            v_trans_x = v_prev_x;\n            v_trans_y = v_prev_y;\n            shrink_by = Math.sqrt(v_prev_lensq / 2);\n          }\n        }\n        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n      }\n      const contourMovements = [];\n      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n        if (j === il) j = 0;\n        if (k === il) k = 0;\n\n        //  (j)---(i)---(k)\n        // console.log('i,j,k', i, j , k)\n\n        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n      }\n      const holesMovements = [];\n      let oneHoleMovements,\n        verticesMovements = contourMovements.concat();\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        oneHoleMovements = [];\n        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n          if (j === il) j = 0;\n          if (k === il) k = 0;\n\n          //  (j)---(i)---(k)\n          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n        }\n        holesMovements.push(oneHoleMovements);\n        verticesMovements = verticesMovements.concat(oneHoleMovements);\n      }\n\n      // Loop bevelSegments, 1 for the front, 1 for the back\n\n      for (let b = 0; b < bevelSegments; b++) {\n        //for ( b = bevelSegments; b > 0; b -- ) {\n\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;\n\n        // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n          v(vert.x, vert.y, -z);\n        }\n\n        // expand holes\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n            v(vert.x, vert.y, -z);\n          }\n        }\n      }\n      const bs = bevelSize + bevelOffset;\n\n      // Back facing vertices\n\n      for (let i = 0; i < vlen; i++) {\n        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n        if (!extrudeByPath) {\n          v(vert.x, vert.y, 0);\n        } else {\n          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n          position2.copy(extrudePts[0]).add(normal).add(binormal);\n          v(position2.x, position2.y, position2.z);\n        }\n      }\n\n      // Add stepped vertices...\n      // Including front facing vertices\n\n      for (let s = 1; s <= steps; s++) {\n        for (let i = 0; i < vlen; i++) {\n          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n          if (!extrudeByPath) {\n            v(vert.x, vert.y, depth / steps * s);\n          } else {\n            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n            position2.copy(extrudePts[s]).add(normal).add(binormal);\n            v(position2.x, position2.y, position2.z);\n          }\n        }\n      }\n\n      // Add bevel segments planes\n\n      //for ( b = 1; b <= bevelSegments; b ++ ) {\n      for (let b = bevelSegments - 1; b >= 0; b--) {\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;\n\n        // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n          v(vert.x, vert.y, depth + z);\n        }\n\n        // expand holes\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n            if (!extrudeByPath) {\n              v(vert.x, vert.y, depth + z);\n            } else {\n              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n            }\n          }\n        }\n      }\n\n      /* Faces */\n\n      // Top and bottom faces\n\n      buildLidFaces();\n\n      // Sides faces\n\n      buildSideFaces();\n\n      /////  Internal functions\n\n      function buildLidFaces() {\n        const start = verticesArray.length / 3;\n        if (bevelEnabled) {\n          let layer = 0; // steps + 1\n          let offset = vlen * layer;\n\n          // Bottom faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2] + offset, face[1] + offset, face[0] + offset);\n          }\n          layer = steps + bevelSegments * 2;\n          offset = vlen * layer;\n\n          // Top faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + offset, face[1] + offset, face[2] + offset);\n          }\n        } else {\n          // Bottom faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2], face[1], face[0]);\n          }\n\n          // Top faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n          }\n        }\n        scope.addGroup(start, verticesArray.length / 3 - start, 0);\n      }\n\n      // Create faces for the z-sides of the shape\n\n      function buildSideFaces() {\n        const start = verticesArray.length / 3;\n        let layeroffset = 0;\n        sidewalls(contour, layeroffset);\n        layeroffset += contour.length;\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          sidewalls(ahole, layeroffset);\n\n          //, true\n          layeroffset += ahole.length;\n        }\n        scope.addGroup(start, verticesArray.length / 3 - start, 1);\n      }\n      function sidewalls(contour, layeroffset) {\n        let i = contour.length;\n        while (--i >= 0) {\n          const j = i;\n          let k = i - 1;\n          if (k < 0) k = contour.length - 1;\n\n          //console.log('b', i,j, i-1, k,vertices.length);\n\n          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {\n            const slen1 = vlen * s;\n            const slen2 = vlen * (s + 1);\n            const a = layeroffset + j + slen1,\n              b = layeroffset + k + slen1,\n              c = layeroffset + k + slen2,\n              d = layeroffset + j + slen2;\n            f4(a, b, c, d);\n          }\n        }\n      }\n      function v(x, y, z) {\n        placeholder.push(x);\n        placeholder.push(y);\n        placeholder.push(z);\n      }\n      function f3(a, b, c) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(c);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n      }\n      function f4(a, b, c, d) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(d);\n        addVertex(b);\n        addVertex(c);\n        addVertex(d);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[3]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n        addUV(uvs[3]);\n      }\n      function addVertex(index) {\n        verticesArray.push(placeholder[index * 3 + 0]);\n        verticesArray.push(placeholder[index * 3 + 1]);\n        verticesArray.push(placeholder[index * 3 + 2]);\n      }\n      function addUV(vector2) {\n        uvArray.push(vector2.x);\n        uvArray.push(vector2.y);\n      }\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    const shapes = this.parameters.shapes;\n    const options = this.parameters.options;\n    return toJSON$1(shapes, options, data);\n  }\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n      geometryShapes.push(shape);\n    }\n    const extrudePath = data.options.extrudePath;\n    if (extrudePath !== undefined) {\n      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\n    }\n    return new ExtrudeGeometry(geometryShapes, data.options);\n  }\n}\nconst WorldUVGenerator = {\n  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n  },\n  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const a_z = vertices[indexA * 3 + 2];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const b_z = vertices[indexB * 3 + 2];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    const c_z = vertices[indexC * 3 + 2];\n    const d_x = vertices[indexD * 3];\n    const d_y = vertices[indexD * 3 + 1];\n    const d_z = vertices[indexD * 3 + 2];\n    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {\n      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n    } else {\n      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n    }\n  }\n};\nfunction toJSON$1(shapes, options, data) {\n  data.shapes = [];\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n  data.options = Object.assign({}, options);\n  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n  return data;\n}\nclass IcosahedronGeometry extends PolyhedronGeometry {\n  constructor(radius = 1, detail = 0) {\n    const t = (1 + Math.sqrt(5)) / 2;\n    const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];\n    const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];\n    super(vertices, indices, radius, detail);\n    this.type = 'IcosahedronGeometry';\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n  }\n  static fromJSON(data) {\n    return new IcosahedronGeometry(data.radius, data.detail);\n  }\n}\nclass OctahedronGeometry extends PolyhedronGeometry {\n  constructor(radius = 1, detail = 0) {\n    const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];\n    const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];\n    super(vertices, indices, radius, detail);\n    this.type = 'OctahedronGeometry';\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n  }\n  static fromJSON(data) {\n    return new OctahedronGeometry(data.radius, data.detail);\n  }\n}\nclass PlaneGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n    super();\n    this.type = 'PlaneGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments\n    };\n    const width_half = width / 2;\n    const height_half = height / 2;\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n    const segment_width = width / gridX;\n    const segment_height = height / gridY;\n\n    //\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    for (let iy = 0; iy < gridY1; iy++) {\n      const y = iy * segment_height - height_half;\n      for (let ix = 0; ix < gridX1; ix++) {\n        const x = ix * segment_width - width_half;\n        vertices.push(x, -y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n      }\n    }\n    for (let iy = 0; iy < gridY; iy++) {\n      for (let ix = 0; ix < gridX; ix++) {\n        const a = ix + gridX1 * iy;\n        const b = ix + gridX1 * (iy + 1);\n        const c = ix + 1 + gridX1 * (iy + 1);\n        const d = ix + 1 + gridX1 * iy;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n  }\n}\nclass RingGeometry extends BufferGeometry {\n  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = 'RingGeometry';\n    this.parameters = {\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      thetaSegments: thetaSegments,\n      phiSegments: phiSegments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    thetaSegments = Math.max(3, thetaSegments);\n    phiSegments = Math.max(1, phiSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // some helper variables\n\n    let radius = innerRadius;\n    const radiusStep = (outerRadius - innerRadius) / phiSegments;\n    const vertex = new Vector3();\n    const uv = new Vector2();\n\n    // generate vertices, normals and uvs\n\n    for (let j = 0; j <= phiSegments; j++) {\n      for (let i = 0; i <= thetaSegments; i++) {\n        // values are generate from the inside of the ring to the outside\n\n        const segment = thetaStart + i / thetaSegments * thetaLength;\n\n        // vertex\n\n        vertex.x = radius * Math.cos(segment);\n        vertex.y = radius * Math.sin(segment);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // normal\n\n        normals.push(0, 0, 1);\n\n        // uv\n\n        uv.x = (vertex.x / outerRadius + 1) / 2;\n        uv.y = (vertex.y / outerRadius + 1) / 2;\n        uvs.push(uv.x, uv.y);\n      }\n\n      // increase the radius for next row of vertices\n\n      radius += radiusStep;\n    }\n\n    // indices\n\n    for (let j = 0; j < phiSegments; j++) {\n      const thetaSegmentLevel = j * (thetaSegments + 1);\n      for (let i = 0; i < thetaSegments; i++) {\n        const segment = i + thetaSegmentLevel;\n        const a = segment;\n        const b = segment + thetaSegments + 1;\n        const c = segment + thetaSegments + 2;\n        const d = segment + 1;\n\n        // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\n  }\n}\nclass ShapeGeometry extends BufferGeometry {\n  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {\n    super();\n    this.type = 'ShapeGeometry';\n    this.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments\n    };\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    let groupStart = 0;\n    let groupCount = 0;\n\n    // allow single and array values for \"shapes\" parameter\n\n    if (Array.isArray(shapes) === false) {\n      addShape(shapes);\n    } else {\n      for (let i = 0; i < shapes.length; i++) {\n        addShape(shapes[i]);\n        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n        groupStart += groupCount;\n        groupCount = 0;\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    // helper functions\n\n    function addShape(shape) {\n      const indexOffset = vertices.length / 3;\n      const points = shape.extractPoints(curveSegments);\n      let shapeVertices = points.shape;\n      const shapeHoles = points.holes;\n\n      // check direction of vertices\n\n      if (ShapeUtils.isClockWise(shapeVertices) === false) {\n        shapeVertices = shapeVertices.reverse();\n      }\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n        if (ShapeUtils.isClockWise(shapeHole) === true) {\n          shapeHoles[i] = shapeHole.reverse();\n        }\n      }\n      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);\n\n      // join vertices of inner and outer paths to a single array\n\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n        shapeVertices = shapeVertices.concat(shapeHole);\n      }\n\n      // vertices, normals, uvs\n\n      for (let i = 0, l = shapeVertices.length; i < l; i++) {\n        const vertex = shapeVertices[i];\n        vertices.push(vertex.x, vertex.y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(vertex.x, vertex.y); // world uvs\n      }\n\n      // indices\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const a = face[0] + indexOffset;\n        const b = face[1] + indexOffset;\n        const c = face[2] + indexOffset;\n        indices.push(a, b, c);\n        groupCount += 3;\n      }\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    const shapes = this.parameters.shapes;\n    return toJSON(shapes, data);\n  }\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n      geometryShapes.push(shape);\n    }\n    return new ShapeGeometry(geometryShapes, data.curveSegments);\n  }\n}\nfunction toJSON(shapes, data) {\n  data.shapes = [];\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n  return data;\n}\nclass SphereGeometry extends BufferGeometry {\n  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {\n    super();\n    this.type = 'SphereGeometry';\n    this.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vector3();\n    const normal = new Vector3();\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n\n      // special case for the poles\n\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n\n        // vertex\n\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // normal\n\n        normal.copy(vertex).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n\n        // uv\n\n        uvs.push(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n  }\n}\nclass TetrahedronGeometry extends PolyhedronGeometry {\n  constructor(radius = 1, detail = 0) {\n    const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];\n    const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];\n    super(vertices, indices, radius, detail);\n    this.type = 'TetrahedronGeometry';\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n  }\n  static fromJSON(data) {\n    return new TetrahedronGeometry(data.radius, data.detail);\n  }\n}\nclass TorusGeometry extends BufferGeometry {\n  constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {\n    super();\n    this.type = 'TorusGeometry';\n    this.parameters = {\n      radius: radius,\n      tube: tube,\n      radialSegments: radialSegments,\n      tubularSegments: tubularSegments,\n      arc: arc\n    };\n    radialSegments = Math.floor(radialSegments);\n    tubularSegments = Math.floor(tubularSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    const center = new Vector3();\n    const vertex = new Vector3();\n    const normal = new Vector3();\n\n    // generate vertices, normals and uvs\n\n    for (let j = 0; j <= radialSegments; j++) {\n      for (let i = 0; i <= tubularSegments; i++) {\n        const u = i / tubularSegments * arc;\n        const v = j / radialSegments * Math.PI * 2;\n\n        // vertex\n\n        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n        vertex.z = tube * Math.sin(v);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // normal\n\n        center.x = radius * Math.cos(u);\n        center.y = radius * Math.sin(u);\n        normal.subVectors(vertex, center).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n\n        // uv\n\n        uvs.push(i / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    }\n\n    // generate indices\n\n    for (let j = 1; j <= radialSegments; j++) {\n      for (let i = 1; i <= tubularSegments; i++) {\n        // indices\n\n        const a = (tubularSegments + 1) * j + i - 1;\n        const b = (tubularSegments + 1) * (j - 1) + i - 1;\n        const c = (tubularSegments + 1) * (j - 1) + i;\n        const d = (tubularSegments + 1) * j + i;\n\n        // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);\n  }\n}\nclass TorusKnotGeometry extends BufferGeometry {\n  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {\n    super();\n    this.type = 'TorusKnotGeometry';\n    this.parameters = {\n      radius: radius,\n      tube: tube,\n      tubularSegments: tubularSegments,\n      radialSegments: radialSegments,\n      p: p,\n      q: q\n    };\n    tubularSegments = Math.floor(tubularSegments);\n    radialSegments = Math.floor(radialSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const P1 = new Vector3();\n    const P2 = new Vector3();\n    const B = new Vector3();\n    const T = new Vector3();\n    const N = new Vector3();\n\n    // generate vertices, normals and uvs\n\n    for (let i = 0; i <= tubularSegments; ++i) {\n      // the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n      const u = i / tubularSegments * p * Math.PI * 2;\n\n      // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n      // these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n      calculatePositionOnCurve(u, p, q, radius, P1);\n      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);\n\n      // calculate orthonormal basis\n\n      T.subVectors(P2, P1);\n      N.addVectors(P2, P1);\n      B.crossVectors(T, N);\n      N.crossVectors(B, T);\n\n      // normalize B, N. T can be ignored, we don't use it\n\n      B.normalize();\n      N.normalize();\n      for (let j = 0; j <= radialSegments; ++j) {\n        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n        const v = j / radialSegments * Math.PI * 2;\n        const cx = -tube * Math.cos(v);\n        const cy = tube * Math.sin(v);\n\n        // now calculate the final vertex position.\n        // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n        vertex.x = P1.x + (cx * N.x + cy * B.x);\n        vertex.y = P1.y + (cx * N.y + cy * B.y);\n        vertex.z = P1.z + (cx * N.z + cy * B.z);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n        normal.subVectors(vertex, P1).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n\n        // uv\n\n        uvs.push(i / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    }\n\n    // generate indices\n\n    for (let j = 1; j <= tubularSegments; j++) {\n      for (let i = 1; i <= radialSegments; i++) {\n        // indices\n\n        const a = (radialSegments + 1) * (j - 1) + (i - 1);\n        const b = (radialSegments + 1) * j + (i - 1);\n        const c = (radialSegments + 1) * j + i;\n        const d = (radialSegments + 1) * (j - 1) + i;\n\n        // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    // this function calculates the current position on the torus curve\n\n    function calculatePositionOnCurve(u, p, q, radius, position) {\n      const cu = Math.cos(u);\n      const su = Math.sin(u);\n      const quOverP = q / p * u;\n      const cs = Math.cos(quOverP);\n      position.x = radius * (2 + cs) * 0.5 * cu;\n      position.y = radius * (2 + cs) * su * 0.5;\n      position.z = radius * Math.sin(quOverP) * 0.5;\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);\n  }\n}\nclass TubeGeometry extends BufferGeometry {\n  constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {\n    super();\n    this.type = 'TubeGeometry';\n    this.parameters = {\n      path: path,\n      tubularSegments: tubularSegments,\n      radius: radius,\n      radialSegments: radialSegments,\n      closed: closed\n    };\n    const frames = path.computeFrenetFrames(tubularSegments, closed);\n\n    // expose internals\n\n    this.tangents = frames.tangents;\n    this.normals = frames.normals;\n    this.binormals = frames.binormals;\n\n    // helper variables\n\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let P = new Vector3();\n\n    // buffer\n\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    // create buffer data\n\n    generateBufferData();\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    // functions\n\n    function generateBufferData() {\n      for (let i = 0; i < tubularSegments; i++) {\n        generateSegment(i);\n      }\n\n      // if the geometry is not closed, generate the last row of vertices and normals\n      // at the regular position on the given path\n      //\n      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n      generateSegment(closed === false ? tubularSegments : 0);\n\n      // uvs are generated in a separate function.\n      // this makes it easy compute correct values for closed geometries\n\n      generateUVs();\n\n      // finally create faces\n\n      generateIndices();\n    }\n    function generateSegment(i) {\n      // we use getPointAt to sample evenly distributed points from the given path\n\n      P = path.getPointAt(i / tubularSegments, P);\n\n      // retrieve corresponding normal and binormal\n\n      const N = frames.normals[i];\n      const B = frames.binormals[i];\n\n      // generate normals and vertices for the current segment\n\n      for (let j = 0; j <= radialSegments; j++) {\n        const v = j / radialSegments * Math.PI * 2;\n        const sin = Math.sin(v);\n        const cos = -Math.cos(v);\n\n        // normal\n\n        normal.x = cos * N.x + sin * B.x;\n        normal.y = cos * N.y + sin * B.y;\n        normal.z = cos * N.z + sin * B.z;\n        normal.normalize();\n        normals.push(normal.x, normal.y, normal.z);\n\n        // vertex\n\n        vertex.x = P.x + radius * normal.x;\n        vertex.y = P.y + radius * normal.y;\n        vertex.z = P.z + radius * normal.z;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    }\n    function generateIndices() {\n      for (let j = 1; j <= tubularSegments; j++) {\n        for (let i = 1; i <= radialSegments; i++) {\n          const a = (radialSegments + 1) * (j - 1) + (i - 1);\n          const b = (radialSegments + 1) * j + (i - 1);\n          const c = (radialSegments + 1) * j + i;\n          const d = (radialSegments + 1) * (j - 1) + i;\n\n          // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n    }\n    function generateUVs() {\n      for (let i = 0; i <= tubularSegments; i++) {\n        for (let j = 0; j <= radialSegments; j++) {\n          uv.x = i / tubularSegments;\n          uv.y = j / radialSegments;\n          uvs.push(uv.x, uv.y);\n        }\n      }\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.path = this.parameters.path.toJSON();\n    return data;\n  }\n  static fromJSON(data) {\n    // This only works for built-in curves (e.g. CatmullRomCurve3).\n    // User defined curves or instances of CurvePath will not be deserialized.\n    return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);\n  }\n}\nclass WireframeGeometry extends BufferGeometry {\n  constructor(geometry = null) {\n    super();\n    this.type = 'WireframeGeometry';\n    this.parameters = {\n      geometry: geometry\n    };\n    if (geometry !== null) {\n      // buffer\n\n      const vertices = [];\n      const edges = new Set();\n\n      // helper variables\n\n      const start = new Vector3();\n      const end = new Vector3();\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n\n        const position = geometry.attributes.position;\n        const indices = geometry.index;\n        let groups = geometry.groups;\n        if (groups.length === 0) {\n          groups = [{\n            start: 0,\n            count: indices.count,\n            materialIndex: 0\n          }];\n        }\n\n        // create a data structure that contains all edges without duplicates\n\n        for (let o = 0, ol = groups.length; o < ol; ++o) {\n          const group = groups[o];\n          const groupStart = group.start;\n          const groupCount = group.count;\n          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {\n            for (let j = 0; j < 3; j++) {\n              const index1 = indices.getX(i + j);\n              const index2 = indices.getX(i + (j + 1) % 3);\n              start.fromBufferAttribute(position, index1);\n              end.fromBufferAttribute(position, index2);\n              if (isUniqueEdge(start, end, edges) === true) {\n                vertices.push(start.x, start.y, start.z);\n                vertices.push(end.x, end.y, end.z);\n              }\n            }\n          }\n        }\n      } else {\n        // non-indexed BufferGeometry\n\n        const position = geometry.attributes.position;\n        for (let i = 0, l = position.count / 3; i < l; i++) {\n          for (let j = 0; j < 3; j++) {\n            // three edges per triangle, an edge is represented as (index1, index2)\n            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n            const index1 = 3 * i + j;\n            const index2 = 3 * i + (j + 1) % 3;\n            start.fromBufferAttribute(position, index1);\n            end.fromBufferAttribute(position, index2);\n            if (isUniqueEdge(start, end, edges) === true) {\n              vertices.push(start.x, start.y, start.z);\n              vertices.push(end.x, end.y, end.z);\n            }\n          }\n        }\n      }\n\n      // build geometry\n\n      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n}\nfunction isUniqueEdge(start, end, edges) {\n  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n  if (edges.has(hash1) === true || edges.has(hash2) === true) {\n    return false;\n  } else {\n    edges.add(hash1);\n    edges.add(hash2);\n    return true;\n  }\n}\nvar Geometries = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BoxGeometry: BoxGeometry,\n  CapsuleGeometry: CapsuleGeometry,\n  CircleGeometry: CircleGeometry,\n  ConeGeometry: ConeGeometry,\n  CylinderGeometry: CylinderGeometry,\n  DodecahedronGeometry: DodecahedronGeometry,\n  EdgesGeometry: EdgesGeometry,\n  ExtrudeGeometry: ExtrudeGeometry,\n  IcosahedronGeometry: IcosahedronGeometry,\n  LatheGeometry: LatheGeometry,\n  OctahedronGeometry: OctahedronGeometry,\n  PlaneGeometry: PlaneGeometry,\n  PolyhedronGeometry: PolyhedronGeometry,\n  RingGeometry: RingGeometry,\n  ShapeGeometry: ShapeGeometry,\n  SphereGeometry: SphereGeometry,\n  TetrahedronGeometry: TetrahedronGeometry,\n  TorusGeometry: TorusGeometry,\n  TorusKnotGeometry: TorusKnotGeometry,\n  TubeGeometry: TubeGeometry,\n  WireframeGeometry: WireframeGeometry\n});\nclass ShadowMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isShadowMaterial = true;\n    this.type = 'ShadowMaterial';\n    this.color = new Color(0x000000);\n    this.transparent = true;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.fog = source.fog;\n    return this;\n  }\n}\nclass RawShaderMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super(parameters);\n    this.isRawShaderMaterial = true;\n    this.type = 'RawShaderMaterial';\n  }\n}\nclass MeshStandardMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isMeshStandardMaterial = true;\n    this.type = 'MeshStandardMaterial';\n    this.defines = {\n      'STANDARD': ''\n    };\n    this.color = new Color(0xffffff); // diffuse\n    this.roughness = 1.0;\n    this.metalness = 0.0;\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.roughnessMap = null;\n    this.metalnessMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new Euler();\n    this.envMapIntensity = 1.0;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.flatShading = false;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.defines = {\n      'STANDARD': ''\n    };\n    this.color.copy(source.color);\n    this.roughness = source.roughness;\n    this.metalness = source.metalness;\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.roughnessMap = source.roughnessMap;\n    this.metalnessMap = source.metalnessMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    this.envMapIntensity = source.envMapIntensity;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    this.fog = source.fog;\n    return this;\n  }\n}\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n  constructor(parameters) {\n    super();\n    this.isMeshPhysicalMaterial = true;\n    this.defines = {\n      'STANDARD': '',\n      'PHYSICAL': ''\n    };\n    this.type = 'MeshPhysicalMaterial';\n    this.anisotropyRotation = 0;\n    this.anisotropyMap = null;\n    this.clearcoatMap = null;\n    this.clearcoatRoughness = 0.0;\n    this.clearcoatRoughnessMap = null;\n    this.clearcoatNormalScale = new Vector2(1, 1);\n    this.clearcoatNormalMap = null;\n    this.ior = 1.5;\n    Object.defineProperty(this, 'reflectivity', {\n      get: function () {\n        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);\n      },\n      set: function (reflectivity) {\n        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);\n      }\n    });\n    this.iridescenceMap = null;\n    this.iridescenceIOR = 1.3;\n    this.iridescenceThicknessRange = [100, 400];\n    this.iridescenceThicknessMap = null;\n    this.sheenColor = new Color(0x000000);\n    this.sheenColorMap = null;\n    this.sheenRoughness = 1.0;\n    this.sheenRoughnessMap = null;\n    this.transmissionMap = null;\n    this.thickness = 0;\n    this.thicknessMap = null;\n    this.attenuationDistance = Infinity;\n    this.attenuationColor = new Color(1, 1, 1);\n    this.specularIntensity = 1.0;\n    this.specularIntensityMap = null;\n    this.specularColor = new Color(1, 1, 1);\n    this.specularColorMap = null;\n    this._anisotropy = 0;\n    this._clearcoat = 0;\n    this._dispersion = 0;\n    this._iridescence = 0;\n    this._sheen = 0.0;\n    this._transmission = 0;\n    this.setValues(parameters);\n  }\n  get anisotropy() {\n    return this._anisotropy;\n  }\n  set anisotropy(value) {\n    if (this._anisotropy > 0 !== value > 0) {\n      this.version++;\n    }\n    this._anisotropy = value;\n  }\n  get clearcoat() {\n    return this._clearcoat;\n  }\n  set clearcoat(value) {\n    if (this._clearcoat > 0 !== value > 0) {\n      this.version++;\n    }\n    this._clearcoat = value;\n  }\n  get iridescence() {\n    return this._iridescence;\n  }\n  set iridescence(value) {\n    if (this._iridescence > 0 !== value > 0) {\n      this.version++;\n    }\n    this._iridescence = value;\n  }\n  get dispersion() {\n    return this._dispersion;\n  }\n  set dispersion(value) {\n    if (this._dispersion > 0 !== value > 0) {\n      this.version++;\n    }\n    this._dispersion = value;\n  }\n  get sheen() {\n    return this._sheen;\n  }\n  set sheen(value) {\n    if (this._sheen > 0 !== value > 0) {\n      this.version++;\n    }\n    this._sheen = value;\n  }\n  get transmission() {\n    return this._transmission;\n  }\n  set transmission(value) {\n    if (this._transmission > 0 !== value > 0) {\n      this.version++;\n    }\n    this._transmission = value;\n  }\n  copy(source) {\n    super.copy(source);\n    this.defines = {\n      'STANDARD': '',\n      'PHYSICAL': ''\n    };\n    this.anisotropy = source.anisotropy;\n    this.anisotropyRotation = source.anisotropyRotation;\n    this.anisotropyMap = source.anisotropyMap;\n    this.clearcoat = source.clearcoat;\n    this.clearcoatMap = source.clearcoatMap;\n    this.clearcoatRoughness = source.clearcoatRoughness;\n    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n    this.clearcoatNormalMap = source.clearcoatNormalMap;\n    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n    this.dispersion = source.dispersion;\n    this.ior = source.ior;\n    this.iridescence = source.iridescence;\n    this.iridescenceMap = source.iridescenceMap;\n    this.iridescenceIOR = source.iridescenceIOR;\n    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];\n    this.iridescenceThicknessMap = source.iridescenceThicknessMap;\n    this.sheen = source.sheen;\n    this.sheenColor.copy(source.sheenColor);\n    this.sheenColorMap = source.sheenColorMap;\n    this.sheenRoughness = source.sheenRoughness;\n    this.sheenRoughnessMap = source.sheenRoughnessMap;\n    this.transmission = source.transmission;\n    this.transmissionMap = source.transmissionMap;\n    this.thickness = source.thickness;\n    this.thicknessMap = source.thicknessMap;\n    this.attenuationDistance = source.attenuationDistance;\n    this.attenuationColor.copy(source.attenuationColor);\n    this.specularIntensity = source.specularIntensity;\n    this.specularIntensityMap = source.specularIntensityMap;\n    this.specularColor.copy(source.specularColor);\n    this.specularColorMap = source.specularColorMap;\n    return this;\n  }\n}\nclass MeshPhongMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isMeshPhongMaterial = true;\n    this.type = 'MeshPhongMaterial';\n    this.color = new Color(0xffffff); // diffuse\n    this.specular = new Color(0x111111);\n    this.shininess = 30;\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new Euler();\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.flatShading = false;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.specular.copy(source.specular);\n    this.shininess = source.shininess;\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    this.fog = source.fog;\n    return this;\n  }\n}\nclass MeshToonMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isMeshToonMaterial = true;\n    this.defines = {\n      'TOON': ''\n    };\n    this.type = 'MeshToonMaterial';\n    this.color = new Color(0xffffff);\n    this.map = null;\n    this.gradientMap = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.alphaMap = null;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.gradientMap = source.gradientMap;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.alphaMap = source.alphaMap;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.fog = source.fog;\n    return this;\n  }\n}\nclass MeshNormalMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isMeshNormalMaterial = true;\n    this.type = 'MeshNormalMaterial';\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.flatShading = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n}\nclass MeshLambertMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isMeshLambertMaterial = true;\n    this.type = 'MeshLambertMaterial';\n    this.color = new Color(0xffffff); // diffuse\n\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new Euler();\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.flatShading = false;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    this.fog = source.fog;\n    return this;\n  }\n}\nclass MeshDepthMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isMeshDepthMaterial = true;\n    this.type = 'MeshDepthMaterial';\n    this.depthPacking = BasicDepthPacking;\n    this.map = null;\n    this.alphaMap = null;\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.depthPacking = source.depthPacking;\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    return this;\n  }\n}\nclass MeshDistanceMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isMeshDistanceMaterial = true;\n    this.type = 'MeshDistanceMaterial';\n    this.map = null;\n    this.alphaMap = null;\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    return this;\n  }\n}\nclass MeshMatcapMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.isMeshMatcapMaterial = true;\n    this.defines = {\n      'MATCAP': ''\n    };\n    this.type = 'MeshMatcapMaterial';\n    this.color = new Color(0xffffff); // diffuse\n\n    this.matcap = null;\n    this.map = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.alphaMap = null;\n    this.flatShading = false;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.defines = {\n      'MATCAP': ''\n    };\n    this.color.copy(source.color);\n    this.matcap = source.matcap;\n    this.map = source.map;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.alphaMap = source.alphaMap;\n    this.flatShading = source.flatShading;\n    this.fog = source.fog;\n    return this;\n  }\n}\nclass LineDashedMaterial extends LineBasicMaterial {\n  constructor(parameters) {\n    super();\n    this.isLineDashedMaterial = true;\n    this.type = 'LineDashedMaterial';\n    this.scale = 1;\n    this.dashSize = 3;\n    this.gapSize = 1;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.scale = source.scale;\n    this.dashSize = source.dashSize;\n    this.gapSize = source.gapSize;\n    return this;\n  }\n}\n\n// converts an array to a specific type\nfunction convertArray(array, type, forceClone) {\n  if (!array ||\n  // let 'undefined' and 'null' pass\n  !forceClone && array.constructor === type) return array;\n  if (typeof type.BYTES_PER_ELEMENT === 'number') {\n    return new type(array); // create typed array\n  }\n  return Array.prototype.slice.call(array); // create Array\n}\nfunction isTypedArray(object) {\n  return ArrayBuffer.isView(object) && !(object instanceof DataView);\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder(times) {\n  function compareTime(i, j) {\n    return times[i] - times[j];\n  }\n  const n = times.length;\n  const result = new Array(n);\n  for (let i = 0; i !== n; ++i) result[i] = i;\n  result.sort(compareTime);\n  return result;\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray(values, stride, order) {\n  const nValues = values.length;\n  const result = new values.constructor(nValues);\n  for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n    const srcOffset = order[i] * stride;\n    for (let j = 0; j !== stride; ++j) {\n      result[dstOffset++] = values[srcOffset + j];\n    }\n  }\n  return result;\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON(jsonKeys, times, values, valuePropertyName) {\n  let i = 1,\n    key = jsonKeys[0];\n  while (key !== undefined && key[valuePropertyName] === undefined) {\n    key = jsonKeys[i++];\n  }\n  if (key === undefined) return; // no data\n\n  let value = key[valuePropertyName];\n  if (value === undefined) return; // no data\n\n  if (Array.isArray(value)) {\n    do {\n      value = key[valuePropertyName];\n      if (value !== undefined) {\n        times.push(key.time);\n        values.push.apply(values, value); // push all elements\n      }\n      key = jsonKeys[i++];\n    } while (key !== undefined);\n  } else if (value.toArray !== undefined) {\n    // ...assume THREE.Math-ish\n\n    do {\n      value = key[valuePropertyName];\n      if (value !== undefined) {\n        times.push(key.time);\n        value.toArray(values, values.length);\n      }\n      key = jsonKeys[i++];\n    } while (key !== undefined);\n  } else {\n    // otherwise push as-is\n\n    do {\n      value = key[valuePropertyName];\n      if (value !== undefined) {\n        times.push(key.time);\n        values.push(value);\n      }\n      key = jsonKeys[i++];\n    } while (key !== undefined);\n  }\n}\nfunction subclip(sourceClip, name, startFrame, endFrame, fps = 30) {\n  const clip = sourceClip.clone();\n  clip.name = name;\n  const tracks = [];\n  for (let i = 0; i < clip.tracks.length; ++i) {\n    const track = clip.tracks[i];\n    const valueSize = track.getValueSize();\n    const times = [];\n    const values = [];\n    for (let j = 0; j < track.times.length; ++j) {\n      const frame = track.times[j] * fps;\n      if (frame < startFrame || frame >= endFrame) continue;\n      times.push(track.times[j]);\n      for (let k = 0; k < valueSize; ++k) {\n        values.push(track.values[j * valueSize + k]);\n      }\n    }\n    if (times.length === 0) continue;\n    track.times = convertArray(times, track.times.constructor);\n    track.values = convertArray(values, track.values.constructor);\n    tracks.push(track);\n  }\n  clip.tracks = tracks;\n\n  // find minimum .times value across all tracks in the trimmed clip\n\n  let minStartTime = Infinity;\n  for (let i = 0; i < clip.tracks.length; ++i) {\n    if (minStartTime > clip.tracks[i].times[0]) {\n      minStartTime = clip.tracks[i].times[0];\n    }\n  }\n\n  // shift all tracks such that clip begins at t=0\n\n  for (let i = 0; i < clip.tracks.length; ++i) {\n    clip.tracks[i].shift(-1 * minStartTime);\n  }\n  clip.resetDuration();\n  return clip;\n}\nfunction makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {\n  if (fps <= 0) fps = 30;\n  const numTracks = referenceClip.tracks.length;\n  const referenceTime = referenceFrame / fps;\n\n  // Make each track's values relative to the values at the reference frame\n  for (let i = 0; i < numTracks; ++i) {\n    const referenceTrack = referenceClip.tracks[i];\n    const referenceTrackType = referenceTrack.ValueTypeName;\n\n    // Skip this track if it's non-numeric\n    if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;\n\n    // Find the track in the target clip whose name and type matches the reference track\n    const targetTrack = targetClip.tracks.find(function (track) {\n      return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n    });\n    if (targetTrack === undefined) continue;\n    let referenceOffset = 0;\n    const referenceValueSize = referenceTrack.getValueSize();\n    if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n      referenceOffset = referenceValueSize / 3;\n    }\n    let targetOffset = 0;\n    const targetValueSize = targetTrack.getValueSize();\n    if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n      targetOffset = targetValueSize / 3;\n    }\n    const lastIndex = referenceTrack.times.length - 1;\n    let referenceValue;\n\n    // Find the value to subtract out of the track\n    if (referenceTime <= referenceTrack.times[0]) {\n      // Reference frame is earlier than the first keyframe, so just use the first keyframe\n      const startIndex = referenceOffset;\n      const endIndex = referenceValueSize - referenceOffset;\n      referenceValue = referenceTrack.values.slice(startIndex, endIndex);\n    } else if (referenceTime >= referenceTrack.times[lastIndex]) {\n      // Reference frame is after the last keyframe, so just use the last keyframe\n      const startIndex = lastIndex * referenceValueSize + referenceOffset;\n      const endIndex = startIndex + referenceValueSize - referenceOffset;\n      referenceValue = referenceTrack.values.slice(startIndex, endIndex);\n    } else {\n      // Interpolate to the reference value\n      const interpolant = referenceTrack.createInterpolant();\n      const startIndex = referenceOffset;\n      const endIndex = referenceValueSize - referenceOffset;\n      interpolant.evaluate(referenceTime);\n      referenceValue = interpolant.resultBuffer.slice(startIndex, endIndex);\n    }\n\n    // Conjugate the quaternion\n    if (referenceTrackType === 'quaternion') {\n      const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n      referenceQuat.toArray(referenceValue);\n    }\n\n    // Subtract the reference value from all of the track values\n\n    const numTimes = targetTrack.times.length;\n    for (let j = 0; j < numTimes; ++j) {\n      const valueStart = j * targetValueSize + targetOffset;\n      if (referenceTrackType === 'quaternion') {\n        // Multiply the conjugate for quaternion track types\n        Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n      } else {\n        const valueEnd = targetValueSize - targetOffset * 2;\n\n        // Subtract each value for all other numeric track types\n        for (let k = 0; k < valueEnd; ++k) {\n          targetTrack.values[valueStart + k] -= referenceValue[k];\n        }\n      }\n    }\n  }\n  targetClip.blendMode = AdditiveAnimationBlendMode;\n  return targetClip;\n}\nconst AnimationUtils = {\n  convertArray: convertArray,\n  isTypedArray: isTypedArray,\n  getKeyframeOrder: getKeyframeOrder,\n  sortedArray: sortedArray,\n  flattenJSON: flattenJSON,\n  subclip: subclip,\n  makeClipAdditive: makeClipAdditive\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    this.parameterPositions = parameterPositions;\n    this._cachedIndex = 0;\n    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);\n    this.sampleValues = sampleValues;\n    this.valueSize = sampleSize;\n    this.settings = null;\n    this.DefaultSettings_ = {};\n  }\n  evaluate(t) {\n    const pp = this.parameterPositions;\n    let i1 = this._cachedIndex,\n      t1 = pp[i1],\n      t0 = pp[i1 - 1];\n    validate_interval: {\n      seek: {\n        let right;\n        linear_scan: {\n          //- See http://jsperf.com/comparison-to-undefined/3\n          //- slower code:\n          //-\n          //- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n          forward_scan: if (!(t < t1)) {\n            for (let giveUpAt = i1 + 2;;) {\n              if (t1 === undefined) {\n                if (t < t0) break forward_scan;\n\n                // after end\n\n                i1 = pp.length;\n                this._cachedIndex = i1;\n                return this.copySampleValue_(i1 - 1);\n              }\n              if (i1 === giveUpAt) break; // this loop\n\n              t0 = t1;\n              t1 = pp[++i1];\n              if (t < t1) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            }\n\n            // prepare binary search on the right side of the index\n            right = pp.length;\n            break linear_scan;\n          }\n\n          //- slower code:\n          //-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n          if (!(t >= t0)) {\n            // looping?\n\n            const t1global = pp[1];\n            if (t < t1global) {\n              i1 = 2; // + 1, using the scan for the details\n              t0 = t1global;\n            }\n\n            // linear reverse scan\n\n            for (let giveUpAt = i1 - 2;;) {\n              if (t0 === undefined) {\n                // before start\n\n                this._cachedIndex = 0;\n                return this.copySampleValue_(0);\n              }\n              if (i1 === giveUpAt) break; // this loop\n\n              t1 = t0;\n              t0 = pp[--i1 - 1];\n              if (t >= t0) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            }\n\n            // prepare binary search on the left side of the index\n            right = i1;\n            i1 = 0;\n            break linear_scan;\n          }\n\n          // the interval is valid\n\n          break validate_interval;\n        } // linear scan\n\n        // binary search\n\n        while (i1 < right) {\n          const mid = i1 + right >>> 1;\n          if (t < pp[mid]) {\n            right = mid;\n          } else {\n            i1 = mid + 1;\n          }\n        }\n        t1 = pp[i1];\n        t0 = pp[i1 - 1];\n\n        // check boundary cases, again\n\n        if (t0 === undefined) {\n          this._cachedIndex = 0;\n          return this.copySampleValue_(0);\n        }\n        if (t1 === undefined) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n          return this.copySampleValue_(i1 - 1);\n        }\n      } // seek\n\n      this._cachedIndex = i1;\n      this.intervalChanged_(i1, t0, t1);\n    } // validate_interval\n\n    return this.interpolate_(i1, t0, t, t1);\n  }\n  getSettings_() {\n    return this.settings || this.DefaultSettings_;\n  }\n  copySampleValue_(index) {\n    // copies a sample value to the result buffer\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      stride = this.valueSize,\n      offset = index * stride;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n\n  // Template methods for derived classes:\n\n  interpolate_(/* i1, t0, t, t1 */\n  ) {\n    throw new Error('call to abstract method');\n    // implementations shall return this.resultBuffer\n  }\n  intervalChanged_(/* i1, t0, t1 */\n  ) {\n\n    // empty\n  }\n}\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this._weightPrev = -0;\n    this._offsetPrev = -0;\n    this._weightNext = -0;\n    this._offsetNext = -0;\n    this.DefaultSettings_ = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n  }\n  intervalChanged_(i1, t0, t1) {\n    const pp = this.parameterPositions;\n    let iPrev = i1 - 2,\n      iNext = i1 + 1,\n      tPrev = pp[iPrev],\n      tNext = pp[iNext];\n    if (tPrev === undefined) {\n      switch (this.getSettings_().endingStart) {\n        case ZeroSlopeEnding:\n          // f'(t0) = 0\n          iPrev = i1;\n          tPrev = 2 * t0 - t1;\n          break;\n        case WrapAroundEnding:\n          // use the other end of the curve\n          iPrev = pp.length - 2;\n          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n          break;\n        default:\n          // ZeroCurvatureEnding\n\n          // f''(t0) = 0 a.k.a. Natural Spline\n          iPrev = i1;\n          tPrev = t1;\n      }\n    }\n    if (tNext === undefined) {\n      switch (this.getSettings_().endingEnd) {\n        case ZeroSlopeEnding:\n          // f'(tN) = 0\n          iNext = i1;\n          tNext = 2 * t1 - t0;\n          break;\n        case WrapAroundEnding:\n          // use the other end of the curve\n          iNext = 1;\n          tNext = t1 + pp[1] - pp[0];\n          break;\n        default:\n          // ZeroCurvatureEnding\n\n          // f''(tN) = 0, a.k.a. Natural Spline\n          iNext = i1 - 1;\n          tNext = t0;\n      }\n    }\n    const halfDt = (t1 - t0) * 0.5,\n      stride = this.valueSize;\n    this._weightPrev = halfDt / (t0 - tPrev);\n    this._weightNext = halfDt / (tNext - t1);\n    this._offsetPrev = iPrev * stride;\n    this._offsetNext = iNext * stride;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      stride = this.valueSize,\n      o1 = i1 * stride,\n      o0 = o1 - stride,\n      oP = this._offsetPrev,\n      oN = this._offsetNext,\n      wP = this._weightPrev,\n      wN = this._weightNext,\n      p = (t - t0) / (t1 - t0),\n      pp = p * p,\n      ppp = pp * p;\n\n    // evaluate polynomials\n\n    const sP = -wP * ppp + 2 * wP * pp - wP * p;\n    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const sN = wN * ppp - wN * pp;\n\n    // combine data linearly\n\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];\n    }\n    return result;\n  }\n}\nclass LinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      stride = this.valueSize,\n      offset1 = i1 * stride,\n      offset0 = offset1 - stride,\n      weight1 = (t - t0) / (t1 - t0),\n      weight0 = 1 - weight1;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n    }\n    return result;\n  }\n}\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  interpolate_(i1 /*, t0, t, t1 */) {\n    return this.copySampleValue_(i1 - 1);\n  }\n}\nclass KeyframeTrack {\n  constructor(name, times, values, interpolation) {\n    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');\n    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);\n    this.name = name;\n    this.times = convertArray(times, this.TimeBufferType);\n    this.values = convertArray(values, this.ValueBufferType);\n    this.setInterpolation(interpolation || this.DefaultInterpolation);\n  }\n\n  // Serialization (in static context, because of constructor invocation\n  // and automatic invocation of .toJSON):\n\n  static toJSON(track) {\n    const trackType = track.constructor;\n    let json;\n\n    // derived classes can define a static toJSON method\n    if (trackType.toJSON !== this.toJSON) {\n      json = trackType.toJSON(track);\n    } else {\n      // by default, we assume the data can be serialized as-is\n      json = {\n        'name': track.name,\n        'times': convertArray(track.times, Array),\n        'values': convertArray(track.values, Array)\n      };\n      const interpolation = track.getInterpolation();\n      if (interpolation !== track.DefaultInterpolation) {\n        json.interpolation = interpolation;\n      }\n    }\n    json.type = track.ValueTypeName; // mandatory\n\n    return json;\n  }\n  InterpolantFactoryMethodDiscrete(result) {\n    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  InterpolantFactoryMethodLinear(result) {\n    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  InterpolantFactoryMethodSmooth(result) {\n    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  setInterpolation(interpolation) {\n    let factoryMethod;\n    switch (interpolation) {\n      case InterpolateDiscrete:\n        factoryMethod = this.InterpolantFactoryMethodDiscrete;\n        break;\n      case InterpolateLinear:\n        factoryMethod = this.InterpolantFactoryMethodLinear;\n        break;\n      case InterpolateSmooth:\n        factoryMethod = this.InterpolantFactoryMethodSmooth;\n        break;\n    }\n    if (factoryMethod === undefined) {\n      const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;\n      if (this.createInterpolant === undefined) {\n        // fall back to default, unless the default itself is messed up\n        if (interpolation !== this.DefaultInterpolation) {\n          this.setInterpolation(this.DefaultInterpolation);\n        } else {\n          throw new Error(message); // fatal, in this case\n        }\n      }\n      console.warn('THREE.KeyframeTrack:', message);\n      return this;\n    }\n    this.createInterpolant = factoryMethod;\n    return this;\n  }\n  getInterpolation() {\n    switch (this.createInterpolant) {\n      case this.InterpolantFactoryMethodDiscrete:\n        return InterpolateDiscrete;\n      case this.InterpolantFactoryMethodLinear:\n        return InterpolateLinear;\n      case this.InterpolantFactoryMethodSmooth:\n        return InterpolateSmooth;\n    }\n  }\n  getValueSize() {\n    return this.values.length / this.times.length;\n  }\n\n  // move all keyframes either forwards or backwards in time\n  shift(timeOffset) {\n    if (timeOffset !== 0.0) {\n      const times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] += timeOffset;\n      }\n    }\n    return this;\n  }\n\n  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n  scale(timeScale) {\n    if (timeScale !== 1.0) {\n      const times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] *= timeScale;\n      }\n    }\n    return this;\n  }\n\n  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n  trim(startTime, endTime) {\n    const times = this.times,\n      nKeys = times.length;\n    let from = 0,\n      to = nKeys - 1;\n    while (from !== nKeys && times[from] < startTime) {\n      ++from;\n    }\n    while (to !== -1 && times[to] > endTime) {\n      --to;\n    }\n    ++to; // inclusive -> exclusive bound\n\n    if (from !== 0 || to !== nKeys) {\n      // empty tracks are forbidden, so keep at least one keyframe\n      if (from >= to) {\n        to = Math.max(to, 1);\n        from = to - 1;\n      }\n      const stride = this.getValueSize();\n      this.times = times.slice(from, to);\n      this.values = this.values.slice(from * stride, to * stride);\n    }\n    return this;\n  }\n\n  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n  validate() {\n    let valid = true;\n    const valueSize = this.getValueSize();\n    if (valueSize - Math.floor(valueSize) !== 0) {\n      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);\n      valid = false;\n    }\n    const times = this.times,\n      values = this.values,\n      nKeys = times.length;\n    if (nKeys === 0) {\n      console.error('THREE.KeyframeTrack: Track is empty.', this);\n      valid = false;\n    }\n    let prevTime = null;\n    for (let i = 0; i !== nKeys; i++) {\n      const currTime = times[i];\n      if (typeof currTime === 'number' && isNaN(currTime)) {\n        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);\n        valid = false;\n        break;\n      }\n      if (prevTime !== null && prevTime > currTime) {\n        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);\n        valid = false;\n        break;\n      }\n      prevTime = currTime;\n    }\n    if (values !== undefined) {\n      if (isTypedArray(values)) {\n        for (let i = 0, n = values.length; i !== n; ++i) {\n          const value = values[i];\n          if (isNaN(value)) {\n            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);\n            valid = false;\n            break;\n          }\n        }\n      }\n    }\n    return valid;\n  }\n\n  // removes equivalent sequential keys as common in morph target sequences\n  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n  optimize() {\n    // times or values may be shared with other tracks, so overwriting is unsafe\n    const times = this.times.slice(),\n      values = this.values.slice(),\n      stride = this.getValueSize(),\n      smoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n      lastIndex = times.length - 1;\n    let writeIndex = 1;\n    for (let i = 1; i < lastIndex; ++i) {\n      let keep = false;\n      const time = times[i];\n      const timeNext = times[i + 1];\n\n      // remove adjacent keyframes scheduled at the same time\n\n      if (time !== timeNext && (i !== 1 || time !== times[0])) {\n        if (!smoothInterpolation) {\n          // remove unnecessary keyframes same as their neighbors\n\n          const offset = i * stride,\n            offsetP = offset - stride,\n            offsetN = offset + stride;\n          for (let j = 0; j !== stride; ++j) {\n            const value = values[offset + j];\n            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n              keep = true;\n              break;\n            }\n          }\n        } else {\n          keep = true;\n        }\n      }\n\n      // in-place compaction\n\n      if (keep) {\n        if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n          const readOffset = i * stride,\n            writeOffset = writeIndex * stride;\n          for (let j = 0; j !== stride; ++j) {\n            values[writeOffset + j] = values[readOffset + j];\n          }\n        }\n        ++writeIndex;\n      }\n    }\n\n    // flush last keyframe (compaction looks ahead)\n\n    if (lastIndex > 0) {\n      times[writeIndex] = times[lastIndex];\n      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n        values[writeOffset + j] = values[readOffset + j];\n      }\n      ++writeIndex;\n    }\n    if (writeIndex !== times.length) {\n      this.times = times.slice(0, writeIndex);\n      this.values = values.slice(0, writeIndex * stride);\n    } else {\n      this.times = times;\n      this.values = values;\n    }\n    return this;\n  }\n  clone() {\n    const times = this.times.slice();\n    const values = this.values.slice();\n    const TypedKeyframeTrack = this.constructor;\n    const track = new TypedKeyframeTrack(this.name, times, values);\n\n    // Interpolant argument to constructor is not saved, so copy the factory method directly.\n    track.createInterpolant = this.createInterpolant;\n    return track;\n  }\n}\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {\n  // No interpolation parameter because only InterpolateDiscrete is valid.\n  constructor(name, times, values) {\n    super(name, times, values);\n  }\n}\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      stride = this.valueSize,\n      alpha = (t - t0) / (t1 - t0);\n    let offset = i1 * stride;\n    for (let end = offset + stride; offset !== end; offset += 4) {\n      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);\n    }\n    return result;\n  }\n}\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n  InterpolantFactoryMethodLinear(result) {\n    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n}\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\n// DefaultInterpolation is inherited;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {\n  // No interpolation parameter because only InterpolateDiscrete is valid.\n  constructor(name, times, values) {\n    super(name, times, values);\n  }\n}\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\nclass AnimationClip {\n  constructor(name = '', duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {\n    this.name = name;\n    this.tracks = tracks;\n    this.duration = duration;\n    this.blendMode = blendMode;\n    this.uuid = generateUUID();\n\n    // this means it should figure out its duration by scanning the tracks\n    if (this.duration < 0) {\n      this.resetDuration();\n    }\n  }\n  static parse(json) {\n    const tracks = [],\n      jsonTracks = json.tracks,\n      frameTime = 1.0 / (json.fps || 1.0);\n    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n    }\n    const clip = new this(json.name, json.duration, tracks, json.blendMode);\n    clip.uuid = json.uuid;\n    return clip;\n  }\n  static toJSON(clip) {\n    const tracks = [],\n      clipTracks = clip.tracks;\n    const json = {\n      'name': clip.name,\n      'duration': clip.duration,\n      'tracks': tracks,\n      'uuid': clip.uuid,\n      'blendMode': clip.blendMode\n    };\n    for (let i = 0, n = clipTracks.length; i !== n; ++i) {\n      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n    }\n    return json;\n  }\n  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n    const numMorphTargets = morphTargetSequence.length;\n    const tracks = [];\n    for (let i = 0; i < numMorphTargets; i++) {\n      let times = [];\n      let values = [];\n      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n      values.push(0, 1, 0);\n      const order = getKeyframeOrder(times);\n      times = sortedArray(times, 1, order);\n      values = sortedArray(values, 1, order);\n\n      // if there is a key at the first frame, duplicate it as the\n      // last frame as well for perfect loop.\n      if (!noLoop && times[0] === 0) {\n        times.push(numMorphTargets);\n        values.push(values[0]);\n      }\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\n    }\n    return new this(name, -1, tracks);\n  }\n  static findByName(objectOrClipArray, name) {\n    let clipArray = objectOrClipArray;\n    if (!Array.isArray(objectOrClipArray)) {\n      const o = objectOrClipArray;\n      clipArray = o.geometry && o.geometry.animations || o.animations;\n    }\n    for (let i = 0; i < clipArray.length; i++) {\n      if (clipArray[i].name === name) {\n        return clipArray[i];\n      }\n    }\n    return null;\n  }\n  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n    const animationToMorphTargets = {};\n\n    // tested with https://regex101.com/ on trick sequences\n    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n    const pattern = /^([\\w-]*?)([\\d]+)$/;\n\n    // sort morph target names into animation groups based\n    // patterns like Walk_001, Walk_002, Run_001, Run_002\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = morphTargets[i];\n      const parts = morphTarget.name.match(pattern);\n      if (parts && parts.length > 1) {\n        const name = parts[1];\n        let animationMorphTargets = animationToMorphTargets[name];\n        if (!animationMorphTargets) {\n          animationToMorphTargets[name] = animationMorphTargets = [];\n        }\n        animationMorphTargets.push(morphTarget);\n      }\n    }\n    const clips = [];\n    for (const name in animationToMorphTargets) {\n      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n    }\n    return clips;\n  }\n\n  // parse the animation.hierarchy format\n  static parseAnimation(animation, bones) {\n    if (!animation) {\n      console.error('THREE.AnimationClip: No animation in JSONLoader data.');\n      return null;\n    }\n    const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {\n      // only return track if there are actually keys.\n      if (animationKeys.length !== 0) {\n        const times = [];\n        const values = [];\n        flattenJSON(animationKeys, times, values, propertyName);\n\n        // empty keys are filtered out, so check again\n        if (times.length !== 0) {\n          destTracks.push(new trackType(trackName, times, values));\n        }\n      }\n    };\n    const tracks = [];\n    const clipName = animation.name || 'default';\n    const fps = animation.fps || 30;\n    const blendMode = animation.blendMode;\n\n    // automatic length determination in AnimationClip.\n    let duration = animation.length || -1;\n    const hierarchyTracks = animation.hierarchy || [];\n    for (let h = 0; h < hierarchyTracks.length; h++) {\n      const animationKeys = hierarchyTracks[h].keys;\n\n      // skip empty tracks\n      if (!animationKeys || animationKeys.length === 0) continue;\n\n      // process morph targets\n      if (animationKeys[0].morphTargets) {\n        // figure out all morph targets used in this track\n        const morphTargetNames = {};\n        let k;\n        for (k = 0; k < animationKeys.length; k++) {\n          if (animationKeys[k].morphTargets) {\n            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n            }\n          }\n        }\n\n        // create a track for each morph target with all zero\n        // morphTargetInfluences except for the keys in which\n        // the morphTarget is named.\n        for (const morphTargetName in morphTargetNames) {\n          const times = [];\n          const values = [];\n          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n            const animationKey = animationKeys[k];\n            times.push(animationKey.time);\n            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n          }\n          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\n        }\n        duration = morphTargetNames.length * fps;\n      } else {\n        // ...assume skeletal animation\n\n        const boneName = '.bones[' + bones[h].name + ']';\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\n        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\n      }\n    }\n    if (tracks.length === 0) {\n      return null;\n    }\n    const clip = new this(clipName, duration, tracks, blendMode);\n    return clip;\n  }\n  resetDuration() {\n    const tracks = this.tracks;\n    let duration = 0;\n    for (let i = 0, n = tracks.length; i !== n; ++i) {\n      const track = this.tracks[i];\n      duration = Math.max(duration, track.times[track.times.length - 1]);\n    }\n    this.duration = duration;\n    return this;\n  }\n  trim() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].trim(0, this.duration);\n    }\n    return this;\n  }\n  validate() {\n    let valid = true;\n    for (let i = 0; i < this.tracks.length; i++) {\n      valid = valid && this.tracks[i].validate();\n    }\n    return valid;\n  }\n  optimize() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].optimize();\n    }\n    return this;\n  }\n  clone() {\n    const tracks = [];\n    for (let i = 0; i < this.tracks.length; i++) {\n      tracks.push(this.tracks[i].clone());\n    }\n    return new this.constructor(this.name, this.duration, tracks, this.blendMode);\n  }\n  toJSON() {\n    return this.constructor.toJSON(this);\n  }\n}\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case 'scalar':\n    case 'double':\n    case 'float':\n    case 'number':\n    case 'integer':\n      return NumberKeyframeTrack;\n    case 'vector':\n    case 'vector2':\n    case 'vector3':\n    case 'vector4':\n      return VectorKeyframeTrack;\n    case 'color':\n      return ColorKeyframeTrack;\n    case 'quaternion':\n      return QuaternionKeyframeTrack;\n    case 'bool':\n    case 'boolean':\n      return BooleanKeyframeTrack;\n    case 'string':\n      return StringKeyframeTrack;\n  }\n  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n}\nfunction parseKeyframeTrack(json) {\n  if (json.type === undefined) {\n    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n  }\n  const trackType = getTrackTypeForValueTypeName(json.type);\n  if (json.times === undefined) {\n    const times = [],\n      values = [];\n    flattenJSON(json.keys, times, values, 'value');\n    json.times = times;\n    json.values = values;\n  }\n\n  // derived classes can define a static parse method\n  if (trackType.parse !== undefined) {\n    return trackType.parse(json);\n  } else {\n    // by default, we assume a constructor compatible with the base\n    return new trackType(json.name, json.times, json.values, json.interpolation);\n  }\n}\nconst Cache = {\n  enabled: false,\n  files: {},\n  add: function (key, file) {\n    if (this.enabled === false) return;\n\n    // console.log( 'THREE.Cache', 'Adding key:', key );\n\n    this.files[key] = file;\n  },\n  get: function (key) {\n    if (this.enabled === false) return;\n\n    // console.log( 'THREE.Cache', 'Checking key:', key );\n\n    return this.files[key];\n  },\n  remove: function (key) {\n    delete this.files[key];\n  },\n  clear: function () {\n    this.files = {};\n  }\n};\nclass LoadingManager {\n  constructor(onLoad, onProgress, onError) {\n    const scope = this;\n    let isLoading = false;\n    let itemsLoaded = 0;\n    let itemsTotal = 0;\n    let urlModifier = undefined;\n    const handlers = [];\n\n    // Refer to #5689 for the reason why we don't set .onStart\n    // in the constructor\n\n    this.onStart = undefined;\n    this.onLoad = onLoad;\n    this.onProgress = onProgress;\n    this.onError = onError;\n    this.itemStart = function (url) {\n      itemsTotal++;\n      if (isLoading === false) {\n        if (scope.onStart !== undefined) {\n          scope.onStart(url, itemsLoaded, itemsTotal);\n        }\n      }\n      isLoading = true;\n    };\n    this.itemEnd = function (url) {\n      itemsLoaded++;\n      if (scope.onProgress !== undefined) {\n        scope.onProgress(url, itemsLoaded, itemsTotal);\n      }\n      if (itemsLoaded === itemsTotal) {\n        isLoading = false;\n        if (scope.onLoad !== undefined) {\n          scope.onLoad();\n        }\n      }\n    };\n    this.itemError = function (url) {\n      if (scope.onError !== undefined) {\n        scope.onError(url);\n      }\n    };\n    this.resolveURL = function (url) {\n      if (urlModifier) {\n        return urlModifier(url);\n      }\n      return url;\n    };\n    this.setURLModifier = function (transform) {\n      urlModifier = transform;\n      return this;\n    };\n    this.addHandler = function (regex, loader) {\n      handlers.push(regex, loader);\n      return this;\n    };\n    this.removeHandler = function (regex) {\n      const index = handlers.indexOf(regex);\n      if (index !== -1) {\n        handlers.splice(index, 2);\n      }\n      return this;\n    };\n    this.getHandler = function (file) {\n      for (let i = 0, l = handlers.length; i < l; i += 2) {\n        const regex = handlers[i];\n        const loader = handlers[i + 1];\n        if (regex.global) regex.lastIndex = 0; // see #17920\n\n        if (regex.test(file)) {\n          return loader;\n        }\n      }\n      return null;\n    };\n  }\n}\nconst DefaultLoadingManager = /*@__PURE__*/new LoadingManager();\nclass Loader {\n  constructor(manager) {\n    this.manager = manager !== undefined ? manager : DefaultLoadingManager;\n    this.crossOrigin = 'anonymous';\n    this.withCredentials = false;\n    this.path = '';\n    this.resourcePath = '';\n    this.requestHeader = {};\n  }\n  load(/* url, onLoad, onProgress, onError */) {}\n  loadAsync(url, onProgress) {\n    const scope = this;\n    return new Promise(function (resolve, reject) {\n      scope.load(url, resolve, onProgress, reject);\n    });\n  }\n  parse(/* data */) {}\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  setWithCredentials(value) {\n    this.withCredentials = value;\n    return this;\n  }\n  setPath(path) {\n    this.path = path;\n    return this;\n  }\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n  setRequestHeader(requestHeader) {\n    this.requestHeader = requestHeader;\n    return this;\n  }\n}\nLoader.DEFAULT_MATERIAL_NAME = '__DEFAULT';\nconst loading = {};\nclass HttpError extends Error {\n  constructor(message, response) {\n    super(message);\n    this.response = response;\n  }\n}\nclass FileLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const cached = Cache.get(url);\n    if (cached !== undefined) {\n      this.manager.itemStart(url);\n      setTimeout(() => {\n        if (onLoad) onLoad(cached);\n        this.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    }\n\n    // Check if request is duplicate\n\n    if (loading[url] !== undefined) {\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      });\n      return;\n    }\n\n    // Initialise array for duplicate requests\n    loading[url] = [];\n    loading[url].push({\n      onLoad: onLoad,\n      onProgress: onProgress,\n      onError: onError\n    });\n\n    // create request\n    const req = new Request(url, {\n      headers: new Headers(this.requestHeader),\n      credentials: this.withCredentials ? 'include' : 'same-origin'\n      // An abort controller could be added within a future PR\n    });\n\n    // record states ( avoid data race )\n    const mimeType = this.mimeType;\n    const responseType = this.responseType;\n\n    // start the fetch\n    fetch(req).then(response => {\n      if (response.status === 200 || response.status === 0) {\n        // Some browsers return HTTP Status 0 when using non-http protocol\n        // e.g. 'file://' or 'data://'. Handle as success.\n\n        if (response.status === 0) {\n          console.warn('THREE.FileLoader: HTTP Status 0 received.');\n        }\n\n        // Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n        if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {\n          return response;\n        }\n        const callbacks = loading[url];\n        const reader = response.body.getReader();\n\n        // Nginx needs X-File-Size check\n        // https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n        const contentLength = response.headers.get('X-File-Size') || response.headers.get('Content-Length');\n        const total = contentLength ? parseInt(contentLength) : 0;\n        const lengthComputable = total !== 0;\n        let loaded = 0;\n\n        // periodically read data into the new stream tracking while download progress\n        const stream = new ReadableStream({\n          start(controller) {\n            readData();\n            function readData() {\n              reader.read().then(({\n                done,\n                value\n              }) => {\n                if (done) {\n                  controller.close();\n                } else {\n                  loaded += value.byteLength;\n                  const event = new ProgressEvent('progress', {\n                    lengthComputable,\n                    loaded,\n                    total\n                  });\n                  for (let i = 0, il = callbacks.length; i < il; i++) {\n                    const callback = callbacks[i];\n                    if (callback.onProgress) callback.onProgress(event);\n                  }\n                  controller.enqueue(value);\n                  readData();\n                }\n              }, e => {\n                controller.error(e);\n              });\n            }\n          }\n        });\n        return new Response(stream);\n      } else {\n        throw new HttpError(`fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response);\n      }\n    }).then(response => {\n      switch (responseType) {\n        case 'arraybuffer':\n          return response.arrayBuffer();\n        case 'blob':\n          return response.blob();\n        case 'document':\n          return response.text().then(text => {\n            const parser = new DOMParser();\n            return parser.parseFromString(text, mimeType);\n          });\n        case 'json':\n          return response.json();\n        default:\n          if (mimeType === undefined) {\n            return response.text();\n          } else {\n            // sniff encoding\n            const re = /charset=\"?([^;\"\\s]*)\"?/i;\n            const exec = re.exec(mimeType);\n            const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;\n            const decoder = new TextDecoder(label);\n            return response.arrayBuffer().then(ab => decoder.decode(ab));\n          }\n      }\n    }).then(data => {\n      // Add to cache only on HTTP success, so that we do not cache\n      // error response bodies as proper responses to requests.\n      Cache.add(url, data);\n      const callbacks = loading[url];\n      delete loading[url];\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onLoad) callback.onLoad(data);\n      }\n    }).catch(err => {\n      // Abort errors and other errors are handled the same\n\n      const callbacks = loading[url];\n      if (callbacks === undefined) {\n        // When onLoad was called and url was deleted in `loading`\n        this.manager.itemError(url);\n        throw err;\n      }\n      delete loading[url];\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onError) callback.onError(err);\n      }\n      this.manager.itemError(url);\n    }).finally(() => {\n      this.manager.itemEnd(url);\n    });\n    this.manager.itemStart(url);\n  }\n  setResponseType(value) {\n    this.responseType = value;\n    return this;\n  }\n  setMimeType(value) {\n    this.mimeType = value;\n    return this;\n  }\n}\nclass AnimationLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(json) {\n    const animations = [];\n    for (let i = 0; i < json.length; i++) {\n      const clip = AnimationClip.parse(json[i]);\n      animations.push(clip);\n    }\n    return animations;\n  }\n}\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const images = [];\n    const texture = new CompressedTexture();\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    let loaded = 0;\n    function loadTexture(i) {\n      loader.load(url[i], function (buffer) {\n        const texDatas = scope.parse(buffer, true);\n        images[i] = {\n          width: texDatas.width,\n          height: texDatas.height,\n          format: texDatas.format,\n          mipmaps: texDatas.mipmaps\n        };\n        loaded += 1;\n        if (loaded === 6) {\n          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n          texture.image = images;\n          texture.format = texDatas.format;\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, onProgress, onError);\n    }\n    if (Array.isArray(url)) {\n      for (let i = 0, il = url.length; i < il; ++i) {\n        loadTexture(i);\n      }\n    } else {\n      // compressed cubemap texture stored in a single DDS file\n\n      loader.load(url, function (buffer) {\n        const texDatas = scope.parse(buffer, true);\n        if (texDatas.isCubemap) {\n          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n          for (let f = 0; f < faces; f++) {\n            images[f] = {\n              mipmaps: []\n            };\n            for (let i = 0; i < texDatas.mipmapCount; i++) {\n              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n              images[f].format = texDatas.format;\n              images[f].width = texDatas.width;\n              images[f].height = texDatas.height;\n            }\n          }\n          texture.image = images;\n        } else {\n          texture.image.width = texDatas.width;\n          texture.image.height = texDatas.height;\n          texture.mipmaps = texDatas.mipmaps;\n        }\n        if (texDatas.mipmapCount === 1) {\n          texture.minFilter = LinearFilter;\n        }\n        texture.format = texDatas.format;\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onProgress, onError);\n    }\n    return texture;\n  }\n}\nclass ImageLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const scope = this;\n    const cached = Cache.get(url);\n    if (cached !== undefined) {\n      scope.manager.itemStart(url);\n      setTimeout(function () {\n        if (onLoad) onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    }\n    const image = createElementNS('img');\n    function onImageLoad() {\n      removeEventListeners();\n      Cache.add(url, this);\n      if (onLoad) onLoad(this);\n      scope.manager.itemEnd(url);\n    }\n    function onImageError(event) {\n      removeEventListeners();\n      if (onError) onError(event);\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    }\n    function removeEventListeners() {\n      image.removeEventListener('load', onImageLoad, false);\n      image.removeEventListener('error', onImageError, false);\n    }\n    image.addEventListener('load', onImageLoad, false);\n    image.addEventListener('error', onImageError, false);\n    if (url.slice(0, 5) !== 'data:') {\n      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;\n    }\n    scope.manager.itemStart(url);\n    image.src = url;\n    return image;\n  }\n}\nclass CubeTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(urls, onLoad, onProgress, onError) {\n    const texture = new CubeTexture();\n    texture.colorSpace = SRGBColorSpace;\n    const loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n    let loaded = 0;\n    function loadTexture(i) {\n      loader.load(urls[i], function (image) {\n        texture.images[i] = image;\n        loaded++;\n        if (loaded === 6) {\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, undefined, onError);\n    }\n    for (let i = 0; i < urls.length; ++i) {\n      loadTexture(i);\n    }\n    return texture;\n  }\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass DataTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const texture = new DataTexture();\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      let texData;\n      try {\n        texData = scope.parse(buffer);\n      } catch (error) {\n        if (onError !== undefined) {\n          onError(error);\n        } else {\n          console.error(error);\n          return;\n        }\n      }\n      if (texData.image !== undefined) {\n        texture.image = texData.image;\n      } else if (texData.data !== undefined) {\n        texture.image.width = texData.width;\n        texture.image.height = texData.height;\n        texture.image.data = texData.data;\n      }\n      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n      if (texData.colorSpace !== undefined) {\n        texture.colorSpace = texData.colorSpace;\n      }\n      if (texData.flipY !== undefined) {\n        texture.flipY = texData.flipY;\n      }\n      if (texData.format !== undefined) {\n        texture.format = texData.format;\n      }\n      if (texData.type !== undefined) {\n        texture.type = texData.type;\n      }\n      if (texData.mipmaps !== undefined) {\n        texture.mipmaps = texData.mipmaps;\n        texture.minFilter = LinearMipmapLinearFilter; // presumably...\n      }\n      if (texData.mipmapCount === 1) {\n        texture.minFilter = LinearFilter;\n      }\n      if (texData.generateMipmaps !== undefined) {\n        texture.generateMipmaps = texData.generateMipmaps;\n      }\n      texture.needsUpdate = true;\n      if (onLoad) onLoad(texture, texData);\n    }, onProgress, onError);\n    return texture;\n  }\n}\nclass TextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const texture = new Texture();\n    const loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n    loader.load(url, function (image) {\n      texture.image = image;\n      texture.needsUpdate = true;\n      if (onLoad !== undefined) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n    return texture;\n  }\n}\nclass Light extends Object3D {\n  constructor(color, intensity = 1) {\n    super();\n    this.isLight = true;\n    this.type = 'Light';\n    this.color = new Color(color);\n    this.intensity = intensity;\n  }\n  dispose() {\n\n    // Empty here in base class; some subclasses override.\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.color.copy(source.color);\n    this.intensity = source.intensity;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.color = this.color.getHex();\n    data.object.intensity = this.intensity;\n    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();\n    if (this.distance !== undefined) data.object.distance = this.distance;\n    if (this.angle !== undefined) data.object.angle = this.angle;\n    if (this.decay !== undefined) data.object.decay = this.decay;\n    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;\n    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();\n    if (this.target !== undefined) data.object.target = this.target.uuid;\n    return data;\n  }\n}\nclass HemisphereLight extends Light {\n  constructor(skyColor, groundColor, intensity) {\n    super(skyColor, intensity);\n    this.isHemisphereLight = true;\n    this.type = 'HemisphereLight';\n    this.position.copy(Object3D.DEFAULT_UP);\n    this.updateMatrix();\n    this.groundColor = new Color(groundColor);\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.groundColor.copy(source.groundColor);\n    return this;\n  }\n}\nconst _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/new Vector3();\nclass LightShadow {\n  constructor(camera) {\n    this.camera = camera;\n    this.intensity = 1;\n    this.bias = 0;\n    this.normalBias = 0;\n    this.radius = 1;\n    this.blurSamples = 8;\n    this.mapSize = new Vector2(512, 512);\n    this.map = null;\n    this.mapPass = null;\n    this.matrix = new Matrix4();\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n    this._frustum = new Frustum();\n    this._frameExtents = new Vector2(1, 1);\n    this._viewportCount = 1;\n    this._viewports = [new Vector4(0, 0, 1, 1)];\n  }\n  getViewportCount() {\n    return this._viewportCount;\n  }\n  getFrustum() {\n    return this._frustum;\n  }\n  updateMatrices(light) {\n    const shadowCamera = this.camera;\n    const shadowMatrix = this.matrix;\n    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n    shadowCamera.position.copy(_lightPositionWorld$1);\n    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n    shadowCamera.lookAt(_lookTarget$1);\n    shadowCamera.updateMatrixWorld();\n    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    shadowMatrix.multiply(_projScreenMatrix$1);\n  }\n  getViewport(viewportIndex) {\n    return this._viewports[viewportIndex];\n  }\n  getFrameExtents() {\n    return this._frameExtents;\n  }\n  dispose() {\n    if (this.map) {\n      this.map.dispose();\n    }\n    if (this.mapPass) {\n      this.mapPass.dispose();\n    }\n  }\n  copy(source) {\n    this.camera = source.camera.clone();\n    this.intensity = source.intensity;\n    this.bias = source.bias;\n    this.radius = source.radius;\n    this.mapSize.copy(source.mapSize);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  toJSON() {\n    const object = {};\n    if (this.intensity !== 1) object.intensity = this.intensity;\n    if (this.bias !== 0) object.bias = this.bias;\n    if (this.normalBias !== 0) object.normalBias = this.normalBias;\n    if (this.radius !== 1) object.radius = this.radius;\n    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();\n    object.camera = this.camera.toJSON(false).object;\n    delete object.camera.matrix;\n    return object;\n  }\n}\nclass SpotLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(50, 1, 0.5, 500));\n    this.isSpotLightShadow = true;\n    this.focus = 1;\n  }\n  updateMatrices(light) {\n    const camera = this.camera;\n    const fov = RAD2DEG * 2 * light.angle * this.focus;\n    const aspect = this.mapSize.width / this.mapSize.height;\n    const far = light.distance || camera.far;\n    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {\n      camera.fov = fov;\n      camera.aspect = aspect;\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n    super.updateMatrices(light);\n  }\n  copy(source) {\n    super.copy(source);\n    this.focus = source.focus;\n    return this;\n  }\n}\nclass SpotLight extends Light {\n  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {\n    super(color, intensity);\n    this.isSpotLight = true;\n    this.type = 'SpotLight';\n    this.position.copy(Object3D.DEFAULT_UP);\n    this.updateMatrix();\n    this.target = new Object3D();\n    this.distance = distance;\n    this.angle = angle;\n    this.penumbra = penumbra;\n    this.decay = decay;\n    this.map = null;\n    this.shadow = new SpotLightShadow();\n  }\n  get power() {\n    // compute the light's luminous power (in lumens) from its intensity (in candela)\n    // by convention for a spotlight, luminous power (lm) = \u03C0 * luminous intensity (cd)\n    return this.intensity * Math.PI;\n  }\n  set power(power) {\n    // set the light's intensity (in candela) from the desired luminous power (in lumens)\n    this.intensity = power / Math.PI;\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.distance = source.distance;\n    this.angle = source.angle;\n    this.penumbra = source.penumbra;\n    this.decay = source.decay;\n    this.target = source.target.clone();\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n}\nconst _projScreenMatrix = /*@__PURE__*/new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/new Vector3();\nconst _lookTarget = /*@__PURE__*/new Vector3();\nclass PointLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(90, 1, 0.5, 500));\n    this.isPointLightShadow = true;\n    this._frameExtents = new Vector2(4, 2);\n    this._viewportCount = 6;\n    this._viewports = [\n    // These viewports map a cube-map onto a 2D texture with the\n    // following orientation:\n    //\n    //  xzXZ\n    //   y Y\n    //\n    // X - Positive x direction\n    // x - Negative x direction\n    // Y - Positive y direction\n    // y - Negative y direction\n    // Z - Positive z direction\n    // z - Negative z direction\n\n    // positive X\n    new Vector4(2, 1, 1, 1),\n    // negative X\n    new Vector4(0, 1, 1, 1),\n    // positive Z\n    new Vector4(3, 1, 1, 1),\n    // negative Z\n    new Vector4(1, 1, 1, 1),\n    // positive Y\n    new Vector4(3, 0, 1, 1),\n    // negative Y\n    new Vector4(1, 0, 1, 1)];\n    this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];\n    this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];\n  }\n  updateMatrices(light, viewportIndex = 0) {\n    const camera = this.camera;\n    const shadowMatrix = this.matrix;\n    const far = light.distance || camera.far;\n    if (far !== camera.far) {\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n    camera.position.copy(_lightPositionWorld);\n    _lookTarget.copy(camera.position);\n    _lookTarget.add(this._cubeDirections[viewportIndex]);\n    camera.up.copy(this._cubeUps[viewportIndex]);\n    camera.lookAt(_lookTarget);\n    camera.updateMatrixWorld();\n    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix);\n  }\n}\nclass PointLight extends Light {\n  constructor(color, intensity, distance = 0, decay = 2) {\n    super(color, intensity);\n    this.isPointLight = true;\n    this.type = 'PointLight';\n    this.distance = distance;\n    this.decay = decay;\n    this.shadow = new PointLightShadow();\n  }\n  get power() {\n    // compute the light's luminous power (in lumens) from its intensity (in candela)\n    // for an isotropic light source, luminous power (lm) = 4 \u03C0 luminous intensity (cd)\n    return this.intensity * 4 * Math.PI;\n  }\n  set power(power) {\n    // set the light's intensity (in candela) from the desired luminous power (in lumens)\n    this.intensity = power / (4 * Math.PI);\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.distance = source.distance;\n    this.decay = source.decay;\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n}\nclass OrthographicCamera extends Camera {\n  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {\n    super();\n    this.isOrthographicCamera = true;\n    this.type = 'OrthographicCamera';\n    this.zoom = 1;\n    this.view = null;\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n    this.near = near;\n    this.far = far;\n    this.updateProjectionMatrix();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.left = source.left;\n    this.right = source.right;\n    this.top = source.top;\n    this.bottom = source.bottom;\n    this.near = source.near;\n    this.far = source.far;\n    this.zoom = source.zoom;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    return this;\n  }\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n    this.updateProjectionMatrix();\n  }\n  updateProjectionMatrix() {\n    const dx = (this.right - this.left) / (2 * this.zoom);\n    const dy = (this.top - this.bottom) / (2 * this.zoom);\n    const cx = (this.right + this.left) / 2;\n    const cy = (this.top + this.bottom) / 2;\n    let left = cx - dx;\n    let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n    if (this.view !== null && this.view.enabled) {\n      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n      left += scaleW * this.view.offsetX;\n      right = left + scaleW * this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = top - scaleH * this.view.height;\n    }\n    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.zoom = this.zoom;\n    data.object.left = this.left;\n    data.object.right = this.right;\n    data.object.top = this.top;\n    data.object.bottom = this.bottom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    return data;\n  }\n}\nclass DirectionalLightShadow extends LightShadow {\n  constructor() {\n    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n    this.isDirectionalLightShadow = true;\n  }\n}\nclass DirectionalLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n    this.isDirectionalLight = true;\n    this.type = 'DirectionalLight';\n    this.position.copy(Object3D.DEFAULT_UP);\n    this.updateMatrix();\n    this.target = new Object3D();\n    this.shadow = new DirectionalLightShadow();\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source) {\n    super.copy(source);\n    this.target = source.target.clone();\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n}\nclass AmbientLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n    this.isAmbientLight = true;\n    this.type = 'AmbientLight';\n  }\n}\nclass RectAreaLight extends Light {\n  constructor(color, intensity, width = 10, height = 10) {\n    super(color, intensity);\n    this.isRectAreaLight = true;\n    this.type = 'RectAreaLight';\n    this.width = width;\n    this.height = height;\n  }\n  get power() {\n    // compute the light's luminous power (in lumens) from its intensity (in nits)\n    return this.intensity * this.width * this.height * Math.PI;\n  }\n  set power(power) {\n    // set the light's intensity (in nits) from the desired luminous power (in lumens)\n    this.intensity = power / (this.width * this.height * Math.PI);\n  }\n  copy(source) {\n    super.copy(source);\n    this.width = source.width;\n    this.height = source.height;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.width = this.width;\n    data.object.height = this.height;\n    return data;\n  }\n}\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n  constructor() {\n    this.isSphericalHarmonics3 = true;\n    this.coefficients = [];\n    for (let i = 0; i < 9; i++) {\n      this.coefficients.push(new Vector3());\n    }\n  }\n  set(coefficients) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].copy(coefficients[i]);\n    }\n    return this;\n  }\n  zero() {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].set(0, 0, 0);\n    }\n    return this;\n  }\n\n  // get the radiance in the direction of the normal\n  // target is a Vector3\n  getAt(normal, target) {\n    // normal is assumed to be unit length\n\n    const x = normal.x,\n      y = normal.y,\n      z = normal.z;\n    const coeff = this.coefficients;\n\n    // band 0\n    target.copy(coeff[0]).multiplyScalar(0.282095);\n\n    // band 1\n    target.addScaledVector(coeff[1], 0.488603 * y);\n    target.addScaledVector(coeff[2], 0.488603 * z);\n    target.addScaledVector(coeff[3], 0.488603 * x);\n\n    // band 2\n    target.addScaledVector(coeff[4], 1.092548 * (x * y));\n    target.addScaledVector(coeff[5], 1.092548 * (y * z));\n    target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));\n    target.addScaledVector(coeff[7], 1.092548 * (x * z));\n    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));\n    return target;\n  }\n\n  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n  // target is a Vector3\n  // https://graphics.stanford.edu/papers/envmap/envmap.pdf\n  getIrradianceAt(normal, target) {\n    // normal is assumed to be unit length\n\n    const x = normal.x,\n      y = normal.y,\n      z = normal.z;\n    const coeff = this.coefficients;\n\n    // band 0\n    target.copy(coeff[0]).multiplyScalar(0.886227); // \u03C0 * 0.282095\n\n    // band 1\n    target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * \u03C0 / 3 ) * 0.488603\n    target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);\n    target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);\n\n    // band 2\n    target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( \u03C0 / 4 ) * 1.092548\n    target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);\n    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( \u03C0 / 4 ) * 0.315392 * 3\n    target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);\n    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( \u03C0 / 4 ) * 0.546274\n\n    return target;\n  }\n  add(sh) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].add(sh.coefficients[i]);\n    }\n    return this;\n  }\n  addScaledSH(sh, s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].addScaledVector(sh.coefficients[i], s);\n    }\n    return this;\n  }\n  scale(s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].multiplyScalar(s);\n    }\n    return this;\n  }\n  lerp(sh, alpha) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].lerp(sh.coefficients[i], alpha);\n    }\n    return this;\n  }\n  equals(sh) {\n    for (let i = 0; i < 9; i++) {\n      if (!this.coefficients[i].equals(sh.coefficients[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  copy(sh) {\n    return this.set(sh.coefficients);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  fromArray(array, offset = 0) {\n    const coefficients = this.coefficients;\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].fromArray(array, offset + i * 3);\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const coefficients = this.coefficients;\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].toArray(array, offset + i * 3);\n    }\n    return array;\n  }\n\n  // evaluate the basis functions\n  // shBasis is an Array[ 9 ]\n  static getBasisAt(normal, shBasis) {\n    // normal is assumed to be unit length\n\n    const x = normal.x,\n      y = normal.y,\n      z = normal.z;\n\n    // band 0\n    shBasis[0] = 0.282095;\n\n    // band 1\n    shBasis[1] = 0.488603 * y;\n    shBasis[2] = 0.488603 * z;\n    shBasis[3] = 0.488603 * x;\n\n    // band 2\n    shBasis[4] = 1.092548 * x * y;\n    shBasis[5] = 1.092548 * y * z;\n    shBasis[6] = 0.315392 * (3 * z * z - 1);\n    shBasis[7] = 1.092548 * x * z;\n    shBasis[8] = 0.546274 * (x * x - y * y);\n  }\n}\nclass LightProbe extends Light {\n  constructor(sh = new SphericalHarmonics3(), intensity = 1) {\n    super(undefined, intensity);\n    this.isLightProbe = true;\n    this.sh = sh;\n  }\n  copy(source) {\n    super.copy(source);\n    this.sh.copy(source.sh);\n    return this;\n  }\n  fromJSON(json) {\n    this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n    this.sh.fromArray(json.sh);\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.sh = this.sh.toArray();\n    return data;\n  }\n}\nclass MaterialLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.textures = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(json) {\n    const textures = this.textures;\n    function getTexture(name) {\n      if (textures[name] === undefined) {\n        console.warn('THREE.MaterialLoader: Undefined texture', name);\n      }\n      return textures[name];\n    }\n    const material = this.createMaterialFromType(json.type);\n    if (json.uuid !== undefined) material.uuid = json.uuid;\n    if (json.name !== undefined) material.name = json.name;\n    if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);\n    if (json.roughness !== undefined) material.roughness = json.roughness;\n    if (json.metalness !== undefined) material.metalness = json.metalness;\n    if (json.sheen !== undefined) material.sheen = json.sheen;\n    if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);\n    if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;\n    if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);\n    if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);\n    if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;\n    if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);\n    if (json.shininess !== undefined) material.shininess = json.shininess;\n    if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;\n    if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;\n    if (json.dispersion !== undefined) material.dispersion = json.dispersion;\n    if (json.iridescence !== undefined) material.iridescence = json.iridescence;\n    if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;\n    if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;\n    if (json.transmission !== undefined) material.transmission = json.transmission;\n    if (json.thickness !== undefined) material.thickness = json.thickness;\n    if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;\n    if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);\n    if (json.anisotropy !== undefined) material.anisotropy = json.anisotropy;\n    if (json.anisotropyRotation !== undefined) material.anisotropyRotation = json.anisotropyRotation;\n    if (json.fog !== undefined) material.fog = json.fog;\n    if (json.flatShading !== undefined) material.flatShading = json.flatShading;\n    if (json.blending !== undefined) material.blending = json.blending;\n    if (json.combine !== undefined) material.combine = json.combine;\n    if (json.side !== undefined) material.side = json.side;\n    if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;\n    if (json.opacity !== undefined) material.opacity = json.opacity;\n    if (json.transparent !== undefined) material.transparent = json.transparent;\n    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;\n    if (json.alphaHash !== undefined) material.alphaHash = json.alphaHash;\n    if (json.depthFunc !== undefined) material.depthFunc = json.depthFunc;\n    if (json.depthTest !== undefined) material.depthTest = json.depthTest;\n    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;\n    if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;\n    if (json.blendSrc !== undefined) material.blendSrc = json.blendSrc;\n    if (json.blendDst !== undefined) material.blendDst = json.blendDst;\n    if (json.blendEquation !== undefined) material.blendEquation = json.blendEquation;\n    if (json.blendSrcAlpha !== undefined) material.blendSrcAlpha = json.blendSrcAlpha;\n    if (json.blendDstAlpha !== undefined) material.blendDstAlpha = json.blendDstAlpha;\n    if (json.blendEquationAlpha !== undefined) material.blendEquationAlpha = json.blendEquationAlpha;\n    if (json.blendColor !== undefined && material.blendColor !== undefined) material.blendColor.setHex(json.blendColor);\n    if (json.blendAlpha !== undefined) material.blendAlpha = json.blendAlpha;\n    if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;\n    if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;\n    if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;\n    if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;\n    if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;\n    if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;\n    if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;\n    if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;\n    if (json.wireframe !== undefined) material.wireframe = json.wireframe;\n    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;\n    if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;\n    if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;\n    if (json.rotation !== undefined) material.rotation = json.rotation;\n    if (json.linewidth !== undefined) material.linewidth = json.linewidth;\n    if (json.dashSize !== undefined) material.dashSize = json.dashSize;\n    if (json.gapSize !== undefined) material.gapSize = json.gapSize;\n    if (json.scale !== undefined) material.scale = json.scale;\n    if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;\n    if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;\n    if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;\n    if (json.dithering !== undefined) material.dithering = json.dithering;\n    if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;\n    if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;\n    if (json.forceSinglePass !== undefined) material.forceSinglePass = json.forceSinglePass;\n    if (json.visible !== undefined) material.visible = json.visible;\n    if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;\n    if (json.userData !== undefined) material.userData = json.userData;\n    if (json.vertexColors !== undefined) {\n      if (typeof json.vertexColors === 'number') {\n        material.vertexColors = json.vertexColors > 0 ? true : false;\n      } else {\n        material.vertexColors = json.vertexColors;\n      }\n    }\n\n    // Shader Material\n\n    if (json.uniforms !== undefined) {\n      for (const name in json.uniforms) {\n        const uniform = json.uniforms[name];\n        material.uniforms[name] = {};\n        switch (uniform.type) {\n          case 't':\n            material.uniforms[name].value = getTexture(uniform.value);\n            break;\n          case 'c':\n            material.uniforms[name].value = new Color().setHex(uniform.value);\n            break;\n          case 'v2':\n            material.uniforms[name].value = new Vector2().fromArray(uniform.value);\n            break;\n          case 'v3':\n            material.uniforms[name].value = new Vector3().fromArray(uniform.value);\n            break;\n          case 'v4':\n            material.uniforms[name].value = new Vector4().fromArray(uniform.value);\n            break;\n          case 'm3':\n            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);\n            break;\n          case 'm4':\n            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);\n            break;\n          default:\n            material.uniforms[name].value = uniform.value;\n        }\n      }\n    }\n    if (json.defines !== undefined) material.defines = json.defines;\n    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;\n    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;\n    if (json.glslVersion !== undefined) material.glslVersion = json.glslVersion;\n    if (json.extensions !== undefined) {\n      for (const key in json.extensions) {\n        material.extensions[key] = json.extensions[key];\n      }\n    }\n    if (json.lights !== undefined) material.lights = json.lights;\n    if (json.clipping !== undefined) material.clipping = json.clipping;\n\n    // for PointsMaterial\n\n    if (json.size !== undefined) material.size = json.size;\n    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;\n\n    // maps\n\n    if (json.map !== undefined) material.map = getTexture(json.map);\n    if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);\n    if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);\n    if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);\n    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;\n    if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);\n    if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;\n    if (json.normalScale !== undefined) {\n      let normalScale = json.normalScale;\n      if (Array.isArray(normalScale) === false) {\n        // Blender exporter used to export a scalar. See #7459\n\n        normalScale = [normalScale, normalScale];\n      }\n      material.normalScale = new Vector2().fromArray(normalScale);\n    }\n    if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);\n    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;\n    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;\n    if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);\n    if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);\n    if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);\n    if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;\n    if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);\n    if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);\n    if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);\n    if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);\n    if (json.envMapRotation !== undefined) material.envMapRotation.fromArray(json.envMapRotation);\n    if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;\n    if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;\n    if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;\n    if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);\n    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;\n    if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);\n    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;\n    if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);\n    if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);\n    if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);\n    if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);\n    if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);\n    if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);\n    if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);\n    if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);\n    if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);\n    if (json.anisotropyMap !== undefined) material.anisotropyMap = getTexture(json.anisotropyMap);\n    if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);\n    if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);\n    return material;\n  }\n  setTextures(value) {\n    this.textures = value;\n    return this;\n  }\n  createMaterialFromType(type) {\n    return MaterialLoader.createMaterialFromType(type);\n  }\n  static createMaterialFromType(type) {\n    const materialLib = {\n      ShadowMaterial,\n      SpriteMaterial,\n      RawShaderMaterial,\n      ShaderMaterial,\n      PointsMaterial,\n      MeshPhysicalMaterial,\n      MeshStandardMaterial,\n      MeshPhongMaterial,\n      MeshToonMaterial,\n      MeshNormalMaterial,\n      MeshLambertMaterial,\n      MeshDepthMaterial,\n      MeshDistanceMaterial,\n      MeshBasicMaterial,\n      MeshMatcapMaterial,\n      LineDashedMaterial,\n      LineBasicMaterial,\n      Material\n    };\n    return new materialLib[type]();\n  }\n}\nclass LoaderUtils {\n  static decodeText(array) {\n    // @deprecated, r165\n\n    console.warn('THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.');\n    if (typeof TextDecoder !== 'undefined') {\n      return new TextDecoder().decode(array);\n    }\n\n    // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n    // throws a \"maximum call stack size exceeded\" error for large arrays.\n\n    let s = '';\n    for (let i = 0, il = array.length; i < il; i++) {\n      // Implicitly assumes little-endian.\n      s += String.fromCharCode(array[i]);\n    }\n    try {\n      // merges multi-byte utf-8 characters.\n\n      return decodeURIComponent(escape(s));\n    } catch (e) {\n      // see #16358\n\n      return s;\n    }\n  }\n  static extractUrlBase(url) {\n    const index = url.lastIndexOf('/');\n    if (index === -1) return './';\n    return url.slice(0, index + 1);\n  }\n  static resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return '';\n\n    // Host Relative URL\n    if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n      path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    }\n\n    // Absolute URL http://,https://,//\n    if (/^(https?:)?\\/\\//i.test(url)) return url;\n\n    // Data URI\n    if (/^data:.*,.*$/i.test(url)) return url;\n\n    // Blob URL\n    if (/^blob:.*$/i.test(url)) return url;\n\n    // Relative URL\n    return path + url;\n  }\n}\nclass InstancedBufferGeometry extends BufferGeometry {\n  constructor() {\n    super();\n    this.isInstancedBufferGeometry = true;\n    this.type = 'InstancedBufferGeometry';\n    this.instanceCount = Infinity;\n  }\n  copy(source) {\n    super.copy(source);\n    this.instanceCount = source.instanceCount;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.instanceCount = this.instanceCount;\n    data.isInstancedBufferGeometry = true;\n    return data;\n  }\n}\nclass BufferGeometryLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(json) {\n    const interleavedBufferMap = {};\n    const arrayBufferMap = {};\n    function getInterleavedBuffer(json, uuid) {\n      if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];\n      const interleavedBuffers = json.interleavedBuffers;\n      const interleavedBuffer = interleavedBuffers[uuid];\n      const buffer = getArrayBuffer(json, interleavedBuffer.buffer);\n      const array = getTypedArray(interleavedBuffer.type, buffer);\n      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);\n      ib.uuid = interleavedBuffer.uuid;\n      interleavedBufferMap[uuid] = ib;\n      return ib;\n    }\n    function getArrayBuffer(json, uuid) {\n      if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];\n      const arrayBuffers = json.arrayBuffers;\n      const arrayBuffer = arrayBuffers[uuid];\n      const ab = new Uint32Array(arrayBuffer).buffer;\n      arrayBufferMap[uuid] = ab;\n      return ab;\n    }\n    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n    const index = json.data.index;\n    if (index !== undefined) {\n      const typedArray = getTypedArray(index.type, index.array);\n      geometry.setIndex(new BufferAttribute(typedArray, 1));\n    }\n    const attributes = json.data.attributes;\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      let bufferAttribute;\n      if (attribute.isInterleavedBufferAttribute) {\n        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n      } else {\n        const typedArray = getTypedArray(attribute.type, attribute.array);\n        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);\n      }\n      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n      if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);\n      geometry.setAttribute(key, bufferAttribute);\n    }\n    const morphAttributes = json.data.morphAttributes;\n    if (morphAttributes) {\n      for (const key in morphAttributes) {\n        const attributeArray = morphAttributes[key];\n        const array = [];\n        for (let i = 0, il = attributeArray.length; i < il; i++) {\n          const attribute = attributeArray[i];\n          let bufferAttribute;\n          if (attribute.isInterleavedBufferAttribute) {\n            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n          } else {\n            const typedArray = getTypedArray(attribute.type, attribute.array);\n            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);\n          }\n          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n          array.push(bufferAttribute);\n        }\n        geometry.morphAttributes[key] = array;\n      }\n    }\n    const morphTargetsRelative = json.data.morphTargetsRelative;\n    if (morphTargetsRelative) {\n      geometry.morphTargetsRelative = true;\n    }\n    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n    if (groups !== undefined) {\n      for (let i = 0, n = groups.length; i !== n; ++i) {\n        const group = groups[i];\n        geometry.addGroup(group.start, group.count, group.materialIndex);\n      }\n    }\n    const boundingSphere = json.data.boundingSphere;\n    if (boundingSphere !== undefined) {\n      const center = new Vector3();\n      if (boundingSphere.center !== undefined) {\n        center.fromArray(boundingSphere.center);\n      }\n      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);\n    }\n    if (json.name) geometry.name = json.name;\n    if (json.userData) geometry.userData = json.userData;\n    return geometry;\n  }\n}\nclass ObjectLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    this.resourcePath = this.resourcePath || path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      let json = null;\n      try {\n        json = JSON.parse(text);\n      } catch (error) {\n        if (onError !== undefined) onError(error);\n        console.error('THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message);\n        return;\n      }\n      const metadata = json.metadata;\n      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\n        if (onError !== undefined) onError(new Error('THREE.ObjectLoader: Can\\'t load ' + url));\n        console.error('THREE.ObjectLoader: Can\\'t load ' + url);\n        return;\n      }\n      scope.parse(json, onLoad);\n    }, onProgress, onError);\n  }\n  async loadAsync(url, onProgress) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    this.resourcePath = this.resourcePath || path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    const text = await loader.loadAsync(url, onProgress);\n    const json = JSON.parse(text);\n    const metadata = json.metadata;\n    if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\n      throw new Error('THREE.ObjectLoader: Can\\'t load ' + url);\n    }\n    return await scope.parseAsync(json);\n  }\n  parse(json, onLoad) {\n    const animations = this.parseAnimations(json.animations);\n    const shapes = this.parseShapes(json.shapes);\n    const geometries = this.parseGeometries(json.geometries, shapes);\n    const images = this.parseImages(json.images, function () {\n      if (onLoad !== undefined) onLoad(object);\n    });\n    const textures = this.parseTextures(json.textures, images);\n    const materials = this.parseMaterials(json.materials, textures);\n    const object = this.parseObject(json.object, geometries, materials, textures, animations);\n    const skeletons = this.parseSkeletons(json.skeletons, object);\n    this.bindSkeletons(object, skeletons);\n    this.bindLightTargets(object);\n\n    //\n\n    if (onLoad !== undefined) {\n      let hasImages = false;\n      for (const uuid in images) {\n        if (images[uuid].data instanceof HTMLImageElement) {\n          hasImages = true;\n          break;\n        }\n      }\n      if (hasImages === false) onLoad(object);\n    }\n    return object;\n  }\n  async parseAsync(json) {\n    const animations = this.parseAnimations(json.animations);\n    const shapes = this.parseShapes(json.shapes);\n    const geometries = this.parseGeometries(json.geometries, shapes);\n    const images = await this.parseImagesAsync(json.images);\n    const textures = this.parseTextures(json.textures, images);\n    const materials = this.parseMaterials(json.materials, textures);\n    const object = this.parseObject(json.object, geometries, materials, textures, animations);\n    const skeletons = this.parseSkeletons(json.skeletons, object);\n    this.bindSkeletons(object, skeletons);\n    this.bindLightTargets(object);\n    return object;\n  }\n  parseShapes(json) {\n    const shapes = {};\n    if (json !== undefined) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const shape = new Shape().fromJSON(json[i]);\n        shapes[shape.uuid] = shape;\n      }\n    }\n    return shapes;\n  }\n  parseSkeletons(json, object) {\n    const skeletons = {};\n    const bones = {};\n\n    // generate bone lookup table\n\n    object.traverse(function (child) {\n      if (child.isBone) bones[child.uuid] = child;\n    });\n\n    // create skeletons\n\n    if (json !== undefined) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const skeleton = new Skeleton().fromJSON(json[i], bones);\n        skeletons[skeleton.uuid] = skeleton;\n      }\n    }\n    return skeletons;\n  }\n  parseGeometries(json, shapes) {\n    const geometries = {};\n    if (json !== undefined) {\n      const bufferGeometryLoader = new BufferGeometryLoader();\n      for (let i = 0, l = json.length; i < l; i++) {\n        let geometry;\n        const data = json[i];\n        switch (data.type) {\n          case 'BufferGeometry':\n          case 'InstancedBufferGeometry':\n            geometry = bufferGeometryLoader.parse(data);\n            break;\n          default:\n            if (data.type in Geometries) {\n              geometry = Geometries[data.type].fromJSON(data, shapes);\n            } else {\n              console.warn(`THREE.ObjectLoader: Unsupported geometry type \"${data.type}\"`);\n            }\n        }\n        geometry.uuid = data.uuid;\n        if (data.name !== undefined) geometry.name = data.name;\n        if (data.userData !== undefined) geometry.userData = data.userData;\n        geometries[data.uuid] = geometry;\n      }\n    }\n    return geometries;\n  }\n  parseMaterials(json, textures) {\n    const cache = {}; // MultiMaterial\n    const materials = {};\n    if (json !== undefined) {\n      const loader = new MaterialLoader();\n      loader.setTextures(textures);\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n        if (cache[data.uuid] === undefined) {\n          cache[data.uuid] = loader.parse(data);\n        }\n        materials[data.uuid] = cache[data.uuid];\n      }\n    }\n    return materials;\n  }\n  parseAnimations(json) {\n    const animations = {};\n    if (json !== undefined) {\n      for (let i = 0; i < json.length; i++) {\n        const data = json[i];\n        const clip = AnimationClip.parse(data);\n        animations[clip.uuid] = clip;\n      }\n    }\n    return animations;\n  }\n  parseImages(json, onLoad) {\n    const scope = this;\n    const images = {};\n    let loader;\n    function loadImage(url) {\n      scope.manager.itemStart(url);\n      return loader.load(url, function () {\n        scope.manager.itemEnd(url);\n      }, undefined, function () {\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      });\n    }\n    function deserializeImage(image) {\n      if (typeof image === 'string') {\n        const url = image;\n        const path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n        return loadImage(path);\n      } else {\n        if (image.data) {\n          return {\n            data: getTypedArray(image.type, image.data),\n            width: image.width,\n            height: image.height\n          };\n        } else {\n          return null;\n        }\n      }\n    }\n    if (json !== undefined && json.length > 0) {\n      const manager = new LoadingManager(onLoad);\n      loader = new ImageLoader(manager);\n      loader.setCrossOrigin(this.crossOrigin);\n      for (let i = 0, il = json.length; i < il; i++) {\n        const image = json[i];\n        const url = image.url;\n        if (Array.isArray(url)) {\n          // load array of images e.g CubeTexture\n\n          const imageArray = [];\n          for (let j = 0, jl = url.length; j < jl; j++) {\n            const currentUrl = url[j];\n            const deserializedImage = deserializeImage(currentUrl);\n            if (deserializedImage !== null) {\n              if (deserializedImage instanceof HTMLImageElement) {\n                imageArray.push(deserializedImage);\n              } else {\n                // special case: handle array of data textures for cube textures\n\n                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n              }\n            }\n          }\n          images[image.uuid] = new Source(imageArray);\n        } else {\n          // load single image\n\n          const deserializedImage = deserializeImage(image.url);\n          images[image.uuid] = new Source(deserializedImage);\n        }\n      }\n    }\n    return images;\n  }\n  async parseImagesAsync(json) {\n    const scope = this;\n    const images = {};\n    let loader;\n    async function deserializeImage(image) {\n      if (typeof image === 'string') {\n        const url = image;\n        const path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n        return await loader.loadAsync(path);\n      } else {\n        if (image.data) {\n          return {\n            data: getTypedArray(image.type, image.data),\n            width: image.width,\n            height: image.height\n          };\n        } else {\n          return null;\n        }\n      }\n    }\n    if (json !== undefined && json.length > 0) {\n      loader = new ImageLoader(this.manager);\n      loader.setCrossOrigin(this.crossOrigin);\n      for (let i = 0, il = json.length; i < il; i++) {\n        const image = json[i];\n        const url = image.url;\n        if (Array.isArray(url)) {\n          // load array of images e.g CubeTexture\n\n          const imageArray = [];\n          for (let j = 0, jl = url.length; j < jl; j++) {\n            const currentUrl = url[j];\n            const deserializedImage = await deserializeImage(currentUrl);\n            if (deserializedImage !== null) {\n              if (deserializedImage instanceof HTMLImageElement) {\n                imageArray.push(deserializedImage);\n              } else {\n                // special case: handle array of data textures for cube textures\n\n                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n              }\n            }\n          }\n          images[image.uuid] = new Source(imageArray);\n        } else {\n          // load single image\n\n          const deserializedImage = await deserializeImage(image.url);\n          images[image.uuid] = new Source(deserializedImage);\n        }\n      }\n    }\n    return images;\n  }\n  parseTextures(json, images) {\n    function parseConstant(value, type) {\n      if (typeof value === 'number') return value;\n      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);\n      return type[value];\n    }\n    const textures = {};\n    if (json !== undefined) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n        if (data.image === undefined) {\n          console.warn('THREE.ObjectLoader: No \"image\" specified for', data.uuid);\n        }\n        if (images[data.image] === undefined) {\n          console.warn('THREE.ObjectLoader: Undefined image', data.image);\n        }\n        const source = images[data.image];\n        const image = source.data;\n        let texture;\n        if (Array.isArray(image)) {\n          texture = new CubeTexture();\n          if (image.length === 6) texture.needsUpdate = true;\n        } else {\n          if (image && image.data) {\n            texture = new DataTexture();\n          } else {\n            texture = new Texture();\n          }\n          if (image) texture.needsUpdate = true; // textures can have undefined image data\n        }\n        texture.source = source;\n        texture.uuid = data.uuid;\n        if (data.name !== undefined) texture.name = data.name;\n        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);\n        if (data.channel !== undefined) texture.channel = data.channel;\n        if (data.offset !== undefined) texture.offset.fromArray(data.offset);\n        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);\n        if (data.center !== undefined) texture.center.fromArray(data.center);\n        if (data.rotation !== undefined) texture.rotation = data.rotation;\n        if (data.wrap !== undefined) {\n          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);\n          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);\n        }\n        if (data.format !== undefined) texture.format = data.format;\n        if (data.internalFormat !== undefined) texture.internalFormat = data.internalFormat;\n        if (data.type !== undefined) texture.type = data.type;\n        if (data.colorSpace !== undefined) texture.colorSpace = data.colorSpace;\n        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);\n        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);\n        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;\n        if (data.flipY !== undefined) texture.flipY = data.flipY;\n        if (data.generateMipmaps !== undefined) texture.generateMipmaps = data.generateMipmaps;\n        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;\n        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;\n        if (data.compareFunction !== undefined) texture.compareFunction = data.compareFunction;\n        if (data.userData !== undefined) texture.userData = data.userData;\n        textures[data.uuid] = texture;\n      }\n    }\n    return textures;\n  }\n  parseObject(data, geometries, materials, textures, animations) {\n    let object;\n    function getGeometry(name) {\n      if (geometries[name] === undefined) {\n        console.warn('THREE.ObjectLoader: Undefined geometry', name);\n      }\n      return geometries[name];\n    }\n    function getMaterial(name) {\n      if (name === undefined) return undefined;\n      if (Array.isArray(name)) {\n        const array = [];\n        for (let i = 0, l = name.length; i < l; i++) {\n          const uuid = name[i];\n          if (materials[uuid] === undefined) {\n            console.warn('THREE.ObjectLoader: Undefined material', uuid);\n          }\n          array.push(materials[uuid]);\n        }\n        return array;\n      }\n      if (materials[name] === undefined) {\n        console.warn('THREE.ObjectLoader: Undefined material', name);\n      }\n      return materials[name];\n    }\n    function getTexture(uuid) {\n      if (textures[uuid] === undefined) {\n        console.warn('THREE.ObjectLoader: Undefined texture', uuid);\n      }\n      return textures[uuid];\n    }\n    let geometry, material;\n    switch (data.type) {\n      case 'Scene':\n        object = new Scene();\n        if (data.background !== undefined) {\n          if (Number.isInteger(data.background)) {\n            object.background = new Color(data.background);\n          } else {\n            object.background = getTexture(data.background);\n          }\n        }\n        if (data.environment !== undefined) {\n          object.environment = getTexture(data.environment);\n        }\n        if (data.fog !== undefined) {\n          if (data.fog.type === 'Fog') {\n            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);\n          } else if (data.fog.type === 'FogExp2') {\n            object.fog = new FogExp2(data.fog.color, data.fog.density);\n          }\n          if (data.fog.name !== '') {\n            object.fog.name = data.fog.name;\n          }\n        }\n        if (data.backgroundBlurriness !== undefined) object.backgroundBlurriness = data.backgroundBlurriness;\n        if (data.backgroundIntensity !== undefined) object.backgroundIntensity = data.backgroundIntensity;\n        if (data.backgroundRotation !== undefined) object.backgroundRotation.fromArray(data.backgroundRotation);\n        if (data.environmentIntensity !== undefined) object.environmentIntensity = data.environmentIntensity;\n        if (data.environmentRotation !== undefined) object.environmentRotation.fromArray(data.environmentRotation);\n        break;\n      case 'PerspectiveCamera':\n        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\n        if (data.focus !== undefined) object.focus = data.focus;\n        if (data.zoom !== undefined) object.zoom = data.zoom;\n        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;\n        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;\n        if (data.view !== undefined) object.view = Object.assign({}, data.view);\n        break;\n      case 'OrthographicCamera':\n        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\n        if (data.zoom !== undefined) object.zoom = data.zoom;\n        if (data.view !== undefined) object.view = Object.assign({}, data.view);\n        break;\n      case 'AmbientLight':\n        object = new AmbientLight(data.color, data.intensity);\n        break;\n      case 'DirectionalLight':\n        object = new DirectionalLight(data.color, data.intensity);\n        object.target = data.target || '';\n        break;\n      case 'PointLight':\n        object = new PointLight(data.color, data.intensity, data.distance, data.decay);\n        break;\n      case 'RectAreaLight':\n        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);\n        break;\n      case 'SpotLight':\n        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);\n        object.target = data.target || '';\n        break;\n      case 'HemisphereLight':\n        object = new HemisphereLight(data.color, data.groundColor, data.intensity);\n        break;\n      case 'LightProbe':\n        object = new LightProbe().fromJSON(data);\n        break;\n      case 'SkinnedMesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        object = new SkinnedMesh(geometry, material);\n        if (data.bindMode !== undefined) object.bindMode = data.bindMode;\n        if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);\n        if (data.skeleton !== undefined) object.skeleton = data.skeleton;\n        break;\n      case 'Mesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        object = new Mesh(geometry, material);\n        break;\n      case 'InstancedMesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        const count = data.count;\n        const instanceMatrix = data.instanceMatrix;\n        const instanceColor = data.instanceColor;\n        object = new InstancedMesh(geometry, material, count);\n        object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);\n        if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);\n        break;\n      case 'BatchedMesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        object = new BatchedMesh(data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material);\n        object.geometry = geometry;\n        object.perObjectFrustumCulled = data.perObjectFrustumCulled;\n        object.sortObjects = data.sortObjects;\n        object._drawRanges = data.drawRanges;\n        object._reservedRanges = data.reservedRanges;\n        object._visibility = data.visibility;\n        object._active = data.active;\n        object._bounds = data.bounds.map(bound => {\n          const box = new Box3();\n          box.min.fromArray(bound.boxMin);\n          box.max.fromArray(bound.boxMax);\n          const sphere = new Sphere();\n          sphere.radius = bound.sphereRadius;\n          sphere.center.fromArray(bound.sphereCenter);\n          return {\n            boxInitialized: bound.boxInitialized,\n            box: box,\n            sphereInitialized: bound.sphereInitialized,\n            sphere: sphere\n          };\n        });\n        object._maxInstanceCount = data.maxInstanceCount;\n        object._maxVertexCount = data.maxVertexCount;\n        object._maxIndexCount = data.maxIndexCount;\n        object._geometryInitialized = data.geometryInitialized;\n        object._geometryCount = data.geometryCount;\n        object._matricesTexture = getTexture(data.matricesTexture.uuid);\n        if (data.colorsTexture !== undefined) object._colorsTexture = getTexture(data.colorsTexture.uuid);\n        break;\n      case 'LOD':\n        object = new LOD();\n        break;\n      case 'Line':\n        object = new Line(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case 'LineLoop':\n        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case 'LineSegments':\n        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case 'PointCloud':\n      case 'Points':\n        object = new Points(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case 'Sprite':\n        object = new Sprite(getMaterial(data.material));\n        break;\n      case 'Group':\n        object = new Group();\n        break;\n      case 'Bone':\n        object = new Bone();\n        break;\n      default:\n        object = new Object3D();\n    }\n    object.uuid = data.uuid;\n    if (data.name !== undefined) object.name = data.name;\n    if (data.matrix !== undefined) {\n      object.matrix.fromArray(data.matrix);\n      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;\n      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);\n    } else {\n      if (data.position !== undefined) object.position.fromArray(data.position);\n      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);\n      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);\n      if (data.scale !== undefined) object.scale.fromArray(data.scale);\n    }\n    if (data.up !== undefined) object.up.fromArray(data.up);\n    if (data.castShadow !== undefined) object.castShadow = data.castShadow;\n    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;\n    if (data.shadow) {\n      if (data.shadow.intensity !== undefined) object.shadow.intensity = data.shadow.intensity;\n      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;\n      if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;\n      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;\n      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);\n      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);\n    }\n    if (data.visible !== undefined) object.visible = data.visible;\n    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;\n    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;\n    if (data.userData !== undefined) object.userData = data.userData;\n    if (data.layers !== undefined) object.layers.mask = data.layers;\n    if (data.children !== undefined) {\n      const children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        object.add(this.parseObject(children[i], geometries, materials, textures, animations));\n      }\n    }\n    if (data.animations !== undefined) {\n      const objectAnimations = data.animations;\n      for (let i = 0; i < objectAnimations.length; i++) {\n        const uuid = objectAnimations[i];\n        object.animations.push(animations[uuid]);\n      }\n    }\n    if (data.type === 'LOD') {\n      if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;\n      const levels = data.levels;\n      for (let l = 0; l < levels.length; l++) {\n        const level = levels[l];\n        const child = object.getObjectByProperty('uuid', level.object);\n        if (child !== undefined) {\n          object.addLevel(child, level.distance, level.hysteresis);\n        }\n      }\n    }\n    return object;\n  }\n  bindSkeletons(object, skeletons) {\n    if (Object.keys(skeletons).length === 0) return;\n    object.traverse(function (child) {\n      if (child.isSkinnedMesh === true && child.skeleton !== undefined) {\n        const skeleton = skeletons[child.skeleton];\n        if (skeleton === undefined) {\n          console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);\n        } else {\n          child.bind(skeleton, child.bindMatrix);\n        }\n      }\n    });\n  }\n  bindLightTargets(object) {\n    object.traverse(function (child) {\n      if (child.isDirectionalLight || child.isSpotLight) {\n        const uuid = child.target;\n        const target = object.getObjectByProperty('uuid', uuid);\n        if (target !== undefined) {\n          child.target = target;\n        } else {\n          child.target = new Object3D();\n        }\n      }\n    });\n  }\n}\nconst TEXTURE_MAPPING = {\n  UVMapping: UVMapping,\n  CubeReflectionMapping: CubeReflectionMapping,\n  CubeRefractionMapping: CubeRefractionMapping,\n  EquirectangularReflectionMapping: EquirectangularReflectionMapping,\n  EquirectangularRefractionMapping: EquirectangularRefractionMapping,\n  CubeUVReflectionMapping: CubeUVReflectionMapping\n};\nconst TEXTURE_WRAPPING = {\n  RepeatWrapping: RepeatWrapping,\n  ClampToEdgeWrapping: ClampToEdgeWrapping,\n  MirroredRepeatWrapping: MirroredRepeatWrapping\n};\nconst TEXTURE_FILTER = {\n  NearestFilter: NearestFilter,\n  NearestMipmapNearestFilter: NearestMipmapNearestFilter,\n  NearestMipmapLinearFilter: NearestMipmapLinearFilter,\n  LinearFilter: LinearFilter,\n  LinearMipmapNearestFilter: LinearMipmapNearestFilter,\n  LinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\nclass ImageBitmapLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.isImageBitmapLoader = true;\n    if (typeof createImageBitmap === 'undefined') {\n      console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');\n    }\n    if (typeof fetch === 'undefined') {\n      console.warn('THREE.ImageBitmapLoader: fetch() not supported.');\n    }\n    this.options = {\n      premultiplyAlpha: 'none'\n    };\n  }\n  setOptions(options) {\n    this.options = options;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const scope = this;\n    const cached = Cache.get(url);\n    if (cached !== undefined) {\n      scope.manager.itemStart(url);\n\n      // If cached is a promise, wait for it to resolve\n      if (cached.then) {\n        cached.then(imageBitmap => {\n          if (onLoad) onLoad(imageBitmap);\n          scope.manager.itemEnd(url);\n        }).catch(e => {\n          if (onError) onError(e);\n        });\n        return;\n      }\n\n      // If cached is not a promise (i.e., it's already an imageBitmap)\n      setTimeout(function () {\n        if (onLoad) onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    }\n    const fetchOptions = {};\n    fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';\n    fetchOptions.headers = this.requestHeader;\n    const promise = fetch(url, fetchOptions).then(function (res) {\n      return res.blob();\n    }).then(function (blob) {\n      return createImageBitmap(blob, Object.assign(scope.options, {\n        colorSpaceConversion: 'none'\n      }));\n    }).then(function (imageBitmap) {\n      Cache.add(url, imageBitmap);\n      if (onLoad) onLoad(imageBitmap);\n      scope.manager.itemEnd(url);\n      return imageBitmap;\n    }).catch(function (e) {\n      if (onError) onError(e);\n      Cache.remove(url);\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    });\n    Cache.add(url, promise);\n    scope.manager.itemStart(url);\n  }\n}\nlet _context;\nclass AudioContext {\n  static getContext() {\n    if (_context === undefined) {\n      _context = new (window.AudioContext || window.webkitAudioContext)();\n    }\n    return _context;\n  }\n  static setContext(value) {\n    _context = value;\n  }\n}\nclass AudioLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        // Create a copy of the buffer. The `decodeAudioData` method\n        // detaches the buffer when complete, preventing reuse.\n        const bufferCopy = buffer.slice(0);\n        const context = AudioContext.getContext();\n        context.decodeAudioData(bufferCopy, function (audioBuffer) {\n          onLoad(audioBuffer);\n        }).catch(handleError);\n      } catch (e) {\n        handleError(e);\n      }\n    }, onProgress, onError);\n    function handleError(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n    }\n  }\n}\nconst _eyeRight = /*@__PURE__*/new Matrix4();\nconst _eyeLeft = /*@__PURE__*/new Matrix4();\nconst _projectionMatrix = /*@__PURE__*/new Matrix4();\nclass StereoCamera {\n  constructor() {\n    this.type = 'StereoCamera';\n    this.aspect = 1;\n    this.eyeSep = 0.064;\n    this.cameraL = new PerspectiveCamera();\n    this.cameraL.layers.enable(1);\n    this.cameraL.matrixAutoUpdate = false;\n    this.cameraR = new PerspectiveCamera();\n    this.cameraR.layers.enable(2);\n    this.cameraR.matrixAutoUpdate = false;\n    this._cache = {\n      focus: null,\n      fov: null,\n      aspect: null,\n      near: null,\n      far: null,\n      zoom: null,\n      eyeSep: null\n    };\n  }\n  update(camera) {\n    const cache = this._cache;\n    const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n    if (needsUpdate) {\n      cache.focus = camera.focus;\n      cache.fov = camera.fov;\n      cache.aspect = camera.aspect * this.aspect;\n      cache.near = camera.near;\n      cache.far = camera.far;\n      cache.zoom = camera.zoom;\n      cache.eyeSep = this.eyeSep;\n\n      // Off-axis stereoscopic effect based on\n      // http://paulbourke.net/stereographics/stereorender/\n\n      _projectionMatrix.copy(camera.projectionMatrix);\n      const eyeSepHalf = cache.eyeSep / 2;\n      const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n      const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;\n      let xmin, xmax;\n\n      // translate xOffset\n\n      _eyeLeft.elements[12] = -eyeSepHalf;\n      _eyeRight.elements[12] = eyeSepHalf;\n\n      // for left eye\n\n      xmin = -ymax * cache.aspect + eyeSepOnProjection;\n      xmax = ymax * cache.aspect + eyeSepOnProjection;\n      _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n      this.cameraL.projectionMatrix.copy(_projectionMatrix);\n\n      // for right eye\n\n      xmin = -ymax * cache.aspect - eyeSepOnProjection;\n      xmax = ymax * cache.aspect - eyeSepOnProjection;\n      _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n      this.cameraR.projectionMatrix.copy(_projectionMatrix);\n    }\n    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);\n    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);\n  }\n}\nclass ArrayCamera extends PerspectiveCamera {\n  constructor(array = []) {\n    super();\n    this.isArrayCamera = true;\n    this.cameras = array;\n  }\n}\nclass Clock {\n  constructor(autoStart = true) {\n    this.autoStart = autoStart;\n    this.startTime = 0;\n    this.oldTime = 0;\n    this.elapsedTime = 0;\n    this.running = false;\n  }\n  start() {\n    this.startTime = now();\n    this.oldTime = this.startTime;\n    this.elapsedTime = 0;\n    this.running = true;\n  }\n  stop() {\n    this.getElapsedTime();\n    this.running = false;\n    this.autoStart = false;\n  }\n  getElapsedTime() {\n    this.getDelta();\n    return this.elapsedTime;\n  }\n  getDelta() {\n    let diff = 0;\n    if (this.autoStart && !this.running) {\n      this.start();\n      return 0;\n    }\n    if (this.running) {\n      const newTime = now();\n      diff = (newTime - this.oldTime) / 1000;\n      this.oldTime = newTime;\n      this.elapsedTime += diff;\n    }\n    return diff;\n  }\n}\nfunction now() {\n  return performance.now();\n}\nconst _position$1 = /*@__PURE__*/new Vector3();\nconst _quaternion$1 = /*@__PURE__*/new Quaternion();\nconst _scale$1 = /*@__PURE__*/new Vector3();\nconst _orientation$1 = /*@__PURE__*/new Vector3();\nclass AudioListener extends Object3D {\n  constructor() {\n    super();\n    this.type = 'AudioListener';\n    this.context = AudioContext.getContext();\n    this.gain = this.context.createGain();\n    this.gain.connect(this.context.destination);\n    this.filter = null;\n    this.timeDelta = 0;\n\n    // private\n\n    this._clock = new Clock();\n  }\n  getInput() {\n    return this.gain;\n  }\n  removeFilter() {\n    if (this.filter !== null) {\n      this.gain.disconnect(this.filter);\n      this.filter.disconnect(this.context.destination);\n      this.gain.connect(this.context.destination);\n      this.filter = null;\n    }\n    return this;\n  }\n  getFilter() {\n    return this.filter;\n  }\n  setFilter(value) {\n    if (this.filter !== null) {\n      this.gain.disconnect(this.filter);\n      this.filter.disconnect(this.context.destination);\n    } else {\n      this.gain.disconnect(this.context.destination);\n    }\n    this.filter = value;\n    this.gain.connect(this.filter);\n    this.filter.connect(this.context.destination);\n    return this;\n  }\n  getMasterVolume() {\n    return this.gain.gain.value;\n  }\n  setMasterVolume(value) {\n    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n    return this;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    const listener = this.context.listener;\n    const up = this.up;\n    this.timeDelta = this._clock.getDelta();\n    this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);\n    _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);\n    if (listener.positionX) {\n      // code path for Chrome (see #14393)\n\n      const endTime = this.context.currentTime + this.timeDelta;\n      listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);\n      listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);\n      listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);\n      listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);\n      listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);\n      listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);\n      listener.upX.linearRampToValueAtTime(up.x, endTime);\n      listener.upY.linearRampToValueAtTime(up.y, endTime);\n      listener.upZ.linearRampToValueAtTime(up.z, endTime);\n    } else {\n      listener.setPosition(_position$1.x, _position$1.y, _position$1.z);\n      listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);\n    }\n  }\n}\nclass Audio extends Object3D {\n  constructor(listener) {\n    super();\n    this.type = 'Audio';\n    this.listener = listener;\n    this.context = listener.context;\n    this.gain = this.context.createGain();\n    this.gain.connect(listener.getInput());\n    this.autoplay = false;\n    this.buffer = null;\n    this.detune = 0;\n    this.loop = false;\n    this.loopStart = 0;\n    this.loopEnd = 0;\n    this.offset = 0;\n    this.duration = undefined;\n    this.playbackRate = 1;\n    this.isPlaying = false;\n    this.hasPlaybackControl = true;\n    this.source = null;\n    this.sourceType = 'empty';\n    this._startedAt = 0;\n    this._progress = 0;\n    this._connected = false;\n    this.filters = [];\n  }\n  getOutput() {\n    return this.gain;\n  }\n  setNodeSource(audioNode) {\n    this.hasPlaybackControl = false;\n    this.sourceType = 'audioNode';\n    this.source = audioNode;\n    this.connect();\n    return this;\n  }\n  setMediaElementSource(mediaElement) {\n    this.hasPlaybackControl = false;\n    this.sourceType = 'mediaNode';\n    this.source = this.context.createMediaElementSource(mediaElement);\n    this.connect();\n    return this;\n  }\n  setMediaStreamSource(mediaStream) {\n    this.hasPlaybackControl = false;\n    this.sourceType = 'mediaStreamNode';\n    this.source = this.context.createMediaStreamSource(mediaStream);\n    this.connect();\n    return this;\n  }\n  setBuffer(audioBuffer) {\n    this.buffer = audioBuffer;\n    this.sourceType = 'buffer';\n    if (this.autoplay) this.play();\n    return this;\n  }\n  play(delay = 0) {\n    if (this.isPlaying === true) {\n      console.warn('THREE.Audio: Audio is already playing.');\n      return;\n    }\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n    this._startedAt = this.context.currentTime + delay;\n    const source = this.context.createBufferSource();\n    source.buffer = this.buffer;\n    source.loop = this.loop;\n    source.loopStart = this.loopStart;\n    source.loopEnd = this.loopEnd;\n    source.onended = this.onEnded.bind(this);\n    source.start(this._startedAt, this._progress + this.offset, this.duration);\n    this.isPlaying = true;\n    this.source = source;\n    this.setDetune(this.detune);\n    this.setPlaybackRate(this.playbackRate);\n    return this.connect();\n  }\n  pause() {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n    if (this.isPlaying === true) {\n      // update current progress\n\n      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;\n      if (this.loop === true) {\n        // ensure _progress does not exceed duration with looped audios\n\n        this._progress = this._progress % (this.duration || this.buffer.duration);\n      }\n      this.source.stop();\n      this.source.onended = null;\n      this.isPlaying = false;\n    }\n    return this;\n  }\n  stop(delay = 0) {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n    this._progress = 0;\n    if (this.source !== null) {\n      this.source.stop(this.context.currentTime + delay);\n      this.source.onended = null;\n    }\n    this.isPlaying = false;\n    return this;\n  }\n  connect() {\n    if (this.filters.length > 0) {\n      this.source.connect(this.filters[0]);\n      for (let i = 1, l = this.filters.length; i < l; i++) {\n        this.filters[i - 1].connect(this.filters[i]);\n      }\n      this.filters[this.filters.length - 1].connect(this.getOutput());\n    } else {\n      this.source.connect(this.getOutput());\n    }\n    this._connected = true;\n    return this;\n  }\n  disconnect() {\n    if (this._connected === false) {\n      return;\n    }\n    if (this.filters.length > 0) {\n      this.source.disconnect(this.filters[0]);\n      for (let i = 1, l = this.filters.length; i < l; i++) {\n        this.filters[i - 1].disconnect(this.filters[i]);\n      }\n      this.filters[this.filters.length - 1].disconnect(this.getOutput());\n    } else {\n      this.source.disconnect(this.getOutput());\n    }\n    this._connected = false;\n    return this;\n  }\n  getFilters() {\n    return this.filters;\n  }\n  setFilters(value) {\n    if (!value) value = [];\n    if (this._connected === true) {\n      this.disconnect();\n      this.filters = value.slice();\n      this.connect();\n    } else {\n      this.filters = value.slice();\n    }\n    return this;\n  }\n  setDetune(value) {\n    this.detune = value;\n    if (this.isPlaying === true && this.source.detune !== undefined) {\n      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);\n    }\n    return this;\n  }\n  getDetune() {\n    return this.detune;\n  }\n  getFilter() {\n    return this.getFilters()[0];\n  }\n  setFilter(filter) {\n    return this.setFilters(filter ? [filter] : []);\n  }\n  setPlaybackRate(value) {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n    this.playbackRate = value;\n    if (this.isPlaying === true) {\n      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);\n    }\n    return this;\n  }\n  getPlaybackRate() {\n    return this.playbackRate;\n  }\n  onEnded() {\n    this.isPlaying = false;\n    this._progress = 0;\n  }\n  getLoop() {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return false;\n    }\n    return this.loop;\n  }\n  setLoop(value) {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n    this.loop = value;\n    if (this.isPlaying === true) {\n      this.source.loop = this.loop;\n    }\n    return this;\n  }\n  setLoopStart(value) {\n    this.loopStart = value;\n    return this;\n  }\n  setLoopEnd(value) {\n    this.loopEnd = value;\n    return this;\n  }\n  getVolume() {\n    return this.gain.gain.value;\n  }\n  setVolume(value) {\n    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n    return this;\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.sourceType !== 'buffer') {\n      console.warn('THREE.Audio: Audio source type cannot be copied.');\n      return this;\n    }\n    this.autoplay = source.autoplay;\n    this.buffer = source.buffer;\n    this.detune = source.detune;\n    this.loop = source.loop;\n    this.loopStart = source.loopStart;\n    this.loopEnd = source.loopEnd;\n    this.offset = source.offset;\n    this.duration = source.duration;\n    this.playbackRate = source.playbackRate;\n    this.hasPlaybackControl = source.hasPlaybackControl;\n    this.sourceType = source.sourceType;\n    this.filters = source.filters.slice();\n    return this;\n  }\n  clone(recursive) {\n    return new this.constructor(this.listener).copy(this, recursive);\n  }\n}\nconst _position = /*@__PURE__*/new Vector3();\nconst _quaternion = /*@__PURE__*/new Quaternion();\nconst _scale = /*@__PURE__*/new Vector3();\nconst _orientation = /*@__PURE__*/new Vector3();\nclass PositionalAudio extends Audio {\n  constructor(listener) {\n    super(listener);\n    this.panner = this.context.createPanner();\n    this.panner.panningModel = 'HRTF';\n    this.panner.connect(this.gain);\n  }\n  connect() {\n    super.connect();\n    this.panner.connect(this.gain);\n  }\n  disconnect() {\n    super.disconnect();\n    this.panner.disconnect(this.gain);\n  }\n  getOutput() {\n    return this.panner;\n  }\n  getRefDistance() {\n    return this.panner.refDistance;\n  }\n  setRefDistance(value) {\n    this.panner.refDistance = value;\n    return this;\n  }\n  getRolloffFactor() {\n    return this.panner.rolloffFactor;\n  }\n  setRolloffFactor(value) {\n    this.panner.rolloffFactor = value;\n    return this;\n  }\n  getDistanceModel() {\n    return this.panner.distanceModel;\n  }\n  setDistanceModel(value) {\n    this.panner.distanceModel = value;\n    return this;\n  }\n  getMaxDistance() {\n    return this.panner.maxDistance;\n  }\n  setMaxDistance(value) {\n    this.panner.maxDistance = value;\n    return this;\n  }\n  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n    this.panner.coneInnerAngle = coneInnerAngle;\n    this.panner.coneOuterAngle = coneOuterAngle;\n    this.panner.coneOuterGain = coneOuterGain;\n    return this;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.hasPlaybackControl === true && this.isPlaying === false) return;\n    this.matrixWorld.decompose(_position, _quaternion, _scale);\n    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);\n    const panner = this.panner;\n    if (panner.positionX) {\n      // code path for Chrome and Firefox (see #14393)\n\n      const endTime = this.context.currentTime + this.listener.timeDelta;\n      panner.positionX.linearRampToValueAtTime(_position.x, endTime);\n      panner.positionY.linearRampToValueAtTime(_position.y, endTime);\n      panner.positionZ.linearRampToValueAtTime(_position.z, endTime);\n      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);\n      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);\n      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);\n    } else {\n      panner.setPosition(_position.x, _position.y, _position.z);\n      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);\n    }\n  }\n}\nclass AudioAnalyser {\n  constructor(audio, fftSize = 2048) {\n    this.analyser = audio.context.createAnalyser();\n    this.analyser.fftSize = fftSize;\n    this.data = new Uint8Array(this.analyser.frequencyBinCount);\n    audio.getOutput().connect(this.analyser);\n  }\n  getFrequencyData() {\n    this.analyser.getByteFrequencyData(this.data);\n    return this.data;\n  }\n  getAverageFrequency() {\n    let value = 0;\n    const data = this.getFrequencyData();\n    for (let i = 0; i < data.length; i++) {\n      value += data[i];\n    }\n    return value / data.length;\n  }\n}\nclass PropertyMixer {\n  constructor(binding, typeName, valueSize) {\n    this.binding = binding;\n    this.valueSize = valueSize;\n    let mixFunction, mixFunctionAdditive, setIdentity;\n\n    // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n    //\n    // interpolators can use .buffer as their .result\n    // the data then goes to 'incoming'\n    //\n    // 'accu0' and 'accu1' are used frame-interleaved for\n    // the cumulative result and are compared to detect\n    // changes\n    //\n    // 'orig' stores the original state of the property\n    //\n    // 'add' is used for additive cumulative results\n    //\n    // 'work' is optional and is only present for quaternion types. It is used\n    // to store intermediate quaternion multiplication results\n\n    switch (typeName) {\n      case 'quaternion':\n        mixFunction = this._slerp;\n        mixFunctionAdditive = this._slerpAdditive;\n        setIdentity = this._setAdditiveIdentityQuaternion;\n        this.buffer = new Float64Array(valueSize * 6);\n        this._workIndex = 5;\n        break;\n      case 'string':\n      case 'bool':\n        mixFunction = this._select;\n\n        // Use the regular mix function and for additive on these types,\n        // additive is not relevant for non-numeric types\n        mixFunctionAdditive = this._select;\n        setIdentity = this._setAdditiveIdentityOther;\n        this.buffer = new Array(valueSize * 5);\n        break;\n      default:\n        mixFunction = this._lerp;\n        mixFunctionAdditive = this._lerpAdditive;\n        setIdentity = this._setAdditiveIdentityNumeric;\n        this.buffer = new Float64Array(valueSize * 5);\n    }\n    this._mixBufferRegion = mixFunction;\n    this._mixBufferRegionAdditive = mixFunctionAdditive;\n    this._setIdentity = setIdentity;\n    this._origIndex = 3;\n    this._addIndex = 4;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    this.useCount = 0;\n    this.referenceCount = 0;\n  }\n\n  // accumulate data in the 'incoming' region into 'accu<i>'\n  accumulate(accuIndex, weight) {\n    // note: happily accumulating nothing when weight = 0, the caller knows\n    // the weight and shouldn't have made the call in the first place\n\n    const buffer = this.buffer,\n      stride = this.valueSize,\n      offset = accuIndex * stride + stride;\n    let currentWeight = this.cumulativeWeight;\n    if (currentWeight === 0) {\n      // accuN := incoming * weight\n\n      for (let i = 0; i !== stride; ++i) {\n        buffer[offset + i] = buffer[i];\n      }\n      currentWeight = weight;\n    } else {\n      // accuN := accuN + incoming * weight\n\n      currentWeight += weight;\n      const mix = weight / currentWeight;\n      this._mixBufferRegion(buffer, offset, 0, mix, stride);\n    }\n    this.cumulativeWeight = currentWeight;\n  }\n\n  // accumulate data in the 'incoming' region into 'add'\n  accumulateAdditive(weight) {\n    const buffer = this.buffer,\n      stride = this.valueSize,\n      offset = stride * this._addIndex;\n    if (this.cumulativeWeightAdditive === 0) {\n      // add = identity\n\n      this._setIdentity();\n    }\n\n    // add := add + incoming * weight\n\n    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n    this.cumulativeWeightAdditive += weight;\n  }\n\n  // apply the state of 'accu<i>' to the binding when accus differ\n  apply(accuIndex) {\n    const stride = this.valueSize,\n      buffer = this.buffer,\n      offset = accuIndex * stride + stride,\n      weight = this.cumulativeWeight,\n      weightAdditive = this.cumulativeWeightAdditive,\n      binding = this.binding;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    if (weight < 1) {\n      // accuN := accuN + original * ( 1 - cumulativeWeight )\n\n      const originalValueOffset = stride * this._origIndex;\n      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n    }\n    if (weightAdditive > 0) {\n      // accuN := accuN + additive accuN\n\n      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n    }\n    for (let i = stride, e = stride + stride; i !== e; ++i) {\n      if (buffer[i] !== buffer[i + stride]) {\n        // value has changed -> update scene graph\n\n        binding.setValue(buffer, offset);\n        break;\n      }\n    }\n  }\n\n  // remember the state of the bound property and copy it to both accus\n  saveOriginalState() {\n    const binding = this.binding;\n    const buffer = this.buffer,\n      stride = this.valueSize,\n      originalValueOffset = stride * this._origIndex;\n    binding.getValue(buffer, originalValueOffset);\n\n    // accu[0..1] := orig -- initially detect changes against the original\n    for (let i = stride, e = originalValueOffset; i !== e; ++i) {\n      buffer[i] = buffer[originalValueOffset + i % stride];\n    }\n\n    // Add to identity for additive\n    this._setIdentity();\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n  }\n\n  // apply the state previously taken via 'saveOriginalState' to the binding\n  restoreOriginalState() {\n    const originalValueOffset = this.valueSize * 3;\n    this.binding.setValue(this.buffer, originalValueOffset);\n  }\n  _setAdditiveIdentityNumeric() {\n    const startIndex = this._addIndex * this.valueSize;\n    const endIndex = startIndex + this.valueSize;\n    for (let i = startIndex; i < endIndex; i++) {\n      this.buffer[i] = 0;\n    }\n  }\n  _setAdditiveIdentityQuaternion() {\n    this._setAdditiveIdentityNumeric();\n    this.buffer[this._addIndex * this.valueSize + 3] = 1;\n  }\n  _setAdditiveIdentityOther() {\n    const startIndex = this._origIndex * this.valueSize;\n    const targetIndex = this._addIndex * this.valueSize;\n    for (let i = 0; i < this.valueSize; i++) {\n      this.buffer[targetIndex + i] = this.buffer[startIndex + i];\n    }\n  }\n\n  // mix functions\n\n  _select(buffer, dstOffset, srcOffset, t, stride) {\n    if (t >= 0.5) {\n      for (let i = 0; i !== stride; ++i) {\n        buffer[dstOffset + i] = buffer[srcOffset + i];\n      }\n    }\n  }\n  _slerp(buffer, dstOffset, srcOffset, t) {\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n  }\n  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    const workOffset = this._workIndex * stride;\n\n    // Store result in intermediate buffer offset\n    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);\n\n    // Slerp to the intermediate result\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n  }\n  _lerp(buffer, dstOffset, srcOffset, t, stride) {\n    const s = 1 - t;\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n    }\n  }\n  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n    }\n  }\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\\\.', '') + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*//((?:WC+[\\/:])*)/.source.replace('WC', _wordChar);\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*//(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*//(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', _wordChar);\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*//\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', _wordChar);\nconst _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');\nconst _supportedObjectNames = ['material', 'materials', 'bones', 'map'];\nclass Composite {\n  constructor(targetGroup, path, optionalParsedPath) {\n    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n    this._targetGroup = targetGroup;\n    this._bindings = targetGroup.subscribe_(path, parsedPath);\n  }\n  getValue(array, offset) {\n    this.bind(); // bind all binding\n\n    const firstValidIndex = this._targetGroup.nCachedObjects_,\n      binding = this._bindings[firstValidIndex];\n\n    // and only call .getValue on the first\n    if (binding !== undefined) binding.getValue(array, offset);\n  }\n  setValue(array, offset) {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].setValue(array, offset);\n    }\n  }\n  bind() {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].bind();\n    }\n  }\n  unbind() {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].unbind();\n    }\n  }\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n  constructor(rootNode, path, parsedPath) {\n    this.path = path;\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);\n    this.rootNode = rootNode;\n\n    // initial state of these methods that calls 'bind'\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n  static create(root, path, parsedPath) {\n    if (!(root && root.isAnimationObjectGroup)) {\n      return new PropertyBinding(root, path, parsedPath);\n    } else {\n      return new PropertyBinding.Composite(root, path, parsedPath);\n    }\n  }\n\n  /**\n   * Replaces spaces with underscores and removes unsupported characters from\n   * node names, to ensure compatibility with parseTrackName().\n   *\n   * @param {string} name Node name to be sanitized.\n   * @return {string}\n   */\n  static sanitizeNodeName(name) {\n    return name.replace(/\\s/g, '_').replace(_reservedRe, '');\n  }\n  static parseTrackName(trackName) {\n    const matches = _trackRe.exec(trackName);\n    if (matches === null) {\n      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\n    }\n    const results = {\n      // directoryName: matches[ 1 ], // (tschw) currently unused\n      nodeName: matches[2],\n      objectName: matches[3],\n      objectIndex: matches[4],\n      propertyName: matches[5],\n      // required\n      propertyIndex: matches[6]\n    };\n    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\n    if (lastDot !== undefined && lastDot !== -1) {\n      const objectName = results.nodeName.substring(lastDot + 1);\n\n      // Object names must be checked against an allowlist. Otherwise, there\n      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n      // 'bar' could be the objectName, or part of a nodeName (which can\n      // include '.' characters).\n      if (_supportedObjectNames.indexOf(objectName) !== -1) {\n        results.nodeName = results.nodeName.substring(0, lastDot);\n        results.objectName = objectName;\n      }\n    }\n    if (results.propertyName === null || results.propertyName.length === 0) {\n      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);\n    }\n    return results;\n  }\n  static findNode(root, nodeName) {\n    if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n      return root;\n    }\n\n    // search into skeleton bones.\n    if (root.skeleton) {\n      const bone = root.skeleton.getBoneByName(nodeName);\n      if (bone !== undefined) {\n        return bone;\n      }\n    }\n\n    // search into node subtree.\n    if (root.children) {\n      const searchNodeSubtree = function (children) {\n        for (let i = 0; i < children.length; i++) {\n          const childNode = children[i];\n          if (childNode.name === nodeName || childNode.uuid === nodeName) {\n            return childNode;\n          }\n          const result = searchNodeSubtree(childNode.children);\n          if (result) return result;\n        }\n        return null;\n      };\n      const subTreeNode = searchNodeSubtree(root.children);\n      if (subTreeNode) {\n        return subTreeNode;\n      }\n    }\n    return null;\n  }\n\n  // these are used to \"bind\" a nonexistent property\n  _getValue_unavailable() {}\n  _setValue_unavailable() {}\n\n  // Getters\n\n  _getValue_direct(buffer, offset) {\n    buffer[offset] = this.targetObject[this.propertyName];\n  }\n  _getValue_array(buffer, offset) {\n    const source = this.resolvedProperty;\n    for (let i = 0, n = source.length; i !== n; ++i) {\n      buffer[offset++] = source[i];\n    }\n  }\n  _getValue_arrayElement(buffer, offset) {\n    buffer[offset] = this.resolvedProperty[this.propertyIndex];\n  }\n  _getValue_toArray(buffer, offset) {\n    this.resolvedProperty.toArray(buffer, offset);\n  }\n\n  // Direct\n\n  _setValue_direct(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n  }\n  _setValue_direct_setNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  // EntireArray\n\n  _setValue_array(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n  }\n  _setValue_array_setNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  // ArrayElement\n\n  _setValue_arrayElement(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n  }\n  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  // HasToFromArray\n\n  _setValue_fromArray(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n  }\n  _setValue_fromArray_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  _getValue_unbound(targetArray, offset) {\n    this.bind();\n    this.getValue(targetArray, offset);\n  }\n  _setValue_unbound(sourceArray, offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  }\n\n  // create getter / setter pair for a property in the scene graph\n  bind() {\n    let targetObject = this.node;\n    const parsedPath = this.parsedPath;\n    const objectName = parsedPath.objectName;\n    const propertyName = parsedPath.propertyName;\n    let propertyIndex = parsedPath.propertyIndex;\n    if (!targetObject) {\n      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);\n      this.node = targetObject;\n    }\n\n    // set fail state so we can just 'return' on error\n    this.getValue = this._getValue_unavailable;\n    this.setValue = this._setValue_unavailable;\n\n    // ensure there is a value node\n    if (!targetObject) {\n      console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.');\n      return;\n    }\n    if (objectName) {\n      let objectIndex = parsedPath.objectIndex;\n\n      // special cases were we need to reach deeper into the hierarchy to get the face materials....\n      switch (objectName) {\n        case 'materials':\n          if (!targetObject.material) {\n            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n            return;\n          }\n          if (!targetObject.material.materials) {\n            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);\n            return;\n          }\n          targetObject = targetObject.material.materials;\n          break;\n        case 'bones':\n          if (!targetObject.skeleton) {\n            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);\n            return;\n          }\n\n          // potential future optimization: skip this if propertyIndex is already an integer\n          // and convert the integer string to a true integer.\n\n          targetObject = targetObject.skeleton.bones;\n\n          // support resolving morphTarget names into indices.\n          for (let i = 0; i < targetObject.length; i++) {\n            if (targetObject[i].name === objectIndex) {\n              objectIndex = i;\n              break;\n            }\n          }\n          break;\n        case 'map':\n          if ('map' in targetObject) {\n            targetObject = targetObject.map;\n            break;\n          }\n          if (!targetObject.material) {\n            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n            return;\n          }\n          if (!targetObject.material.map) {\n            console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);\n            return;\n          }\n          targetObject = targetObject.material.map;\n          break;\n        default:\n          if (targetObject[objectName] === undefined) {\n            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);\n            return;\n          }\n          targetObject = targetObject[objectName];\n      }\n      if (objectIndex !== undefined) {\n        if (targetObject[objectIndex] === undefined) {\n          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);\n          return;\n        }\n        targetObject = targetObject[objectIndex];\n      }\n    }\n\n    // resolve property\n    const nodeProperty = targetObject[propertyName];\n    if (nodeProperty === undefined) {\n      const nodeName = parsedPath.nodeName;\n      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject);\n      return;\n    }\n\n    // determine versioning scheme\n    let versioning = this.Versioning.None;\n    this.targetObject = targetObject;\n    if (targetObject.isMaterial === true) {\n      versioning = this.Versioning.NeedsUpdate;\n    } else if (targetObject.isObject3D === true) {\n      versioning = this.Versioning.MatrixWorldNeedsUpdate;\n    }\n\n    // determine how the property gets bound\n    let bindingType = this.BindingType.Direct;\n    if (propertyIndex !== undefined) {\n      // access a sub element of the property array (only primitives are supported right now)\n\n      if (propertyName === 'morphTargetInfluences') {\n        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n        // support resolving morphTarget names into indices.\n        if (!targetObject.geometry) {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);\n          return;\n        }\n        if (!targetObject.geometry.morphAttributes) {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);\n          return;\n        }\n        if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n        }\n      }\n      bindingType = this.BindingType.ArrayElement;\n      this.resolvedProperty = nodeProperty;\n      this.propertyIndex = propertyIndex;\n    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\n      // must use copy for Object3D.Euler/Quaternion\n\n      bindingType = this.BindingType.HasFromToArray;\n      this.resolvedProperty = nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      bindingType = this.BindingType.EntireArray;\n      this.resolvedProperty = nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    }\n\n    // select getter / setter\n    this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  }\n  unbind() {\n    this.node = null;\n\n    // back to the prototype version of getValue / setValue\n    // note: avoiding to mutate the shape of 'this' via 'delete'\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n}\nPropertyBinding.Composite = Composite;\nPropertyBinding.prototype.BindingType = {\n  Direct: 0,\n  EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: 3\n};\nPropertyBinding.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: 1,\n  MatrixWorldNeedsUpdate: 2\n};\nPropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[\n// Direct\nPropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [\n// EntireArray\n\nPropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [\n// ArrayElement\nPropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [\n// HasToFromArray\nPropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n  constructor() {\n    this.isAnimationObjectGroup = true;\n    this.uuid = generateUUID();\n\n    // cached objects followed by the active ones\n    this._objects = Array.prototype.slice.call(arguments);\n    this.nCachedObjects_ = 0; // threshold\n    // note: read by PropertyBinding.Composite\n\n    const indices = {};\n    this._indicesByUUID = indices; // for bookkeeping\n\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      indices[arguments[i].uuid] = i;\n    }\n    this._paths = []; // inside: string\n    this._parsedPaths = []; // inside: { we don't care, here }\n    this._bindings = []; // inside: Array< PropertyBinding >\n    this._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n    const scope = this;\n    this.stats = {\n      objects: {\n        get total() {\n          return scope._objects.length;\n        },\n        get inUse() {\n          return this.total - scope.nCachedObjects_;\n        }\n      },\n      get bindingsPerObject() {\n        return scope._bindings.length;\n      }\n    };\n  }\n  add() {\n    const objects = this._objects,\n      indicesByUUID = this._indicesByUUID,\n      paths = this._paths,\n      parsedPaths = this._parsedPaths,\n      bindings = this._bindings,\n      nBindings = bindings.length;\n    let knownObject = undefined,\n      nObjects = objects.length,\n      nCachedObjects = this.nCachedObjects_;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i],\n        uuid = object.uuid;\n      let index = indicesByUUID[uuid];\n      if (index === undefined) {\n        // unknown object -> add it to the ACTIVE region\n\n        index = nObjects++;\n        indicesByUUID[uuid] = index;\n        objects.push(object);\n\n        // accounting is done, now do the same for all bindings\n\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n        }\n      } else if (index < nCachedObjects) {\n        knownObject = objects[index];\n\n        // move existing object to the ACTIVE region\n\n        const firstActiveIndex = --nCachedObjects,\n          lastCachedObject = objects[firstActiveIndex];\n        indicesByUUID[lastCachedObject.uuid] = index;\n        objects[index] = lastCachedObject;\n        indicesByUUID[uuid] = firstActiveIndex;\n        objects[firstActiveIndex] = object;\n\n        // accounting is done, now do the same for all bindings\n\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          const bindingsForPath = bindings[j],\n            lastCached = bindingsForPath[firstActiveIndex];\n          let binding = bindingsForPath[index];\n          bindingsForPath[index] = lastCached;\n          if (binding === undefined) {\n            // since we do not bother to create new bindings\n            // for objects that are cached, the binding may\n            // or may not exist\n\n            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);\n          }\n          bindingsForPath[firstActiveIndex] = binding;\n        }\n      } else if (objects[index] !== knownObject) {\n        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');\n      } // else the object is already where we want it to be\n    } // for arguments\n\n    this.nCachedObjects_ = nCachedObjects;\n  }\n  remove() {\n    const objects = this._objects,\n      indicesByUUID = this._indicesByUUID,\n      bindings = this._bindings,\n      nBindings = bindings.length;\n    let nCachedObjects = this.nCachedObjects_;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i],\n        uuid = object.uuid,\n        index = indicesByUUID[uuid];\n      if (index !== undefined && index >= nCachedObjects) {\n        // move existing object into the CACHED region\n\n        const lastCachedIndex = nCachedObjects++,\n          firstActiveObject = objects[lastCachedIndex];\n        indicesByUUID[firstActiveObject.uuid] = index;\n        objects[index] = firstActiveObject;\n        indicesByUUID[uuid] = lastCachedIndex;\n        objects[lastCachedIndex] = object;\n\n        // accounting is done, now do the same for all bindings\n\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          const bindingsForPath = bindings[j],\n            firstActive = bindingsForPath[lastCachedIndex],\n            binding = bindingsForPath[index];\n          bindingsForPath[index] = firstActive;\n          bindingsForPath[lastCachedIndex] = binding;\n        }\n      }\n    } // for arguments\n\n    this.nCachedObjects_ = nCachedObjects;\n  }\n\n  // remove & forget\n  uncache() {\n    const objects = this._objects,\n      indicesByUUID = this._indicesByUUID,\n      bindings = this._bindings,\n      nBindings = bindings.length;\n    let nCachedObjects = this.nCachedObjects_,\n      nObjects = objects.length;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i],\n        uuid = object.uuid,\n        index = indicesByUUID[uuid];\n      if (index !== undefined) {\n        delete indicesByUUID[uuid];\n        if (index < nCachedObjects) {\n          // object is cached, shrink the CACHED region\n\n          const firstActiveIndex = --nCachedObjects,\n            lastCachedObject = objects[firstActiveIndex],\n            lastIndex = --nObjects,\n            lastObject = objects[lastIndex];\n\n          // last cached object takes this object's place\n          indicesByUUID[lastCachedObject.uuid] = index;\n          objects[index] = lastCachedObject;\n\n          // last object goes to the activated slot and pop\n          indicesByUUID[lastObject.uuid] = firstActiveIndex;\n          objects[firstActiveIndex] = lastObject;\n          objects.pop();\n\n          // accounting is done, now do the same for all bindings\n\n          for (let j = 0, m = nBindings; j !== m; ++j) {\n            const bindingsForPath = bindings[j],\n              lastCached = bindingsForPath[firstActiveIndex],\n              last = bindingsForPath[lastIndex];\n            bindingsForPath[index] = lastCached;\n            bindingsForPath[firstActiveIndex] = last;\n            bindingsForPath.pop();\n          }\n        } else {\n          // object is active, just swap with the last and pop\n\n          const lastIndex = --nObjects,\n            lastObject = objects[lastIndex];\n          if (lastIndex > 0) {\n            indicesByUUID[lastObject.uuid] = index;\n          }\n          objects[index] = lastObject;\n          objects.pop();\n\n          // accounting is done, now do the same for all bindings\n\n          for (let j = 0, m = nBindings; j !== m; ++j) {\n            const bindingsForPath = bindings[j];\n            bindingsForPath[index] = bindingsForPath[lastIndex];\n            bindingsForPath.pop();\n          }\n        } // cached or active\n      } // if object is known\n    } // for arguments\n\n    this.nCachedObjects_ = nCachedObjects;\n  }\n\n  // Internal interface used by befriended PropertyBinding.Composite:\n\n  subscribe_(path, parsedPath) {\n    // returns an array of bindings for the given path that is changed\n    // according to the contained objects in the group\n\n    const indicesByPath = this._bindingsIndicesByPath;\n    let index = indicesByPath[path];\n    const bindings = this._bindings;\n    if (index !== undefined) return bindings[index];\n    const paths = this._paths,\n      parsedPaths = this._parsedPaths,\n      objects = this._objects,\n      nObjects = objects.length,\n      nCachedObjects = this.nCachedObjects_,\n      bindingsForPath = new Array(nObjects);\n    index = bindings.length;\n    indicesByPath[path] = index;\n    paths.push(path);\n    parsedPaths.push(parsedPath);\n    bindings.push(bindingsForPath);\n    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {\n      const object = objects[i];\n      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\n    }\n    return bindingsForPath;\n  }\n  unsubscribe_(path) {\n    // tells the group to forget about a property path and no longer\n    // update the array previously obtained with 'subscribe_'\n\n    const indicesByPath = this._bindingsIndicesByPath,\n      index = indicesByPath[path];\n    if (index !== undefined) {\n      const paths = this._paths,\n        parsedPaths = this._parsedPaths,\n        bindings = this._bindings,\n        lastBindingsIndex = bindings.length - 1,\n        lastBindings = bindings[lastBindingsIndex],\n        lastBindingsPath = path[lastBindingsIndex];\n      indicesByPath[lastBindingsPath] = index;\n      bindings[index] = lastBindings;\n      bindings.pop();\n      parsedPaths[index] = parsedPaths[lastBindingsIndex];\n      parsedPaths.pop();\n      paths[index] = paths[lastBindingsIndex];\n      paths.pop();\n    }\n  }\n}\nclass AnimationAction {\n  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {\n    this._mixer = mixer;\n    this._clip = clip;\n    this._localRoot = localRoot;\n    this.blendMode = blendMode;\n    const tracks = clip.tracks,\n      nTracks = tracks.length,\n      interpolants = new Array(nTracks);\n    const interpolantSettings = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n    for (let i = 0; i !== nTracks; ++i) {\n      const interpolant = tracks[i].createInterpolant(null);\n      interpolants[i] = interpolant;\n      interpolant.settings = interpolantSettings;\n    }\n    this._interpolantSettings = interpolantSettings;\n    this._interpolants = interpolants; // bound by the mixer\n\n    // inside: PropertyMixer (managed by the mixer)\n    this._propertyBindings = new Array(nTracks);\n    this._cacheIndex = null; // for the memory manager\n    this._byClipCacheIndex = null; // for the memory manager\n\n    this._timeScaleInterpolant = null;\n    this._weightInterpolant = null;\n    this.loop = LoopRepeat;\n    this._loopCount = -1;\n\n    // global mixer time when the action is to be started\n    // it's set back to 'null' upon start of the action\n    this._startTime = null;\n\n    // scaled local time of the action\n    // gets clamped or wrapped to 0..clip.duration according to loop\n    this.time = 0;\n    this.timeScale = 1;\n    this._effectiveTimeScale = 1;\n    this.weight = 1;\n    this._effectiveWeight = 1;\n    this.repetitions = Infinity; // no. of repetitions when looping\n\n    this.paused = false; // true -> zero effective time scale\n    this.enabled = true; // false -> zero effective weight\n\n    this.clampWhenFinished = false; // keep feeding the last frame?\n\n    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\n    this.zeroSlopeAtEnd = true; // clips for start, loop and end\n  }\n\n  // State & Scheduling\n\n  play() {\n    this._mixer._activateAction(this);\n    return this;\n  }\n  stop() {\n    this._mixer._deactivateAction(this);\n    return this.reset();\n  }\n  reset() {\n    this.paused = false;\n    this.enabled = true;\n    this.time = 0; // restart clip\n    this._loopCount = -1; // forget previous loops\n    this._startTime = null; // forget scheduling\n\n    return this.stopFading().stopWarping();\n  }\n  isRunning() {\n    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n  }\n\n  // return true when play has been called\n  isScheduled() {\n    return this._mixer._isActiveAction(this);\n  }\n  startAt(time) {\n    this._startTime = time;\n    return this;\n  }\n  setLoop(mode, repetitions) {\n    this.loop = mode;\n    this.repetitions = repetitions;\n    return this;\n  }\n\n  // Weight\n\n  // set the weight stopping any scheduled fading\n  // although .enabled = false yields an effective weight of zero, this\n  // method does *not* change .enabled, because it would be confusing\n  setEffectiveWeight(weight) {\n    this.weight = weight;\n\n    // note: same logic as when updated at runtime\n    this._effectiveWeight = this.enabled ? weight : 0;\n    return this.stopFading();\n  }\n\n  // return the weight considering fading and .enabled\n  getEffectiveWeight() {\n    return this._effectiveWeight;\n  }\n  fadeIn(duration) {\n    return this._scheduleFading(duration, 0, 1);\n  }\n  fadeOut(duration) {\n    return this._scheduleFading(duration, 1, 0);\n  }\n  crossFadeFrom(fadeOutAction, duration, warp) {\n    fadeOutAction.fadeOut(duration);\n    this.fadeIn(duration);\n    if (warp) {\n      const fadeInDuration = this._clip.duration,\n        fadeOutDuration = fadeOutAction._clip.duration,\n        startEndRatio = fadeOutDuration / fadeInDuration,\n        endStartRatio = fadeInDuration / fadeOutDuration;\n      fadeOutAction.warp(1.0, startEndRatio, duration);\n      this.warp(endStartRatio, 1.0, duration);\n    }\n    return this;\n  }\n  crossFadeTo(fadeInAction, duration, warp) {\n    return fadeInAction.crossFadeFrom(this, duration, warp);\n  }\n  stopFading() {\n    const weightInterpolant = this._weightInterpolant;\n    if (weightInterpolant !== null) {\n      this._weightInterpolant = null;\n      this._mixer._takeBackControlInterpolant(weightInterpolant);\n    }\n    return this;\n  }\n\n  // Time Scale Control\n\n  // set the time scale stopping any scheduled warping\n  // although .paused = true yields an effective time scale of zero, this\n  // method does *not* change .paused, because it would be confusing\n  setEffectiveTimeScale(timeScale) {\n    this.timeScale = timeScale;\n    this._effectiveTimeScale = this.paused ? 0 : timeScale;\n    return this.stopWarping();\n  }\n\n  // return the time scale considering warping and .paused\n  getEffectiveTimeScale() {\n    return this._effectiveTimeScale;\n  }\n  setDuration(duration) {\n    this.timeScale = this._clip.duration / duration;\n    return this.stopWarping();\n  }\n  syncWith(action) {\n    this.time = action.time;\n    this.timeScale = action.timeScale;\n    return this.stopWarping();\n  }\n  halt(duration) {\n    return this.warp(this._effectiveTimeScale, 0, duration);\n  }\n  warp(startTimeScale, endTimeScale, duration) {\n    const mixer = this._mixer,\n      now = mixer.time,\n      timeScale = this.timeScale;\n    let interpolant = this._timeScaleInterpolant;\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._timeScaleInterpolant = interpolant;\n    }\n    const times = interpolant.parameterPositions,\n      values = interpolant.sampleValues;\n    times[0] = now;\n    times[1] = now + duration;\n    values[0] = startTimeScale / timeScale;\n    values[1] = endTimeScale / timeScale;\n    return this;\n  }\n  stopWarping() {\n    const timeScaleInterpolant = this._timeScaleInterpolant;\n    if (timeScaleInterpolant !== null) {\n      this._timeScaleInterpolant = null;\n      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n    }\n    return this;\n  }\n\n  // Object Accessors\n\n  getMixer() {\n    return this._mixer;\n  }\n  getClip() {\n    return this._clip;\n  }\n  getRoot() {\n    return this._localRoot || this._mixer._root;\n  }\n\n  // Interna\n\n  _update(time, deltaTime, timeDirection, accuIndex) {\n    // called by the mixer\n\n    if (!this.enabled) {\n      // call ._updateWeight() to update ._effectiveWeight\n\n      this._updateWeight(time);\n      return;\n    }\n    const startTime = this._startTime;\n    if (startTime !== null) {\n      // check for scheduled start of action\n\n      const timeRunning = (time - startTime) * timeDirection;\n      if (timeRunning < 0 || timeDirection === 0) {\n        deltaTime = 0;\n      } else {\n        this._startTime = null; // unschedule\n        deltaTime = timeDirection * timeRunning;\n      }\n    }\n\n    // apply time scale and advance time\n\n    deltaTime *= this._updateTimeScale(time);\n    const clipTime = this._updateTime(deltaTime);\n\n    // note: _updateTime may disable the action resulting in\n    // an effective weight of 0\n\n    const weight = this._updateWeight(time);\n    if (weight > 0) {\n      const interpolants = this._interpolants;\n      const propertyMixers = this._propertyBindings;\n      switch (this.blendMode) {\n        case AdditiveAnimationBlendMode:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulateAdditive(weight);\n          }\n          break;\n        case NormalAnimationBlendMode:\n        default:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulate(accuIndex, weight);\n          }\n      }\n    }\n  }\n  _updateWeight(time) {\n    let weight = 0;\n    if (this.enabled) {\n      weight = this.weight;\n      const interpolant = this._weightInterpolant;\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n        weight *= interpolantValue;\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopFading();\n          if (interpolantValue === 0) {\n            // faded out, disable\n            this.enabled = false;\n          }\n        }\n      }\n    }\n    this._effectiveWeight = weight;\n    return weight;\n  }\n  _updateTimeScale(time) {\n    let timeScale = 0;\n    if (!this.paused) {\n      timeScale = this.timeScale;\n      const interpolant = this._timeScaleInterpolant;\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n        timeScale *= interpolantValue;\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopWarping();\n          if (timeScale === 0) {\n            // motion has halted, pause\n            this.paused = true;\n          } else {\n            // warp done - apply final time scale\n            this.timeScale = timeScale;\n          }\n        }\n      }\n    }\n    this._effectiveTimeScale = timeScale;\n    return timeScale;\n  }\n  _updateTime(deltaTime) {\n    const duration = this._clip.duration;\n    const loop = this.loop;\n    let time = this.time + deltaTime;\n    let loopCount = this._loopCount;\n    const pingPong = loop === LoopPingPong;\n    if (deltaTime === 0) {\n      if (loopCount === -1) return time;\n      return pingPong && (loopCount & 1) === 1 ? duration - time : time;\n    }\n    if (loop === LoopOnce) {\n      if (loopCount === -1) {\n        // just started\n\n        this._loopCount = 0;\n        this._setEndings(true, true, false);\n      }\n      handle_stop: {\n        if (time >= duration) {\n          time = duration;\n        } else if (time < 0) {\n          time = 0;\n        } else {\n          this.time = time;\n          break handle_stop;\n        }\n        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n        this.time = time;\n        this._mixer.dispatchEvent({\n          type: 'finished',\n          action: this,\n          direction: deltaTime < 0 ? -1 : 1\n        });\n      }\n    } else {\n      // repetitive Repeat or PingPong\n\n      if (loopCount === -1) {\n        // just started\n\n        if (deltaTime >= 0) {\n          loopCount = 0;\n          this._setEndings(true, this.repetitions === 0, pingPong);\n        } else {\n          // when looping in reverse direction, the initial\n          // transition through zero counts as a repetition,\n          // so leave loopCount at -1\n\n          this._setEndings(this.repetitions === 0, true, pingPong);\n        }\n      }\n      if (time >= duration || time < 0) {\n        // wrap around\n\n        const loopDelta = Math.floor(time / duration); // signed\n        time -= duration * loopDelta;\n        loopCount += Math.abs(loopDelta);\n        const pending = this.repetitions - loopCount;\n        if (pending <= 0) {\n          // have to stop (switch state, clamp time, fire event)\n\n          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n          time = deltaTime > 0 ? duration : 0;\n          this.time = time;\n          this._mixer.dispatchEvent({\n            type: 'finished',\n            action: this,\n            direction: deltaTime > 0 ? 1 : -1\n          });\n        } else {\n          // keep running\n\n          if (pending === 1) {\n            // entering the last round\n\n            const atStart = deltaTime < 0;\n            this._setEndings(atStart, !atStart, pingPong);\n          } else {\n            this._setEndings(false, false, pingPong);\n          }\n          this._loopCount = loopCount;\n          this.time = time;\n          this._mixer.dispatchEvent({\n            type: 'loop',\n            action: this,\n            loopDelta: loopDelta\n          });\n        }\n      } else {\n        this.time = time;\n      }\n      if (pingPong && (loopCount & 1) === 1) {\n        // invert time for the \"pong round\"\n\n        return duration - time;\n      }\n    }\n    return time;\n  }\n  _setEndings(atStart, atEnd, pingPong) {\n    const settings = this._interpolantSettings;\n    if (pingPong) {\n      settings.endingStart = ZeroSlopeEnding;\n      settings.endingEnd = ZeroSlopeEnding;\n    } else {\n      // assuming for LoopOnce atStart == atEnd == true\n\n      if (atStart) {\n        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingStart = WrapAroundEnding;\n      }\n      if (atEnd) {\n        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingEnd = WrapAroundEnding;\n      }\n    }\n  }\n  _scheduleFading(duration, weightNow, weightThen) {\n    const mixer = this._mixer,\n      now = mixer.time;\n    let interpolant = this._weightInterpolant;\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._weightInterpolant = interpolant;\n    }\n    const times = interpolant.parameterPositions,\n      values = interpolant.sampleValues;\n    times[0] = now;\n    values[0] = weightNow;\n    times[1] = now + duration;\n    values[1] = weightThen;\n    return this;\n  }\n}\nconst _controlInterpolantsResultBuffer = new Float32Array(1);\nclass AnimationMixer extends EventDispatcher {\n  constructor(root) {\n    super();\n    this._root = root;\n    this._initMemoryManager();\n    this._accuIndex = 0;\n    this.time = 0;\n    this.timeScale = 1.0;\n  }\n  _bindAction(action, prototypeAction) {\n    const root = action._localRoot || this._root,\n      tracks = action._clip.tracks,\n      nTracks = tracks.length,\n      bindings = action._propertyBindings,\n      interpolants = action._interpolants,\n      rootUuid = root.uuid,\n      bindingsByRoot = this._bindingsByRootAndName;\n    let bindingsByName = bindingsByRoot[rootUuid];\n    if (bindingsByName === undefined) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n    for (let i = 0; i !== nTracks; ++i) {\n      const track = tracks[i],\n        trackName = track.name;\n      let binding = bindingsByName[trackName];\n      if (binding !== undefined) {\n        ++binding.referenceCount;\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n        if (binding !== undefined) {\n          // existing binding, make sure the cache knows\n\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n          continue;\n        }\n        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n        ++binding.referenceCount;\n        this._addInactiveBinding(binding, rootUuid, trackName);\n        bindings[i] = binding;\n      }\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  }\n  _activateAction(action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        // this action has been forgotten by the cache, but the user\n        // appears to be still using it -> rebind\n\n        const rootUuid = (action._localRoot || this._root).uuid,\n          clipUuid = action._clip.uuid,\n          actionsForClip = this._actionsByClip[clipUuid];\n        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n      const bindings = action._propertyBindings;\n\n      // increment reference counts / sort out state\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n          binding.saveOriginalState();\n        }\n      }\n      this._lendAction(action);\n    }\n  }\n  _deactivateAction(action) {\n    if (this._isActiveAction(action)) {\n      const bindings = action._propertyBindings;\n\n      // decrement reference counts / sort out state\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n          this._takeBackBinding(binding);\n        }\n      }\n      this._takeBackAction(action);\n    }\n  }\n\n  // Memory manager\n\n  _initMemoryManager() {\n    this._actions = []; // 'nActiveActions' followed by inactive ones\n    this._nActiveActions = 0;\n    this._actionsByClip = {};\n    // inside:\n    // {\n    // \tknownActions: Array< AnimationAction > - used as prototypes\n    // \tactionByRoot: AnimationAction - lookup\n    // }\n\n    this._bindings = []; // 'nActiveBindings' followed by inactive ones\n    this._nActiveBindings = 0;\n    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n    this._controlInterpolants = []; // same game as above\n    this._nActiveControlInterpolants = 0;\n    const scope = this;\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n        get inUse() {\n          return scope._nActiveActions;\n        }\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n        get inUse() {\n          return scope._nActiveBindings;\n        }\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        }\n      }\n    };\n  }\n\n  // Memory management for AnimationAction objects\n\n  _isActiveAction(action) {\n    const index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  }\n  _addInactiveAction(action, clipUuid, rootUuid) {\n    const actions = this._actions,\n      actionsByClip = this._actionsByClip;\n    let actionsForClip = actionsByClip[clipUuid];\n    if (actionsForClip === undefined) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {}\n      };\n      action._byClipCacheIndex = 0;\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      const knownActions = actionsForClip.knownActions;\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n    action._cacheIndex = actions.length;\n    actions.push(action);\n    actionsForClip.actionByRoot[rootUuid] = action;\n  }\n  _removeInactiveAction(action) {\n    const actions = this._actions,\n      lastInactiveAction = actions[actions.length - 1],\n      cacheIndex = action._cacheIndex;\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n    action._cacheIndex = null;\n    const clipUuid = action._clip.uuid,\n      actionsByClip = this._actionsByClip,\n      actionsForClip = actionsByClip[clipUuid],\n      knownActionsForClip = actionsForClip.knownActions,\n      lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n      byClipCacheIndex = action._byClipCacheIndex;\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n    action._byClipCacheIndex = null;\n    const actionByRoot = actionsForClip.actionByRoot,\n      rootUuid = (action._localRoot || this._root).uuid;\n    delete actionByRoot[rootUuid];\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n    this._removeInactiveBindingsForAction(action);\n  }\n  _removeInactiveBindingsForAction(action) {\n    const bindings = action._propertyBindings;\n    for (let i = 0, n = bindings.length; i !== n; ++i) {\n      const binding = bindings[i];\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n  _lendAction(action) {\n    // [ active actions |  inactive actions  ]\n    // [  active actions >| inactive actions ]\n    //                 s        a\n    //                  <-swap->\n    //                 a        s\n\n    const actions = this._actions,\n      prevIndex = action._cacheIndex,\n      lastActiveIndex = this._nActiveActions++,\n      firstInactiveAction = actions[lastActiveIndex];\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  }\n  _takeBackAction(action) {\n    // [  active actions  | inactive actions ]\n    // [ active actions |< inactive actions  ]\n    //        a        s\n    //         <-swap->\n    //        s        a\n\n    const actions = this._actions,\n      prevIndex = action._cacheIndex,\n      firstInactiveIndex = --this._nActiveActions,\n      lastActiveAction = actions[firstInactiveIndex];\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  }\n\n  // Memory management for PropertyMixer objects\n\n  _addInactiveBinding(binding, rootUuid, trackName) {\n    const bindingsByRoot = this._bindingsByRootAndName,\n      bindings = this._bindings;\n    let bindingByName = bindingsByRoot[rootUuid];\n    if (bindingByName === undefined) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n    bindingByName[trackName] = binding;\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  }\n  _removeInactiveBinding(binding) {\n    const bindings = this._bindings,\n      propBinding = binding.binding,\n      rootUuid = propBinding.rootNode.uuid,\n      trackName = propBinding.path,\n      bindingsByRoot = this._bindingsByRootAndName,\n      bindingByName = bindingsByRoot[rootUuid],\n      lastInactiveBinding = bindings[bindings.length - 1],\n      cacheIndex = binding._cacheIndex;\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n    delete bindingByName[trackName];\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  }\n  _lendBinding(binding) {\n    const bindings = this._bindings,\n      prevIndex = binding._cacheIndex,\n      lastActiveIndex = this._nActiveBindings++,\n      firstInactiveBinding = bindings[lastActiveIndex];\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  }\n  _takeBackBinding(binding) {\n    const bindings = this._bindings,\n      prevIndex = binding._cacheIndex,\n      firstInactiveIndex = --this._nActiveBindings,\n      lastActiveBinding = bindings[firstInactiveIndex];\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  }\n\n  // Memory management of Interpolants for weight and time scale\n\n  _lendControlInterpolant() {\n    const interpolants = this._controlInterpolants,\n      lastActiveIndex = this._nActiveControlInterpolants++;\n    let interpolant = interpolants[lastActiveIndex];\n    if (interpolant === undefined) {\n      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer);\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n    return interpolant;\n  }\n  _takeBackControlInterpolant(interpolant) {\n    const interpolants = this._controlInterpolants,\n      prevIndex = interpolant.__cacheIndex,\n      firstInactiveIndex = --this._nActiveControlInterpolants,\n      lastActiveInterpolant = interpolants[firstInactiveIndex];\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  }\n\n  // return an action for a clip optionally using a custom root target\n  // object (this method allocates a lot of dynamic memory in case a\n  // previously unknown clip/root combination is specified)\n  clipAction(clip, optionalRoot, blendMode) {\n    const root = optionalRoot || this._root,\n      rootUuid = root.uuid;\n    let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n    const clipUuid = clipObject !== null ? clipObject.uuid : clip;\n    const actionsForClip = this._actionsByClip[clipUuid];\n    let prototypeAction = null;\n    if (blendMode === undefined) {\n      if (clipObject !== null) {\n        blendMode = clipObject.blendMode;\n      } else {\n        blendMode = NormalAnimationBlendMode;\n      }\n    }\n    if (actionsForClip !== undefined) {\n      const existingAction = actionsForClip.actionByRoot[rootUuid];\n      if (existingAction !== undefined && existingAction.blendMode === blendMode) {\n        return existingAction;\n      }\n\n      // we know the clip, so we don't have to parse all\n      // the bindings again but can just copy\n      prototypeAction = actionsForClip.knownActions[0];\n\n      // also, take the clip from the prototype action\n      if (clipObject === null) clipObject = prototypeAction._clip;\n    }\n\n    // clip must be known when specified via string\n    if (clipObject === null) return null;\n\n    // allocate all resources required to run it\n    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n    this._bindAction(newAction, prototypeAction);\n\n    // and make the action known to the memory manager\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n    return newAction;\n  }\n\n  // get an existing action\n  existingAction(clip, optionalRoot) {\n    const root = optionalRoot || this._root,\n      rootUuid = root.uuid,\n      clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n      clipUuid = clipObject ? clipObject.uuid : clip,\n      actionsForClip = this._actionsByClip[clipUuid];\n    if (actionsForClip !== undefined) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n    return null;\n  }\n\n  // deactivates all previously scheduled actions\n  stopAllAction() {\n    const actions = this._actions,\n      nActions = this._nActiveActions;\n    for (let i = nActions - 1; i >= 0; --i) {\n      actions[i].stop();\n    }\n    return this;\n  }\n\n  // advance the time and update apply the animation\n  update(deltaTime) {\n    deltaTime *= this.timeScale;\n    const actions = this._actions,\n      nActions = this._nActiveActions,\n      time = this.time += deltaTime,\n      timeDirection = Math.sign(deltaTime),\n      accuIndex = this._accuIndex ^= 1;\n\n    // run active actions\n\n    for (let i = 0; i !== nActions; ++i) {\n      const action = actions[i];\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    }\n\n    // update scene graph\n\n    const bindings = this._bindings,\n      nBindings = this._nActiveBindings;\n    for (let i = 0; i !== nBindings; ++i) {\n      bindings[i].apply(accuIndex);\n    }\n    return this;\n  }\n\n  // Allows you to seek to a specific time in an animation.\n  setTime(timeInSeconds) {\n    this.time = 0; // Zero out time attribute for AnimationMixer object;\n    for (let i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n    }\n    return this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n  }\n\n  // return this mixer's root target object\n  getRoot() {\n    return this._root;\n  }\n\n  // free all resources specific to a particular clip\n  uncacheClip(clip) {\n    const actions = this._actions,\n      clipUuid = clip.uuid,\n      actionsByClip = this._actionsByClip,\n      actionsForClip = actionsByClip[clipUuid];\n    if (actionsForClip !== undefined) {\n      // note: just calling _removeInactiveAction would mess up the\n      // iteration state and also require updating the state we can\n      // just throw away\n\n      const actionsToRemove = actionsForClip.knownActions;\n      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        const action = actionsToRemove[i];\n        this._deactivateAction(action);\n        const cacheIndex = action._cacheIndex,\n          lastInactiveAction = actions[actions.length - 1];\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n        this._removeInactiveBindingsForAction(action);\n      }\n      delete actionsByClip[clipUuid];\n    }\n  }\n\n  // free all resources specific to a particular root target object\n  uncacheRoot(root) {\n    const rootUuid = root.uuid,\n      actionsByClip = this._actionsByClip;\n    for (const clipUuid in actionsByClip) {\n      const actionByRoot = actionsByClip[clipUuid].actionByRoot,\n        action = actionByRoot[rootUuid];\n      if (action !== undefined) {\n        this._deactivateAction(action);\n        this._removeInactiveAction(action);\n      }\n    }\n    const bindingsByRoot = this._bindingsByRootAndName,\n      bindingByName = bindingsByRoot[rootUuid];\n    if (bindingByName !== undefined) {\n      for (const trackName in bindingByName) {\n        const binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n\n  // remove a targeted clip from the cache\n  uncacheAction(clip, optionalRoot) {\n    const action = this.existingAction(clip, optionalRoot);\n    if (action !== null) {\n      this._deactivateAction(action);\n      this._removeInactiveAction(action);\n    }\n  }\n}\nclass RenderTarget3D extends RenderTarget {\n  constructor(width = 1, height = 1, depth = 1, options = {}) {\n    super(width, height, options);\n    this.isRenderTarget3D = true;\n    this.depth = depth;\n    this.texture = new Data3DTexture(null, width, height, depth);\n    this.texture.isRenderTargetTexture = true;\n  }\n}\nclass RenderTargetArray extends RenderTarget {\n  constructor(width = 1, height = 1, depth = 1, options = {}) {\n    super(width, height, options);\n    this.isRenderTargetArray = true;\n    this.depth = depth;\n    this.texture = new DataArrayTexture(null, width, height, depth);\n    this.texture.isRenderTargetTexture = true;\n  }\n}\nclass Uniform {\n  constructor(value) {\n    this.value = value;\n  }\n  clone() {\n    return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());\n  }\n}\nlet _id = 0;\nclass UniformsGroup extends EventDispatcher {\n  constructor() {\n    super();\n    this.isUniformsGroup = true;\n    Object.defineProperty(this, 'id', {\n      value: _id++\n    });\n    this.name = '';\n    this.usage = StaticDrawUsage;\n    this.uniforms = [];\n  }\n  add(uniform) {\n    this.uniforms.push(uniform);\n    return this;\n  }\n  remove(uniform) {\n    const index = this.uniforms.indexOf(uniform);\n    if (index !== -1) this.uniforms.splice(index, 1);\n    return this;\n  }\n  setName(name) {\n    this.name = name;\n    return this;\n  }\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n    return this;\n  }\n  copy(source) {\n    this.name = source.name;\n    this.usage = source.usage;\n    const uniformsSource = source.uniforms;\n    this.uniforms.length = 0;\n    for (let i = 0, l = uniformsSource.length; i < l; i++) {\n      const uniforms = Array.isArray(uniformsSource[i]) ? uniformsSource[i] : [uniformsSource[i]];\n      for (let j = 0; j < uniforms.length; j++) {\n        this.uniforms.push(uniforms[j].clone());\n      }\n    }\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n  constructor(array, stride, meshPerAttribute = 1) {\n    super(array, stride);\n    this.isInstancedInterleavedBuffer = true;\n    this.meshPerAttribute = meshPerAttribute;\n  }\n  copy(source) {\n    super.copy(source);\n    this.meshPerAttribute = source.meshPerAttribute;\n    return this;\n  }\n  clone(data) {\n    const ib = super.clone(data);\n    ib.meshPerAttribute = this.meshPerAttribute;\n    return ib;\n  }\n  toJSON(data) {\n    const json = super.toJSON(data);\n    json.isInstancedInterleavedBuffer = true;\n    json.meshPerAttribute = this.meshPerAttribute;\n    return json;\n  }\n}\nclass GLBufferAttribute {\n  constructor(buffer, type, itemSize, elementSize, count) {\n    this.isGLBufferAttribute = true;\n    this.name = '';\n    this.buffer = buffer;\n    this.type = type;\n    this.itemSize = itemSize;\n    this.elementSize = elementSize;\n    this.count = count;\n    this.version = 0;\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  setBuffer(buffer) {\n    this.buffer = buffer;\n    return this;\n  }\n  setType(type, elementSize) {\n    this.type = type;\n    this.elementSize = elementSize;\n    return this;\n  }\n  setItemSize(itemSize) {\n    this.itemSize = itemSize;\n    return this;\n  }\n  setCount(count) {\n    this.count = count;\n    return this;\n  }\n}\nconst _matrix = /*@__PURE__*/new Matrix4();\nclass Raycaster {\n  constructor(origin, direction, near = 0, far = Infinity) {\n    this.ray = new Ray(origin, direction);\n    // direction is assumed to be normalized (for accurate distance calculations)\n\n    this.near = near;\n    this.far = far;\n    this.camera = null;\n    this.layers = new Layers();\n    this.params = {\n      Mesh: {},\n      Line: {\n        threshold: 1\n      },\n      LOD: {},\n      Points: {\n        threshold: 1\n      },\n      Sprite: {}\n    };\n  }\n  set(origin, direction) {\n    // direction is assumed to be normalized (for accurate distance calculations)\n\n    this.ray.set(origin, direction);\n  }\n  setFromCamera(coords, camera) {\n    if (camera.isPerspectiveCamera) {\n      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n      this.camera = camera;\n    } else if (camera.isOrthographicCamera) {\n      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\n      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n      this.camera = camera;\n    } else {\n      console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);\n    }\n  }\n  setFromXRController(controller) {\n    _matrix.identity().extractRotation(controller.matrixWorld);\n    this.ray.origin.setFromMatrixPosition(controller.matrixWorld);\n    this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);\n    return this;\n  }\n  intersectObject(object, recursive = true, intersects = []) {\n    intersect(object, this, intersects, recursive);\n    intersects.sort(ascSort);\n    return intersects;\n  }\n  intersectObjects(objects, recursive = true, intersects = []) {\n    for (let i = 0, l = objects.length; i < l; i++) {\n      intersect(objects[i], this, intersects, recursive);\n    }\n    intersects.sort(ascSort);\n    return intersects;\n  }\n}\nfunction ascSort(a, b) {\n  return a.distance - b.distance;\n}\nfunction intersect(object, raycaster, intersects, recursive) {\n  let propagate = true;\n  if (object.layers.test(raycaster.layers)) {\n    const result = object.raycast(raycaster, intersects);\n    if (result === false) propagate = false;\n  }\n  if (propagate === true && recursive === true) {\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      intersect(children[i], raycaster, intersects, true);\n    }\n  }\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.\n * theta (the azimuthal angle) is measured from the positive z-axis.\n */\nclass Spherical {\n  constructor(radius = 1, phi = 0, theta = 0) {\n    this.radius = radius;\n    this.phi = phi; // polar angle\n    this.theta = theta; // azimuthal angle\n\n    return this;\n  }\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this;\n  }\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this;\n  }\n\n  // restrict phi to be between EPS and PI-EPS\n  makeSafe() {\n    const EPS = 0.000001;\n    this.phi = clamp(this.phi, EPS, Math.PI - EPS);\n    return this;\n  }\n  setFromVector3(v) {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n  }\n  setFromCartesianCoords(x, y, z) {\n    this.radius = Math.sqrt(x * x + y * y + z * z);\n    if (this.radius === 0) {\n      this.theta = 0;\n      this.phi = 0;\n    } else {\n      this.theta = Math.atan2(x, z);\n      this.phi = Math.acos(clamp(y / this.radius, -1, 1));\n    }\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\nclass Cylindrical {\n  constructor(radius = 1, theta = 0, y = 0) {\n    this.radius = radius; // distance from the origin to a point in the x-z plane\n    this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n    this.y = y; // height above the x-z plane\n\n    return this;\n  }\n  set(radius, theta, y) {\n    this.radius = radius;\n    this.theta = theta;\n    this.y = y;\n    return this;\n  }\n  copy(other) {\n    this.radius = other.radius;\n    this.theta = other.theta;\n    this.y = other.y;\n    return this;\n  }\n  setFromVector3(v) {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n  }\n  setFromCartesianCoords(x, y, z) {\n    this.radius = Math.sqrt(x * x + z * z);\n    this.theta = Math.atan2(x, z);\n    this.y = y;\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nclass Matrix2 {\n  constructor(n11, n12, n21, n22) {\n    Matrix2.prototype.isMatrix2 = true;\n    this.elements = [1, 0, 0, 1];\n    if (n11 !== undefined) {\n      this.set(n11, n12, n21, n22);\n    }\n  }\n  identity() {\n    this.set(1, 0, 0, 1);\n    return this;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 4; i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  set(n11, n12, n21, n22) {\n    const te = this.elements;\n    te[0] = n11;\n    te[2] = n12;\n    te[1] = n21;\n    te[3] = n22;\n    return this;\n  }\n}\nconst _vector$4 = /*@__PURE__*/new Vector2();\nclass Box2 {\n  constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {\n    this.isBox2 = true;\n    this.min = min;\n    this.max = max;\n  }\n  set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n    return this;\n  }\n  setFromPoints(points) {\n    this.makeEmpty();\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n    return this;\n  }\n  setFromCenterAndSize(center, size) {\n    const halfSize = _vector$4.copy(size).multiplyScalar(0.5);\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n  makeEmpty() {\n    this.min.x = this.min.y = +Infinity;\n    this.max.x = this.max.y = -Infinity;\n    return this;\n  }\n  isEmpty() {\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n    return this.max.x < this.min.x || this.max.y < this.min.y;\n  }\n  getCenter(target) {\n    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n  getSize(target) {\n    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);\n  }\n  expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  }\n  expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n  expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  }\n  containsPoint(point) {\n    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y;\n  }\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;\n  }\n  getParameter(point, target) {\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n\n    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));\n  }\n  intersectsBox(box) {\n    // using 4 splitting planes to rule out intersections\n\n    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y;\n  }\n  clampPoint(point, target) {\n    return target.copy(point).clamp(this.min, this.max);\n  }\n  distanceToPoint(point) {\n    return this.clampPoint(point, _vector$4).distanceTo(point);\n  }\n  intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n    if (this.isEmpty()) this.makeEmpty();\n    return this;\n  }\n  union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  }\n  translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  }\n  equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}\nconst _startP = /*@__PURE__*/new Vector3();\nconst _startEnd = /*@__PURE__*/new Vector3();\nclass Line3 {\n  constructor(start = new Vector3(), end = new Vector3()) {\n    this.start = start;\n    this.end = end;\n  }\n  set(start, end) {\n    this.start.copy(start);\n    this.end.copy(end);\n    return this;\n  }\n  copy(line) {\n    this.start.copy(line.start);\n    this.end.copy(line.end);\n    return this;\n  }\n  getCenter(target) {\n    return target.addVectors(this.start, this.end).multiplyScalar(0.5);\n  }\n  delta(target) {\n    return target.subVectors(this.end, this.start);\n  }\n  distanceSq() {\n    return this.start.distanceToSquared(this.end);\n  }\n  distance() {\n    return this.start.distanceTo(this.end);\n  }\n  at(t, target) {\n    return this.delta(target).multiplyScalar(t).add(this.start);\n  }\n  closestPointToPointParameter(point, clampToLine) {\n    _startP.subVectors(point, this.start);\n    _startEnd.subVectors(this.end, this.start);\n    const startEnd2 = _startEnd.dot(_startEnd);\n    const startEnd_startP = _startEnd.dot(_startP);\n    let t = startEnd_startP / startEnd2;\n    if (clampToLine) {\n      t = clamp(t, 0, 1);\n    }\n    return t;\n  }\n  closestPointToPoint(point, clampToLine, target) {\n    const t = this.closestPointToPointParameter(point, clampToLine);\n    return this.delta(target).multiplyScalar(t).add(this.start);\n  }\n  applyMatrix4(matrix) {\n    this.start.applyMatrix4(matrix);\n    this.end.applyMatrix4(matrix);\n    return this;\n  }\n  equals(line) {\n    return line.start.equals(this.start) && line.end.equals(this.end);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _vector$3 = /*@__PURE__*/new Vector3();\nclass SpotLightHelper extends Object3D {\n  constructor(light, color) {\n    super();\n    this.light = light;\n    this.matrixAutoUpdate = false;\n    this.color = color;\n    this.type = 'SpotLightHelper';\n    const geometry = new BufferGeometry();\n    const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];\n    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {\n      const p1 = i / l * Math.PI * 2;\n      const p2 = j / l * Math.PI * 2;\n      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);\n    }\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    const material = new LineBasicMaterial({\n      fog: false,\n      toneMapped: false\n    });\n    this.cone = new LineSegments(geometry, material);\n    this.add(this.cone);\n    this.update();\n  }\n  dispose() {\n    this.cone.geometry.dispose();\n    this.cone.material.dispose();\n  }\n  update() {\n    this.light.updateWorldMatrix(true, false);\n    this.light.target.updateWorldMatrix(true, false);\n\n    // update the local matrix based on the parent and light target transforms\n    if (this.parent) {\n      this.parent.updateWorldMatrix(true);\n      this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld);\n    } else {\n      this.matrix.copy(this.light.matrixWorld);\n    }\n    this.matrixWorld.copy(this.light.matrixWorld);\n    const coneLength = this.light.distance ? this.light.distance : 1000;\n    const coneWidth = coneLength * Math.tan(this.light.angle);\n    this.cone.scale.set(coneWidth, coneWidth, coneLength);\n    _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);\n    this.cone.lookAt(_vector$3);\n    if (this.color !== undefined) {\n      this.cone.material.color.set(this.color);\n    } else {\n      this.cone.material.color.copy(this.light.color);\n    }\n  }\n}\nconst _vector$2 = /*@__PURE__*/new Vector3();\nconst _boneMatrix = /*@__PURE__*/new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/new Matrix4();\nclass SkeletonHelper extends LineSegments {\n  constructor(object) {\n    const bones = getBoneList(object);\n    const geometry = new BufferGeometry();\n    const vertices = [];\n    const colors = [];\n    const color1 = new Color(0, 0, 1);\n    const color2 = new Color(0, 1, 0);\n    for (let i = 0; i < bones.length; i++) {\n      const bone = bones[i];\n      if (bone.parent && bone.parent.isBone) {\n        vertices.push(0, 0, 0);\n        vertices.push(0, 0, 0);\n        colors.push(color1.r, color1.g, color1.b);\n        colors.push(color2.r, color2.g, color2.b);\n      }\n    }\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({\n      vertexColors: true,\n      depthTest: false,\n      depthWrite: false,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n    this.isSkeletonHelper = true;\n    this.type = 'SkeletonHelper';\n    this.root = object;\n    this.bones = bones;\n    this.matrix = object.matrixWorld;\n    this.matrixAutoUpdate = false;\n  }\n  updateMatrixWorld(force) {\n    const bones = this.bones;\n    const geometry = this.geometry;\n    const position = geometry.getAttribute('position');\n    _matrixWorldInv.copy(this.root.matrixWorld).invert();\n    for (let i = 0, j = 0; i < bones.length; i++) {\n      const bone = bones[i];\n      if (bone.parent && bone.parent.isBone) {\n        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);\n        _vector$2.setFromMatrixPosition(_boneMatrix);\n        position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);\n        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);\n        _vector$2.setFromMatrixPosition(_boneMatrix);\n        position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);\n        j += 2;\n      }\n    }\n    geometry.getAttribute('position').needsUpdate = true;\n    super.updateMatrixWorld(force);\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nfunction getBoneList(object) {\n  const boneList = [];\n  if (object.isBone === true) {\n    boneList.push(object);\n  }\n  for (let i = 0; i < object.children.length; i++) {\n    boneList.push.apply(boneList, getBoneList(object.children[i]));\n  }\n  return boneList;\n}\nclass PointLightHelper extends Mesh {\n  constructor(light, sphereSize, color) {\n    const geometry = new SphereGeometry(sphereSize, 4, 2);\n    const material = new MeshBasicMaterial({\n      wireframe: true,\n      fog: false,\n      toneMapped: false\n    });\n    super(geometry, material);\n    this.light = light;\n    this.color = color;\n    this.type = 'PointLightHelper';\n    this.matrix = this.light.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.update();\n\n    /*\n    // TODO: delete this comment?\n    const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n    const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n    const d = light.distance;\n    if ( d === 0.0 ) {\n    \tthis.lightDistance.visible = false;\n    } else {\n    \tthis.lightDistance.scale.set( d, d, d );\n    }\n    this.add( this.lightDistance );\n    */\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n  update() {\n    this.light.updateWorldMatrix(true, false);\n    if (this.color !== undefined) {\n      this.material.color.set(this.color);\n    } else {\n      this.material.color.copy(this.light.color);\n    }\n\n    /*\n    const d = this.light.distance;\n    \tif ( d === 0.0 ) {\n    \t\tthis.lightDistance.visible = false;\n    \t} else {\n    \t\tthis.lightDistance.visible = true;\n    \tthis.lightDistance.scale.set( d, d, d );\n    \t}\n    */\n  }\n}\nconst _vector$1 = /*@__PURE__*/new Vector3();\nconst _color1 = /*@__PURE__*/new Color();\nconst _color2 = /*@__PURE__*/new Color();\nclass HemisphereLightHelper extends Object3D {\n  constructor(light, size, color) {\n    super();\n    this.light = light;\n    this.matrix = light.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.color = color;\n    this.type = 'HemisphereLightHelper';\n    const geometry = new OctahedronGeometry(size);\n    geometry.rotateY(Math.PI * 0.5);\n    this.material = new MeshBasicMaterial({\n      wireframe: true,\n      fog: false,\n      toneMapped: false\n    });\n    if (this.color === undefined) this.material.vertexColors = true;\n    const position = geometry.getAttribute('position');\n    const colors = new Float32Array(position.count * 3);\n    geometry.setAttribute('color', new BufferAttribute(colors, 3));\n    this.add(new Mesh(geometry, this.material));\n    this.update();\n  }\n  dispose() {\n    this.children[0].geometry.dispose();\n    this.children[0].material.dispose();\n  }\n  update() {\n    const mesh = this.children[0];\n    if (this.color !== undefined) {\n      this.material.color.set(this.color);\n    } else {\n      const colors = mesh.geometry.getAttribute('color');\n      _color1.copy(this.light.color);\n      _color2.copy(this.light.groundColor);\n      for (let i = 0, l = colors.count; i < l; i++) {\n        const color = i < l / 2 ? _color1 : _color2;\n        colors.setXYZ(i, color.r, color.g, color.b);\n      }\n      colors.needsUpdate = true;\n    }\n    this.light.updateWorldMatrix(true, false);\n    mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());\n  }\n}\nclass GridHelper extends LineSegments {\n  constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {\n    color1 = new Color(color1);\n    color2 = new Color(color2);\n    const center = divisions / 2;\n    const step = size / divisions;\n    const halfSize = size / 2;\n    const vertices = [],\n      colors = [];\n    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n      vertices.push(-halfSize, 0, k, halfSize, 0, k);\n      vertices.push(k, 0, -halfSize, k, 0, halfSize);\n      const color = i === center ? color1 : color2;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({\n      vertexColors: true,\n      toneMapped: false\n    });\n    super(geometry, material);\n    this.type = 'GridHelper';\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nclass PolarGridHelper extends LineSegments {\n  constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {\n    color1 = new Color(color1);\n    color2 = new Color(color2);\n    const vertices = [];\n    const colors = [];\n\n    // create the sectors\n\n    if (sectors > 1) {\n      for (let i = 0; i < sectors; i++) {\n        const v = i / sectors * (Math.PI * 2);\n        const x = Math.sin(v) * radius;\n        const z = Math.cos(v) * radius;\n        vertices.push(0, 0, 0);\n        vertices.push(x, 0, z);\n        const color = i & 1 ? color1 : color2;\n        colors.push(color.r, color.g, color.b);\n        colors.push(color.r, color.g, color.b);\n      }\n    }\n\n    // create the rings\n\n    for (let i = 0; i < rings; i++) {\n      const color = i & 1 ? color1 : color2;\n      const r = radius - radius / rings * i;\n      for (let j = 0; j < divisions; j++) {\n        // first vertex\n\n        let v = j / divisions * (Math.PI * 2);\n        let x = Math.sin(v) * r;\n        let z = Math.cos(v) * r;\n        vertices.push(x, 0, z);\n        colors.push(color.r, color.g, color.b);\n\n        // second vertex\n\n        v = (j + 1) / divisions * (Math.PI * 2);\n        x = Math.sin(v) * r;\n        z = Math.cos(v) * r;\n        vertices.push(x, 0, z);\n        colors.push(color.r, color.g, color.b);\n      }\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({\n      vertexColors: true,\n      toneMapped: false\n    });\n    super(geometry, material);\n    this.type = 'PolarGridHelper';\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nconst _v1 = /*@__PURE__*/new Vector3();\nconst _v2 = /*@__PURE__*/new Vector3();\nconst _v3 = /*@__PURE__*/new Vector3();\nclass DirectionalLightHelper extends Object3D {\n  constructor(light, size, color) {\n    super();\n    this.light = light;\n    this.matrix = light.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.color = color;\n    this.type = 'DirectionalLightHelper';\n    if (size === undefined) size = 1;\n    let geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));\n    const material = new LineBasicMaterial({\n      fog: false,\n      toneMapped: false\n    });\n    this.lightPlane = new Line(geometry, material);\n    this.add(this.lightPlane);\n    geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n    this.targetLine = new Line(geometry, material);\n    this.add(this.targetLine);\n    this.update();\n  }\n  dispose() {\n    this.lightPlane.geometry.dispose();\n    this.lightPlane.material.dispose();\n    this.targetLine.geometry.dispose();\n    this.targetLine.material.dispose();\n  }\n  update() {\n    this.light.updateWorldMatrix(true, false);\n    this.light.target.updateWorldMatrix(true, false);\n    _v1.setFromMatrixPosition(this.light.matrixWorld);\n    _v2.setFromMatrixPosition(this.light.target.matrixWorld);\n    _v3.subVectors(_v2, _v1);\n    this.lightPlane.lookAt(_v2);\n    if (this.color !== undefined) {\n      this.lightPlane.material.color.set(this.color);\n      this.targetLine.material.color.set(this.color);\n    } else {\n      this.lightPlane.material.color.copy(this.light.color);\n      this.targetLine.material.color.copy(this.light.color);\n    }\n    this.targetLine.lookAt(_v2);\n    this.targetLine.scale.z = _v3.length();\n  }\n}\nconst _vector = /*@__PURE__*/new Vector3();\nconst _camera = /*@__PURE__*/new Camera();\n\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttps://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html\n */\n\nclass CameraHelper extends LineSegments {\n  constructor(camera) {\n    const geometry = new BufferGeometry();\n    const material = new LineBasicMaterial({\n      color: 0xffffff,\n      vertexColors: true,\n      toneMapped: false\n    });\n    const vertices = [];\n    const colors = [];\n    const pointMap = {};\n\n    // near\n\n    addLine('n1', 'n2');\n    addLine('n2', 'n4');\n    addLine('n4', 'n3');\n    addLine('n3', 'n1');\n\n    // far\n\n    addLine('f1', 'f2');\n    addLine('f2', 'f4');\n    addLine('f4', 'f3');\n    addLine('f3', 'f1');\n\n    // sides\n\n    addLine('n1', 'f1');\n    addLine('n2', 'f2');\n    addLine('n3', 'f3');\n    addLine('n4', 'f4');\n\n    // cone\n\n    addLine('p', 'n1');\n    addLine('p', 'n2');\n    addLine('p', 'n3');\n    addLine('p', 'n4');\n\n    // up\n\n    addLine('u1', 'u2');\n    addLine('u2', 'u3');\n    addLine('u3', 'u1');\n\n    // target\n\n    addLine('c', 't');\n    addLine('p', 'c');\n\n    // cross\n\n    addLine('cn1', 'cn2');\n    addLine('cn3', 'cn4');\n    addLine('cf1', 'cf2');\n    addLine('cf3', 'cf4');\n    function addLine(a, b) {\n      addPoint(a);\n      addPoint(b);\n    }\n    function addPoint(id) {\n      vertices.push(0, 0, 0);\n      colors.push(0, 0, 0);\n      if (pointMap[id] === undefined) {\n        pointMap[id] = [];\n      }\n      pointMap[id].push(vertices.length / 3 - 1);\n    }\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n    super(geometry, material);\n    this.type = 'CameraHelper';\n    this.camera = camera;\n    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();\n    this.matrix = camera.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.pointMap = pointMap;\n    this.update();\n\n    // colors\n\n    const colorFrustum = new Color(0xffaa00);\n    const colorCone = new Color(0xff0000);\n    const colorUp = new Color(0x00aaff);\n    const colorTarget = new Color(0xffffff);\n    const colorCross = new Color(0x333333);\n    this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);\n  }\n  setColors(frustum, cone, up, target, cross) {\n    const geometry = this.geometry;\n    const colorAttribute = geometry.getAttribute('color');\n\n    // near\n\n    colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b); // n1, n2\n    colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b); // n2, n4\n    colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b); // n4, n3\n    colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b); // n3, n1\n\n    // far\n\n    colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b); // f1, f2\n    colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b); // f2, f4\n    colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b); // f4, f3\n    colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b); // f3, f1\n\n    // sides\n\n    colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b); // n1, f1\n    colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b); // n2, f2\n    colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b); // n3, f3\n    colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);\n    colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b); // n4, f4\n\n    // cone\n\n    colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);\n    colorAttribute.setXYZ(25, cone.r, cone.g, cone.b); // p, n1\n    colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);\n    colorAttribute.setXYZ(27, cone.r, cone.g, cone.b); // p, n2\n    colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);\n    colorAttribute.setXYZ(29, cone.r, cone.g, cone.b); // p, n3\n    colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);\n    colorAttribute.setXYZ(31, cone.r, cone.g, cone.b); // p, n4\n\n    // up\n\n    colorAttribute.setXYZ(32, up.r, up.g, up.b);\n    colorAttribute.setXYZ(33, up.r, up.g, up.b); // u1, u2\n    colorAttribute.setXYZ(34, up.r, up.g, up.b);\n    colorAttribute.setXYZ(35, up.r, up.g, up.b); // u2, u3\n    colorAttribute.setXYZ(36, up.r, up.g, up.b);\n    colorAttribute.setXYZ(37, up.r, up.g, up.b); // u3, u1\n\n    // target\n\n    colorAttribute.setXYZ(38, target.r, target.g, target.b);\n    colorAttribute.setXYZ(39, target.r, target.g, target.b); // c, t\n    colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);\n    colorAttribute.setXYZ(41, cross.r, cross.g, cross.b); // p, c\n\n    // cross\n\n    colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);\n    colorAttribute.setXYZ(43, cross.r, cross.g, cross.b); // cn1, cn2\n    colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);\n    colorAttribute.setXYZ(45, cross.r, cross.g, cross.b); // cn3, cn4\n\n    colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);\n    colorAttribute.setXYZ(47, cross.r, cross.g, cross.b); // cf1, cf2\n    colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);\n    colorAttribute.setXYZ(49, cross.r, cross.g, cross.b); // cf3, cf4\n\n    colorAttribute.needsUpdate = true;\n  }\n  update() {\n    const geometry = this.geometry;\n    const pointMap = this.pointMap;\n    const w = 1,\n      h = 1;\n\n    // we need just camera projection matrix inverse\n    // world matrix must be identity\n\n    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);\n\n    // Adjust z values based on coordinate system\n    const nearZ = this.camera.coordinateSystem === WebGLCoordinateSystem ? -1 : 0;\n\n    // center / target\n    setPoint('c', pointMap, geometry, _camera, 0, 0, nearZ);\n    setPoint('t', pointMap, geometry, _camera, 0, 0, 1);\n\n    // near\n\n    setPoint('n1', pointMap, geometry, _camera, -w, -h, nearZ);\n    setPoint('n2', pointMap, geometry, _camera, w, -h, nearZ);\n    setPoint('n3', pointMap, geometry, _camera, -w, h, nearZ);\n    setPoint('n4', pointMap, geometry, _camera, w, h, nearZ);\n\n    // far\n\n    setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);\n    setPoint('f2', pointMap, geometry, _camera, w, -h, 1);\n    setPoint('f3', pointMap, geometry, _camera, -w, h, 1);\n    setPoint('f4', pointMap, geometry, _camera, w, h, 1);\n\n    // up\n\n    setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, nearZ);\n    setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, nearZ);\n    setPoint('u3', pointMap, geometry, _camera, 0, h * 2, nearZ);\n\n    // cross\n\n    setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);\n    setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);\n    setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);\n    setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);\n    setPoint('cn1', pointMap, geometry, _camera, -w, 0, nearZ);\n    setPoint('cn2', pointMap, geometry, _camera, w, 0, nearZ);\n    setPoint('cn3', pointMap, geometry, _camera, 0, -h, nearZ);\n    setPoint('cn4', pointMap, geometry, _camera, 0, h, nearZ);\n    geometry.getAttribute('position').needsUpdate = true;\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nfunction setPoint(point, pointMap, geometry, camera, x, y, z) {\n  _vector.set(x, y, z).unproject(camera);\n  const points = pointMap[point];\n  if (points !== undefined) {\n    const position = geometry.getAttribute('position');\n    for (let i = 0, l = points.length; i < l; i++) {\n      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);\n    }\n  }\n}\nconst _box = /*@__PURE__*/new Box3();\nclass BoxHelper extends LineSegments {\n  constructor(object, color = 0xffff00) {\n    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n    const positions = new Float32Array(8 * 3);\n    const geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(indices, 1));\n    geometry.setAttribute('position', new BufferAttribute(positions, 3));\n    super(geometry, new LineBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    this.object = object;\n    this.type = 'BoxHelper';\n    this.matrixAutoUpdate = false;\n    this.update();\n  }\n  update(object) {\n    if (object !== undefined) {\n      console.warn('THREE.BoxHelper: .update() has no longer arguments.');\n    }\n    if (this.object !== undefined) {\n      _box.setFromObject(this.object);\n    }\n    if (_box.isEmpty()) return;\n    const min = _box.min;\n    const max = _box.max;\n\n    /*\n    \t5____4\n    1/___0/|\n    | 6__|_7\n    2/___3/\n    \t0: max.x, max.y, max.z\n    1: min.x, max.y, max.z\n    2: min.x, min.y, max.z\n    3: max.x, min.y, max.z\n    4: max.x, max.y, min.z\n    5: min.x, max.y, min.z\n    6: min.x, min.y, min.z\n    7: max.x, min.y, min.z\n    */\n\n    const position = this.geometry.attributes.position;\n    const array = position.array;\n    array[0] = max.x;\n    array[1] = max.y;\n    array[2] = max.z;\n    array[3] = min.x;\n    array[4] = max.y;\n    array[5] = max.z;\n    array[6] = min.x;\n    array[7] = min.y;\n    array[8] = max.z;\n    array[9] = max.x;\n    array[10] = min.y;\n    array[11] = max.z;\n    array[12] = max.x;\n    array[13] = max.y;\n    array[14] = min.z;\n    array[15] = min.x;\n    array[16] = max.y;\n    array[17] = min.z;\n    array[18] = min.x;\n    array[19] = min.y;\n    array[20] = min.z;\n    array[21] = max.x;\n    array[22] = min.y;\n    array[23] = min.z;\n    position.needsUpdate = true;\n    this.geometry.computeBoundingSphere();\n  }\n  setFromObject(object) {\n    this.object = object;\n    this.update();\n    return this;\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.object = source.object;\n    return this;\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nclass Box3Helper extends LineSegments {\n  constructor(box, color = 0xffff00) {\n    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];\n    const geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(indices, 1));\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    super(geometry, new LineBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    this.box = box;\n    this.type = 'Box3Helper';\n    this.geometry.computeBoundingSphere();\n  }\n  updateMatrixWorld(force) {\n    const box = this.box;\n    if (box.isEmpty()) return;\n    box.getCenter(this.position);\n    box.getSize(this.scale);\n    this.scale.multiplyScalar(0.5);\n    super.updateMatrixWorld(force);\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nclass PlaneHelper extends Line {\n  constructor(plane, size = 1, hex = 0xffff00) {\n    const color = hex;\n    const positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    super(geometry, new LineBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    this.type = 'PlaneHelper';\n    this.plane = plane;\n    this.size = size;\n    const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];\n    const geometry2 = new BufferGeometry();\n    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));\n    geometry2.computeBoundingSphere();\n    this.add(new Mesh(geometry2, new MeshBasicMaterial({\n      color: color,\n      opacity: 0.2,\n      transparent: true,\n      depthWrite: false,\n      toneMapped: false\n    })));\n  }\n  updateMatrixWorld(force) {\n    this.position.set(0, 0, 0);\n    this.scale.set(0.5 * this.size, 0.5 * this.size, 1);\n    this.lookAt(this.plane.normal);\n    this.translateZ(-this.plane.constant);\n    super.updateMatrixWorld(force);\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n    this.children[0].geometry.dispose();\n    this.children[0].material.dispose();\n  }\n}\nconst _axis = /*@__PURE__*/new Vector3();\nlet _lineGeometry, _coneGeometry;\nclass ArrowHelper extends Object3D {\n  // dir is assumed to be normalized\n\n  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {\n    super();\n    this.type = 'ArrowHelper';\n    if (_lineGeometry === undefined) {\n      _lineGeometry = new BufferGeometry();\n      _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);\n      _coneGeometry.translate(0, -0.5, 0);\n    }\n    this.position.copy(origin);\n    this.line = new Line(_lineGeometry, new LineBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    this.line.matrixAutoUpdate = false;\n    this.add(this.line);\n    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    this.cone.matrixAutoUpdate = false;\n    this.add(this.cone);\n    this.setDirection(dir);\n    this.setLength(length, headLength, headWidth);\n  }\n  setDirection(dir) {\n    // dir is assumed to be normalized\n\n    if (dir.y > 0.99999) {\n      this.quaternion.set(0, 0, 0, 1);\n    } else if (dir.y < -0.99999) {\n      this.quaternion.set(1, 0, 0, 0);\n    } else {\n      _axis.set(dir.z, 0, -dir.x).normalize();\n      const radians = Math.acos(dir.y);\n      this.quaternion.setFromAxisAngle(_axis, radians);\n    }\n  }\n  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {\n    this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458\n    this.line.updateMatrix();\n    this.cone.scale.set(headWidth, headLength, headWidth);\n    this.cone.position.y = length;\n    this.cone.updateMatrix();\n  }\n  setColor(color) {\n    this.line.material.color.set(color);\n    this.cone.material.color.set(color);\n  }\n  copy(source) {\n    super.copy(source, false);\n    this.line.copy(source.line);\n    this.cone.copy(source.cone);\n    return this;\n  }\n  dispose() {\n    this.line.geometry.dispose();\n    this.line.material.dispose();\n    this.cone.geometry.dispose();\n    this.cone.material.dispose();\n  }\n}\nclass AxesHelper extends LineSegments {\n  constructor(size = 1) {\n    const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];\n    const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({\n      vertexColors: true,\n      toneMapped: false\n    });\n    super(geometry, material);\n    this.type = 'AxesHelper';\n  }\n  setColors(xAxisColor, yAxisColor, zAxisColor) {\n    const color = new Color();\n    const array = this.geometry.attributes.color.array;\n    color.set(xAxisColor);\n    color.toArray(array, 0);\n    color.toArray(array, 3);\n    color.set(yAxisColor);\n    color.toArray(array, 6);\n    color.toArray(array, 9);\n    color.set(zAxisColor);\n    color.toArray(array, 12);\n    color.toArray(array, 15);\n    this.geometry.attributes.color.needsUpdate = true;\n    return this;\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nclass ShapePath {\n  constructor() {\n    this.type = 'ShapePath';\n    this.color = new Color();\n    this.subPaths = [];\n    this.currentPath = null;\n  }\n  moveTo(x, y) {\n    this.currentPath = new Path();\n    this.subPaths.push(this.currentPath);\n    this.currentPath.moveTo(x, y);\n    return this;\n  }\n  lineTo(x, y) {\n    this.currentPath.lineTo(x, y);\n    return this;\n  }\n  quadraticCurveTo(aCPx, aCPy, aX, aY) {\n    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\n    return this;\n  }\n  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\n    return this;\n  }\n  splineThru(pts) {\n    this.currentPath.splineThru(pts);\n    return this;\n  }\n  toShapes(isCCW) {\n    function toShapesNoHoles(inSubpaths) {\n      const shapes = [];\n      for (let i = 0, l = inSubpaths.length; i < l; i++) {\n        const tmpPath = inSubpaths[i];\n        const tmpShape = new Shape();\n        tmpShape.curves = tmpPath.curves;\n        shapes.push(tmpShape);\n      }\n      return shapes;\n    }\n    function isPointInsidePolygon(inPt, inPolygon) {\n      const polyLen = inPolygon.length;\n\n      // inPt on polygon contour => immediate success    or\n      // toggling of inside/outside at every single! intersection point of an edge\n      //  with the horizontal line through inPt, left of inPt\n      //  not counting lowerY endpoints of edges and whole edges on that line\n      let inside = false;\n      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n        let edgeLowPt = inPolygon[p];\n        let edgeHighPt = inPolygon[q];\n        let edgeDx = edgeHighPt.x - edgeLowPt.x;\n        let edgeDy = edgeHighPt.y - edgeLowPt.y;\n        if (Math.abs(edgeDy) > Number.EPSILON) {\n          // not parallel\n          if (edgeDy < 0) {\n            edgeLowPt = inPolygon[q];\n            edgeDx = -edgeDx;\n            edgeHighPt = inPolygon[p];\n            edgeDy = -edgeDy;\n          }\n          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;\n          if (inPt.y === edgeLowPt.y) {\n            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?\n            // continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n          } else {\n            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n            if (perpEdge === 0) return true; // inPt is on contour ?\n            if (perpEdge < 0) continue;\n            inside = !inside; // true intersection left of inPt\n          }\n        } else {\n          // parallel or collinear\n          if (inPt.y !== edgeLowPt.y) continue; // parallel\n          // edge lies on the same horizontal line as inPt\n          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !\n          // continue;\n        }\n      }\n      return inside;\n    }\n    const isClockWise = ShapeUtils.isClockWise;\n    const subPaths = this.subPaths;\n    if (subPaths.length === 0) return [];\n    let solid, tmpPath, tmpShape;\n    const shapes = [];\n    if (subPaths.length === 1) {\n      tmpPath = subPaths[0];\n      tmpShape = new Shape();\n      tmpShape.curves = tmpPath.curves;\n      shapes.push(tmpShape);\n      return shapes;\n    }\n    let holesFirst = !isClockWise(subPaths[0].getPoints());\n    holesFirst = isCCW ? !holesFirst : holesFirst;\n\n    // console.log(\"Holes first\", holesFirst);\n\n    const betterShapeHoles = [];\n    const newShapes = [];\n    let newShapeHoles = [];\n    let mainIdx = 0;\n    let tmpPoints;\n    newShapes[mainIdx] = undefined;\n    newShapeHoles[mainIdx] = [];\n    for (let i = 0, l = subPaths.length; i < l; i++) {\n      tmpPath = subPaths[i];\n      tmpPoints = tmpPath.getPoints();\n      solid = isClockWise(tmpPoints);\n      solid = isCCW ? !solid : solid;\n      if (solid) {\n        if (!holesFirst && newShapes[mainIdx]) mainIdx++;\n        newShapes[mainIdx] = {\n          s: new Shape(),\n          p: tmpPoints\n        };\n        newShapes[mainIdx].s.curves = tmpPath.curves;\n        if (holesFirst) mainIdx++;\n        newShapeHoles[mainIdx] = [];\n\n        //console.log('cw', i);\n      } else {\n        newShapeHoles[mainIdx].push({\n          h: tmpPath,\n          p: tmpPoints[0]\n        });\n\n        //console.log('ccw', i);\n      }\n    }\n\n    // only Holes? -> probably all Shapes with wrong orientation\n    if (!newShapes[0]) return toShapesNoHoles(subPaths);\n    if (newShapes.length > 1) {\n      let ambiguous = false;\n      let toChange = 0;\n      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        betterShapeHoles[sIdx] = [];\n      }\n      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        const sho = newShapeHoles[sIdx];\n        for (let hIdx = 0; hIdx < sho.length; hIdx++) {\n          const ho = sho[hIdx];\n          let hole_unassigned = true;\n          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n              if (sIdx !== s2Idx) toChange++;\n              if (hole_unassigned) {\n                hole_unassigned = false;\n                betterShapeHoles[s2Idx].push(ho);\n              } else {\n                ambiguous = true;\n              }\n            }\n          }\n          if (hole_unassigned) {\n            betterShapeHoles[sIdx].push(ho);\n          }\n        }\n      }\n      if (toChange > 0 && ambiguous === false) {\n        newShapeHoles = betterShapeHoles;\n      }\n    }\n    let tmpHoles;\n    for (let i = 0, il = newShapes.length; i < il; i++) {\n      tmpShape = newShapes[i].s;\n      shapes.push(tmpShape);\n      tmpHoles = newShapeHoles[i];\n      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {\n        tmpShape.holes.push(tmpHoles[j].h);\n      }\n    }\n\n    //console.log(\"shape\", shapes);\n\n    return shapes;\n  }\n}\nclass Controls extends EventDispatcher {\n  constructor(object, domElement = null) {\n    super();\n    this.object = object;\n    this.domElement = domElement;\n    this.enabled = true;\n    this.state = -1;\n    this.keys = {};\n    this.mouseButtons = {\n      LEFT: null,\n      MIDDLE: null,\n      RIGHT: null\n    };\n    this.touches = {\n      ONE: null,\n      TWO: null\n    };\n  }\n  connect() {}\n  disconnect() {}\n  dispose() {}\n  update(/* delta */) {}\n}\nfunction contain(texture, aspect) {\n  const imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;\n  if (imageAspect > aspect) {\n    texture.repeat.x = 1;\n    texture.repeat.y = imageAspect / aspect;\n    texture.offset.x = 0;\n    texture.offset.y = (1 - texture.repeat.y) / 2;\n  } else {\n    texture.repeat.x = aspect / imageAspect;\n    texture.repeat.y = 1;\n    texture.offset.x = (1 - texture.repeat.x) / 2;\n    texture.offset.y = 0;\n  }\n  return texture;\n}\nfunction cover(texture, aspect) {\n  const imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;\n  if (imageAspect > aspect) {\n    texture.repeat.x = aspect / imageAspect;\n    texture.repeat.y = 1;\n    texture.offset.x = (1 - texture.repeat.x) / 2;\n    texture.offset.y = 0;\n  } else {\n    texture.repeat.x = 1;\n    texture.repeat.y = imageAspect / aspect;\n    texture.offset.x = 0;\n    texture.offset.y = (1 - texture.repeat.y) / 2;\n  }\n  return texture;\n}\nfunction fill(texture) {\n  texture.repeat.x = 1;\n  texture.repeat.y = 1;\n  texture.offset.x = 0;\n  texture.offset.y = 0;\n  return texture;\n}\n\n/**\n * Given the width, height, format, and type of a texture. Determines how many\n * bytes must be used to represent the texture.\n *\n * @param {Number} width\n * @param {Number} height\n * @param {Number} format\n * @param {Number} type\n * @return {Number} The number of bytes required to represent the texture.\n */\nfunction getByteLength(width, height, format, type) {\n  const typeByteLength = getTextureTypeByteLength(type);\n  switch (format) {\n    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml\n    case AlphaFormat:\n      return width * height;\n    case LuminanceFormat:\n      return width * height;\n    case LuminanceAlphaFormat:\n      return width * height * 2;\n    case RedFormat:\n      return width * height / typeByteLength.components * typeByteLength.byteLength;\n    case RedIntegerFormat:\n      return width * height / typeByteLength.components * typeByteLength.byteLength;\n    case RGFormat:\n      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;\n    case RGIntegerFormat:\n      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;\n    case RGBFormat:\n      return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;\n    case RGBAFormat:\n      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;\n    case RGBAIntegerFormat:\n      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;\n\n    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/\n    case RGB_S3TC_DXT1_Format:\n    case RGBA_S3TC_DXT1_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n    case RGBA_S3TC_DXT3_Format:\n    case RGBA_S3TC_DXT5_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n\n    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/\n    case RGB_PVRTC_2BPPV1_Format:\n    case RGBA_PVRTC_2BPPV1_Format:\n      return Math.max(width, 16) * Math.max(height, 8) / 4;\n    case RGB_PVRTC_4BPPV1_Format:\n    case RGBA_PVRTC_4BPPV1_Format:\n      return Math.max(width, 8) * Math.max(height, 8) / 2;\n\n    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/\n    case RGB_ETC1_Format:\n    case RGB_ETC2_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n    case RGBA_ETC2_EAC_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n\n    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/\n    case RGBA_ASTC_4x4_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n    case RGBA_ASTC_5x4_Format:\n      return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;\n    case RGBA_ASTC_5x5_Format:\n      return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_6x5_Format:\n      return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_6x6_Format:\n      return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;\n    case RGBA_ASTC_8x5_Format:\n      return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_8x6_Format:\n      return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;\n    case RGBA_ASTC_8x8_Format:\n      return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;\n    case RGBA_ASTC_10x5_Format:\n      return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_10x6_Format:\n      return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;\n    case RGBA_ASTC_10x8_Format:\n      return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;\n    case RGBA_ASTC_10x10_Format:\n      return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;\n    case RGBA_ASTC_12x10_Format:\n      return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;\n    case RGBA_ASTC_12x12_Format:\n      return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;\n\n    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/\n    case RGBA_BPTC_Format:\n    case RGB_BPTC_SIGNED_Format:\n    case RGB_BPTC_UNSIGNED_Format:\n      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;\n\n    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/\n    case RED_RGTC1_Format:\n    case SIGNED_RED_RGTC1_Format:\n      return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;\n    case RED_GREEN_RGTC2_Format:\n    case SIGNED_RED_GREEN_RGTC2_Format:\n      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;\n  }\n  throw new Error(`Unable to determine texture byte length for ${format} format.`);\n}\nfunction getTextureTypeByteLength(type) {\n  switch (type) {\n    case UnsignedByteType:\n    case ByteType:\n      return {\n        byteLength: 1,\n        components: 1\n      };\n    case UnsignedShortType:\n    case ShortType:\n    case HalfFloatType:\n      return {\n        byteLength: 2,\n        components: 1\n      };\n    case UnsignedShort4444Type:\n    case UnsignedShort5551Type:\n      return {\n        byteLength: 2,\n        components: 4\n      };\n    case UnsignedIntType:\n    case IntType:\n    case FloatType:\n      return {\n        byteLength: 4,\n        components: 1\n      };\n    case UnsignedInt5999Type:\n      return {\n        byteLength: 4,\n        components: 3\n      };\n  }\n  throw new Error(`Unknown texture type ${type}.`);\n}\nconst TextureUtils = {\n  contain,\n  cover,\n  fill,\n  getByteLength\n};\nif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {\n    detail: {\n      revision: REVISION\n    }\n  }));\n}\nif (typeof window !== 'undefined') {\n  if (window.__THREE__) {\n    console.warn('WARNING: Multiple instances of Three.js being imported.');\n  } else {\n    window.__THREE__ = REVISION;\n  }\n}\nexport { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils, Matrix2, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OneFactor, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, Path, PerspectiveCamera, Plane, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RAD2DEG, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDepthPacking, RGBFormat, RGBIntegerFormat, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGDepthPacking, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RenderTarget, RenderTarget3D, RenderTargetArray, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, ShaderMaterial, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGLRenderTarget, WebGPUCoordinateSystem, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, arrayNeedsUint32, cloneUniforms, createCanvasElement, createElementNS, getByteLength, getUnlitUniformColorSpace, mergeUniforms, probeAsync, toNormalizedProjectionMatrix, toReversedProjectionMatrix, warnOnce };", "/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nimport { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4, EventDispatcher, MathUtils, WebGLCoordinateSystem, WebGPUCoordinateSystem, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, DynamicDrawUsage, InterleavedBufferAttribute, NoColorSpace, UnsignedIntType, IntType, BackSide, CubeReflectionMapping, CubeRefractionMapping, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, NormalBlending, PointsMaterial, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, Texture, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, ShadowMaterial, Uint32BufferAttribute, Uint16BufferAttribute, DoubleSide, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, RenderTarget, Plane, Object3D, HalfFloatType, LinearMipMapLinearFilter, OrthographicCamera, BufferGeometry, Float32BufferAttribute, BufferAttribute, UVMapping, Euler, LinearSRGBColorSpace, LessCompare, VSMShadowMap, RGFormat, BasicShadowMap, SphereGeometry, CubeUVReflectionMapping, PerspectiveCamera, RGBAFormat, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, SRGBColorSpace, PCFShadowMap, FrontSide, Frustum, DataTexture, RedIntegerFormat, RedFormat, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, UnsignedShortType, ByteType, ShortType, createCanvasElement, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, SrcAlphaFactor, SrcAlphaSaturateFactor, DstColorFactor, DstAlphaFactor, OneMinusSrcColorFactor, OneMinusSrcAlphaFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor, CullFaceNone, CullFaceBack, CullFaceFront, CustomBlending, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, AlphaFormat, LuminanceFormat, LuminanceAlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NeverCompare, AlwaysCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, warnOnce, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';\nexport { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LinearTransfer, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Matrix2, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneGeometry, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RenderTarget3D, RenderTargetArray, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding } from './three.core.js';\nconst refreshUniforms = ['alphaMap', 'alphaTest', 'anisotropy', 'anisotropyMap', 'anisotropyRotation', 'aoMap', 'attenuationColor', 'attenuationDistance', 'bumpMap', 'clearcoat', 'clearcoatMap', 'clearcoatNormalMap', 'clearcoatNormalScale', 'clearcoatRoughness', 'color', 'dispersion', 'displacementMap', 'emissive', 'emissiveMap', 'envMap', 'gradientMap', 'ior', 'iridescence', 'iridescenceIOR', 'iridescenceMap', 'iridescenceThicknessMap', 'lightMap', 'map', 'matcap', 'metalness', 'metalnessMap', 'normalMap', 'normalScale', 'opacity', 'roughness', 'roughnessMap', 'sheen', 'sheenColor', 'sheenColorMap', 'sheenRoughnessMap', 'shininess', 'specular', 'specularColor', 'specularColorMap', 'specularIntensity', 'specularIntensityMap', 'specularMap', 'thickness', 'transmission', 'transmissionMap'];\n\n/**\n * This class is used by {@link WebGPURenderer} as management component.\n * It's primary purpose is to determine whether render objects require a\n * refresh right before they are going to be rendered or not.\n */\nclass NodeMaterialObserver {\n  /**\n   * Constructs a new node material observer.\n   *\n   * @param {NodeBuilder} builder - The node builder.\n   */\n  constructor(builder) {\n    /**\n     * A node material can be used by more than one render object so the\n     * monitor must maintain a list of render objects.\n     *\n     * @type {WeakMap<RenderObject,Object>}\n     */\n    this.renderObjects = new WeakMap();\n\n    /**\n     * Whether the material uses node objects or not.\n     *\n     * @type {Boolean}\n     */\n    this.hasNode = this.containsNode(builder);\n\n    /**\n     * Whether the node builder's 3D object is animated or not.\n     *\n     * @type {Boolean}\n     */\n    this.hasAnimation = builder.object.isSkinnedMesh === true;\n\n    /**\n     * A list of all possible material uniforms\n     *\n     * @type {Array<String>}\n     */\n    this.refreshUniforms = refreshUniforms;\n\n    /**\n     * Holds the current render ID from the node frame.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.renderId = 0;\n  }\n\n  /**\n   * Returns `true` if the given render object is verified for the first time of this observer.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Boolean} Whether the given render object is verified for the first time of this observer.\n   */\n  firstInitialization(renderObject) {\n    const hasInitialized = this.renderObjects.has(renderObject);\n    if (hasInitialized === false) {\n      this.getRenderObjectData(renderObject);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns monitoring data for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Object} The monitoring data.\n   */\n  getRenderObjectData(renderObject) {\n    let data = this.renderObjects.get(renderObject);\n    if (data === undefined) {\n      const {\n        geometry,\n        material,\n        object\n      } = renderObject;\n      data = {\n        material: this.getMaterialData(material),\n        geometry: {\n          attributes: this.getAttributesData(geometry.attributes),\n          indexVersion: geometry.index ? geometry.index.version : null,\n          drawRange: {\n            start: geometry.drawRange.start,\n            count: geometry.drawRange.count\n          }\n        },\n        worldMatrix: object.matrixWorld.clone()\n      };\n      if (object.center) {\n        data.center = object.center.clone();\n      }\n      if (object.morphTargetInfluences) {\n        data.morphTargetInfluences = object.morphTargetInfluences.slice();\n      }\n      if (renderObject.bundle !== null) {\n        data.version = renderObject.bundle.version;\n      }\n      if (data.material.transmission > 0) {\n        const {\n          width,\n          height\n        } = renderObject.context;\n        data.bufferWidth = width;\n        data.bufferHeight = height;\n      }\n      this.renderObjects.set(renderObject, data);\n    }\n    return data;\n  }\n\n  /**\n   * Returns an attribute data structure holding the attributes versions for\n   * monitoring.\n   *\n   * @param {Object} attributes - The geometry attributes.\n   * @return {Object} An object for monitoring the versions of attributes.\n   */\n  getAttributesData(attributes) {\n    const attributesData = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      attributesData[name] = {\n        version: attribute.version\n      };\n    }\n    return attributesData;\n  }\n\n  /**\n   * Returns `true` if the node builder's material uses\n   * node properties.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Boolean} Whether the node builder's material uses node properties or not.\n   */\n  containsNode(builder) {\n    const material = builder.material;\n    for (const property in material) {\n      if (material[property] && material[property].isNode) return true;\n    }\n    if (builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null) return true;\n    return false;\n  }\n\n  /**\n   * Returns a material data structure holding the material property values for\n   * monitoring.\n   *\n   * @param {Material} material - The material.\n   * @return {Object} An object for monitoring material properties.\n   */\n  getMaterialData(material) {\n    const data = {};\n    for (const property of this.refreshUniforms) {\n      const value = material[property];\n      if (value === null || value === undefined) continue;\n      if (typeof value === 'object' && value.clone !== undefined) {\n        if (value.isTexture === true) {\n          data[property] = {\n            id: value.id,\n            version: value.version\n          };\n        } else {\n          data[property] = value.clone();\n        }\n      } else {\n        data[property] = value;\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Returns `true` if the given render object has not changed its state.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Boolean} Whether the given render object has changed its state or not.\n   */\n  equals(renderObject) {\n    const {\n      object,\n      material,\n      geometry\n    } = renderObject;\n    const renderObjectData = this.getRenderObjectData(renderObject);\n\n    // world matrix\n\n    if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {\n      renderObjectData.worldMatrix.copy(object.matrixWorld);\n      return false;\n    }\n\n    // material\n\n    const materialData = renderObjectData.material;\n    for (const property in materialData) {\n      const value = materialData[property];\n      const mtlValue = material[property];\n      if (value.equals !== undefined) {\n        if (value.equals(mtlValue) === false) {\n          value.copy(mtlValue);\n          return false;\n        }\n      } else if (mtlValue.isTexture === true) {\n        if (value.id !== mtlValue.id || value.version !== mtlValue.version) {\n          value.id = mtlValue.id;\n          value.version = mtlValue.version;\n          return false;\n        }\n      } else if (value !== mtlValue) {\n        materialData[property] = mtlValue;\n        return false;\n      }\n    }\n    if (materialData.transmission > 0) {\n      const {\n        width,\n        height\n      } = renderObject.context;\n      if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {\n        renderObjectData.bufferWidth = width;\n        renderObjectData.bufferHeight = height;\n        return false;\n      }\n    }\n\n    // geometry\n\n    const storedGeometryData = renderObjectData.geometry;\n    const attributes = geometry.attributes;\n    const storedAttributes = storedGeometryData.attributes;\n    const storedAttributeNames = Object.keys(storedAttributes);\n    const currentAttributeNames = Object.keys(attributes);\n    if (storedAttributeNames.length !== currentAttributeNames.length) {\n      renderObjectData.geometry.attributes = this.getAttributesData(attributes);\n      return false;\n    }\n\n    // compare each attribute\n\n    for (const name of storedAttributeNames) {\n      const storedAttributeData = storedAttributes[name];\n      const attribute = attributes[name];\n      if (attribute === undefined) {\n        // attribute was removed\n        delete storedAttributes[name];\n        return false;\n      }\n      if (storedAttributeData.version !== attribute.version) {\n        storedAttributeData.version = attribute.version;\n        return false;\n      }\n    }\n\n    // check index\n\n    const index = geometry.index;\n    const storedIndexVersion = storedGeometryData.indexVersion;\n    const currentIndexVersion = index ? index.version : null;\n    if (storedIndexVersion !== currentIndexVersion) {\n      storedGeometryData.indexVersion = currentIndexVersion;\n      return false;\n    }\n\n    // check drawRange\n\n    if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {\n      storedGeometryData.drawRange.start = geometry.drawRange.start;\n      storedGeometryData.drawRange.count = geometry.drawRange.count;\n      return false;\n    }\n\n    // morph targets\n\n    if (renderObjectData.morphTargetInfluences) {\n      let morphChanged = false;\n      for (let i = 0; i < renderObjectData.morphTargetInfluences.length; i++) {\n        if (renderObjectData.morphTargetInfluences[i] !== object.morphTargetInfluences[i]) {\n          morphChanged = true;\n        }\n      }\n      if (morphChanged) return true;\n    }\n\n    // center\n\n    if (renderObjectData.center) {\n      if (renderObjectData.center.equals(object.center) === false) {\n        renderObjectData.center.copy(object.center);\n        return true;\n      }\n    }\n\n    // bundle\n\n    if (renderObject.bundle !== null) {\n      renderObjectData.version = renderObject.bundle.version;\n    }\n    return true;\n  }\n\n  /**\n   * Checks if the given render object requires a refresh.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @param {NodeFrame} nodeFrame - The current node frame.\n   * @return {Boolean} Whether the given render object requires a refresh or not.\n   */\n  needsRefresh(renderObject, nodeFrame) {\n    if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject)) return true;\n    const {\n      renderId\n    } = nodeFrame;\n    if (this.renderId !== renderId) {\n      this.renderId = renderId;\n      return true;\n    }\n    const isStatic = renderObject.object.static === true;\n    const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;\n    if (isStatic || isBundle) return false;\n    const notEqual = this.equals(renderObject) !== true;\n    return notEqual;\n  }\n}\n\n/** @module NodeUtils **/\n\n// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.\n// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.\n// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\nfunction cyrb53(value, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed,\n    h2 = 0x41c6ce57 ^ seed;\n  if (value instanceof Array) {\n    for (let i = 0, val; i < value.length; i++) {\n      val = value[i];\n      h1 = Math.imul(h1 ^ val, 2654435761);\n      h2 = Math.imul(h2 ^ val, 1597334677);\n    }\n  } else {\n    for (let i = 0, ch; i < value.length; i++) {\n      ch = value.charCodeAt(i);\n      h1 = Math.imul(h1 ^ ch, 2654435761);\n      h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n  }\n  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);\n  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n}\n\n/**\n * Computes a hash for the given string.\n *\n * @method\n * @param {String} str - The string to be hashed.\n * @return {Number} The hash.\n */\nconst hashString = str => cyrb53(str);\n\n/**\n * Computes a hash for the given array.\n *\n * @method\n * @param {Array<Number>} array - The array to be hashed.\n * @return {Number} The hash.\n */\nconst hashArray = array => cyrb53(array);\n\n/**\n * Computes a hash for the given list of parameters.\n *\n * @method\n * @param {...Number} params - A list of parameters.\n * @return {Number} The hash.\n */\nconst hash$1 = (...params) => cyrb53(params);\n\n/**\n * Computes a cache key for the given node.\n *\n * @method\n * @param {Object} object - The object to be hashed.\n * @param {Boolean} [force=false] - Whether to force a cache key computation or not.\n * @return {Number} The hash.\n */\nfunction getCacheKey$1(object, force = false) {\n  const values = [];\n  if (object.isNode === true) {\n    values.push(object.id);\n    object = object.getSelf();\n  }\n  for (const {\n    property,\n    childNode\n  } of getNodeChildren(object)) {\n    values.push(values, cyrb53(property.slice(0, -4)), childNode.getCacheKey(force));\n  }\n  return cyrb53(values);\n}\n\n/**\n * This generator function can be used to iterate over the node children\n * of the given object.\n *\n * @generator\n * @param {Object} node - The object to be hashed.\n * @param {Boolean} [toJSON=false] - Whether to return JSON or not.\n * @yields {Object} A result node holding the property, index (if available) and the child node.\n */\nfunction* getNodeChildren(node, toJSON = false) {\n  for (const property in node) {\n    // Ignore private properties.\n    if (property.startsWith('_') === true) continue;\n    const object = node[property];\n    if (Array.isArray(object) === true) {\n      for (let i = 0; i < object.length; i++) {\n        const child = object[i];\n        if (child && (child.isNode === true || toJSON && typeof child.toJSON === 'function')) {\n          yield {\n            property,\n            index: i,\n            childNode: child\n          };\n        }\n      }\n    } else if (object && object.isNode === true) {\n      yield {\n        property,\n        childNode: object\n      };\n    } else if (typeof object === 'object') {\n      for (const subProperty in object) {\n        const child = object[subProperty];\n        if (child && (child.isNode === true || toJSON && typeof child.toJSON === 'function')) {\n          yield {\n            property,\n            index: subProperty,\n            childNode: child\n          };\n        }\n      }\n    }\n  }\n}\nconst typeFromLength = /*@__PURE__*/new Map([[1, 'float'], [2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);\nconst dataFromObject = /*@__PURE__*/new WeakMap();\n\n/**\n * Returns the data type for the given the length.\n *\n * @method\n * @param {Number} length - The length.\n * @return {String} The data type.\n */\nfunction getTypeFromLength(length) {\n  return typeFromLength.get(length);\n}\n\n/**\n * Returns the typed array for the given data type.\n *\n * @method\n * @param {String} type - The data type.\n * @return {TypedArray} The typed array.\n */\nfunction getTypedArrayFromType(type) {\n  // Handle component type for vectors and matrices\n  if (/[iu]?vec\\d/.test(type)) {\n    // Handle int vectors\n    if (type.startsWith('ivec')) return Int32Array;\n    // Handle uint vectors\n    if (type.startsWith('uvec')) return Uint32Array;\n    // Default to float vectors\n    return Float32Array;\n  }\n\n  // Handle matrices (always float)\n  if (/mat\\d/.test(type)) return Float32Array;\n\n  // Basic types\n  if (/float/.test(type)) return Float32Array;\n  if (/uint/.test(type)) return Uint32Array;\n  if (/int/.test(type)) return Int32Array;\n  throw new Error(`THREE.NodeUtils: Unsupported type: ${type}`);\n}\n\n/**\n * Returns the length for the given data type.\n *\n * @method\n * @param {String} type - The data type.\n * @return {Number} The length.\n */\nfunction getLengthFromType(type) {\n  if (/float|int|uint/.test(type)) return 1;\n  if (/vec2/.test(type)) return 2;\n  if (/vec3/.test(type)) return 3;\n  if (/vec4/.test(type)) return 4;\n  if (/mat3/.test(type)) return 9;\n  if (/mat4/.test(type)) return 16;\n  console.error('THREE.TSL: Unsupported type:', type);\n}\n\n/**\n * Returns the data type for the given value.\n *\n * @method\n * @param {Any} value - The value.\n * @return {String?} The data type.\n */\nfunction getValueType(value) {\n  if (value === undefined || value === null) return null;\n  const typeOf = typeof value;\n  if (value.isNode === true) {\n    return 'node';\n  } else if (typeOf === 'number') {\n    return 'float';\n  } else if (typeOf === 'boolean') {\n    return 'bool';\n  } else if (typeOf === 'string') {\n    return 'string';\n  } else if (typeOf === 'function') {\n    return 'shader';\n  } else if (value.isVector2 === true) {\n    return 'vec2';\n  } else if (value.isVector3 === true) {\n    return 'vec3';\n  } else if (value.isVector4 === true) {\n    return 'vec4';\n  } else if (value.isMatrix3 === true) {\n    return 'mat3';\n  } else if (value.isMatrix4 === true) {\n    return 'mat4';\n  } else if (value.isColor === true) {\n    return 'color';\n  } else if (value instanceof ArrayBuffer) {\n    return 'ArrayBuffer';\n  }\n  return null;\n}\n\n/**\n * Returns the value/object for the given data type and parameters.\n *\n * @method\n * @param {String} type - The given type.\n * @param {...Any} params - A parameter list.\n * @return {Any} The value/object.\n */\nfunction getValueFromType(type, ...params) {\n  const last4 = type ? type.slice(-4) : undefined;\n  if (params.length === 1) {\n    // ensure same behaviour as in NodeBuilder.format()\n\n    if (last4 === 'vec2') params = [params[0], params[0]];else if (last4 === 'vec3') params = [params[0], params[0], params[0]];else if (last4 === 'vec4') params = [params[0], params[0], params[0], params[0]];\n  }\n  if (type === 'color') {\n    return new Color(...params);\n  } else if (last4 === 'vec2') {\n    return new Vector2(...params);\n  } else if (last4 === 'vec3') {\n    return new Vector3(...params);\n  } else if (last4 === 'vec4') {\n    return new Vector4(...params);\n  } else if (last4 === 'mat3') {\n    return new Matrix3(...params);\n  } else if (last4 === 'mat4') {\n    return new Matrix4(...params);\n  } else if (type === 'bool') {\n    return params[0] || false;\n  } else if (type === 'float' || type === 'int' || type === 'uint') {\n    return params[0] || 0;\n  } else if (type === 'string') {\n    return params[0] || '';\n  } else if (type === 'ArrayBuffer') {\n    return base64ToArrayBuffer(params[0]);\n  }\n  return null;\n}\n\n/**\n * Gets the object data that can be shared between different rendering steps.\n *\n * @param {Object} object - The object to get the data for.\n * @return {Object} The object data.\n */\nfunction getDataFromObject(object) {\n  let data = dataFromObject.get(object);\n  if (data === undefined) {\n    data = {};\n    dataFromObject.set(object, data);\n  }\n  return data;\n}\n\n/**\n * Converts the given array buffer to a Base64 string.\n *\n * @method\n * @param {ArrayBuffer} arrayBuffer - The array buffer.\n * @return {String} The Base64 string.\n */\nfunction arrayBufferToBase64(arrayBuffer) {\n  let chars = '';\n  const array = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < array.length; i++) {\n    chars += String.fromCharCode(array[i]);\n  }\n  return btoa(chars);\n}\n\n/**\n * Converts the given Base64 string to an array buffer.\n *\n * @method\n * @param {String} base64 - The Base64 string.\n * @return {ArrayBuffer} The array buffer.\n */\nfunction base64ToArrayBuffer(base64) {\n  return Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;\n}\nvar NodeUtils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  arrayBufferToBase64: arrayBufferToBase64,\n  base64ToArrayBuffer: base64ToArrayBuffer,\n  getCacheKey: getCacheKey$1,\n  getDataFromObject: getDataFromObject,\n  getLengthFromType: getLengthFromType,\n  getNodeChildren: getNodeChildren,\n  getTypeFromLength: getTypeFromLength,\n  getTypedArrayFromType: getTypedArrayFromType,\n  getValueFromType: getValueFromType,\n  getValueType: getValueType,\n  hash: hash$1,\n  hashArray: hashArray,\n  hashString: hashString\n});\n\n/** @module NodeConstants **/\n\n/**\n * Possible shader stages.\n *\n * @property {string} VERTEX The vertex shader stage.\n * @property {string} FRAGMENT The fragment shader stage.\n */\nconst NodeShaderStage = {\n  VERTEX: 'vertex',\n  FRAGMENT: 'fragment'\n};\n\n/**\n * Update types of a node.\n *\n * @property {string} NONE The update method is not executed.\n * @property {string} FRAME The update method is executed per frame.\n * @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.\n * @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.\n */\nconst NodeUpdateType = {\n  NONE: 'none',\n  FRAME: 'frame',\n  RENDER: 'render',\n  OBJECT: 'object'\n};\n\n/**\n * Data types of a node.\n *\n * @property {string} BOOLEAN Boolean type.\n * @property {string} INTEGER Integer type.\n * @property {string} FLOAT Float type.\n * @property {string} VECTOR2 Two-dimensional vector type.\n * @property {string} VECTOR3 Three-dimensional vector type.\n * @property {string} VECTOR4 Four-dimensional vector type.\n * @property {string} MATRIX2 2x2 matrix type.\n * @property {string} MATRIX3 3x3 matrix type.\n * @property {string} MATRIX4 4x4 matrix type.\n */\nconst NodeType = {\n  BOOLEAN: 'bool',\n  INTEGER: 'int',\n  FLOAT: 'float',\n  VECTOR2: 'vec2',\n  VECTOR3: 'vec3',\n  VECTOR4: 'vec4',\n  MATRIX2: 'mat2',\n  MATRIX3: 'mat3',\n  MATRIX4: 'mat4'\n};\n\n/**\n * Access types of a node. These are relevant for compute and storage usage.\n *\n * @property {string} READ_ONLY Read-only access\n * @property {string} WRITE_ONLY Write-only access.\n * @property {string} READ_WRITE Read and write access.\n */\nconst NodeAccess = {\n  READ_ONLY: 'readOnly',\n  WRITE_ONLY: 'writeOnly',\n  READ_WRITE: 'readWrite'\n};\nconst defaultShaderStages = ['fragment', 'vertex'];\nconst defaultBuildStages = ['setup', 'analyze', 'generate'];\nconst shaderStages = [...defaultShaderStages, 'compute'];\nconst vectorComponents = ['x', 'y', 'z', 'w'];\nlet _nodeId = 0;\n\n/**\n * Base class for all nodes.\n *\n * @augments EventDispatcher\n */\nclass Node extends EventDispatcher {\n  static get type() {\n    return 'Node';\n  }\n\n  /**\n   * Constructs a new node.\n   *\n   * @param {String?} nodeType - The node type.\n   */\n  constructor(nodeType = null) {\n    super();\n\n    /**\n     * The node type. This represents the result type of the node (e.g. `float` or `vec3`).\n     *\n     * @type {String?}\n     * @default null\n     */\n    this.nodeType = nodeType;\n\n    /**\n     * The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.\n     *\n     * @type {String}\n     * @default 'none'\n     */\n    this.updateType = NodeUpdateType.NONE;\n\n    /**\n     * The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.\n     *\n     * @type {String}\n     * @default 'none'\n     */\n    this.updateBeforeType = NodeUpdateType.NONE;\n\n    /**\n     * The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.\n     *\n     * @type {String}\n     * @default 'none'\n     */\n    this.updateAfterType = NodeUpdateType.NONE;\n\n    /**\n     * The UUID of the node.\n     *\n     * @type {String}\n     * @readonly\n     */\n    this.uuid = MathUtils.generateUUID();\n\n    /**\n     * The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.\n     *\n     * @type {Number}\n     * @readonly\n     * @default 0\n     */\n    this.version = 0;\n\n    /**\n     * Whether this node is global or not. This property is relevant for the internal\n     * node caching system. All nodes which should be declared just once should\n     * set this flag to `true` (a typical example is {@link AttributeNode}).\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.global = false;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isNode = true;\n\n    // private\n\n    /**\n     * The cache key of this node.\n     *\n     * @private\n     * @type {Number?}\n     * @default null\n     */\n    this._cacheKey = null;\n\n    /**\n     * The cache key 's version.\n     *\n     * @private\n     * @type {Number}\n     * @default 0\n     */\n    this._cacheKeyVersion = 0;\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n\n  /**\n   * Set this property to `true` when the node should be regenerated.\n   *\n   * @type {Boolean}\n   * @default false\n   * @param {boolean} value\n   */\n  set needsUpdate(value) {\n    if (value === true) {\n      this.version++;\n    }\n  }\n\n  /**\n   * The type of the class. The value is usually the constructor name.\n   *\n   * @type {String}\n  \t * @readonly\n   */\n  get type() {\n    return this.constructor.type;\n  }\n\n  /**\n   * Convenient method for defining {@link Node#update}.\n   *\n   * @param {Function} callback - The update method.\n   * @param {String} updateType - The update type.\n   * @return {Node} A reference to this node.\n   */\n  onUpdate(callback, updateType) {\n    this.updateType = updateType;\n    this.update = callback.bind(this.getSelf());\n    return this;\n  }\n\n  /**\n   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n   * this method automatically sets the update type to `FRAME`.\n   *\n   * @param {Function} callback - The update method.\n   * @return {Node} A reference to this node.\n   */\n  onFrameUpdate(callback) {\n    return this.onUpdate(callback, NodeUpdateType.FRAME);\n  }\n\n  /**\n   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n   * this method automatically sets the update type to `RENDER`.\n   *\n   * @param {Function} callback - The update method.\n   * @return {Node} A reference to this node.\n   */\n  onRenderUpdate(callback) {\n    return this.onUpdate(callback, NodeUpdateType.RENDER);\n  }\n\n  /**\n   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n   * this method automatically sets the update type to `OBJECT`.\n   *\n   * @param {Function} callback - The update method.\n   * @return {Node} A reference to this node.\n   */\n  onObjectUpdate(callback) {\n    return this.onUpdate(callback, NodeUpdateType.OBJECT);\n  }\n\n  /**\n   * Convenient method for defining {@link Node#updateReference}.\n   *\n   * @param {Function} callback - The update method.\n   * @return {Node} A reference to this node.\n   */\n  onReference(callback) {\n    this.updateReference = callback.bind(this.getSelf());\n    return this;\n  }\n\n  /**\n   * The `this` reference might point to a Proxy so this method can be used\n   * to get the reference to the actual node instance.\n   *\n   * @return {Node} A reference to the node.\n   */\n  getSelf() {\n    // Returns non-node object.\n\n    return this.self || this;\n  }\n\n  /**\n   * Nodes might refer to other objects like materials. This method allows to dynamically update the reference\n   * to such objects based on a given state (e.g. the current node frame or builder).\n   *\n   * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n   * @return {Any} The updated reference.\n   */\n  updateReference(/*state*/\n  ) {\n    return this;\n  }\n\n  /**\n   * By default this method returns the value of the {@link Node#global} flag. This method\n   * can be overwritten in derived classes if an analytical way is required to determine the\n   * global status.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Boolean} Whether this node is global or not.\n   */\n  isGlobal(/*builder*/\n  ) {\n    return this.global;\n  }\n\n  /**\n   * Generator function that can be used to iterate over the child nodes.\n   *\n   * @generator\n   * @yields {Node} A child node.\n   */\n  *getChildren() {\n    for (const {\n      childNode\n    } of getNodeChildren(this)) {\n      yield childNode;\n    }\n  }\n\n  /**\n   * Calling this method dispatches the `dispose` event. This event can be used\n   * to register event listeners for clean up tasks.\n   */\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n  /**\n   * Callback for {@link Node#traverse}.\n   *\n   * @callback traverseCallback\n   * @param {Node} node - The current node.\n   */\n\n  /**\n   * Can be used to traverse through the node's hierarchy.\n   *\n   * @param {traverseCallback} callback - A callback that is executed per node.\n   */\n  traverse(callback) {\n    callback(this);\n    for (const childNode of this.getChildren()) {\n      childNode.traverse(callback);\n    }\n  }\n\n  /**\n   * Returns the cache key for this node.\n   *\n   * @param {Boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.\n   * @return {Number} The cache key of the node.\n   */\n  getCacheKey(force = false) {\n    force = force || this.version !== this._cacheKeyVersion;\n    if (force === true || this._cacheKey === null) {\n      this._cacheKey = hash$1(getCacheKey$1(this, force), this.customCacheKey());\n      this._cacheKeyVersion = this.version;\n    }\n    return this._cacheKey;\n  }\n\n  /**\n   * Generate a custom cache key for this node.\n   *\n   * @return {Number} The cache key of the node.\n   */\n  customCacheKey() {\n    return 0;\n  }\n\n  /**\n   * Returns the references to this node which is by default `this`.\n   *\n   * @return {Node} A reference to this node.\n   */\n  getScope() {\n    return this;\n  }\n\n  /**\n   * Returns the hash of the node which is used to identify the node. By default it's\n   * the {@link Node#uuid} however derived node classes might have to overwrite this method\n   * depending on their implementation.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The hash.\n   */\n  getHash(/*builder*/\n  ) {\n    return this.uuid;\n  }\n\n  /**\n   * Returns the update type of {@link Node#update}.\n   *\n   * @return {NodeUpdateType} The update type.\n   */\n  getUpdateType() {\n    return this.updateType;\n  }\n\n  /**\n   * Returns the update type of {@link Node#updateBefore}.\n   *\n   * @return {NodeUpdateType} The update type.\n   */\n  getUpdateBeforeType() {\n    return this.updateBeforeType;\n  }\n\n  /**\n   * Returns the update type of {@link Node#updateAfter}.\n   *\n   * @return {NodeUpdateType} The update type.\n   */\n  getUpdateAfterType() {\n    return this.updateAfterType;\n  }\n\n  /**\n   * Certain types are composed of multiple elements. For example a `vec3`\n   * is composed of three `float` values. This method returns the type of\n   * these elements.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The type of the node.\n   */\n  getElementType(builder) {\n    const type = this.getNodeType(builder);\n    const elementType = builder.getElementType(type);\n    return elementType;\n  }\n\n  /**\n   * Returns the node's type.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The type of the node.\n   */\n  getNodeType(builder) {\n    const nodeProperties = builder.getNodeProperties(this);\n    if (nodeProperties.outputNode) {\n      return nodeProperties.outputNode.getNodeType(builder);\n    }\n    return this.nodeType;\n  }\n\n  /**\n   * This method is used during the build process of a node and ensures\n   * equal nodes are not built multiple times but just once. For example if\n   * `attribute( 'uv' )` is used multiple times by the user, the build\n   * process makes sure to process just the first node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node} The shared node if possible. Otherwise `this` is returned.\n   */\n  getShared(builder) {\n    const hash = this.getHash(builder);\n    const nodeFromHash = builder.getNodeFromHash(hash);\n    return nodeFromHash || this;\n  }\n\n  /**\n   * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.\n   * This method is often overwritten in derived modules to prepare the node which is used as the output/result.\n   * The output node must be returned in the `return` statement.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node?} The output node.\n   */\n  setup(builder) {\n    const nodeProperties = builder.getNodeProperties(this);\n    let index = 0;\n    for (const childNode of this.getChildren()) {\n      nodeProperties['node' + index++] = childNode;\n    }\n\n    // return a outputNode if exists or null\n\n    return nodeProperties.outputNode || null;\n  }\n\n  /**\n   * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.\n   * This stage analyzes the node hierarchy and ensures descendent nodes are built.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  analyze(builder) {\n    const usageCount = builder.increaseUsage(this);\n    if (usageCount === 1) {\n      // node flow children\n\n      const nodeProperties = builder.getNodeProperties(this);\n      for (const childNode of Object.values(nodeProperties)) {\n        if (childNode && childNode.isNode === true) {\n          childNode.build(builder);\n        }\n      }\n    }\n  }\n\n  /**\n   * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.\n   * This state builds the output node and returns the resulting shader string.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {String?} output - Can be used to define the output type.\n   * @return {String?} The generated shader string.\n   */\n  generate(builder, output) {\n    const {\n      outputNode\n    } = builder.getNodeProperties(this);\n    if (outputNode && outputNode.isNode === true) {\n      return outputNode.build(builder, output);\n    }\n  }\n\n  /**\n   * The method can be implemented to update the node's internal state before it is used to render an object.\n   * The {@link Node#updateBeforeType} property defines how often the update is executed.\n   *\n   * @abstract\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n   */\n  updateBefore(/*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * The method can be implemented to update the node's internal state after it was used to render an object.\n   * The {@link Node#updateAfterType} property defines how often the update is executed.\n   *\n   * @abstract\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n   */\n  updateAfter(/*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * The method can be implemented to update the node's internal state when it is used to render an object.\n   * The {@link Node#updateType} property defines how often the update is executed.\n   *\n   * @abstract\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n   */\n  update(/*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * This method performs the build of a node. The behavior of this method as well as its return value depend\n   * on the current build stage (setup, analyze or generate).\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {String?} output - Can be used to define the output type.\n   * @return {String?} When this method is executed in the setup or analyze stage, `null` is returned. In the generate stage, the generated shader string.\n   */\n  build(builder, output = null) {\n    const refNode = this.getShared(builder);\n    if (this !== refNode) {\n      return refNode.build(builder, output);\n    }\n    builder.addNode(this);\n    builder.addChain(this);\n\n    /* Build stages expected results:\n    \t- \"setup\"\t\t-> Node\n    \t- \"analyze\"\t\t-> null\n    \t- \"generate\"\t-> String\n    */\n    let result = null;\n    const buildStage = builder.getBuildStage();\n    if (buildStage === 'setup') {\n      this.updateReference(builder);\n      const properties = builder.getNodeProperties(this);\n      if (properties.initialized !== true) {\n        //const stackNodesBeforeSetup = builder.stack.nodes.length;\n\n        properties.initialized = true;\n        const outputNode = this.setup(builder); // return a node or null\n        const isNodeOutput = outputNode && outputNode.isNode === true;\n\n        /*if ( isNodeOutput && builder.stack.nodes.length !== stackNodesBeforeSetup ) {\n        \t\t// !! no outputNode !!\n        \t//outputNode = builder.stack;\n        \t}*/\n\n        for (const childNode of Object.values(properties)) {\n          if (childNode && childNode.isNode === true) {\n            childNode.build(builder);\n          }\n        }\n        if (isNodeOutput) {\n          outputNode.build(builder);\n        }\n        properties.outputNode = outputNode;\n      }\n    } else if (buildStage === 'analyze') {\n      this.analyze(builder);\n    } else if (buildStage === 'generate') {\n      const isGenerateOnce = this.generate.length === 1;\n      if (isGenerateOnce) {\n        const type = this.getNodeType(builder);\n        const nodeData = builder.getDataFromNode(this);\n        result = nodeData.snippet;\n        if (result === undefined) {\n          result = this.generate(builder) || '';\n          nodeData.snippet = result;\n        } else if (nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined) {\n          builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);\n        }\n        result = builder.format(result, type, output);\n      } else {\n        result = this.generate(builder, output) || '';\n      }\n    }\n    builder.removeChain(this);\n    builder.addSequentialNode(this);\n    return result;\n  }\n\n  /**\n   * Returns the child nodes as a JSON object.\n   *\n   * @return {Object} The serialized child objects as JSON.\n   */\n  getSerializeChildren() {\n    return getNodeChildren(this);\n  }\n\n  /**\n   * Serializes the node to JSON.\n   *\n   * @param {Object} json - The output JSON object.\n   */\n  serialize(json) {\n    const nodeChildren = this.getSerializeChildren();\n    const inputNodes = {};\n    for (const {\n      property,\n      index,\n      childNode\n    } of nodeChildren) {\n      if (index !== undefined) {\n        if (inputNodes[property] === undefined) {\n          inputNodes[property] = Number.isInteger(index) ? [] : {};\n        }\n        inputNodes[property][index] = childNode.toJSON(json.meta).uuid;\n      } else {\n        inputNodes[property] = childNode.toJSON(json.meta).uuid;\n      }\n    }\n    if (Object.keys(inputNodes).length > 0) {\n      json.inputNodes = inputNodes;\n    }\n  }\n\n  /**\n   * Deserializes the node from the given JSON.\n   *\n   * @param {Object} json - The JSON object.\n   */\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n      for (const property in json.inputNodes) {\n        if (Array.isArray(json.inputNodes[property])) {\n          const inputArray = [];\n          for (const uuid of json.inputNodes[property]) {\n            inputArray.push(nodes[uuid]);\n          }\n          this[property] = inputArray;\n        } else if (typeof json.inputNodes[property] === 'object') {\n          const inputObject = {};\n          for (const subProperty in json.inputNodes[property]) {\n            const uuid = json.inputNodes[property][subProperty];\n            inputObject[subProperty] = nodes[uuid];\n          }\n          this[property] = inputObject;\n        } else {\n          const uuid = json.inputNodes[property];\n          this[property] = nodes[uuid];\n        }\n      }\n    }\n  }\n\n  /**\n   * Serializes the node into the three.js JSON Object/Scene format.\n   *\n   * @param {Object?} meta - An optional JSON object that already holds serialized data from other scene objects.\n   * @return {Object} The serialized node.\n   */\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n\n    // serialize\n\n    let data = meta.nodes[uuid];\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.6,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      if (isRoot !== true) meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n}\n\n/**\n * Base class for representing element access on an array-like\n * node data structures.\n *\n * @augments Node\n */\nclass ArrayElementNode extends Node {\n  // @TODO: If extending from TempNode it breaks webgpu_compute\n\n  static get type() {\n    return 'ArrayElementNode';\n  }\n\n  /**\n   * Constructs an array element node.\n   *\n   * @param {Node} node - The array-like node.\n   * @param {Node} indexNode - The index node that defines the element access.\n   */\n  constructor(node, indexNode) {\n    super();\n\n    /**\n     * The array-like node.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * The index node that defines the element access.\n     *\n     * @type {Node}\n     */\n    this.indexNode = indexNode;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isArrayElementNode = true;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from the array-like node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    return this.node.getElementType(builder);\n  }\n  generate(builder) {\n    const nodeSnippet = this.node.build(builder);\n    const indexSnippet = this.indexNode.build(builder, 'uint');\n    return `${nodeSnippet}[ ${indexSnippet} ]`;\n  }\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a convert operation during the shader generation process\n * meaning it converts the data type of a node to a target data type.\n *\n * @augments Node\n */\nclass ConvertNode extends Node {\n  static get type() {\n    return 'ConvertNode';\n  }\n\n  /**\n   * Constructs a new convert node.\n   *\n   * @param {Node} node - The node which type should be converted.\n   * @param {String} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.\n   */\n  constructor(node, convertTo) {\n    super();\n\n    /**\n     * The node which type should be converted.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * The target node type. Multiple types can be defined by separating them with a `|` sign.\n     *\n     * @type {String}\n     */\n    this.convertTo = convertTo;\n  }\n\n  /**\n   * This method is overwritten since the implementation tries to infer the best\n   * matching type from the {@link ConvertNode#convertTo} property.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    const requestType = this.node.getNodeType(builder);\n    let convertTo = null;\n    for (const overloadingType of this.convertTo.split('|')) {\n      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {\n        convertTo = overloadingType;\n      }\n    }\n    return convertTo;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.convertTo = this.convertTo;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.convertTo = data.convertTo;\n  }\n  generate(builder, output) {\n    const node = this.node;\n    const type = this.getNodeType(builder);\n    const snippet = node.build(builder, type);\n    return builder.format(snippet, type, output);\n  }\n}\n\n/**\n * This module uses cache management to create temporary variables\n * if the node is used more than once to prevent duplicate calculations.\n *\n * The class acts as a base class for many other nodes types.\n *\n * @augments Node\n */\nclass TempNode extends Node {\n  static get type() {\n    return 'TempNode';\n  }\n\n  /**\n   * Constructs a temp node.\n   *\n   * @param {String?} nodeType - The node type.\n   */\n  constructor(nodeType = null) {\n    super(nodeType);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isTempNode = true;\n  }\n\n  /**\n   * Whether this node is used more than once in context of other nodes.\n   *\n   * @param {NodeBuilder} builder - The node builder.\n   * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes.\n   */\n  hasDependencies(builder) {\n    return builder.getDataFromNode(this).usageCount > 1;\n  }\n  build(builder, output) {\n    const buildStage = builder.getBuildStage();\n    if (buildStage === 'generate') {\n      const type = builder.getVectorType(this.getNodeType(builder, output));\n      const nodeData = builder.getDataFromNode(this);\n      if (nodeData.propertyName !== undefined) {\n        return builder.format(nodeData.propertyName, type, output);\n      } else if (type !== 'void' && output !== 'void' && this.hasDependencies(builder)) {\n        const snippet = super.build(builder, type);\n        const nodeVar = builder.getVarFromNode(this, null, type);\n        const propertyName = builder.getPropertyName(nodeVar);\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n        nodeData.snippet = snippet;\n        nodeData.propertyName = propertyName;\n        return builder.format(nodeData.propertyName, type, output);\n      }\n    }\n    return super.build(builder, output);\n  }\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a join operation during the shader generation process.\n * For example in can compose/join two single floats into a `vec2` type.\n *\n * @augments TempNode\n */\nclass JoinNode extends TempNode {\n  static get type() {\n    return 'JoinNode';\n  }\n\n  /**\n   * Constructs a new join node.\n   *\n   * @param {Array<Node>} nodes - An array of nodes that should be joined.\n   * @param {String?} [nodeType=null] - The node type.\n   */\n  constructor(nodes = [], nodeType = null) {\n    super(nodeType);\n\n    /**\n     * An array of nodes that should be joined.\n     *\n     * @type {Array<Node>}\n     */\n    this.nodes = nodes;\n  }\n\n  /**\n   * This method is overwritten since the node type must be inferred from the\n   * joined data length if not explicitly defined.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    if (this.nodeType !== null) {\n      return builder.getVectorType(this.nodeType);\n    }\n    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const nodes = this.nodes;\n    const primitiveType = builder.getComponentType(type);\n    const snippetValues = [];\n    for (const input of nodes) {\n      let inputSnippet = input.build(builder);\n      const inputPrimitiveType = builder.getComponentType(input.getNodeType(builder));\n      if (inputPrimitiveType !== primitiveType) {\n        inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);\n      }\n      snippetValues.push(inputSnippet);\n    }\n    const snippet = `${builder.getType(type)}( ${snippetValues.join(', ')} )`;\n    return builder.format(snippet, type, output);\n  }\n}\nconst _stringVectorComponents = vectorComponents.join('');\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SplitNode` represents a property access operation which means it is\n * used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.\n * For example:\n * ```js\n * const redValue = color.r;\n * ```\n *\n * @augments Node\n */\nclass SplitNode extends Node {\n  static get type() {\n    return 'SplitNode';\n  }\n\n  /**\n   * Constructs a new split node.\n   *\n   * @param {Node} node - The node that should be accessed.\n   * @param {String} [components='x'] - The components that should be accessed.\n   */\n  constructor(node, components = 'x') {\n    super();\n\n    /**\n     * The node that should be accessed.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * The components that should be accessed.\n     *\n     * @type {string}\n     */\n    this.components = components;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isSplitNode = true;\n  }\n\n  /**\n   * Returns the vector length which is computed based on the requested components.\n   *\n   * @return {Number} The vector length.\n   */\n  getVectorLength() {\n    let vectorLength = this.components.length;\n    for (const c of this.components) {\n      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);\n    }\n    return vectorLength;\n  }\n\n  /**\n   * Returns the component type of the node's type.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The component type.\n   */\n  getComponentType(builder) {\n    return builder.getComponentType(this.node.getNodeType(builder));\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from requested components.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));\n  }\n  generate(builder, output) {\n    const node = this.node;\n    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));\n    let snippet = null;\n    if (nodeTypeLength > 1) {\n      let type = null;\n      const componentsLength = this.getVectorLength();\n      if (componentsLength >= nodeTypeLength) {\n        // needed expand the input node\n\n        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));\n      }\n      const nodeSnippet = node.build(builder, type);\n      if (this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice(0, this.components.length)) {\n        // unnecessary swizzle\n\n        snippet = builder.format(nodeSnippet, type, output);\n      } else {\n        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);\n      }\n    } else {\n      // ignore .components if .node returns float/integer\n\n      snippet = node.build(builder, output);\n    }\n    return snippet;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.components = this.components;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.components = data.components;\n  }\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SetNode` represents a set operation which means it is used to implement any\n * `setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.\n * For example:\n * ```js\n * materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );\n * ```\n *\n * @augments TempNode\n */\nclass SetNode extends TempNode {\n  static get type() {\n    return 'SetNode';\n  }\n\n  /**\n   * Constructs a new set node.\n   *\n   * @param {Node} sourceNode - The node that should be updated.\n   * @param {String} components - The components that should be updated.\n   * @param {Node} targetNode - The value node.\n   */\n  constructor(sourceNode, components, targetNode) {\n    super();\n\n    /**\n     * The node that should be updated.\n     *\n     * @type {Node}\n     */\n    this.sourceNode = sourceNode;\n\n    /**\n     * The components that should be updated.\n     *\n     * @type {String}\n     */\n    this.components = components;\n\n    /**\n     * The value node.\n     *\n     * @type {Node}\n     */\n    this.targetNode = targetNode;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    return this.sourceNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      sourceNode,\n      components,\n      targetNode\n    } = this;\n    const sourceType = this.getNodeType(builder);\n    const componentType = builder.getComponentType(targetNode.getNodeType(builder));\n    const targetType = builder.getTypeFromLength(components.length, componentType);\n    const targetSnippet = targetNode.build(builder, targetType);\n    const sourceSnippet = sourceNode.build(builder, sourceType);\n    const length = builder.getTypeLength(sourceType);\n    const snippetValues = [];\n    for (let i = 0; i < length; i++) {\n      const component = vectorComponents[i];\n      if (component === components[0]) {\n        snippetValues.push(targetSnippet);\n        i += components.length - 1;\n      } else {\n        snippetValues.push(sourceSnippet + '.' + component);\n      }\n    }\n    return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;\n  }\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a flip operation during the shader generation process\n * meaning it flips normalized values with the following formula:\n * ```\n * x = 1 - x;\n * ```\n * `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and\n * `flipSTPQ()` method invocations on node objects. For example:\n * ```js\n * uvNode = uvNode.flipY();\n * ```\n *\n * @augments TempNode\n */\nclass FlipNode extends TempNode {\n  static get type() {\n    return 'FlipNode';\n  }\n\n  /**\n   * Constructs a new flip node.\n   *\n   * @param {Node} sourceNode - The node which component(s) should be flipped.\n   * @param {String} components - The components that should be flipped e.g. `'x'` or `'xy'`.\n   */\n  constructor(sourceNode, components) {\n    super();\n\n    /**\n     * The node which component(s) should be flipped.\n     *\n     * @type {Node}\n     */\n    this.sourceNode = sourceNode;\n\n    /**\n     * The components that should be flipped e.g. `'x'` or `'xy'`.\n     *\n     * @type {String}\n     */\n    this.components = components;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from the source node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    return this.sourceNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      components,\n      sourceNode\n    } = this;\n    const sourceType = this.getNodeType(builder);\n    const sourceSnippet = sourceNode.build(builder);\n    const sourceCache = builder.getVarFromNode(this);\n    const sourceProperty = builder.getPropertyName(sourceCache);\n    builder.addLineFlowCode(sourceProperty + ' = ' + sourceSnippet, this);\n    const length = builder.getTypeLength(sourceType);\n    const snippetValues = [];\n    let componentIndex = 0;\n    for (let i = 0; i < length; i++) {\n      const component = vectorComponents[i];\n      if (component === components[componentIndex]) {\n        snippetValues.push('1.0 - ' + (sourceProperty + '.' + component));\n        componentIndex++;\n      } else {\n        snippetValues.push(sourceProperty + '.' + component);\n      }\n    }\n    return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;\n  }\n}\n\n/**\n * Base class for representing data input nodes.\n *\n * @augments Node\n */\nclass InputNode extends Node {\n  static get type() {\n    return 'InputNode';\n  }\n\n  /**\n   * Constructs a new input node.\n   *\n   * @param {Any} value - The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n   * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n   */\n  constructor(value, nodeType = null) {\n    super(nodeType);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isInputNode = true;\n\n    /**\n     * The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n     *\n     * @type {Any}\n     */\n    this.value = value;\n\n    /**\n     * The precision of the value in the shader.\n     *\n     * @type {('low'|'medium'|'high')?}\n     * @default null\n     */\n    this.precision = null;\n  }\n  getNodeType(/*builder*/\n  ) {\n    if (this.nodeType === null) {\n      return getValueType(this.value);\n    }\n    return this.nodeType;\n  }\n\n  /**\n   * Returns the input type of the node which is by default the node type. Derived modules\n   * might overwrite this method and use a fixed type or compute one analytically.\n   *\n   * A typical example for different input and node types are textures. The input type of a\n   * normal RGBA texture is `texture` whereas its node type is `vec4`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(builder) {\n    return this.getNodeType(builder);\n  }\n\n  /**\n   * Sets the precision to the given value. The method can be\n   * overwritten in derived classes if the final precision must be computed\n   * analytically.\n   *\n   * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.\n   * @return {InputNode} A reference to this node.\n   */\n  setPrecision(precision) {\n    this.precision = precision;\n    return this;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value;\n    if (this.value && this.value.toArray) data.value = this.value.toArray();\n    data.valueType = getValueType(this.value);\n    data.nodeType = this.nodeType;\n    if (data.valueType === 'ArrayBuffer') data.value = arrayBufferToBase64(data.value);\n    data.precision = this.precision;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.nodeType = data.nodeType;\n    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;\n    this.precision = data.precision || null;\n    if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);\n  }\n  generate(/*builder, output*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\n\n/**\n * Class for representing a constant value in the shader.\n *\n * @augments InputNode\n */\nclass ConstNode extends InputNode {\n  static get type() {\n    return 'ConstNode';\n  }\n\n  /**\n   * Constructs a new input node.\n   *\n   * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).\n   * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n   */\n  constructor(value, nodeType = null) {\n    super(value, nodeType);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isConstNode = true;\n  }\n\n  /**\n   * Generates the shader string of the value with the current node builder.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The generated value as a shader string.\n   */\n  generateConst(builder) {\n    return builder.generateConst(this.getNodeType(builder), this.value);\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    return builder.format(this.generateConst(builder), type, output);\n  }\n}\n\n//\n\nlet currentStack = null;\nconst NodeElements = new Map();\nfunction addMethodChaining(name, nodeElement) {\n  if (NodeElements.has(name)) {\n    console.warn(`Redefinition of method chaining ${name}`);\n    return;\n  }\n  if (typeof nodeElement !== 'function') throw new Error(`Node element ${name} is not a function`);\n  NodeElements.set(name, nodeElement);\n}\nconst parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\nconst parseSwizzleAndSort = props => parseSwizzle(props).split('').sort().join('');\nconst shaderNodeHandler = {\n  setup(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(nodeObjects(inputs), ...params);\n  },\n  get(node, prop, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (node.isStackNode !== true && prop === 'assign') {\n        return (...params) => {\n          currentStack.assign(nodeObj, ...params);\n          return nodeObj;\n        };\n      } else if (NodeElements.has(prop)) {\n        const nodeElement = NodeElements.get(prop);\n        return node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : (...params) => nodeElement(nodeObj, ...params);\n      } else if (prop === 'self') {\n        return node;\n      } else if (prop.endsWith('Assign') && NodeElements.has(prop.slice(0, prop.length - 'Assign'.length))) {\n        const nodeElement = NodeElements.get(prop.slice(0, prop.length - 'Assign'.length));\n        return node.isStackNode ? (...params) => nodeObj.assign(params[0], nodeElement(...params)) : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));\n      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n\n        prop = parseSwizzle(prop);\n        return nodeObject(new SplitNode(nodeObj, prop));\n      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        // set properties ( swizzle ) and sort to xyzw sequence\n\n        prop = parseSwizzleAndSort(prop.slice(3).toLowerCase());\n        return value => nodeObject(new SetNode(node, prop, value));\n      } else if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        // set properties ( swizzle ) and sort to xyzw sequence\n\n        prop = parseSwizzleAndSort(prop.slice(4).toLowerCase());\n        return () => nodeObject(new FlipNode(nodeObject(node), prop));\n      } else if (prop === 'width' || prop === 'height' || prop === 'depth') {\n        // accessing property\n\n        if (prop === 'width') prop = 'x';else if (prop === 'height') prop = 'y';else if (prop === 'depth') prop = 'z';\n        return nodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n\n        return nodeObject(new ArrayElementNode(nodeObj, new ConstNode(Number(prop), 'uint')));\n      }\n    }\n    return Reflect.get(node, prop, nodeObj);\n  },\n  set(node, prop, value, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      // setting properties\n\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test(prop) === true) {\n        nodeObj[prop].assign(value);\n        return true;\n      }\n    }\n    return Reflect.set(node, prop, value, nodeObj);\n  }\n};\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\nconst ShaderNodeObject = function (obj, altType = null) {\n  const type = getValueType(obj);\n  if (type === 'node') {\n    let nodeObject = nodeObjectsCacheMap.get(obj);\n    if (nodeObject === undefined) {\n      nodeObject = new Proxy(obj, shaderNodeHandler);\n      nodeObjectsCacheMap.set(obj, nodeObject);\n      nodeObjectsCacheMap.set(nodeObject, nodeObject);\n    }\n    return nodeObject;\n  } else if (altType === null && (type === 'float' || type === 'boolean') || type && type !== 'shader' && type !== 'string') {\n    return nodeObject(getConstNode(obj, altType));\n  } else if (type === 'shader') {\n    return Fn(obj);\n  }\n  return obj;\n};\nconst ShaderNodeObjects = function (objects, altType = null) {\n  for (const name in objects) {\n    objects[name] = nodeObject(objects[name], altType);\n  }\n  return objects;\n};\nconst ShaderNodeArray = function (array, altType = null) {\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    array[i] = nodeObject(array[i], altType);\n  }\n  return array;\n};\nconst ShaderNodeProxy = function (NodeClass, scope = null, factor = null, settings = null) {\n  const assignNode = node => nodeObject(settings !== null ? Object.assign(node, settings) : node);\n  if (scope === null) {\n    return (...params) => {\n      return assignNode(new NodeClass(...nodeArray(params)));\n    };\n  } else if (factor !== null) {\n    factor = nodeObject(factor);\n    return (...params) => {\n      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));\n    };\n  } else {\n    return (...params) => {\n      return assignNode(new NodeClass(scope, ...nodeArray(params)));\n    };\n  }\n};\nconst ShaderNodeImmutable = function (NodeClass, ...params) {\n  return nodeObject(new NodeClass(...nodeArray(params)));\n};\nclass ShaderCallNodeInternal extends Node {\n  constructor(shaderNode, inputNodes) {\n    super();\n    this.shaderNode = shaderNode;\n    this.inputNodes = inputNodes;\n  }\n  getNodeType(builder) {\n    return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);\n  }\n  call(builder) {\n    const {\n      shaderNode,\n      inputNodes\n    } = this;\n    const properties = builder.getNodeProperties(shaderNode);\n    if (properties.onceOutput) return properties.onceOutput;\n\n    //\n\n    let result = null;\n    if (shaderNode.layout) {\n      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);\n      if (functionNodesCacheMap === undefined) {\n        functionNodesCacheMap = new WeakMap();\n        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);\n      }\n      let functionNode = functionNodesCacheMap.get(shaderNode);\n      if (functionNode === undefined) {\n        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));\n        functionNodesCacheMap.set(shaderNode, functionNode);\n      }\n      if (builder.currentFunctionNode !== null) {\n        builder.currentFunctionNode.includes.push(functionNode);\n      }\n      result = nodeObject(functionNode.call(inputNodes));\n    } else {\n      const jsFunc = shaderNode.jsFunc;\n      const outputNode = inputNodes !== null ? jsFunc(inputNodes, builder) : jsFunc(builder);\n      result = nodeObject(outputNode);\n    }\n    if (shaderNode.once) {\n      properties.onceOutput = result;\n    }\n    return result;\n  }\n  getOutputNode(builder) {\n    const properties = builder.getNodeProperties(this);\n    if (properties.outputNode === null) {\n      properties.outputNode = this.setupOutput(builder);\n    }\n    return properties.outputNode;\n  }\n  setup(builder) {\n    return this.getOutputNode(builder);\n  }\n  setupOutput(builder) {\n    builder.addStack();\n    builder.stack.outputNode = this.call(builder);\n    return builder.removeStack();\n  }\n  generate(builder, output) {\n    const outputNode = this.getOutputNode(builder);\n    return outputNode.build(builder, output);\n  }\n}\nclass ShaderNodeInternal extends Node {\n  constructor(jsFunc, nodeType) {\n    super(nodeType);\n    this.jsFunc = jsFunc;\n    this.layout = null;\n    this.global = true;\n    this.once = false;\n  }\n  setLayout(layout) {\n    this.layout = layout;\n    return this;\n  }\n  call(inputs = null) {\n    nodeObjects(inputs);\n    return nodeObject(new ShaderCallNodeInternal(this, inputs));\n  }\n  setup() {\n    return this.call();\n  }\n}\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\nfor (const bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\nconst uintsCacheMap = new Map();\nfor (const uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\nfor (const int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\nfor (const float of floats) floatsCacheMap.set(float, new ConstNode(float));\nfor (const float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\nconst cacheMaps = {\n  bool: boolsCacheMap,\n  uint: uintsCacheMap,\n  ints: intsCacheMap,\n  float: floatsCacheMap\n};\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nconst getConstNode = (value, type) => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value, type);\n  }\n};\nconst safeGetNodeType = node => {\n  try {\n    return node.getNodeType();\n  } catch (_) {\n    return undefined;\n  }\n};\nconst ConvertType = function (type, cacheMap = null) {\n  return (...params) => {\n    if (params.length === 0 || !['bool', 'float', 'int', 'uint'].includes(type) && params.every(param => typeof param !== 'object')) {\n      params = [getValueFromType(type, ...params)];\n    }\n    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n      return nodeObject(cacheMap.get(params[0]));\n    }\n    if (params.length === 1) {\n      const node = getConstNode(params[0], type);\n      if (safeGetNodeType(node) === type) return nodeObject(node);\n      return nodeObject(new ConvertNode(node, type));\n    }\n    const nodes = params.map(param => getConstNode(param));\n    return nodeObject(new JoinNode(nodes, type));\n  };\n};\n\n// exports\n\nconst defined = v => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nconst getConstNodeType = value => value !== undefined && value !== null ? value.nodeType || value.convertTo || (typeof value === 'string' ? value : null) : null;\n\n// shader node base\n\nfunction ShaderNode(jsFunc, nodeType) {\n  return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);\n}\nconst nodeObject = (val, altType = null) => /* new */ShaderNodeObject(val, altType);\nconst nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);\nconst nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);\nconst nodeProxy = (...params) => new ShaderNodeProxy(...params);\nconst nodeImmutable = (...params) => new ShaderNodeImmutable(...params);\nconst Fn = (jsFunc, nodeType) => {\n  const shaderNode = new ShaderNode(jsFunc, nodeType);\n  const fn = (...params) => {\n    let inputs;\n    nodeObjects(params);\n    if (params[0] && params[0].isNode) {\n      inputs = [...params];\n    } else {\n      inputs = params[0];\n    }\n    return shaderNode.call(inputs);\n  };\n  fn.shaderNode = shaderNode;\n  fn.setLayout = layout => {\n    shaderNode.setLayout(layout);\n    return fn;\n  };\n  fn.once = () => {\n    shaderNode.once = true;\n    return fn;\n  };\n  return fn;\n};\nconst tslFn = (...params) => {\n  // @deprecated, r168\n\n  console.warn('TSL.ShaderNode: tslFn() has been renamed to Fn().');\n  return Fn(...params);\n};\n\n//\n\naddMethodChaining('toGlobal', node => {\n  node.global = true;\n  return node;\n});\n\n//\n\nconst setCurrentStack = stack => {\n  currentStack = stack;\n};\nconst getCurrentStack = () => currentStack;\nconst If = (...params) => currentStack.If(...params);\nfunction append(node) {\n  if (currentStack) currentStack.add(node);\n  return node;\n}\naddMethodChaining('append', append);\n\n// types\n\nconst color = new ConvertType('color');\nconst float = new ConvertType('float', cacheMaps.float);\nconst int = new ConvertType('int', cacheMaps.ints);\nconst uint = new ConvertType('uint', cacheMaps.uint);\nconst bool = new ConvertType('bool', cacheMaps.bool);\nconst vec2 = new ConvertType('vec2');\nconst ivec2 = new ConvertType('ivec2');\nconst uvec2 = new ConvertType('uvec2');\nconst bvec2 = new ConvertType('bvec2');\nconst vec3 = new ConvertType('vec3');\nconst ivec3 = new ConvertType('ivec3');\nconst uvec3 = new ConvertType('uvec3');\nconst bvec3 = new ConvertType('bvec3');\nconst vec4 = new ConvertType('vec4');\nconst ivec4 = new ConvertType('ivec4');\nconst uvec4 = new ConvertType('uvec4');\nconst bvec4 = new ConvertType('bvec4');\nconst mat2 = new ConvertType('mat2');\nconst mat3 = new ConvertType('mat3');\nconst mat4 = new ConvertType('mat4');\nconst string = (value = '') => nodeObject(new ConstNode(value, 'string'));\nconst arrayBuffer = value => nodeObject(new ConstNode(value, 'ArrayBuffer'));\naddMethodChaining('toColor', color);\naddMethodChaining('toFloat', float);\naddMethodChaining('toInt', int);\naddMethodChaining('toUint', uint);\naddMethodChaining('toBool', bool);\naddMethodChaining('toVec2', vec2);\naddMethodChaining('toIVec2', ivec2);\naddMethodChaining('toUVec2', uvec2);\naddMethodChaining('toBVec2', bvec2);\naddMethodChaining('toVec3', vec3);\naddMethodChaining('toIVec3', ivec3);\naddMethodChaining('toUVec3', uvec3);\naddMethodChaining('toBVec3', bvec3);\naddMethodChaining('toVec4', vec4);\naddMethodChaining('toIVec4', ivec4);\naddMethodChaining('toUVec4', uvec4);\naddMethodChaining('toBVec4', bvec4);\naddMethodChaining('toMat2', mat2);\naddMethodChaining('toMat3', mat3);\naddMethodChaining('toMat4', mat4);\n\n// basic nodes\n\nconst element = /*@__PURE__*/nodeProxy(ArrayElementNode);\nconst convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));\nconst split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));\naddMethodChaining('element', element);\naddMethodChaining('convert', convert);\n\n/** @module UniformGroupNode **/\n\n/**\n * This node can be used to group single instances of {@link UniformNode}\n * and manage them as a uniform buffer.\n *\n * In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`\n * will be used when defining the {@link UniformNode#groupNode} property.\n *\n * - `objectGroup`: Uniform buffer per object.\n * - `renderGroup`: Shared uniform buffer, updated once per render call.\n * - `frameGroup`: Shared uniform buffer, updated once per frame.\n *\n * @augments Node\n */\nclass UniformGroupNode extends Node {\n  static get type() {\n    return 'UniformGroupNode';\n  }\n\n  /**\n   * Constructs a new uniform group node.\n   *\n   * @param {String} name - The name of the uniform group node.\n   * @param {Boolean} [shared=false] - Whether this uniform group node is shared or not.\n   * @param {Number} [order=1] - Influences the internal sorting.\n   */\n  constructor(name, shared = false, order = 1) {\n    super('string');\n\n    /**\n     * The name of the uniform group node.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * Whether this uniform group node is shared or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.shared = shared;\n\n    /**\n     * Influences the internal sorting.\n     * TODO: Add details when this property should be changed.\n     *\n     * @type {Number}\n     * @default 1\n     */\n    this.order = order;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isUniformGroup = true;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.name = this.name;\n    data.version = this.version;\n    data.shared = this.shared;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.name = data.name;\n    this.version = data.version;\n    this.shared = data.shared;\n  }\n}\n\n/**\n * TSL function for creating a uniform group node with the given name.\n *\n * @function\n * @param {String} name - The name of the uniform group node.\n * @returns {UniformGroupNode}\n */\nconst uniformGroup = name => new UniformGroupNode(name);\n\n/**\n * TSL function for creating a shared uniform group node with the given name and order.\n *\n * @function\n * @param {String} name - The name of the uniform group node.\n * @param {Number} [order=0] - Influences the internal sorting.\n * @returns {UniformGroupNode}\n */\nconst sharedUniformGroup = (name, order = 0) => new UniformGroupNode(name, true, order);\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per frame.\n *\n * @type {UniformGroupNode}\n */\nconst frameGroup = /*@__PURE__*/sharedUniformGroup('frame');\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per render.\n *\n * @type {UniformGroupNode}\n */\nconst renderGroup = /*@__PURE__*/sharedUniformGroup('render');\n\n/**\n * TSL object that represents a uniform group node which is updated once per object.\n *\n * @type {UniformGroupNode}\n */\nconst objectGroup = /*@__PURE__*/uniformGroup('object');\n\n/** @module UniformNode **/\n\n/**\n * Class for representing a uniform.\n *\n * @augments InputNode\n */\nclass UniformNode extends InputNode {\n  static get type() {\n    return 'UniformNode';\n  }\n\n  /**\n   * Constructs a new uniform node.\n   *\n   * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n   * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n   */\n  constructor(value, nodeType = null) {\n    super(value, nodeType);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isUniformNode = true;\n\n    /**\n     * The name or label of the uniform.\n     *\n     * @type {String}\n     * @default ''\n     */\n    this.name = '';\n\n    /**\n     * The uniform group of this uniform. By default, uniforms are\n     * managed per object but they might belong to a shared group\n     * which is updated per frame or render call.\n     *\n     * @type {UniformGroupNode}\n     */\n    this.groupNode = objectGroup;\n  }\n\n  /**\n   * Sets the {@link UniformNode#name} property.\n   *\n   * @param {String} name - The name of the uniform.\n   * @return {UniformNode} A reference to this node.\n   */\n  label(name) {\n    this.name = name;\n    return this;\n  }\n\n  /**\n   * Sets the {@link UniformNode#groupNode} property.\n   *\n   * @param {UniformGroupNode} group - The uniform group.\n   * @return {UniformNode} A reference to this node.\n   */\n  setGroup(group) {\n    this.groupNode = group;\n    return this;\n  }\n\n  /**\n   * Returns the {@link UniformNode#groupNode}.\n   *\n   * @return {UniformGroupNode} The uniform group.\n   */\n  getGroup() {\n    return this.groupNode;\n  }\n\n  /**\n   * By default, this method returns the result of {@link Node#getHash} but derived\n   * classes might overwrite this method with a different implementation.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The uniform hash.\n   */\n  getUniformHash(builder) {\n    return this.getHash(builder);\n  }\n  onUpdate(callback, updateType) {\n    const self = this.getSelf();\n    callback = callback.bind(self);\n    return super.onUpdate(frame => {\n      const value = callback(frame, self);\n      if (value !== undefined) {\n        this.value = value;\n      }\n    }, updateType);\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const hash = this.getUniformHash(builder);\n    let sharedNode = builder.getNodeFromHash(hash);\n    if (sharedNode === undefined) {\n      builder.setHashNode(this, hash);\n      sharedNode = this;\n    }\n    const sharedNodeType = sharedNode.getInputType(builder);\n    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label);\n    const propertyName = builder.getPropertyName(nodeUniform);\n    if (builder.context.label !== undefined) delete builder.context.label;\n    return builder.format(propertyName, type, output);\n  }\n}\n\n/**\n * TSL function for creating a uniform node.\n *\n * @function\n * @param {Any} arg1 - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n * @param {String?} arg2 - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n * @returns {UniformNode}\n */\nconst uniform = (arg1, arg2) => {\n  const nodeType = getConstNodeType(arg2 || arg1);\n\n  // @TODO: get ConstNode from .traverse() in the future\n  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;\n  return nodeObject(new UniformNode(value, nodeType));\n};\n\n/** @module PropertyNode **/\n\n/**\n * This class represents a shader property. It can be used\n * to explicitly define a property and assign a value to it.\n *\n * ```js\n * const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );\n *```\n * `PropertyNode` is used by the engine to predefined common material properties\n * for TSL code.\n *\n * @augments Node\n */\nclass PropertyNode extends Node {\n  static get type() {\n    return 'PropertyNode';\n  }\n\n  /**\n   * Constructs a new property node.\n   *\n   * @param {String} nodeType - The type of the node.\n   * @param {String?} [name=null] - The name of the property in the shader.\n   * @param {Boolean} [varying=false] - Whether this property is a varying or not.\n   */\n  constructor(nodeType, name = null, varying = false) {\n    super(nodeType);\n\n    /**\n     * The name of the property in the shader. If no name is defined,\n     * the node system auto-generates one.\n     *\n     * @type {String?}\n     * @default null\n     */\n    this.name = name;\n\n    /**\n     * Whether this property is a varying or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.varying = varying;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isPropertyNode = true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n\n  /**\n   * The method is overwritten so it always returns `true`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Boolean} Whether this node is global or not.\n   */\n  isGlobal(/*builder*/\n  ) {\n    return true;\n  }\n  generate(builder) {\n    let nodeVar;\n    if (this.varying === true) {\n      nodeVar = builder.getVaryingFromNode(this, this.name);\n      nodeVar.needsInterpolation = true;\n    } else {\n      nodeVar = builder.getVarFromNode(this, this.name);\n    }\n    return builder.getPropertyName(nodeVar);\n  }\n}\n\n/**\n * TSL function for creating a property node.\n *\n * @function\n * @param {String} type - The type of the node.\n * @param {String?} [name=null] - The name of the property in the shader.\n * @returns {PropertyNode}\n */\nconst property = (type, name) => nodeObject(new PropertyNode(type, name));\n\n/**\n * TSL function for creating a varying property node.\n *\n * @function\n * @param {String} type - The type of the node.\n * @param {String?} [name=null] - The name of the varying in the shader.\n * @returns {PropertyNode}\n */\nconst varyingProperty = (type, name) => nodeObject(new PropertyNode(type, name, true));\n\n/**\n * TSL object that represents the shader variable `DiffuseColor`.\n *\n * @type {PropertyNode<vec4>}\n */\nconst diffuseColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec4', 'DiffuseColor');\n\n/**\n * TSL object that represents the shader variable `EmissiveColor`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst emissive = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'EmissiveColor');\n\n/**\n * TSL object that represents the shader variable `Roughness`.\n *\n * @type {PropertyNode<float>}\n */\nconst roughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Roughness');\n\n/**\n * TSL object that represents the shader variable `Metalness`.\n *\n * @type {PropertyNode<float>}\n */\nconst metalness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Metalness');\n\n/**\n * TSL object that represents the shader variable `Clearcoat`.\n *\n * @type {PropertyNode<float>}\n */\nconst clearcoat = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Clearcoat');\n\n/**\n * TSL object that represents the shader variable `ClearcoatRoughness`.\n *\n * @type {PropertyNode<float>}\n */\nconst clearcoatRoughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'ClearcoatRoughness');\n\n/**\n * TSL object that represents the shader variable `Sheen`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst sheen = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'Sheen');\n\n/**\n * TSL object that represents the shader variable `SheenRoughness`.\n *\n * @type {PropertyNode<float>}\n */\nconst sheenRoughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'SheenRoughness');\n\n/**\n * TSL object that represents the shader variable `Iridescence`.\n *\n * @type {PropertyNode<float>}\n */\nconst iridescence = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Iridescence');\n\n/**\n * TSL object that represents the shader variable `IridescenceIOR`.\n *\n * @type {PropertyNode<float>}\n */\nconst iridescenceIOR = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IridescenceIOR');\n\n/**\n * TSL object that represents the shader variable `IridescenceThickness`.\n *\n * @type {PropertyNode<float>}\n */\nconst iridescenceThickness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IridescenceThickness');\n\n/**\n * TSL object that represents the shader variable `AlphaT`.\n *\n * @type {PropertyNode<float>}\n */\nconst alphaT = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'AlphaT');\n\n/**\n * TSL object that represents the shader variable `Anisotropy`.\n *\n * @type {PropertyNode<float>}\n */\nconst anisotropy = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Anisotropy');\n\n/**\n * TSL object that represents the shader variable `AnisotropyT`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst anisotropyT = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'AnisotropyT');\n\n/**\n * TSL object that represents the shader variable `AnisotropyB`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst anisotropyB = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'AnisotropyB');\n\n/**\n * TSL object that represents the shader variable `SpecularColor`.\n *\n * @type {PropertyNode<color>}\n */\nconst specularColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'color', 'SpecularColor');\n\n/**\n * TSL object that represents the shader variable `SpecularF90`.\n *\n * @type {PropertyNode<float>}\n */\nconst specularF90 = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'SpecularF90');\n\n/**\n * TSL object that represents the shader variable `Shininess`.\n *\n * @type {PropertyNode<float>}\n */\nconst shininess = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Shininess');\n\n/**\n * TSL object that represents the shader variable `Output`.\n *\n * @type {PropertyNode<vec4>}\n */\nconst output = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec4', 'Output');\n\n/**\n * TSL object that represents the shader variable `dashSize`.\n *\n * @type {PropertyNode<float>}\n */\nconst dashSize = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'dashSize');\n\n/**\n * TSL object that represents the shader variable `gapSize`.\n *\n * @type {PropertyNode<float>}\n */\nconst gapSize = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'gapSize');\n\n/**\n * TSL object that represents the shader variable `pointWidth`.\n *\n * @type {PropertyNode<float>}\n */\nconst pointWidth = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'pointWidth');\n\n/**\n * TSL object that represents the shader variable `IOR`.\n *\n * @type {PropertyNode<float>}\n */\nconst ior = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IOR');\n\n/**\n * TSL object that represents the shader variable `Transmission`.\n *\n * @type {PropertyNode<float>}\n */\nconst transmission = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Transmission');\n\n/**\n * TSL object that represents the shader variable `Thickness`.\n *\n * @type {PropertyNode<float>}\n */\nconst thickness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Thickness');\n\n/**\n * TSL object that represents the shader variable `AttenuationDistance`.\n *\n * @type {PropertyNode<float>}\n */\nconst attenuationDistance = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'AttenuationDistance');\n\n/**\n * TSL object that represents the shader variable `AttenuationColor`.\n *\n * @type {PropertyNode<color>}\n */\nconst attenuationColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'color', 'AttenuationColor');\n\n/**\n * TSL object that represents the shader variable `Dispersion`.\n *\n * @type {PropertyNode<float>}\n */\nconst dispersion = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Dispersion');\n\n/** @module AssignNode **/\n\n/**\n * These node represents an assign operation. Meaning a node is assigned\n * to another node.\n *\n * @augments TempNode\n */\nclass AssignNode extends TempNode {\n  static get type() {\n    return 'AssignNode';\n  }\n\n  /**\n   * Constructs a new assign node.\n   *\n   * @param {Node} targetNode - The target node.\n   * @param {Node} sourceNode - The source type.\n   */\n  constructor(targetNode, sourceNode) {\n    super();\n\n    /**\n     * The target node.\n     *\n     * @type {Node}\n     */\n    this.targetNode = targetNode;\n\n    /**\n     * The source node.\n     *\n     * @type {Node}\n     */\n    this.sourceNode = sourceNode;\n  }\n\n  /**\n   * Whether this node is used more than once in context of other nodes. This method\n   * is overwritten since it always returns `false` (assigns are unique).\n   *\n   * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.\n   */\n  hasDependencies() {\n    return false;\n  }\n  getNodeType(builder, output) {\n    return output !== 'void' ? this.targetNode.getNodeType(builder) : 'void';\n  }\n\n  /**\n   * Whether a split is required when assigning source to target. This can happen when the component length of\n   * target and source data type does not match.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Boolean} Whether a split is required when assigning source to target.\n   */\n  needsSplitAssign(builder) {\n    const {\n      targetNode\n    } = this;\n    if (builder.isAvailable('swizzleAssign') === false && targetNode.isSplitNode && targetNode.components.length > 1) {\n      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));\n      const assignDifferentVector = vectorComponents.join('').slice(0, targetLength) !== targetNode.components;\n      return assignDifferentVector;\n    }\n    return false;\n  }\n  generate(builder, output) {\n    const {\n      targetNode,\n      sourceNode\n    } = this;\n    const needsSplitAssign = this.needsSplitAssign(builder);\n    const targetType = targetNode.getNodeType(builder);\n    const target = targetNode.context({\n      assign: true\n    }).build(builder);\n    const source = sourceNode.build(builder, targetType);\n    const sourceType = sourceNode.getNodeType(builder);\n    const nodeData = builder.getDataFromNode(this);\n\n    //\n\n    let snippet;\n    if (nodeData.initialized === true) {\n      if (output !== 'void') {\n        snippet = target;\n      }\n    } else if (needsSplitAssign) {\n      const sourceVar = builder.getVarFromNode(this, null, targetType);\n      const sourceProperty = builder.getPropertyName(sourceVar);\n      builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);\n      const targetRoot = targetNode.node.context({\n        assign: true\n      }).build(builder);\n      for (let i = 0; i < targetNode.components.length; i++) {\n        const component = targetNode.components[i];\n        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);\n      }\n      if (output !== 'void') {\n        snippet = target;\n      }\n    } else {\n      snippet = `${target} = ${source}`;\n      if (output === 'void' || sourceType === 'void') {\n        builder.addLineFlowCode(snippet, this);\n        if (output !== 'void') {\n          snippet = target;\n        }\n      }\n    }\n    nodeData.initialized = true;\n    return builder.format(snippet, targetType, output);\n  }\n}\n\n/**\n * TSL function for creating an assign node.\n *\n * @function\n * @param {Node} targetNode - The target node.\n * @param {Node} sourceNode - The source type.\n * @returns {AssignNode}\n */\nconst assign = /*@__PURE__*/nodeProxy(AssignNode);\naddMethodChaining('assign', assign);\n\n/**\n * This module represents the call of a {@link FunctionNode}. Developers are usually not confronted\n * with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate\n * this logic.\n *\n * @augments TempNode\n */\nclass FunctionCallNode extends TempNode {\n  static get type() {\n    return 'FunctionCallNode';\n  }\n\n  /**\n   * Constructs a new function call node.\n   *\n   * @param {FunctionNode?} functionNode - The function node.\n   * @param {Object<String, Node>} [parameters={}] - The parameters for the function call.\n   */\n  constructor(functionNode = null, parameters = {}) {\n    super();\n\n    /**\n     * The function node.\n     *\n     * @type {FunctionNode}\n     * @default null\n     */\n    this.functionNode = functionNode;\n\n    /**\n     * The parameters of the function call.\n     *\n     * @type {Object<String, Node>}\n     * @default {}\n     */\n    this.parameters = parameters;\n  }\n\n  /**\n   * Sets the parameters of the function call node.\n   *\n   * @param {Object<String, Node>} parameters - The parameters to set.\n   * @return {FunctionCallNode} A reference to this node.\n   */\n  setParameters(parameters) {\n    this.parameters = parameters;\n    return this;\n  }\n\n  /**\n   * Returns the parameters of the function call node.\n   *\n   * @return {Object<String, Node>} The parameters of this node.\n   */\n  getParameters() {\n    return this.parameters;\n  }\n  getNodeType(builder) {\n    return this.functionNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const params = [];\n    const functionNode = this.functionNode;\n    const inputs = functionNode.getInputs(builder);\n    const parameters = this.parameters;\n    const generateInput = (node, inputNode) => {\n      const type = inputNode.type;\n      const pointer = type === 'pointer';\n      let output;\n      if (pointer) output = '&' + node.build(builder);else output = node.build(builder, type);\n      return output;\n    };\n    if (Array.isArray(parameters)) {\n      for (let i = 0; i < parameters.length; i++) {\n        params.push(generateInput(parameters[i], inputs[i]));\n      }\n    } else {\n      for (const inputNode of inputs) {\n        const node = parameters[inputNode.name];\n        if (node !== undefined) {\n          params.push(generateInput(node, inputNode));\n        } else {\n          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);\n        }\n      }\n    }\n    const functionName = functionNode.build(builder, 'property');\n    return `${functionName}( ${params.join(', ')} )`;\n  }\n}\nconst call = (func, ...params) => {\n  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);\n  return nodeObject(new FunctionCallNode(nodeObject(func), params));\n};\naddMethodChaining('call', call);\n\n/** @module OperatorNode **/\n\n/**\n * This node represents basic mathematical and logical operations like addition,\n * subtraction or comparisons (e.g. `equal()`).\n *\n * @augments TempNode\n */\nclass OperatorNode extends TempNode {\n  static get type() {\n    return 'OperatorNode';\n  }\n\n  /**\n   * Constructs a new operator node.\n   *\n   * @param {String} op - The operator.\n   * @param {Node} aNode - The first input.\n   * @param {Node} bNode - The second input.\n   * @param {...Node} params - Additional input parameters.\n   */\n  constructor(op, aNode, bNode, ...params) {\n    super();\n    if (params.length > 0) {\n      let finalOp = new OperatorNode(op, aNode, bNode);\n      for (let i = 0; i < params.length - 1; i++) {\n        finalOp = new OperatorNode(op, finalOp, params[i]);\n      }\n      aNode = finalOp;\n      bNode = params[params.length - 1];\n    }\n\n    /**\n     * The operator.\n     *\n     * @type {String}\n     */\n    this.op = op;\n\n    /**\n     * The first input.\n     *\n     * @type {Node}\n     */\n    this.aNode = aNode;\n\n    /**\n     * The second input.\n     *\n     * @type {Node}\n     */\n    this.bNode = bNode;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from the operator\n   * and the input node types.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {String} output - The current output string.\n   * @return {String} The node type.\n   */\n  getNodeType(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const typeA = aNode.getNodeType(builder);\n    const typeB = typeof bNode !== 'undefined' ? bNode.getNodeType(builder) : null;\n    if (typeA === 'void' || typeB === 'void') {\n      return 'void';\n    } else if (op === '%') {\n      return typeA;\n    } else if (op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {\n      return builder.getIntegerType(typeA);\n    } else if (op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^') {\n      return 'bool';\n    } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n      const typeLength = output ? builder.getTypeLength(output) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));\n      return typeLength > 1 ? `bvec${typeLength}` : 'bool';\n    } else {\n      if (typeA === 'float' && builder.isMatrix(typeB)) {\n        return typeB;\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n\n        return builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n\n        return builder.getVectorFromMatrix(typeB);\n      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\n        // anytype x anytype: use the greater length vector\n\n        return typeB;\n      }\n      return typeA;\n    }\n  }\n  generate(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const type = this.getNodeType(builder, output);\n    let typeA = null;\n    let typeB = null;\n    if (type !== 'void') {\n      typeA = aNode.getNodeType(builder);\n      typeB = typeof bNode !== 'undefined' ? bNode.getNodeType(builder) : null;\n      if (op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==') {\n        if (builder.isVector(typeA)) {\n          typeB = typeA;\n        } else if (typeA !== typeB) {\n          typeA = typeB = 'float';\n        }\n      } else if (op === '>>' || op === '<<') {\n        typeA = type;\n        typeB = builder.changeComponentType(typeB, 'uint');\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n\n        typeB = builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n\n        typeA = builder.getVectorFromMatrix(typeB);\n      } else {\n        // anytype x anytype\n\n        typeA = typeB = type;\n      }\n    } else {\n      typeA = typeB = type;\n    }\n    const a = aNode.build(builder, typeA);\n    const b = typeof bNode !== 'undefined' ? bNode.build(builder, typeB) : null;\n    const outputLength = builder.getTypeLength(output);\n    const fnOpSnippet = builder.getFunctionOperator(op);\n    if (output !== 'void') {\n      if (op === '<' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('lessThan', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} < ${b} )`, type, output);\n        }\n      } else if (op === '<=' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('lessThanEqual', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} <= ${b} )`, type, output);\n        }\n      } else if (op === '>' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('greaterThan', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} > ${b} )`, type, output);\n        }\n      } else if (op === '>=' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('greaterThanEqual', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} >= ${b} )`, type, output);\n        }\n      } else if (op === '!' || op === '~') {\n        return builder.format(`(${op}${a})`, typeA, output);\n      } else if (fnOpSnippet) {\n        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`( ${a} ${op} ${b} )`, type, output);\n      }\n    } else if (typeA !== 'void') {\n      if (fnOpSnippet) {\n        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`${a} ${op} ${b}`, type, output);\n      }\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.op = this.op;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.op = data.op;\n  }\n}\n\n/**\n * Returns the addition of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst add = /*@__PURE__*/nodeProxy(OperatorNode, '+');\n\n/**\n * Returns the subtraction of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst sub = /*@__PURE__*/nodeProxy(OperatorNode, '-');\n\n/**\n * Returns the multiplication of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst mul = /*@__PURE__*/nodeProxy(OperatorNode, '*');\n\n/**\n * Returns the division of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst div = /*@__PURE__*/nodeProxy(OperatorNode, '/');\n\n/**\n * Computes the remainder of dividing the first node by the second, for integer values.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst modInt = /*@__PURE__*/nodeProxy(OperatorNode, '%');\n\n/**\n * Checks if two nodes are equal.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst equal = /*@__PURE__*/nodeProxy(OperatorNode, '==');\n\n/**\n * Checks if two nodes are not equal.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst notEqual = /*@__PURE__*/nodeProxy(OperatorNode, '!=');\n\n/**\n * Checks if the first node is less than the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst lessThan = /*@__PURE__*/nodeProxy(OperatorNode, '<');\n\n/**\n * Checks if the first node is greater than the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst greaterThan = /*@__PURE__*/nodeProxy(OperatorNode, '>');\n\n/**\n * Checks if the first node is less than or equal to the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst lessThanEqual = /*@__PURE__*/nodeProxy(OperatorNode, '<=');\n\n/**\n * Checks if the first node is greater than or equal to the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst greaterThanEqual = /*@__PURE__*/nodeProxy(OperatorNode, '>=');\n\n/**\n * Performs logical AND on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst and = /*@__PURE__*/nodeProxy(OperatorNode, '&&');\n\n/**\n * Performs logical OR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst or = /*@__PURE__*/nodeProxy(OperatorNode, '||');\n\n/**\n * Performs logical NOT on a node.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst not = /*@__PURE__*/nodeProxy(OperatorNode, '!');\n\n/**\n * Performs logical XOR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst xor = /*@__PURE__*/nodeProxy(OperatorNode, '^^');\n\n/**\n * Performs bitwise AND on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitAnd = /*@__PURE__*/nodeProxy(OperatorNode, '&');\n\n/**\n * Performs bitwise NOT on a node.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitNot = /*@__PURE__*/nodeProxy(OperatorNode, '~');\n\n/**\n * Performs bitwise OR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitOr = /*@__PURE__*/nodeProxy(OperatorNode, '|');\n\n/**\n * Performs bitwise XOR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitXor = /*@__PURE__*/nodeProxy(OperatorNode, '^');\n\n/**\n * Shifts a node to the left.\n *\n * @function\n * @param {Node} aNode - The node to shift.\n * @param {Node} bNode - The value to shift.\n * @returns {OperatorNode}\n */\nconst shiftLeft = /*@__PURE__*/nodeProxy(OperatorNode, '<<');\n\n/**\n * Shifts a node to the right.\n *\n * @function\n * @param {Node} aNode - The node to shift.\n * @param {Node} bNode - The value to shift.\n * @returns {OperatorNode}\n */\nconst shiftRight = /*@__PURE__*/nodeProxy(OperatorNode, '>>');\naddMethodChaining('add', add);\naddMethodChaining('sub', sub);\naddMethodChaining('mul', mul);\naddMethodChaining('div', div);\naddMethodChaining('modInt', modInt);\naddMethodChaining('equal', equal);\naddMethodChaining('notEqual', notEqual);\naddMethodChaining('lessThan', lessThan);\naddMethodChaining('greaterThan', greaterThan);\naddMethodChaining('lessThanEqual', lessThanEqual);\naddMethodChaining('greaterThanEqual', greaterThanEqual);\naddMethodChaining('and', and);\naddMethodChaining('or', or);\naddMethodChaining('not', not);\naddMethodChaining('xor', xor);\naddMethodChaining('bitAnd', bitAnd);\naddMethodChaining('bitNot', bitNot);\naddMethodChaining('bitOr', bitOr);\naddMethodChaining('bitXor', bitXor);\naddMethodChaining('shiftLeft', shiftLeft);\naddMethodChaining('shiftRight', shiftRight);\nconst remainder = (...params) => {\n  // @deprecated, r168\n\n  console.warn('TSL.OperatorNode: .remainder() has been renamed to .modInt().');\n  return modInt(...params);\n};\naddMethodChaining('remainder', remainder);\n\n/** @module MathNode **/\n\n/**\n * This node represents a variety of mathematical methods available in shaders.\n * They are divided into three categories:\n *\n * - Methods with one input like `sin`, `cos` or `normalize`.\n * - Methods with two inputs like `dot`, `cross` or `pow`.\n * - Methods with three inputs like `mix`, `clamp` or `smoothstep`.\n *\n * @augments TempNode\n */\nclass MathNode extends TempNode {\n  static get type() {\n    return 'MathNode';\n  }\n\n  /**\n   * Constructs a new math node.\n   *\n   * @param {String} method - The method name.\n   * @param {Node} aNode - The first input.\n   * @param {Node?} [bNode=null] - The second input.\n   * @param {Node?} [cNode=null] - The third input.\n   */\n  constructor(method, aNode, bNode = null, cNode = null) {\n    super();\n\n    /**\n     * The method name.\n     *\n     * @type {String}\n     */\n    this.method = method;\n\n    /**\n     * The first input.\n     *\n     * @type {Node}\n     */\n    this.aNode = aNode;\n\n    /**\n     * The second input.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.bNode = bNode;\n\n    /**\n     * The third input.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.cNode = cNode;\n  }\n\n  /**\n   * The input type is inferred from the node types of the input nodes.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(builder) {\n    const aType = this.aNode.getNodeType(builder);\n    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;\n    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;\n    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);\n    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);\n    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);\n    if (aLen > bLen && aLen > cLen) {\n      return aType;\n    } else if (bLen > cLen) {\n      return bType;\n    } else if (cLen > aLen) {\n      return cType;\n    }\n    return aType;\n  }\n\n  /**\n   * The selected method as well as the input type determine the node type of this node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    const method = this.method;\n    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {\n      return 'float';\n    } else if (method === MathNode.CROSS) {\n      return 'vec3';\n    } else if (method === MathNode.ALL) {\n      return 'bool';\n    } else if (method === MathNode.EQUALS) {\n      return builder.changeComponentType(this.aNode.getNodeType(builder), 'bool');\n    } else if (method === MathNode.MOD) {\n      return this.aNode.getNodeType(builder);\n    } else {\n      return this.getInputType(builder);\n    }\n  }\n  generate(builder, output) {\n    let method = this.method;\n    const type = this.getNodeType(builder);\n    const inputType = this.getInputType(builder);\n    const a = this.aNode;\n    const b = this.bNode;\n    const c = this.cNode;\n    const coordinateSystem = builder.renderer.coordinateSystem;\n    if (method === MathNode.TRANSFORM_DIRECTION) {\n      // dir can be either a direction vector or a normal vector\n      // upper-left 3x3 of matrix is assumed to be orthogonal\n\n      let tA = a;\n      let tB = b;\n      if (builder.isMatrix(tA.getNodeType(builder))) {\n        tB = vec4(vec3(tB), 0.0);\n      } else {\n        tA = vec4(vec3(tA), 0.0);\n      }\n      const mulNode = mul(tA, tB).xyz;\n      return normalize(mulNode).build(builder, output);\n    } else if (method === MathNode.NEGATE) {\n      return builder.format('( - ' + a.build(builder, inputType) + ' )', type, output);\n    } else if (method === MathNode.ONE_MINUS) {\n      return sub(1.0, a).build(builder, output);\n    } else if (method === MathNode.RECIPROCAL) {\n      return div(1.0, a).build(builder, output);\n    } else if (method === MathNode.DIFFERENCE) {\n      return abs(sub(a, b)).build(builder, output);\n    } else {\n      const params = [];\n      if (method === MathNode.CROSS || method === MathNode.MOD) {\n        params.push(a.build(builder, type), b.build(builder, type));\n      } else if (coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP) {\n        params.push(a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? 'float' : inputType), b.build(builder, inputType));\n      } else if (coordinateSystem === WebGLCoordinateSystem && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {\n        params.push(a.build(builder, inputType), b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else if (method === MathNode.REFRACT) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, 'float'));\n      } else if (method === MathNode.MIX) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else {\n        if (coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null) {\n          method = 'atan2';\n        }\n        params.push(a.build(builder, inputType));\n        if (b !== null) params.push(b.build(builder, inputType));\n        if (c !== null) params.push(c.build(builder, inputType));\n      }\n      return builder.format(`${builder.getMethod(method, type)}( ${params.join(', ')} )`, type, output);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.method = this.method;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.method = data.method;\n  }\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.TRANSPOSE = 'transpose';\n\n// 2 inputs\n\nMathNode.BITCAST = 'bitcast';\nMathNode.EQUALS = 'equals';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.MOD = 'mod';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\n\n// 1 inputs\n\n/**\n * A small value used to handle floating-point precision errors.\n *\n * @type {Node<float>}\n */\nconst EPSILON = /*@__PURE__*/float(1e-6);\n\n/**\n * Represents infinity.\n *\n * @type {Node<float>}\n */\nconst INFINITY = /*@__PURE__*/float(1e6);\n\n/**\n * Represents PI.\n *\n * @type {Node<float>}\n */\nconst PI = /*@__PURE__*/float(Math.PI);\n\n/**\n * Represents PI * 2.\n *\n * @type {Node<float>}\n */\nconst PI2 = /*@__PURE__*/float(Math.PI * 2);\n\n/**\n * Returns `true` if all components of `x` are `true`.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node<bool>}\n */\nconst all = /*@__PURE__*/nodeProxy(MathNode, MathNode.ALL);\n\n/**\n * Returns `true` if any components of `x` are `true`.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node<bool>}\n */\nconst any = /*@__PURE__*/nodeProxy(MathNode, MathNode.ANY);\n\n/**\n * Converts a quantity in degrees to radians.\n *\n * @function\n * @param {Node | Number} x - The input in degrees.\n * @returns {Node}\n */\nconst radians = /*@__PURE__*/nodeProxy(MathNode, MathNode.RADIANS);\n\n/**\n * Convert a quantity in radians to degrees.\n *\n * @function\n * @param {Node | Number} x - The input in radians.\n * @returns {Node}\n */\nconst degrees = /*@__PURE__*/nodeProxy(MathNode, MathNode.DEGREES);\n\n/**\n * Returns the natural exponentiation of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst exp = /*@__PURE__*/nodeProxy(MathNode, MathNode.EXP);\n\n/**\n * Returns 2 raised to the power of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst exp2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.EXP2);\n\n/**\n * Returns the natural logarithm of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst log = /*@__PURE__*/nodeProxy(MathNode, MathNode.LOG);\n\n/**\n * Returns the base 2 logarithm of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst log2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.LOG2);\n\n/**\n * Returns the square root of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst sqrt = /*@__PURE__*/nodeProxy(MathNode, MathNode.SQRT);\n\n/**\n * Returns the inverse of the square root of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst inverseSqrt = /*@__PURE__*/nodeProxy(MathNode, MathNode.INVERSE_SQRT);\n\n/**\n * Finds the nearest integer less than or equal to the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst floor = /*@__PURE__*/nodeProxy(MathNode, MathNode.FLOOR);\n\n/**\n * Finds the nearest integer that is greater than or equal to the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst ceil = /*@__PURE__*/nodeProxy(MathNode, MathNode.CEIL);\n\n/**\n * Calculates the unit vector in the same direction as the original vector.\n *\n * @function\n * @param {Node} x - The input vector.\n * @returns {Node}\n */\nconst normalize = /*@__PURE__*/nodeProxy(MathNode, MathNode.NORMALIZE);\n\n/**\n * Computes the fractional part of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst fract = /*@__PURE__*/nodeProxy(MathNode, MathNode.FRACT);\n\n/**\n * Returns the sine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst sin = /*@__PURE__*/nodeProxy(MathNode, MathNode.SIN);\n\n/**\n * Returns the cosine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst cos = /*@__PURE__*/nodeProxy(MathNode, MathNode.COS);\n\n/**\n * Returns the tangent of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst tan = /*@__PURE__*/nodeProxy(MathNode, MathNode.TAN);\n\n/**\n * Returns the arcsine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst asin = /*@__PURE__*/nodeProxy(MathNode, MathNode.ASIN);\n\n/**\n * Returns the arccosine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst acos = /*@__PURE__*/nodeProxy(MathNode, MathNode.ACOS);\n\n/**\n * Returns the arc-tangent of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst atan = /*@__PURE__*/nodeProxy(MathNode, MathNode.ATAN);\n\n/**\n * Returns the absolute value of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst abs = /*@__PURE__*/nodeProxy(MathNode, MathNode.ABS);\n\n/**\n * Extracts the sign of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst sign = /*@__PURE__*/nodeProxy(MathNode, MathNode.SIGN);\n\n/**\n * Calculates the length of a vector.\n *\n * @function\n * @param {Node} x - The parameter.\n * @returns {Node<float>}\n */\nconst length = /*@__PURE__*/nodeProxy(MathNode, MathNode.LENGTH);\n\n/**\n * Negates the value of the parameter (-x).\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst negate = /*@__PURE__*/nodeProxy(MathNode, MathNode.NEGATE);\n\n/**\n * Return `1` minus the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst oneMinus = /*@__PURE__*/nodeProxy(MathNode, MathNode.ONE_MINUS);\n\n/**\n * Returns the partial derivative of the parameter with respect to x.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst dFdx = /*@__PURE__*/nodeProxy(MathNode, MathNode.DFDX);\n\n/**\n * Returns the partial derivative of the parameter with respect to y.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst dFdy = /*@__PURE__*/nodeProxy(MathNode, MathNode.DFDY);\n\n/**\n * Rounds the parameter to the nearest integer.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst round = /*@__PURE__*/nodeProxy(MathNode, MathNode.ROUND);\n\n/**\n * Returns the reciprocal of the parameter `(1/x)`.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst reciprocal = /*@__PURE__*/nodeProxy(MathNode, MathNode.RECIPROCAL);\n\n/**\n * Truncates the parameter, removing the fractional part.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst trunc = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRUNC);\n\n/**\n * Returns the sum of the absolute derivatives in x and y.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst fwidth = /*@__PURE__*/nodeProxy(MathNode, MathNode.FWIDTH);\n\n/**\n * Returns the transpose of a matrix.\n *\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node}\n */\nconst transpose = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRANSPOSE);\n\n// 2 inputs\n\n/**\n * Reinterpret the bit representation of a value in one type as a value in another type.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @param {String} y - The new type.\n * @returns {Node}\n */\nconst bitcast = /*@__PURE__*/nodeProxy(MathNode, MathNode.BITCAST);\n\n/**\n * Returns `true` if `x` equals `y`.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @param {Node | Number} y - The second parameter.\n * @returns {Node<bool>}\n */\nconst equals = /*@__PURE__*/nodeProxy(MathNode, MathNode.EQUALS);\n\n/**\n * Returns the lesser of two values.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst min$1 = /*@__PURE__*/nodeProxy(MathNode, MathNode.MIN);\n\n/**\n * Returns the greater of two values.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst max$1 = /*@__PURE__*/nodeProxy(MathNode, MathNode.MAX);\n\n/**\n * Computes the remainder of dividing the first node by the second one.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst mod = /*@__PURE__*/nodeProxy(MathNode, MathNode.MOD);\n\n/**\n * Generate a step function by comparing two values.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst step = /*@__PURE__*/nodeProxy(MathNode, MathNode.STEP);\n\n/**\n * Calculates the reflection direction for an incident vector.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst reflect = /*@__PURE__*/nodeProxy(MathNode, MathNode.REFLECT);\n\n/**\n * Calculates the distance between two points.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first point.\n * @param {Node<vec2|vec3|vec4>} y - The second point.\n * @returns {Node<float>}\n */\nconst distance = /*@__PURE__*/nodeProxy(MathNode, MathNode.DISTANCE);\n\n/**\n * Calculates the absolute difference between two values.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @param {Node | Number} y - The second parameter.\n * @returns {Node}\n */\nconst difference = /*@__PURE__*/nodeProxy(MathNode, MathNode.DIFFERENCE);\n\n/**\n * Calculates the dot product of two vectors.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first vector.\n * @param {Node<vec2|vec3|vec4>} y - The second vector.\n * @returns {Node<float>}\n */\nconst dot = /*@__PURE__*/nodeProxy(MathNode, MathNode.DOT);\n\n/**\n * Calculates the cross product of two vectors.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first vector.\n * @param {Node<vec2|vec3|vec4>} y - The second vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst cross = /*@__PURE__*/nodeProxy(MathNode, MathNode.CROSS);\n\n/**\n * Return the value of the first parameter raised to the power of the second one.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @param {Node | Number} y - The second parameter.\n * @returns {Node}\n */\nconst pow = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW);\n\n/**\n * Returns the square of the parameter.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @returns {Node}\n */\nconst pow2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 2);\n\n/**\n * Returns the cube of the parameter.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @returns {Node}\n */\nconst pow3 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 3);\n\n/**\n * Returns the fourth power of the parameter.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @returns {Node}\n */\nconst pow4 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 4);\n\n/**\n * Transforms the direction of a vector by a matrix and then normalizes the result.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} direction - The direction vector.\n * @param {Node<mat2|mat3|mat4>} matrix - The transformation matrix.\n * @returns {Node}\n */\nconst transformDirection = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);\n\n/**\n * Returns the cube root of a number.\n *\n * @function\n * @param {Node | Number} a - The first parameter.\n * @returns {Node}\n */\nconst cbrt = a => mul(sign(a), pow(abs(a), 1.0 / 3.0));\n\n/**\n * Calculate the squared length of a vector.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} a - The vector.\n * @returns {Node<float>}\n */\nconst lengthSq = a => dot(a, a);\n\n/**\n * Linearly interpolates between two values.\n *\n * @function\n * @param {Node | Number} a - The first parameter.\n * @param {Node | Number} b - The second parameter.\n * @param {Node | Number} t - The interpolation value.\n * @returns {Node}\n */\nconst mix = /*@__PURE__*/nodeProxy(MathNode, MathNode.MIX);\n\n/**\n * Constrains a value to lie between two further values.\n *\n * @function\n * @param {Node | Number} value - The value to constrain.\n * @param {Node | Number} [low=0] - The lower bound.\n * @param {Node | Number} [high=1] - The upper bound.\n * @returns {Node}\n */\nconst clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));\n\n/**\n * Constrains a value between `0` and `1`.\n *\n * @function\n * @param {Node | Number} value - The value to constrain.\n * @returns {Node}\n */\nconst saturate = value => clamp(value);\n\n/**\n * Calculates the refraction direction for an incident vector.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @param {Node<float>} eta - The the ratio of indices of refraction.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst refract = /*@__PURE__*/nodeProxy(MathNode, MathNode.REFRACT);\n\n/**\n * Performs a Hermite interpolation between two values.\n *\n * @function\n * @param {Node | Number} low - The value of the lower edge of the Hermite function.\n * @param {Node | Number} high - The value of the upper edge of the Hermite function.\n * @param {Node | Number} x - The source value for interpolation.\n * @returns {Node}\n */\nconst smoothstep = /*@__PURE__*/nodeProxy(MathNode, MathNode.SMOOTHSTEP);\n\n/**\n * Returns a vector pointing in the same direction as another.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} N - The vector to orient.\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} Nref - The reference vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst faceForward = /*@__PURE__*/nodeProxy(MathNode, MathNode.FACEFORWARD);\n\n/**\n * Returns a random value for the given uv.\n *\n * @function\n * @param {Node<vec2>} uv - The uv node.\n * @returns {Node<float>}\n */\nconst rand = /*@__PURE__*/Fn(([uv]) => {\n  const a = 12.9898,\n    b = 78.233,\n    c = 43758.5453;\n  const dt = dot(uv.xy, vec2(a, b)),\n    sn = mod(dt, PI);\n  return fract(sin(sn).mul(c));\n});\n\n/**\n * Alias for `mix()` with a different parameter order.\n *\n * @function\n * @param {Node | Number} t - The interpolation value.\n * @param {Node | Number} e1 - The first parameter.\n * @param {Node | Number} e2 - The second parameter.\n * @returns {Node}\n */\nconst mixElement = (t, e1, e2) => mix(e1, e2, t);\n\n/**\n * Alias for `smoothstep()` with a different parameter order.\n *\n * @function\n * @param {Node | Number} x - The source value for interpolation.\n * @param {Node | Number} low - The value of the lower edge of the Hermite function.\n * @param {Node | Number} high - The value of the upper edge of the Hermite function.\n * @returns {Node}\n */\nconst smoothstepElement = (x, low, high) => smoothstep(low, high, x);\n\n/**\n * Returns the arc-tangent of the quotient of its parameters.\n *\n * @function\n * @param {Node | Number} y - The y parameter.\n * @param {Node | Number} x - The x parameter.\n * @returns {Node}\n */\nconst atan2 = (y, x) => {\n  // @deprecated, r172\n\n  console.warn('THREE.TSL: \"atan2\" is overloaded. Use \"atan\" instead.');\n  return atan(y, x);\n};\n\n// GLSL alias function\n\nconst faceforward = faceForward;\nconst inversesqrt = inverseSqrt;\n\n// Method chaining\n\naddMethodChaining('all', all);\naddMethodChaining('any', any);\naddMethodChaining('equals', equals);\naddMethodChaining('radians', radians);\naddMethodChaining('degrees', degrees);\naddMethodChaining('exp', exp);\naddMethodChaining('exp2', exp2);\naddMethodChaining('log', log);\naddMethodChaining('log2', log2);\naddMethodChaining('sqrt', sqrt);\naddMethodChaining('inverseSqrt', inverseSqrt);\naddMethodChaining('floor', floor);\naddMethodChaining('ceil', ceil);\naddMethodChaining('normalize', normalize);\naddMethodChaining('fract', fract);\naddMethodChaining('sin', sin);\naddMethodChaining('cos', cos);\naddMethodChaining('tan', tan);\naddMethodChaining('asin', asin);\naddMethodChaining('acos', acos);\naddMethodChaining('atan', atan);\naddMethodChaining('abs', abs);\naddMethodChaining('sign', sign);\naddMethodChaining('length', length);\naddMethodChaining('lengthSq', lengthSq);\naddMethodChaining('negate', negate);\naddMethodChaining('oneMinus', oneMinus);\naddMethodChaining('dFdx', dFdx);\naddMethodChaining('dFdy', dFdy);\naddMethodChaining('round', round);\naddMethodChaining('reciprocal', reciprocal);\naddMethodChaining('trunc', trunc);\naddMethodChaining('fwidth', fwidth);\naddMethodChaining('atan2', atan2);\naddMethodChaining('min', min$1);\naddMethodChaining('max', max$1);\naddMethodChaining('mod', mod);\naddMethodChaining('step', step);\naddMethodChaining('reflect', reflect);\naddMethodChaining('distance', distance);\naddMethodChaining('dot', dot);\naddMethodChaining('cross', cross);\naddMethodChaining('pow', pow);\naddMethodChaining('pow2', pow2);\naddMethodChaining('pow3', pow3);\naddMethodChaining('pow4', pow4);\naddMethodChaining('transformDirection', transformDirection);\naddMethodChaining('mix', mixElement);\naddMethodChaining('clamp', clamp);\naddMethodChaining('refract', refract);\naddMethodChaining('smoothstep', smoothstepElement);\naddMethodChaining('faceForward', faceForward);\naddMethodChaining('difference', difference);\naddMethodChaining('saturate', saturate);\naddMethodChaining('cbrt', cbrt);\naddMethodChaining('transpose', transpose);\naddMethodChaining('rand', rand);\n\n/** @module ConditionalNode **/\n\n/**\n * Represents a logical `if/else` statement. Can be used as an alternative\n * to the `If()`/`Else()` syntax.\n *\n * The corresponding TSL `select()` looks like so:\n * ```js\n * velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );\n * ```\n * The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`\n * determine the outcome of the entire statement.\n *\n * @augments Node\n */\nclass ConditionalNode extends Node {\n  static get type() {\n    return 'ConditionalNode';\n  }\n\n  /**\n   * Constructs a new conditional node.\n   *\n   * @param {Node} condNode - The node that defines the condition.\n   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n   * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n   */\n  constructor(condNode, ifNode, elseNode = null) {\n    super();\n\n    /**\n     * The node that defines the condition.\n     *\n     * @type {Node}\n     */\n    this.condNode = condNode;\n\n    /**\n     * The node that is evaluate when the condition ends up `true`.\n     *\n     * @type {Node}\n     */\n    this.ifNode = ifNode;\n\n    /**\n     * The node that is evaluate when the condition ends up `false`.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.elseNode = elseNode;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from the if/else\n   * nodes.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    const {\n      ifNode,\n      elseNode\n    } = builder.getNodeProperties(this);\n    if (ifNode === undefined) {\n      // fallback setup\n\n      this.setup(builder);\n      return this.getNodeType(builder);\n    }\n    const ifType = ifNode.getNodeType(builder);\n    if (elseNode !== null) {\n      const elseType = elseNode.getNodeType(builder);\n      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {\n        return elseType;\n      }\n    }\n    return ifType;\n  }\n  setup(builder) {\n    const condNode = this.condNode.cache();\n    const ifNode = this.ifNode.cache();\n    const elseNode = this.elseNode ? this.elseNode.cache() : null;\n\n    //\n\n    const currentNodeBlock = builder.context.nodeBlock;\n    builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;\n    if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;\n\n    //\n\n    const properties = builder.getNodeProperties(this);\n    properties.condNode = condNode;\n    properties.ifNode = ifNode.context({\n      nodeBlock: ifNode\n    });\n    properties.elseNode = elseNode ? elseNode.context({\n      nodeBlock: elseNode\n    }) : null;\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const nodeData = builder.getDataFromNode(this);\n    if (nodeData.nodeProperty !== undefined) {\n      return nodeData.nodeProperty;\n    }\n    const {\n      condNode,\n      ifNode,\n      elseNode\n    } = builder.getNodeProperties(this);\n    const needsOutput = output !== 'void';\n    const nodeProperty = needsOutput ? property(type).build(builder) : '';\n    nodeData.nodeProperty = nodeProperty;\n    const nodeSnippet = condNode.build(builder, 'bool');\n    builder.addFlowCode(`\\n${builder.tab}if ( ${nodeSnippet} ) {\\n\\n`).addFlowTab();\n    let ifSnippet = ifNode.build(builder, type);\n    if (ifSnippet) {\n      if (needsOutput) {\n        ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n      } else {\n        ifSnippet = 'return ' + ifSnippet + ';';\n      }\n    }\n    builder.removeFlowTab().addFlowCode(builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}');\n    if (elseNode !== null) {\n      builder.addFlowCode(' else {\\n\\n').addFlowTab();\n      let elseSnippet = elseNode.build(builder, type);\n      if (elseSnippet) {\n        if (needsOutput) {\n          elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n        } else {\n          elseSnippet = 'return ' + elseSnippet + ';';\n        }\n      }\n      builder.removeFlowTab().addFlowCode(builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n');\n    } else {\n      builder.addFlowCode('\\n\\n');\n    }\n    return builder.format(nodeProperty, type, output);\n  }\n}\n\n/**\n * TSL function for creating a conditional node.\n *\n * @function\n * @param {Node} condNode - The node that defines the condition.\n * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n * @returns {ConditionalNode}\n */\nconst select = /*@__PURE__*/nodeProxy(ConditionalNode);\naddMethodChaining('select', select);\n\n//\n\nconst cond = (...params) => {\n  // @deprecated, r168\n\n  console.warn('TSL.ConditionalNode: cond() has been renamed to select().');\n  return select(...params);\n};\naddMethodChaining('cond', cond);\n\n/** @module ContextNode **/\n\n/**\n * This node can be used as a context management component for another node.\n * {@link NodeBuilder} performs its node building process in a specific context and\n * this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:\n *\n * ```js\n *node.context( { getUV: () => customCoord } );\n *```\n * @augments Node\n */\nclass ContextNode extends Node {\n  static get type() {\n    return 'ContextNode';\n  }\n\n  /**\n   * Constructs a new context node.\n   *\n   * @param {Node} node - The node whose context should be modified.\n   * @param {Object} [value={}] - The modified context data.\n   */\n  constructor(node, value = {}) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isContextNode = true;\n\n    /**\n     * The node whose context should be modified.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * The modified context data.\n     *\n     * @type {Object}\n     * @default {}\n     */\n    this.value = value;\n  }\n\n  /**\n   * This method is overwritten to ensure it returns the reference to {@link module:ContextNode~ContextNode#node}.\n   *\n   * @return {Node} A reference to {@link module:ContextNode~ContextNode#node}.\n   */\n  getScope() {\n    return this.node.getScope();\n  }\n\n  /**\n   * This method is overwritten to ensure it returns the type of {@link module:ContextNode~ContextNode#node}.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  analyze(builder) {\n    this.node.build(builder);\n  }\n  setup(builder) {\n    const previousContext = builder.getContext();\n    builder.setContext({\n      ...builder.context,\n      ...this.value\n    });\n    const node = this.node.build(builder);\n    builder.setContext(previousContext);\n    return node;\n  }\n  generate(builder, output) {\n    const previousContext = builder.getContext();\n    builder.setContext({\n      ...builder.context,\n      ...this.value\n    });\n    const snippet = this.node.build(builder, output);\n    builder.setContext(previousContext);\n    return snippet;\n  }\n}\n\n/**\n * TSL function for creating a context node.\n *\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {Object} [value={}] - The modified context data.\n * @returns {ContextNode}\n */\nconst context = /*@__PURE__*/nodeProxy(ContextNode);\n\n/**\n * TSL function for defining a label context value for a given node.\n *\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {String} name - The name/label to set.\n * @returns {ContextNode}\n */\nconst label = (node, name) => context(node, {\n  label: name\n});\naddMethodChaining('context', context);\naddMethodChaining('label', label);\n\n/** @module VarNode **/\n\n/**\n * Class for representing shader variables as nodes. Variables are created from\n * existing nodes like the following:\n *\n * ```js\n * const depth = sampleDepth( uvNode ).toVar( 'depth' );\n * ```\n *\n * @augments Node\n */\nclass VarNode extends Node {\n  static get type() {\n    return 'VarNode';\n  }\n\n  /**\n   * Constructs a new variable node.\n   *\n   * @param {Node} node - The node for which a variable should be created.\n   * @param {String?} name - The name of the variable in the shader.\n   */\n  constructor(node, name = null) {\n    super();\n\n    /**\n     * The node for which a variable should be created.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * The name of the variable in the shader. If no name is defined,\n     * the node system auto-generates one.\n     *\n     * @type {String?}\n     * @default null\n     */\n    this.name = name;\n\n    /**\n     * `VarNode` sets this property to `true` by default.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.global = true;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isVarNode = true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      node,\n      name\n    } = this;\n    const nodeVar = builder.getVarFromNode(this, name, builder.getVectorType(this.getNodeType(builder)));\n    const propertyName = builder.getPropertyName(nodeVar);\n    const snippet = node.build(builder, nodeVar.type);\n    builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n    return propertyName;\n  }\n}\n\n/**\n * TSL function for creating a var node.\n *\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {String?} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nconst createVar = /*@__PURE__*/nodeProxy(VarNode);\naddMethodChaining('toVar', (...params) => createVar(...params).append());\n\n// Deprecated\n\nconst temp = node => {\n  // @deprecated, r170\n\n  console.warn('TSL: \"temp\" is deprecated. Use \".toVar()\" instead.');\n  return createVar(node);\n};\naddMethodChaining('temp', temp);\n\n/** @module VaryingNode **/\n\n/**\n * Class for representing shader varyings as nodes. Varyings are create from\n * existing nodes like the following:\n *\n * ```js\n * const positionLocal = positionGeometry.varying( 'vPositionLocal' );\n * ```\n *\n * @augments Node\n */\nclass VaryingNode extends Node {\n  static get type() {\n    return 'VaryingNode';\n  }\n\n  /**\n   * Constructs a new varying node.\n   *\n   * @param {Node} node - The node for which a varying should be created.\n   * @param {String?} name - The name of the varying in the shader.\n   */\n  constructor(node, name = null) {\n    super();\n\n    /**\n     * The node for which a varying should be created.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * The name of the varying in the shader. If no name is defined,\n     * the node system auto-generates one.\n     *\n     * @type {String?}\n     * @default null\n     */\n    this.name = name;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isVaryingNode = true;\n  }\n\n  /**\n   * The method is overwritten so it always returns `true`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Boolean} Whether this node is global or not.\n   */\n  isGlobal(/*builder*/\n  ) {\n    return true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  getNodeType(builder) {\n    // VaryingNode is auto type\n\n    return this.node.getNodeType(builder);\n  }\n\n  /**\n   * This method performs the setup of a varying node with the current node builder.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {NodeVarying} The node varying from the node builder.\n   */\n  setupVarying(builder) {\n    const properties = builder.getNodeProperties(this);\n    let varying = properties.varying;\n    if (varying === undefined) {\n      const name = this.name;\n      const type = this.getNodeType(builder);\n      properties.varying = varying = builder.getVaryingFromNode(this, name, type);\n      properties.node = this.node;\n    }\n\n    // this property can be used to check if the varying can be optimized for a variable\n    varying.needsInterpolation || (varying.needsInterpolation = builder.shaderStage === 'fragment');\n    return varying;\n  }\n  setup(builder) {\n    this.setupVarying(builder);\n  }\n  analyze(builder) {\n    this.setupVarying(builder);\n    return this.node.analyze(builder);\n  }\n  generate(builder) {\n    const properties = builder.getNodeProperties(this);\n    const varying = this.setupVarying(builder);\n    const needsReassign = builder.shaderStage === 'fragment' && properties.reassignPosition === true && builder.context.needsPositionReassign;\n    if (properties.propertyName === undefined || needsReassign) {\n      const type = this.getNodeType(builder);\n      const propertyName = builder.getPropertyName(varying, NodeShaderStage.VERTEX);\n\n      // force node run in vertex stage\n      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node, type, propertyName);\n      properties.propertyName = propertyName;\n      if (needsReassign) {\n        // once reassign varying in fragment stage\n        properties.reassignPosition = false;\n      } else if (properties.reassignPosition === undefined && builder.context.isPositionNodeInput) {\n        properties.reassignPosition = true;\n      }\n    }\n    return builder.getPropertyName(varying);\n  }\n}\n\n/**\n * TSL function for creating a varying node.\n *\n * @function\n * @param {Node} node - The node for which a varying should be created.\n * @param {String?} name - The name of the varying in the shader.\n * @returns {VaryingNode}\n */\nconst varying = /*@__PURE__*/nodeProxy(VaryingNode);\n\n/**\n * Computes a node in the vertex stage.\n *\n * @function\n * @param {Node} node - The node which should be executed in the vertex stage.\n * @returns {VaryingNode}\n */\nconst vertexStage = node => varying(node);\naddMethodChaining('varying', varying);\naddMethodChaining('vertexStage', vertexStage);\n\n/** @module ColorSpaceFunctions **/\n\n/**\n * Converts the given color value from sRGB to linear-sRGB color space.\n *\n * @method\n * @param {Node<vec3>} color - The sRGB color.\n * @return {Node<vec3>} The linear-sRGB color.\n */\nconst sRGBTransferEOTF = /*@__PURE__*/Fn(([color]) => {\n  const a = color.mul(0.9478672986).add(0.0521327014).pow(2.4);\n  const b = color.mul(0.0773993808);\n  const factor = color.lessThanEqual(0.04045);\n  const rgbResult = mix(a, b, factor);\n  return rgbResult;\n}).setLayout({\n  name: 'sRGBTransferEOTF',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }]\n});\n\n/**\n * Converts the given color value from linear-sRGB to sRGB color space.\n *\n * @method\n * @param {Node<vec3>} color - The linear-sRGB color.\n * @return {Node<vec3>} The sRGB color.\n */\nconst sRGBTransferOETF = /*@__PURE__*/Fn(([color]) => {\n  const a = color.pow(0.41666).mul(1.055).sub(0.055);\n  const b = color.mul(12.92);\n  const factor = color.lessThanEqual(0.0031308);\n  const rgbResult = mix(a, b, factor);\n  return rgbResult;\n}).setLayout({\n  name: 'sRGBTransferOETF',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }]\n});\n\n/** @module ColorSpaceNode **/\n\nconst WORKING_COLOR_SPACE = 'WorkingColorSpace';\nconst OUTPUT_COLOR_SPACE = 'OutputColorSpace';\n\n/**\n * This node represents a color space conversion. Meaning it converts\n * a color value from a source to a target color space.\n *\n * @augments TempNode\n */\nclass ColorSpaceNode extends TempNode {\n  static get type() {\n    return 'ColorSpaceNode';\n  }\n\n  /**\n   * Constructs a new color space node.\n   *\n   * @param {Node} colorNode - Represents the color to convert.\n   * @param {String} source - The source color space.\n   * @param {String} target - The target color space.\n   */\n  constructor(colorNode, source, target) {\n    super('vec4');\n\n    /**\n     * Represents the color to convert.\n     *\n     * @type {Node}\n     */\n    this.colorNode = colorNode;\n\n    /**\n     * The source color space.\n     *\n     * @type {String}\n     */\n    this.source = source;\n\n    /**\n     * The target color space.\n     *\n     * @type {String}\n     */\n    this.target = target;\n  }\n\n  /**\n   * This method resolves the constants `WORKING_COLOR_SPACE` and\n   * `OUTPUT_COLOR_SPACE` based on the current configuration of the\n   * color management and renderer.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {String} colorSpace - The color space to resolve.\n   * @return {String} The resolved color space.\n   */\n  resolveColorSpace(builder, colorSpace) {\n    if (colorSpace === WORKING_COLOR_SPACE) {\n      return ColorManagement.workingColorSpace;\n    } else if (colorSpace === OUTPUT_COLOR_SPACE) {\n      return builder.context.outputColorSpace || builder.renderer.outputColorSpace;\n    }\n    return colorSpace;\n  }\n  setup(builder) {\n    const {\n      colorNode\n    } = this;\n    const source = this.resolveColorSpace(builder, this.source);\n    const target = this.resolveColorSpace(builder, this.target);\n    let outputNode = colorNode;\n    if (ColorManagement.enabled === false || source === target || !source || !target) {\n      return outputNode;\n    }\n    if (ColorManagement.getTransfer(source) === SRGBTransfer) {\n      outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);\n    }\n    if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) {\n      outputNode = vec4(mat3(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(outputNode.rgb), outputNode.a);\n    }\n    if (ColorManagement.getTransfer(target) === SRGBTransfer) {\n      outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);\n    }\n    return outputNode;\n  }\n}\n\n/**\n * TSL function for converting a given color node to the current output color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @returns {ColorSpaceNode}\n */\nconst toOutputColorSpace = node => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE));\n\n/**\n * TSL function for converting a given color node to the current working color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @returns {ColorSpaceNode}\n */\nconst toWorkingColorSpace = node => nodeObject(new ColorSpaceNode(nodeObject(node), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE));\n\n/**\n * TSL function for converting a given color node from the current working color space to the given color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {String} colorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nconst workingToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, colorSpace));\n\n/**\n * TSL function for converting a given color node from the given color space to the current working color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {String} colorSpace - The source color space.\n * @returns {ColorSpaceNode}\n */\nconst colorSpaceToWorking = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), colorSpace, WORKING_COLOR_SPACE));\n\n/**\n * TSL function for converting a given color node from one color space to another one.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {String} sourceColorSpace - The source color space.\n * @param {String} targetColorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nconst convertColorSpace = (node, sourceColorSpace, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace));\naddMethodChaining('toOutputColorSpace', toOutputColorSpace);\naddMethodChaining('toWorkingColorSpace', toWorkingColorSpace);\naddMethodChaining('workingToColorSpace', workingToColorSpace);\naddMethodChaining('colorSpaceToWorking', colorSpaceToWorking);\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/** @module ReferenceBaseNode **/\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nlet ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {\n  static get type() {\n    return 'ReferenceElementNode';\n  }\n\n  /**\n   * Constructs a new reference element node.\n   *\n   * @param {Node?} referenceNode - The reference node.\n   * @param {Node} indexNode - The index node that defines the element access.\n   */\n  constructor(referenceNode, indexNode) {\n    super(referenceNode, indexNode);\n\n    /**\n     * Similar to {@link module:ReferenceBaseNode~ReferenceBaseNode#reference}, an additional\n     * property references to the current node.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.referenceNode = referenceNode;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isReferenceElementNode = true;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from\n   * the uniform type of the reference node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType() {\n    return this.referenceNode.uniformType;\n  }\n  generate(builder) {\n    const snippet = super.generate(builder);\n    const arrayType = this.referenceNode.getNodeType();\n    const elementType = this.getNodeType();\n    return builder.format(snippet, arrayType, elementType);\n  }\n};\n\n/**\n * Base class for nodes which establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceBaseNode extends Node {\n  static get type() {\n    return 'ReferenceBaseNode';\n  }\n\n  /**\n   * Constructs a new reference base node.\n   *\n   * @param {String} property - The name of the property the node refers to.\n   * @param {String} uniformType - The uniform type that should be used to represent the property value.\n   * @param {Object?} [object=null] - The object the property belongs to.\n   * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.\n   */\n  constructor(property, uniformType, object = null, count = null) {\n    super();\n\n    /**\n     * The name of the property the node refers to.\n     *\n     * @type {String}\n     */\n    this.property = property;\n\n    /**\n     * The uniform type that should be used to represent the property value.\n     *\n     * @type {String}\n     */\n    this.uniformType = uniformType;\n\n    /**\n     * The object the property belongs to.\n     *\n     * @type {Object?}\n     * @default null\n     */\n    this.object = object;\n\n    /**\n     * When the linked property is an array, this parameter defines its length.\n     *\n     * @type {Number?}\n     * @default null\n     */\n    this.count = count;\n\n    /**\n     * The property name might have dots so nested properties can be referred.\n     * The hierarchy of the names is stored inside this array.\n     *\n     * @type {Array<String>}\n     */\n    this.properties = property.split('.');\n\n    /**\n     * Points to the current referred object. This property exists next to {@link module:ReferenceNode~ReferenceNode#object}\n     * since the final reference might be updated from calling code.\n     *\n     * @type {Object?}\n     * @default null\n     */\n    this.reference = object;\n\n    /**\n     * The uniform node that holds the value of the reference node.\n     *\n     * @type {UniformNode}\n     * @default null\n     */\n    this.node = null;\n\n    /**\n     * The uniform group of the internal uniform.\n     *\n     * @type {UniformGroupNode}\n     * @default null\n     */\n    this.group = null;\n\n    /**\n     * Overwritten since reference nodes are updated per object.\n     *\n     * @type {String}\n     * @default 'object'\n     */\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n\n  /**\n   * Sets the uniform group for this reference node.\n   *\n   * @param {UniformGroupNode} group - The uniform group to set.\n   * @return {ReferenceBaseNode} A reference to this node.\n   */\n  setGroup(group) {\n    this.group = group;\n    return this;\n  }\n\n  /**\n   * When the referred property is array-like, this method can be used\n   * to access elements via an index node.\n   *\n   * @param {IndexNode} indexNode - indexNode.\n   * @return {ReferenceElementNode} A reference to an element.\n   */\n  element(indexNode) {\n    return nodeObject(new ReferenceElementNode$1(this, nodeObject(indexNode)));\n  }\n\n  /**\n   * Sets the node type which automatically defines the internal\n   * uniform type.\n   *\n   * @param {String} uniformType - The type to set.\n   */\n  setNodeType(uniformType) {\n    const node = uniform(null, uniformType).getSelf();\n    if (this.group !== null) {\n      node.setGroup(this.group);\n    }\n    this.node = node;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from\n   * the type of the reference node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    if (this.node === null) {\n      this.updateReference(builder);\n      this.updateValue();\n    }\n    return this.node.getNodeType(builder);\n  }\n\n  /**\n   * Returns the property value from the given referred object.\n   *\n   * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n   * @return {Any} The value.\n   */\n  getValueFromReference(object = this.reference) {\n    const {\n      properties\n    } = this;\n    let value = object[properties[0]];\n    for (let i = 1; i < properties.length; i++) {\n      value = value[properties[i]];\n    }\n    return value;\n  }\n\n  /**\n   * Allows to update the reference based on the given state. The state is only\n   * evaluated {@link module:ReferenceBaseNode~ReferenceBaseNode#object} is not set.\n   *\n   * @param {(NodeFrame|NodeBuilder)} state - The current state.\n   * @return {Object} The updated reference.\n   */\n  updateReference(state) {\n    this.reference = this.object !== null ? this.object : state.object;\n    return this.reference;\n  }\n\n  /**\n   * The output of the reference node is the internal uniform node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {UniformNode} The output node.\n   */\n  setup() {\n    this.updateValue();\n    return this.node;\n  }\n\n  /**\n   * Overwritten to to update the internal uniform value.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update(/*frame*/\n  ) {\n    this.updateValue();\n  }\n\n  /**\n   * Retrieves the value from the referred object property and uses it\n   * to updated the internal uniform.\n   */\n  updateValue() {\n    if (this.node === null) this.setNodeType(this.uniformType);\n    const value = this.getValueFromReference();\n    if (Array.isArray(value)) {\n      this.node.array = value;\n    } else {\n      this.node.value = value;\n    }\n  }\n}\n\n/**\n * TSL function for creating a reference base node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Object} object - The object the property belongs to.\n * @returns {ReferenceBaseNode}\n */\nconst reference$1 = (name, type, object) => nodeObject(new ReferenceBaseNode(name, type, object));\n\n/** @module RendererReferenceNode **/\n\n/**\n * This node is a special type of reference node which is intended\n * for linking renderer properties with node values.\n * ```js\n * const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );\n * ```\n * When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will\n * automatically be updated.\n *\n * @augments ReferenceBaseNode\n */\nclass RendererReferenceNode extends ReferenceBaseNode {\n  static get type() {\n    return 'RendererReferenceNode';\n  }\n\n  /**\n   * Constructs a new renderer reference node.\n   *\n   * @param {String} property - The name of the property the node refers to.\n   * @param {String} inputType - The uniform type that should be used to represent the property value.\n   * @param {Renderer?} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n   * the node refers to the renderer of the current state.\n   */\n  constructor(property, inputType, renderer = null) {\n    super(property, inputType, renderer);\n\n    /**\n     * The renderer the property belongs to. When no renderer is set,\n     * the node refers to the renderer of the current state.\n     *\n     * @type {Renderer?}\n     * @default null\n     */\n    this.renderer = renderer;\n    this.setGroup(renderGroup);\n  }\n\n  /**\n   * Updates the reference based on the given state. The state is only evaluated\n   * {@link module:RendererReferenceNode~RendererReferenceNode#renderer} is not set.\n   *\n   * @param {(NodeFrame|NodeBuilder)} state - The current state.\n   * @return {Object} The updated reference.\n   */\n  updateReference(state) {\n    this.reference = this.renderer !== null ? this.renderer : state.renderer;\n    return this.reference;\n  }\n}\n\n/**\n * TSL function for creating a renderer reference node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Renderer?} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n * the node refers to the renderer of the current state.\n * @returns {RendererReferenceNode}\n */\nconst rendererReference = (name, type, renderer = null) => nodeObject(new RendererReferenceNode(name, type, renderer));\n\n/** @module ToneMappingNode **/\n\n/**\n * This node represents a tone mapping operation.\n *\n * @augments TempNode\n */\nclass ToneMappingNode extends TempNode {\n  static get type() {\n    return 'ToneMappingNode';\n  }\n\n  /**\n   * Constructs a new tone mapping node.\n   *\n   * @param {Number} toneMapping - The tone mapping type.\n   * @param {Node} exposureNode - The tone mapping exposure.\n   * @param {Node} [colorNode=null] - The color node to process.\n   */\n  constructor(toneMapping, exposureNode = toneMappingExposure, colorNode = null) {\n    super('vec3');\n\n    /**\n     * The tone mapping type.\n     *\n     * @type {Number}\n     */\n    this.toneMapping = toneMapping;\n\n    /**\n     * The tone mapping exposure.\n     *\n     * @type {Node}\n     * @default null\n     */\n    this.exposureNode = exposureNode;\n\n    /**\n     * Represents the color to process.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.colorNode = colorNode;\n  }\n\n  /**\n   * Overwrites the default `customCacheKey()` implementation by including the tone\n   * mapping type into the cache key.\n   *\n   * @return {Number} The hash.\n   */\n  customCacheKey() {\n    return hash$1(this.toneMapping);\n  }\n  setup(builder) {\n    const colorNode = this.colorNode || builder.context.color;\n    const toneMapping = this.toneMapping;\n    if (toneMapping === NoToneMapping) return colorNode;\n    let outputNode = null;\n    const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping);\n    if (toneMappingFn !== null) {\n      outputNode = vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);\n    } else {\n      console.error('ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping);\n      outputNode = colorNode;\n    }\n    return outputNode;\n  }\n}\n\n/**\n * TSL function for creating a tone mapping node.\n *\n * @function\n * @param {Number} mapping - The tone mapping type.\n * @param {Node<float> | Number} exposure - The tone mapping exposure.\n * @param {Node<vec3> | Color} color - The color node to process.\n * @returns {ToneMappingNode<vec3>}\n */\nconst toneMapping = (mapping, exposure, color) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color)));\n\n/**\n * TSL object that represents the global tone mapping exposure of the renderer.\n *\n * @type {RendererReferenceNode<vec3>}\n */\nconst toneMappingExposure = /*@__PURE__*/rendererReference('toneMappingExposure', 'float');\naddMethodChaining('toneMapping', (color, mapping, exposure) => toneMapping(mapping, exposure, color));\n\n/** @module BufferAttributeNode **/\n\n/**\n * In earlier `three.js` versions it was only possible to define attribute data\n * on geometry level. With `BufferAttributeNode`, it is also possible to do this\n * on the node level.\n * ```js\n * const geometry = new THREE.PlaneGeometry();\n * const positionAttribute = geometry.getAttribute( 'position' );\n *\n * const colors = [];\n * for ( let i = 0; i < position.count; i ++ ) {\n * \tcolors.push( 1, 0, 0 );\n * }\n *\n * material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );\n * ```\n * This new approach is especially interesting when geometry data are generated via\n * compute shaders. The below line converts a storage buffer into an attribute node.\n * ```js\n * material.positionNode = positionBuffer.toAttribute();\n * ```\n * @augments InputNode\n */\nclass BufferAttributeNode extends InputNode {\n  static get type() {\n    return 'BufferAttributeNode';\n  }\n\n  /**\n   * Constructs a new buffer attribute node.\n   *\n   * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.\n   * @param {String?} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n   * @param {Number} [bufferStride=0] - The buffer stride.\n   * @param {Number} [bufferOffset=0] - The buffer offset.\n   */\n  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {\n    super(value, bufferType);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isBufferNode = true;\n\n    /**\n     * The buffer type (e.g. `'vec3'`).\n     *\n     * @type {String}\n     * @default null\n     */\n    this.bufferType = bufferType;\n\n    /**\n     * The buffer stride.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.bufferStride = bufferStride;\n\n    /**\n     * The buffer offset.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.bufferOffset = bufferOffset;\n\n    /**\n     * The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,\n     * if you are planning to update the attribute data per frame.\n     *\n     * @type {Number}\n     * @default StaticDrawUsage\n     */\n    this.usage = StaticDrawUsage;\n\n    /**\n     * Whether the attribute is instanced or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.instanced = false;\n\n    /**\n     * A reference to the buffer attribute.\n     *\n     * @type {BufferAttribute?}\n     * @default null\n     */\n    this.attribute = null;\n\n    /**\n     * `BufferAttributeNode` sets this property to `true` by default.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.global = true;\n    if (value && value.isBufferAttribute === true) {\n      this.attribute = value;\n      this.usage = value.usage;\n      this.instanced = value.isInstancedBufferAttribute;\n    }\n  }\n\n  /**\n   * This method is overwritten since the attribute data might be shared\n   * and thus the hash should be shared as well.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The hash.\n   */\n  getHash(builder) {\n    if (this.bufferStride === 0 && this.bufferOffset === 0) {\n      let bufferData = builder.globalCache.getData(this.value);\n      if (bufferData === undefined) {\n        bufferData = {\n          node: this\n        };\n        builder.globalCache.setData(this.value, bufferData);\n      }\n      return bufferData.node.uuid;\n    }\n    return this.uuid;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from\n   * the buffer attribute.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    if (this.bufferType === null) {\n      this.bufferType = builder.getTypeFromAttribute(this.attribute);\n    }\n    return this.bufferType;\n  }\n\n  /**\n   * Depending on which value was passed to the node, `setup()` behaves\n   * differently. If no instance of `BufferAttribute` was passed, the method\n   * creates an internal attribute and configures it respectively.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    if (this.attribute !== null) return;\n    const type = this.getNodeType(builder);\n    const array = this.value;\n    const itemSize = builder.getTypeLength(type);\n    const stride = this.bufferStride || itemSize;\n    const offset = this.bufferOffset;\n    const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);\n    const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);\n    buffer.setUsage(this.usage);\n    this.attribute = bufferAttribute;\n    this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n  }\n\n  /**\n   * Generates the code snippet of the buffer attribute node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The generated code snippet.\n   */\n  generate(builder) {\n    const nodeType = this.getNodeType(builder);\n    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);\n    const propertyName = builder.getPropertyName(nodeAttribute);\n    let output = null;\n    if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {\n      this.name = propertyName;\n      output = propertyName;\n    } else {\n      const nodeVarying = varying(this);\n      output = nodeVarying.build(builder, nodeType);\n    }\n    return output;\n  }\n\n  /**\n   * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(/*builder*/\n  ) {\n    return 'bufferAttribute';\n  }\n\n  /**\n   * Sets the `usage` property to the given value.\n   *\n   * @param {Number} value - The usage to set.\n   * @return {BufferAttributeNode} A reference to this node.\n   */\n  setUsage(value) {\n    this.usage = value;\n    if (this.attribute && this.attribute.isBufferAttribute === true) {\n      this.attribute.usage = value;\n    }\n    return this;\n  }\n\n  /**\n   * Sets the `instanced` property to the given value.\n   *\n   * @param {Number} value - The value to set.\n   * @return {BufferAttributeNode} A reference to this node.\n   */\n  setInstanced(value) {\n    this.instanced = value;\n    return this;\n  }\n}\n\n/**\n * TSL function for creating a buffer attribute node.\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst bufferAttribute = (array, type = null, stride = 0, offset = 0) => nodeObject(new BufferAttributeNode(array, type, stride, offset));\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage.\n * Use this function if attribute data are updated per frame.\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst dynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);\n\n/**\n * TSL function for creating a buffer attribute node but with enabled instancing\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst instancedBufferAttribute = (array, type = null, stride = 0, offset = 0) => bufferAttribute(array, type, stride, offset).setInstanced(true);\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst instancedDynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);\naddMethodChaining('toAttribute', bufferNode => bufferAttribute(bufferNode.value));\n\n/** @module ComputeNode **/\n\n/**\n * TODO\n *\n * @augments Node\n */\nclass ComputeNode extends Node {\n  static get type() {\n    return 'ComputeNode';\n  }\n\n  /**\n   * Constructs a new compute node.\n   *\n   * @param {Node} computeNode - TODO\n   * @param {Number} count - TODO.\n   * @param {Array<Number>} [workgroupSize=[64]] - TODO.\n   */\n  constructor(computeNode, count, workgroupSize = [64]) {\n    super('void');\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isComputeNode = true;\n\n    /**\n     * TODO\n     *\n     * @type {Node}\n     */\n    this.computeNode = computeNode;\n\n    /**\n     * TODO\n     *\n     * @type {Number}\n     */\n    this.count = count;\n\n    /**\n     * TODO\n     *\n     * @type {Array<Number>}\n     * @default [64]\n     */\n    this.workgroupSize = workgroupSize;\n\n    /**\n     * TODO\n     *\n     * @type {Number}\n     */\n    this.dispatchCount = 0;\n\n    /**\n     * TODO\n     *\n     * @type {Number}\n     */\n    this.version = 1;\n\n    /**\n     * The name or label of the uniform.\n     *\n     * @type {String}\n     * @default ''\n     */\n    this.name = '';\n\n    /**\n     * The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since {@link ComputeNode#updateBefore}\n     * is executed once per object by default.\n     *\n     * @type {String}\n     * @default 'object'\n     */\n    this.updateBeforeType = NodeUpdateType.OBJECT;\n\n    /**\n     * TODO\n     *\n     * @type {Function}\n     */\n    this.onInitFunction = null;\n    this.updateDispatchCount();\n  }\n\n  /**\n   * Executes the `dispose` event for this node.\n   */\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n  /**\n   * Sets the {@link ComputeNode#name} property.\n   *\n   * @param {String} name - The name of the uniform.\n   * @return {ComputeNode} A reference to this node.\n   */\n  label(name) {\n    this.name = name;\n    return this;\n  }\n\n  /**\n   * TODO\n   */\n  updateDispatchCount() {\n    const {\n      count,\n      workgroupSize\n    } = this;\n    let size = workgroupSize[0];\n    for (let i = 1; i < workgroupSize.length; i++) size *= workgroupSize[i];\n    this.dispatchCount = Math.ceil(count / size);\n  }\n\n  /**\n   * TODO\n   *\n   * @param {Function} callback - TODO.\n   * @return {ComputeNode} A reference to this node.\n   */\n  onInit(callback) {\n    this.onInitFunction = callback;\n    return this;\n  }\n\n  /**\n   * The method execute the compute for this node.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  updateBefore({\n    renderer\n  }) {\n    renderer.compute(this);\n  }\n  generate(builder) {\n    const {\n      shaderStage\n    } = builder;\n    if (shaderStage === 'compute') {\n      const snippet = this.computeNode.build(builder, 'void');\n      if (snippet !== '') {\n        builder.addLineFlowCode(snippet, this);\n      }\n    }\n  }\n}\n\n/**\n * TSL function for creating a compute node.\n *\n * @function\n * @param {Node} node - TODO\n * @param {Number} count - TODO.\n * @param {Array<Number>} [workgroupSize=[64]] - TODO.\n * @returns {AtomicFunctionNode}\n */\nconst compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));\naddMethodChaining('compute', compute);\n\n/** @module CacheNode **/\n\n/**\n * This node can be used as a cache management component for another node.\n * Caching is in general used by default in {@link NodeBuilder} but this node\n * allows the usage of a shared parent cache during the build process.\n *\n * @augments Node\n */\nclass CacheNode extends Node {\n  static get type() {\n    return 'CacheNode';\n  }\n\n  /**\n   * Constructs a new cache node.\n   *\n   * @param {Node} node - The node that should be cached.\n   * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n   */\n  constructor(node, parent = true) {\n    super();\n\n    /**\n     * The node that should be cached.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * Whether this node refers to a shared parent cache or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.parent = parent;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isCacheNode = true;\n  }\n  getNodeType(builder) {\n    const previousCache = builder.getCache();\n    const cache = builder.getCacheFromNode(this, this.parent);\n    builder.setCache(cache);\n    const nodeType = this.node.getNodeType(builder);\n    builder.setCache(previousCache);\n    return nodeType;\n  }\n  build(builder, ...params) {\n    const previousCache = builder.getCache();\n    const cache = builder.getCacheFromNode(this, this.parent);\n    builder.setCache(cache);\n    const data = this.node.build(builder, ...params);\n    builder.setCache(previousCache);\n    return data;\n  }\n}\n\n/**\n * TSL function for creating a cache node.\n *\n * @function\n * @param {Node} node - The node that should be cached.\n * @param {Boolean} parent - Whether this node refers to a shared parent cache or not.\n * @returns {CacheNode}\n */\nconst cache = (node, parent) => nodeObject(new CacheNode(nodeObject(node), parent));\naddMethodChaining('cache', cache);\n\n/** @module BypassNode **/\n\n/**\n * The class generates the code of a given node but returns another node in the output.\n * This can be used to call a method or node that does not return a value, i.e.\n * type `void` on an input where returning a value is required. Example:\n *\n * ```js\n * material.colorNode = myColor.bypass( runVoidFn() )\n *```\n *\n * @augments Node\n */\nclass BypassNode extends Node {\n  static get type() {\n    return 'BypassNode';\n  }\n\n  /**\n   * Constructs a new bypass node.\n   *\n   * @param {Node} outputNode - The output node.\n   * @param {Node} callNode - The call node.\n   */\n  constructor(outputNode, callNode) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isBypassNode = true;\n\n    /**\n     * The output node.\n     *\n     * @type {Node}\n     */\n    this.outputNode = outputNode;\n\n    /**\n     * The call node.\n     *\n     * @type {Node}\n     */\n    this.callNode = callNode;\n  }\n  getNodeType(builder) {\n    return this.outputNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const snippet = this.callNode.build(builder, 'void');\n    if (snippet !== '') {\n      builder.addLineFlowCode(snippet, this);\n    }\n    return this.outputNode.build(builder);\n  }\n}\n\n/**\n * TSL function for creating a bypass node.\n *\n * @function\n * @param {Node} outputNode - The output node.\n * @param {Node} callNode - The call node.\n * @returns {BypassNode}\n */\nconst bypass = /*@__PURE__*/nodeProxy(BypassNode);\naddMethodChaining('bypass', bypass);\n\n/** @module RemapNode **/\n\n/**\n * This node allows to remap a node value from one range into another. E.g a value of\n * `0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.\n * `RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.\n *\n * @augments Node\n */\nclass RemapNode extends Node {\n  static get type() {\n    return 'RemapNode';\n  }\n\n  /**\n   * Constructs a new remap node.\n   *\n   * @param {Node} node - The node that should be remapped.\n   * @param {Node} inLowNode - The source or current lower bound of the range.\n   * @param {Node} inHighNode - The source or current upper bound of the range.\n   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n   */\n  constructor(node, inLowNode, inHighNode, outLowNode = float(0), outHighNode = float(1)) {\n    super();\n\n    /**\n     * The node that should be remapped.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * The source or current lower bound of the range.\n     *\n     * @type {Node}\n     */\n    this.inLowNode = inLowNode;\n\n    /**\n     * The source or current upper bound of the range.\n     *\n     * @type {Node}\n     */\n    this.inHighNode = inHighNode;\n\n    /**\n     * The target lower bound of the range.\n     *\n     * @type {Node}\n     * @default float(0)\n     */\n    this.outLowNode = outLowNode;\n\n    /**\n     * The target upper bound of the range.\n     *\n     * @type {Node}\n     * @default float(1)\n     */\n    this.outHighNode = outHighNode;\n\n    /**\n     * Whether the node value should be clamped before\n     * remapping it to the target range.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.doClamp = true;\n  }\n  setup() {\n    const {\n      node,\n      inLowNode,\n      inHighNode,\n      outLowNode,\n      outHighNode,\n      doClamp\n    } = this;\n    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));\n    if (doClamp === true) t = t.clamp();\n    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);\n  }\n}\n\n/**\n * TSL function for creating a remap node.\n *\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nconst remap = /*@__PURE__*/nodeProxy(RemapNode, null, null, {\n  doClamp: false\n});\n\n/**\n * TSL function for creating a remap node, but with enabled clamping.\n *\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nconst remapClamp = /*@__PURE__*/nodeProxy(RemapNode);\naddMethodChaining('remap', remap);\naddMethodChaining('remapClamp', remapClamp);\n\n/** @module ExpressionNode **/\n\n/**\n * This class can be used to implement basic expressions in shader code.\n * Basic examples for that are `return`, `continue` or `discard` statements.\n *\n * @augments Node\n */\nclass ExpressionNode extends Node {\n  static get type() {\n    return 'ExpressionNode';\n  }\n\n  /**\n   * Constructs a new expression node.\n   *\n   * @param {String} [snippet=''] - The native code snippet.\n   * @param {String} [nodeType='void'] - The node type.\n   */\n  constructor(snippet = '', nodeType = 'void') {\n    super(nodeType);\n\n    /**\n     * The native code snippet.\n     *\n     * @type {String}\n     * @default ''\n     */\n    this.snippet = snippet;\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const snippet = this.snippet;\n    if (type === 'void') {\n      builder.addLineFlowCode(snippet, this);\n    } else {\n      return builder.format(`( ${snippet} )`, type, output);\n    }\n  }\n}\n\n/**\n * TSL function for creating an expression node.\n *\n * @function\n * @param {String} [snippet=''] - The native code snippet.\n * @param {String} [nodeType='void'] - The node type.\n * @returns {ExpressionNode}\n */\nconst expression = /*@__PURE__*/nodeProxy(ExpressionNode);\n\n/** @module Discard **/\n\n/**\n * Represents a `discard` shader operation in TSL.\n *\n * @method\n * @param {ConditionalNode?} conditional - An optional conditional node. It allows to decide whether the discard should be executed or not.\n * @return {Node} The `discard` expression.\n */\nconst Discard = conditional => (conditional ? select(conditional, expression('discard')) : expression('discard')).append();\n\n/**\n * Represents a `return` shader operation in TSL.\n *\n * @method\n * @return {ExpressionNode} The `return` expression.\n */\nconst Return = () => expression('return').append();\naddMethodChaining('discard', Discard);\n\n/** @module RenderOutputNode **/\n\n/**\n * Normally, tone mapping and color conversion happens automatically\n * before outputting pixel too the default (screen) framebuffer. In certain\n * post processing setups this happens to late because certain effects\n * require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used\n * to apply tone mapping and color space conversion at an arbitrary point\n * in the effect chain.\n *\n * When applying tone mapping and color space conversion manually with this node,\n * you have to set {@link PostProcessing#outputColorTransform} to `false`.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n * postProcessing.outputColorTransform = false;\n *\n * const scenePass = pass( scene, camera );\n * const outputPass = renderOutput( scenePass );\n *\n * postProcessing.outputNode = outputPass;\n * ```\n *\n * @augments TempNode\n */\nclass RenderOutputNode extends TempNode {\n  static get type() {\n    return 'RenderOutputNode';\n  }\n\n  /**\n   * Constructs a new render output node.\n   *\n   * @param {Node} colorNode - The color node to process.\n   * @param {Number} toneMapping - The tone mapping type.\n   * @param {String} outputColorSpace - The output color space.\n   */\n  constructor(colorNode, toneMapping, outputColorSpace) {\n    super('vec4');\n\n    /**\n     * The color node to process.\n     *\n     * @type {Node}\n     */\n    this.colorNode = colorNode;\n\n    /**\n     * The tone mapping type.\n     *\n     * @type {Number?}\n     */\n    this.toneMapping = toneMapping;\n\n    /**\n     * The output color space.\n     *\n     * @type {String?}\n     */\n    this.outputColorSpace = outputColorSpace;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isRenderOutputNode = true;\n  }\n  setup({\n    context\n  }) {\n    let outputNode = this.colorNode || context.color;\n\n    // tone mapping\n\n    const toneMapping = (this.toneMapping !== null ? this.toneMapping : context.toneMapping) || NoToneMapping;\n    const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace) || NoColorSpace;\n    if (toneMapping !== NoToneMapping) {\n      outputNode = outputNode.toneMapping(toneMapping);\n    }\n\n    // working to output color space\n\n    if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) {\n      outputNode = outputNode.workingToColorSpace(outputColorSpace);\n    }\n    return outputNode;\n  }\n}\n\n/**\n * TSL function for creating a posterize node.\n *\n * @function\n * @param {Node} color - The color node to process.\n * @param {Number?} [toneMapping=null] - The tone mapping type.\n * @param {String?} [outputColorSpace=null] - The output color space.\n * @returns {RenderOutputNode}\n */\nconst renderOutput = (color, toneMapping = null, outputColorSpace = null) => nodeObject(new RenderOutputNode(nodeObject(color), toneMapping, outputColorSpace));\naddMethodChaining('renderOutput', renderOutput);\n\n// Non-PURE exports list, side-effects are required here.\n// TSL Base Syntax\n\nfunction addNodeElement(name /*, nodeElement*/) {\n  console.warn('THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name);\n}\n\n/** @module AttributeNode **/\n\n/**\n * Base class for representing shader attributes as nodes.\n *\n * @augments Node\n */\nclass AttributeNode extends Node {\n  static get type() {\n    return 'AttributeNode';\n  }\n\n  /**\n   * Constructs a new attribute node.\n   *\n   * @param {String} attributeName - The name of the attribute.\n   * @param {String?} nodeType - The node type.\n   */\n  constructor(attributeName, nodeType = null) {\n    super(nodeType);\n\n    /**\n     * `AttributeNode` sets this property to `true` by default.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.global = true;\n    this._attributeName = attributeName;\n  }\n  getHash(builder) {\n    return this.getAttributeName(builder);\n  }\n  getNodeType(builder) {\n    let nodeType = this.nodeType;\n    if (nodeType === null) {\n      const attributeName = this.getAttributeName(builder);\n      if (builder.hasGeometryAttribute(attributeName)) {\n        const attribute = builder.geometry.getAttribute(attributeName);\n        nodeType = builder.getTypeFromAttribute(attribute);\n      } else {\n        nodeType = 'float';\n      }\n    }\n    return nodeType;\n  }\n\n  /**\n   * Sets the attribute name to the given value. The method can be\n   * overwritten in derived classes if the final name must be computed\n   * analytically.\n   *\n   * @param {String} attributeName - The name of the attribute.\n   * @return {AttributeNode} A reference to this node.\n   */\n  setAttributeName(attributeName) {\n    this._attributeName = attributeName;\n    return this;\n  }\n\n  /**\n   * Returns the attribute name of this node. The method can be\n   * overwritten in derived classes if the final name must be computed\n   * analytically.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The attribute name.\n   */\n  getAttributeName(/*builder*/\n  ) {\n    return this._attributeName;\n  }\n  generate(builder) {\n    const attributeName = this.getAttributeName(builder);\n    const nodeType = this.getNodeType(builder);\n    const geometryAttribute = builder.hasGeometryAttribute(attributeName);\n    if (geometryAttribute === true) {\n      const attribute = builder.geometry.getAttribute(attributeName);\n      const attributeType = builder.getTypeFromAttribute(attribute);\n      const nodeAttribute = builder.getAttribute(attributeName, attributeType);\n      if (builder.shaderStage === 'vertex') {\n        return builder.format(nodeAttribute.name, attributeType, nodeType);\n      } else {\n        const nodeVarying = varying(this);\n        return nodeVarying.build(builder, nodeType);\n      }\n    } else {\n      console.warn(`AttributeNode: Vertex attribute \"${attributeName}\" not found on geometry.`);\n      return builder.generateConst(nodeType);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.global = this.global;\n    data._attributeName = this._attributeName;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.global = data.global;\n    this._attributeName = data._attributeName;\n  }\n}\n\n/**\n * TSL function for creating an attribute node.\n *\n * @function\n * @param {String} name - The name of the attribute.\n * @param {String?} nodeType - The node type.\n * @returns {AttributeNode}\n */\nconst attribute = (name, nodeType) => nodeObject(new AttributeNode(name, nodeType));\n\n/** @module UV **/\n\n/**\n * TSL function for creating an uv attribute node with the given index.\n *\n * @function\n * @param {Number} [index=0] - The uv index.\n * @return {AttributeNode<vec2>} The uv attribute node.\n */\nconst uv = (index = 0) => attribute('uv' + (index > 0 ? index : ''), 'vec2');\n\n/** @module TextureSizeNode **/\n\n/**\n * A node that represents the dimensions of a texture. The texture size is\n * retrieved in the shader via built-in shader functions like `textureDimensions()`\n * or `textureSize()`.\n *\n * @augments Node\n */\nclass TextureSizeNode extends Node {\n  static get type() {\n    return 'TextureSizeNode';\n  }\n\n  /**\n   * Constructs a new texture size node.\n   *\n   * @param {TextureNode} textureNode - A texture node which size should be retrieved.\n   * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.\n   */\n  constructor(textureNode, levelNode = null) {\n    super('uvec2');\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isTextureSizeNode = true;\n\n    /**\n     * A texture node which size should be retrieved.\n     *\n     * @type {TextureNode}\n     */\n    this.textureNode = textureNode;\n\n    /**\n     * A level node which defines the requested mip.\n     *\n     * @type {Node<int>}\n     * @default null\n     */\n    this.levelNode = levelNode;\n  }\n  generate(builder, output) {\n    const textureProperty = this.textureNode.build(builder, 'property');\n    const level = this.levelNode === null ? '0' : this.levelNode.build(builder, 'int');\n    return builder.format(`${builder.getMethod('textureDimensions')}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output);\n  }\n}\n\n/**\n * TSL function for creating a texture size node.\n *\n * @function\n * @param {TextureNode} textureNode - A texture node which size should be retrieved.\n * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.\n * @returns {TextureSizeNode}\n */\nconst textureSize = /*@__PURE__*/nodeProxy(TextureSizeNode);\n\n/** @module MatcapUVNode **/\n\n/**\n * A special type of uniform node that computes the\n * maximum mipmap level for a given texture node.\n *\n * ```js\n * const level = maxMipLevel( textureNode );\n * ```\n *\n * @augments module:UniformNode~UniformNode\n */\nclass MaxMipLevelNode extends UniformNode {\n  static get type() {\n    return 'MaxMipLevelNode';\n  }\n\n  /**\n   * Constructs a new max mip level node.\n   *\n   * @param {TextureNode} textureNode - The texture node to compute the max mip level for.\n   */\n  constructor(textureNode) {\n    super(0);\n\n    /**\n     * The texture node to compute the max mip level for.\n     *\n     * @private\n     * @type {TextureNode}\n     */\n    this._textureNode = textureNode;\n\n    /**\n     * The `updateType` is set to `NodeUpdateType.FRAME` since the node updates\n     * the texture once per frame in its {@link MaxMipLevelNode#update} method.\n     *\n     * @type {String}\n     * @default 'frame'\n     */\n    this.updateType = NodeUpdateType.FRAME;\n  }\n\n  /**\n   * The texture node to compute the max mip level for.\n   *\n   * @readonly\n   * @type {TextureNode}\n   */\n  get textureNode() {\n    return this._textureNode;\n  }\n\n  /**\n   * The texture.\n   *\n   * @readonly\n   * @type {Texture}\n   */\n  get texture() {\n    return this._textureNode.value;\n  }\n  update() {\n    const texture = this.texture;\n    const images = texture.images;\n    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture.image;\n    if (image && image.width !== undefined) {\n      const {\n        width,\n        height\n      } = image;\n      this.value = Math.log2(Math.max(width, height));\n    }\n  }\n}\n\n/**\n * TSL function for creating a max mip level node.\n *\n * @function\n * @param {TextureNode} textureNode - The texture node to compute the max mip level for.\n * @returns {MaxMipLevelNode}\n */\nconst maxMipLevel = /*@__PURE__*/nodeProxy(MaxMipLevelNode);\n\n/** @module TextureNode **/\n\n/**\n * This type of uniform node represents a 2D texture.\n *\n * @augments module:UniformNode~UniformNode\n */\nclass TextureNode extends UniformNode {\n  static get type() {\n    return 'TextureNode';\n  }\n\n  /**\n   * Constructs a new texture node.\n   *\n   * @param {Texture} value - The texture.\n   * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n   * @param {Node<int>?} [levelNode=null] - The level node.\n   * @param {Node<float>?} [biasNode=null] - The bias node.\n   */\n  constructor(value, uvNode = null, levelNode = null, biasNode = null) {\n    super(value);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isTextureNode = true;\n\n    /**\n     * Represents the texture coordinates.\n     *\n     * @type {Node<vec2|vec3>?}\n     * @default null\n     */\n    this.uvNode = uvNode;\n\n    /**\n     * Represents the mip level that should be selected.\n     *\n     * @type {Node<int>?}\n     * @default null\n     */\n    this.levelNode = levelNode;\n\n    /**\n     * Represents the bias to be applied during level-of-detail computation.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.biasNode = biasNode;\n\n    /**\n     * Represents a reference value a texture sample is compared to.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.compareNode = null;\n\n    /**\n     * When using texture arrays, the depth node defines the layer to select.\n     *\n     * @type {Node<int>?}\n     * @default null\n     */\n    this.depthNode = null;\n\n    /**\n     * When defined, a texture is sampled using explicit gradients.\n     *\n     * @type {Array<Node<vec2>>?}\n     * @default null\n     */\n    this.gradNode = null;\n\n    /**\n     * Whether texture values should be sampled or fetched.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.sampler = true;\n\n    /**\n     * Whether the uv transformation matrix should be\n     * automatically updated or not. Use `setUpdateMatrix()`\n     * if you want to change the value of the property.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.updateMatrix = false;\n\n    /**\n     * By default the `update()` method is not executed. `setUpdateMatrix()`\n     * sets the value to `frame` when the uv transformation matrix should\n     * automatically be updated.\n     *\n     * @type {String}\n     * @default 'none'\n     */\n    this.updateType = NodeUpdateType.NONE;\n\n    /**\n     * The reference node.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.referenceNode = null;\n\n    /**\n     * The texture value is stored in a private property.\n     *\n     * @private\n     * @type {Texture}\n     */\n    this._value = value;\n\n    /**\n     * The uniform node that represents the uv transformation matrix.\n     *\n     * @private\n     * @type {UniformNode<mat3>?}\n     */\n    this._matrixUniform = null;\n    this.setUpdateMatrix(uvNode === null);\n  }\n  set value(value) {\n    if (this.referenceNode) {\n      this.referenceNode.value = value;\n    } else {\n      this._value = value;\n    }\n  }\n\n  /**\n   * The texture value.\n   *\n   * @type {Texture}\n   */\n  get value() {\n    return this.referenceNode ? this.referenceNode.value : this._value;\n  }\n\n  /**\n   * Overwritten since the uniform hash is defined by the texture's UUID.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The uniform hash.\n   */\n  getUniformHash(/*builder*/\n  ) {\n    return this.value.uuid;\n  }\n\n  /**\n   * Overwritten since the node type is inferred from the texture type.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(/*builder*/\n  ) {\n    if (this.value.isDepthTexture === true) return 'float';\n    if (this.value.type === UnsignedIntType) {\n      return 'uvec4';\n    } else if (this.value.type === IntType) {\n      return 'ivec4';\n    }\n    return 'vec4';\n  }\n\n  /**\n   * Overwrites the default implementation to return a fixed value `'texture'`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(/*builder*/\n  ) {\n    return 'texture';\n  }\n\n  /**\n   * Returns a default uvs based on the current texture's channel.\n   *\n   * @return {AttributeNode<vec2>} The default uvs.\n   */\n  getDefaultUV() {\n    return uv(this.value.channel);\n  }\n\n  /**\n   * Overwritten to always return the texture reference of the node.\n   *\n   * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n   * @return {Texture} The texture reference.\n   */\n  updateReference(/*state*/\n  ) {\n    return this.value;\n  }\n\n  /**\n   * Transforms the given uv node with the texture transformation matrix.\n   *\n   * @param {Node} uvNode - The uv node to transform.\n   * @return {Node} The transformed uv node.\n   */\n  getTransformedUV(uvNode) {\n    if (this._matrixUniform === null) this._matrixUniform = uniform(this.value.matrix);\n    return this._matrixUniform.mul(vec3(uvNode, 1)).xy;\n  }\n\n  /**\n   * Defines whether the uv transformation matrix should automatically be updated or not.\n   *\n   * @param {Boolean} value - The update toggle.\n   * @return {TextureNode} A reference to this node.\n   */\n  setUpdateMatrix(value) {\n    this.updateMatrix = value;\n    this.updateType = value ? NodeUpdateType.RENDER : NodeUpdateType.NONE;\n    return this;\n  }\n\n  /**\n   * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary\n   * to modify the uv node for correct sampling.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {Node} uvNode - The uv node to setup.\n   * @return {Node} The updated uv node.\n   */\n  setupUV(builder, uvNode) {\n    const texture = this.value;\n    if (builder.isFlipY() && (texture.image instanceof ImageBitmap && texture.flipY === true || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true)) {\n      if (this.sampler) {\n        uvNode = uvNode.flipY();\n      } else {\n        uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));\n      }\n    }\n    return uvNode;\n  }\n\n  /**\n   * Setups texture node by preparing the internal nodes for code generation.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    const properties = builder.getNodeProperties(this);\n    properties.referenceNode = this.referenceNode;\n\n    //\n\n    const texture = this.value;\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().');\n    }\n\n    //\n\n    let uvNode = this.uvNode;\n    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {\n      uvNode = builder.context.getUV(this);\n    }\n    if (!uvNode) uvNode = this.getDefaultUV();\n    if (this.updateMatrix === true) {\n      uvNode = this.getTransformedUV(uvNode);\n    }\n    uvNode = this.setupUV(builder, uvNode);\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getTextureLevel) {\n      levelNode = builder.context.getTextureLevel(this);\n    }\n\n    //\n\n    properties.uvNode = uvNode;\n    properties.levelNode = levelNode;\n    properties.biasNode = this.biasNode;\n    properties.compareNode = this.compareNode;\n    properties.gradNode = this.gradNode;\n    properties.depthNode = this.depthNode;\n  }\n\n  /**\n   * Generates the uv code snippet.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {Node} uvNode - The uv node to generate code for.\n   * @return {String} The generated code snippet.\n   */\n  generateUV(builder, uvNode) {\n    return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');\n  }\n\n  /**\n   * Generates the snippet for the texture sampling.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {String} textureProperty - The texture property.\n   * @param {String} uvSnippet - The uv snippet.\n   * @param {String} levelSnippet - The level snippet.\n   * @param {String} biasSnippet - The bias snippet.\n   * @param {String} depthSnippet - The depth snippet.\n   * @param {String} compareSnippet - The compare snippet.\n   * @param {String} gradSnippet - The grad snippet.\n   * @return {String} The generated code snippet.\n   */\n  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet) {\n    const texture = this.value;\n    let snippet;\n    if (levelSnippet) {\n      snippet = builder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet);\n    } else if (biasSnippet) {\n      snippet = builder.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet);\n    } else if (gradSnippet) {\n      snippet = builder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet);\n    } else if (compareSnippet) {\n      snippet = builder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet);\n    } else if (this.sampler === false) {\n      snippet = builder.generateTextureLoad(texture, textureProperty, uvSnippet, depthSnippet);\n    } else {\n      snippet = builder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet);\n    }\n    return snippet;\n  }\n\n  /**\n   * Generates the code snippet of the texture node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {String} output - The current output.\n   * @return {String} The generated code snippet.\n   */\n  generate(builder, output) {\n    const texture = this.value;\n    const properties = builder.getNodeProperties(this);\n    const textureProperty = super.generate(builder, 'property');\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeData = builder.getDataFromNode(this);\n      let propertyName = nodeData.propertyName;\n      if (propertyName === undefined) {\n        const {\n          uvNode,\n          levelNode,\n          biasNode,\n          compareNode,\n          depthNode,\n          gradNode\n        } = properties;\n        const uvSnippet = this.generateUV(builder, uvNode);\n        const levelSnippet = levelNode ? levelNode.build(builder, 'float') : null;\n        const biasSnippet = biasNode ? biasNode.build(builder, 'float') : null;\n        const depthSnippet = depthNode ? depthNode.build(builder, 'int') : null;\n        const compareSnippet = compareNode ? compareNode.build(builder, 'float') : null;\n        const gradSnippet = gradNode ? [gradNode[0].build(builder, 'vec2'), gradNode[1].build(builder, 'vec2')] : null;\n        const nodeVar = builder.getVarFromNode(this);\n        propertyName = builder.getPropertyName(nodeVar);\n        const snippet = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet);\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n        nodeData.snippet = snippet;\n        nodeData.propertyName = propertyName;\n      }\n      let snippet = propertyName;\n      const nodeType = this.getNodeType(builder);\n      if (builder.needsToWorkingColorSpace(texture)) {\n        snippet = colorSpaceToWorking(expression(snippet, nodeType), texture.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      return builder.format(snippet, nodeType, output);\n    }\n  }\n\n  /**\n   * Sets the sampler value.\n   *\n   * @param {Boolean} value - The sampler value to set.\n   * @return {TextureNode} A reference to this texture node.\n   */\n  setSampler(value) {\n    this.sampler = value;\n    return this;\n  }\n\n  /**\n   * Returns the sampler value.\n   *\n   * @return {Boolean} The sampler value.\n   */\n  getSampler() {\n    return this.sampler;\n  }\n\n  // @TODO: Move to TSL\n\n  uv(uvNode) {\n    // @deprecated, r172\n\n    console.warn('THREE.TextureNode: .uv() has been renamed. Use .sample() instead.');\n    return this.sample(uvNode);\n  }\n\n  /**\n   * Samples the texture with the given uv node.\n   *\n   * @param {Node} uvNode - The uv node.\n   * @return {TextureNode} A texture node representing the texture sample.\n   */\n  sample(uvNode) {\n    const textureNode = this.clone();\n    textureNode.uvNode = nodeObject(uvNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n\n  /**\n   * Samples a blurred version of the texture by defining an internal bias.\n   *\n   * @param {Node<float>} amountNode - How blurred the texture should be.\n   * @return {TextureNode} A texture node representing the texture sample.\n   */\n  blur(amountNode) {\n    const textureNode = this.clone();\n    textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n\n  /**\n   * Samples a specific mip of the texture.\n   *\n   * @param {Node<int>} levelNode - The mip level to sample.\n   * @return {TextureNode} A texture node representing the texture sample.\n   */\n  level(levelNode) {\n    const textureNode = this.clone();\n    textureNode.levelNode = nodeObject(levelNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n\n  /**\n   * Returns the texture size of the requested level.\n   *\n   * @param {Node<int>} levelNode - The level to compute the size for.\n   * @return {TextureSizeNode} The texture size.\n   */\n  size(levelNode) {\n    return textureSize(this, levelNode);\n  }\n\n  /**\n   * Samples the texture with the given bias.\n   *\n   * @param {Node<float>} biasNode - The bias node.\n   * @return {TextureNode} A texture node representing the texture sample.\n   */\n  bias(biasNode) {\n    const textureNode = this.clone();\n    textureNode.biasNode = nodeObject(biasNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n\n  /**\n   * Samples the texture by executing a compare operation.\n   *\n   * @param {Node<float>} compareNode - The node that defines the compare value.\n   * @return {TextureNode} A texture node representing the texture sample.\n   */\n  compare(compareNode) {\n    const textureNode = this.clone();\n    textureNode.compareNode = nodeObject(compareNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n\n  /**\n   * Samples the texture using an explicit gradient.\n   *\n   * @param {Node<vec2>} gradNodeX - The gradX node.\n   * @param {Node<vec2>} gradNodeY - The gradY node.\n   * @return {TextureNode} A texture node representing the texture sample.\n   */\n  grad(gradNodeX, gradNodeY) {\n    const textureNode = this.clone();\n    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n\n  /**\n   * Samples the texture by defining a depth node.\n   *\n   * @param {Node<int>} depthNode - The depth node.\n   * @return {TextureNode} A texture node representing the texture sample.\n   */\n  depth(depthNode) {\n    const textureNode = this.clone();\n    textureNode.depthNode = nodeObject(depthNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n\n  // --\n\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n    data.sampler = this.sampler;\n    data.updateMatrix = this.updateMatrix;\n    data.updateType = this.updateType;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n    this.sampler = data.sampler;\n    this.updateMatrix = data.updateMatrix;\n    this.updateType = data.updateType;\n  }\n\n  /**\n   * The update is used to implement the update of the uv transformation matrix.\n   */\n  update() {\n    const texture = this.value;\n    const matrixUniform = this._matrixUniform;\n    if (matrixUniform !== null) matrixUniform.value = texture.matrix;\n    if (texture.matrixAutoUpdate === true) {\n      texture.updateMatrix();\n    }\n  }\n\n  /**\n   * Clones the texture node.\n   *\n   * @return {TextureNode} The cloned texture node.\n   */\n  clone() {\n    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);\n    newNode.sampler = this.sampler;\n    return newNode;\n  }\n}\n\n/**\n * TSL function for creating a texture node.\n *\n * @function\n * @param {Texture} value - The texture.\n * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @param {Node<float>?} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst texture = /*@__PURE__*/nodeProxy(TextureNode);\n\n/**\n * TSL function for creating a texture node that fetches/loads texels without interpolation.\n *\n * @function\n * @param {Texture} value - The texture.\n * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @param {Node<float>?} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst textureLoad = (...params) => texture(...params).setSampler(false);\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\n/**\n * Converts a texture or texture node to a sampler.\n *\n * @function\n * @param {TextureNode|Texture} aTexture - The texture or texture node to convert.\n * @returns {Node}\n */\nconst sampler = aTexture => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert('sampler');\n\n/** @module Camera **/\n\n/**\n * TSL object that represents the `near` value of the camera used for the current render.\n *\n * @type {UniformNode<float>}\n */\nconst cameraNear = /*@__PURE__*/uniform('float').label('cameraNear').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.near);\n\n/**\n * TSL object that represents the `far` value of the camera used for the current render.\n *\n * @type {UniformNode<float>}\n */\nconst cameraFar = /*@__PURE__*/uniform('float').label('cameraFar').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.far);\n\n/**\n * TSL object that represents the projection matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraProjectionMatrix = /*@__PURE__*/uniform('mat4').label('cameraProjectionMatrix').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.projectionMatrix);\n\n/**\n * TSL object that represents the inverse projection matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraProjectionMatrixInverse = /*@__PURE__*/uniform('mat4').label('cameraProjectionMatrixInverse').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.projectionMatrixInverse);\n\n/**\n * TSL object that represents the view matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraViewMatrix = /*@__PURE__*/uniform('mat4').label('cameraViewMatrix').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.matrixWorldInverse);\n\n/**\n * TSL object that represents the world matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraWorldMatrix = /*@__PURE__*/uniform('mat4').label('cameraWorldMatrix').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.matrixWorld);\n\n/**\n * TSL object that represents the normal matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat3>}\n */\nconst cameraNormalMatrix = /*@__PURE__*/uniform('mat3').label('cameraNormalMatrix').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.normalMatrix);\n\n/**\n * TSL object that represents the position in world space of the camera used for the current render.\n *\n * @type {UniformNode<vec3>}\n */\nconst cameraPosition = /*@__PURE__*/uniform(new Vector3()).label('cameraPosition').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}, self) => self.value.setFromMatrixPosition(camera.matrixWorld));\n\n/** @module Object3DNode **/\n\n/**\n * This node can be used to access transformation related metrics of 3D objects.\n * Depending on the selected scope, a different metric is represented as a uniform\n * in the shader. The following scopes are supported:\n *\n * - `POSITION`: The object's position in world space.\n * - `VIEW_POSITION`: The object's position in view/camera space.\n * - `DIRECTION`: The object's direction in world space.\n * - `SCALE`: The object's scale in world space.\n * - `WORLD_MATRIX`: The object's matrix in world space.\n *\n * @augments Node\n */\nclass Object3DNode extends Node {\n  static get type() {\n    return 'Object3DNode';\n  }\n\n  /**\n   * Constructs a new object 3D node.\n   *\n   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n   * @param {Object3D?} [object3d=null] - The 3D object.\n   */\n  constructor(scope, object3d = null) {\n    super();\n\n    /**\n     * The node reports a different type of transformation depending on the scope.\n     *\n     * @type {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')}\n     */\n    this.scope = scope;\n\n    /**\n     * The 3D object.\n     *\n     * @type {Object3D?}\n     * @default null\n     */\n    this.object3d = object3d;\n\n    /**\n     * Overwritten since this type of node is updated per object.\n     *\n     * @type {String}\n     * @default 'object'\n     */\n    this.updateType = NodeUpdateType.OBJECT;\n\n    /**\n     * Holds the value of the node as a uniform.\n     *\n     * @private\n     * @type {UniformNode}\n     */\n    this._uniformNode = new UniformNode(null);\n  }\n\n  /**\n   * Overwritten since the node type is inferred from the scope.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType() {\n    const scope = this.scope;\n    if (scope === Object3DNode.WORLD_MATRIX) {\n      return 'mat4';\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {\n      return 'vec3';\n    }\n  }\n\n  /**\n   * Updates the uniform value depending on the scope.\n   *\n   * @param {NodeFrame} frame - The current node frame.\n   */\n  update(frame) {\n    const object = this.object3d;\n    const uniformNode = this._uniformNode;\n    const scope = this.scope;\n    if (scope === Object3DNode.WORLD_MATRIX) {\n      uniformNode.value = object.matrixWorld;\n    } else if (scope === Object3DNode.POSITION) {\n      uniformNode.value = uniformNode.value || new Vector3();\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n    } else if (scope === Object3DNode.SCALE) {\n      uniformNode.value = uniformNode.value || new Vector3();\n      uniformNode.value.setFromMatrixScale(object.matrixWorld);\n    } else if (scope === Object3DNode.DIRECTION) {\n      uniformNode.value = uniformNode.value || new Vector3();\n      object.getWorldDirection(uniformNode.value);\n    } else if (scope === Object3DNode.VIEW_POSITION) {\n      const camera = frame.camera;\n      uniformNode.value = uniformNode.value || new Vector3();\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);\n    }\n  }\n\n  /**\n   * Generates the code snippet of the uniform node. The node type of the uniform\n   * node also depends on the selected scope.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The generated code snippet.\n   */\n  generate(builder) {\n    const scope = this.scope;\n    if (scope === Object3DNode.WORLD_MATRIX) {\n      this._uniformNode.nodeType = 'mat4';\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {\n      this._uniformNode.nodeType = 'vec3';\n    }\n    return this._uniformNode.build(builder);\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n  }\n}\nObject3DNode.WORLD_MATRIX = 'worldMatrix';\nObject3DNode.POSITION = 'position';\nObject3DNode.SCALE = 'scale';\nObject3DNode.VIEW_POSITION = 'viewPosition';\nObject3DNode.DIRECTION = 'direction';\n\n/**\n * TSL function for creating an object 3D node that represents the object's direction in world space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectDirection = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.DIRECTION);\n\n/**\n * TSL function for creating an object 3D node that represents the object's world matrix.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<mat4>}\n */\nconst objectWorldMatrix = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in world space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectPosition = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.POSITION);\n\n/**\n * TSL function for creating an object 3D node that represents the object's scale in world space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectScale = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.SCALE);\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in view/camera space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectViewPosition = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);\n\n/** @module ModelNode **/\n\n/**\n * This type of node is a specialized version of `Object3DNode`\n * with larger set of model related metrics. Unlike `Object3DNode`,\n * `ModelNode` extracts the reference to the 3D object from the\n * current node frame state.\n *\n * @augments module:Object3DNode~Object3DNode\n */\nclass ModelNode extends Object3DNode {\n  static get type() {\n    return 'ModelNode';\n  }\n\n  /**\n   * Constructs a new object model node.\n   *\n   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n   */\n  constructor(scope) {\n    super(scope);\n  }\n\n  /**\n   * Extracts the model reference from the frame state and then\n   * updates the uniform value depending on the scope.\n   *\n   * @param {NodeFrame} frame - The current node frame.\n   */\n  update(frame) {\n    this.object3d = frame.object;\n    super.update(frame);\n  }\n}\n\n/**\n * TSL object that represents the object's direction in world space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelDirection = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.DIRECTION);\n\n/**\n * TSL object that represents the object's world matrix.\n *\n * @type {ModelNode<mat4>}\n */\nconst modelWorldMatrix = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);\n\n/**\n * TSL object that represents the object's position in world space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelPosition = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.POSITION);\n\n/**\n * TSL object that represents the object's scale in world space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelScale = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.SCALE);\n\n/**\n * TSL object that represents the object's position in view/camera space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelViewPosition = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);\n\n/**\n * TSL object that represents the object's normal matrix.\n *\n * @type {UniformNode<mat3>}\n */\nconst modelNormalMatrix = /*@__PURE__*/uniform(new Matrix3()).onObjectUpdate(({\n  object\n}, self) => self.value.getNormalMatrix(object.matrixWorld));\n\n/**\n * TSL object that represents the object's inverse world matrix.\n *\n * @type {UniformNode<mat4>}\n */\nconst modelWorldMatrixInverse = /*@__PURE__*/uniform(new Matrix4()).onObjectUpdate(({\n  object\n}, self) => self.value.copy(object.matrixWorld).invert());\n\n/**\n * TSL object that represents the object's model view matrix.\n *\n * @type {Node<mat4>}\n */\nconst modelViewMatrix = /*@__PURE__*/Fn(builder => {\n  return builder.renderer.nodes.modelViewMatrix || mediumpModelViewMatrix;\n}).once()().toVar('modelViewMatrix');\n\n// GPU Precision\n\n/**\n * TSL object that represents the object's model view in `mediump` precision.\n *\n * @type {Node<mat4>}\n */\nconst mediumpModelViewMatrix = /*@__PURE__*/cameraViewMatrix.mul(modelWorldMatrix);\n\n// CPU Precision\n\n/**\n * TSL object that represents the object's model view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @type {Node<mat4>}\n */\nconst highpModelViewMatrix = /*@__PURE__*/Fn(builder => {\n  builder.context.isHighPrecisionModelViewMatrix = true;\n  return uniform('mat4').onObjectUpdate(({\n    object,\n    camera\n  }) => {\n    return object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n  });\n}).once()().toVar('highpModelViewMatrix');\n\n/**\n * TSL object that represents the object's model normal view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @type {Node<mat3>}\n */\nconst highpModelNormalViewMatrix = /*@__PURE__*/Fn(builder => {\n  const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n  return uniform('mat3').onObjectUpdate(({\n    object,\n    camera\n  }) => {\n    if (isHighPrecisionModelViewMatrix !== true) {\n      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n    }\n    return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n  });\n}).once()().toVar('highpModelNormalViewMatrix');\n\n/** @module Position **/\n\n/**\n * TSL object that represents the position attribute of the current rendered object.\n *\n * @type {AttributeNode<vec3>}\n */\nconst positionGeometry = /*@__PURE__*/attribute('position', 'vec3');\n\n/**\n * TSL object that represents the vertex position in local space of the current rendered object.\n *\n * @type {AttributeNode<vec3>}\n */\nconst positionLocal = /*@__PURE__*/positionGeometry.varying('positionLocal');\n\n/**\n * TSL object that represents the previous vertex position in local space of the current rendered object.\n * Used in context of {@link module:VelocityNode~VelocityNode} for rendering motion vectors.\n *\n * @type {AttributeNode<vec3>}\n */\nconst positionPrevious = /*@__PURE__*/positionGeometry.varying('positionPrevious');\n\n/**\n * TSL object that represents the vertex position in world space of the current rendered object.\n *\n * @type {VaryingNode<vec3>}\n */\nconst positionWorld = /*@__PURE__*/modelWorldMatrix.mul(positionLocal).xyz.varying('v_positionWorld').context({\n  needsPositionReassign: true\n});\n\n/**\n * TSL object that represents the position world direction of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst positionWorldDirection = /*@__PURE__*/positionLocal.transformDirection(modelWorldMatrix).varying('v_positionWorldDirection').normalize().toVar('positionWorldDirection').context({\n  needsPositionReassign: true\n});\n\n/**\n * TSL object that represents the vertex position in view space of the current rendered object.\n *\n * @type {VaryingNode<vec3>}\n */\nconst positionView = /*@__PURE__*/Fn(builder => {\n  return builder.context.setupPositionView();\n}, 'vec3').once()().varying('v_positionView').context({\n  needsPositionReassign: true\n});\n\n/**\n * TSL object that represents the position view direction of the current rendered object.\n *\n * @type {VaryingNode<vec3>}\n */\nconst positionViewDirection = /*@__PURE__*/positionView.negate().varying('v_positionViewDirection').normalize().toVar('positionViewDirection');\n\n/** @module FrontFacingNode **/\n\n/**\n * This node can be used to evaluate whether a primitive is front or back facing.\n *\n * @augments Node\n */\nclass FrontFacingNode extends Node {\n  static get type() {\n    return 'FrontFacingNode';\n  }\n\n  /**\n   * Constructs a new front facing node.\n   */\n  constructor() {\n    super('bool');\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isFrontFacingNode = true;\n  }\n  generate(builder) {\n    const {\n      renderer,\n      material\n    } = builder;\n    if (renderer.coordinateSystem === WebGLCoordinateSystem) {\n      if (material.side === BackSide) {\n        return 'false';\n      }\n    }\n    return builder.getFrontFacing();\n  }\n}\n\n/**\n * TSL object that represents whether a primitive is front or back facing\n *\n * @type {FrontFacingNode<bool>}\n */\nconst frontFacing = /*@__PURE__*/nodeImmutable(FrontFacingNode);\n\n/**\n * TSL object that represents the front facing status as a number instead of a bool.\n * `1` means front facing, `-1` means back facing.\n *\n * @type {Node<float>}\n */\nconst faceDirection = /*@__PURE__*/float(frontFacing).mul(2.0).sub(1.0);\n\n/** @module Normal **/\n\n/**\n * TSL object that represents the normal attribute of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalGeometry = /*@__PURE__*/attribute('normal', 'vec3');\n\n/**\n * TSL object that represents the vertex normal in local space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalLocal = /*@__PURE__*/Fn(builder => {\n  if (builder.geometry.hasAttribute('normal') === false) {\n    console.warn('TSL.NormalNode: Vertex attribute \"normal\" not found on geometry.');\n    return vec3(0, 1, 0);\n  }\n  return normalGeometry;\n}, 'vec3').once()().toVar('normalLocal');\n\n/**\n * TSL object that represents the flat vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalFlat = /*@__PURE__*/positionView.dFdx().cross(positionView.dFdy()).normalize().toVar('normalFlat');\n\n/**\n * TSL object that represents the vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalView = /*@__PURE__*/Fn(builder => {\n  let node;\n  if (builder.material.flatShading === true) {\n    node = normalFlat;\n  } else {\n    node = varying(transformNormalToView(normalLocal), 'v_normalView').normalize();\n  }\n  return node;\n}, 'vec3').once()().toVar('normalView');\n\n/**\n * TSL object that represents the vertex normal in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalWorld = /*@__PURE__*/varying(normalView.transformDirection(cameraViewMatrix), 'v_normalWorld').normalize().toVar('normalWorld');\n\n/**\n * TSL object that represents the transformed vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedNormalView = /*@__PURE__*/Fn(builder => {\n  return builder.context.setupNormal();\n}, 'vec3').once()().mul(faceDirection).toVar('transformedNormalView');\n\n/**\n * TSL object that represents the transformed vertex normal in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedNormalWorld = /*@__PURE__*/transformedNormalView.transformDirection(cameraViewMatrix).toVar('transformedNormalWorld');\n\n/**\n * TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedClearcoatNormalView = /*@__PURE__*/Fn(builder => {\n  return builder.context.setupClearcoatNormal();\n}, 'vec3').once()().mul(faceDirection).toVar('transformedClearcoatNormalView');\n\n/**\n * Transforms the normal with the given matrix.\n *\n * @function\n * @param {Node<vec3>} normal - The normal.\n * @param {Node<mat3>} [matrix=modelWorldMatrix] - The matrix.\n * @return {Node<vec3>} The transformed normal.\n */\nconst transformNormal = /*@__PURE__*/Fn(([normal, matrix = modelWorldMatrix]) => {\n  const m = mat3(matrix);\n  const transformedNormal = normal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));\n  return m.mul(transformedNormal).xyz;\n});\n\n/**\n * Transforms the given normal from local to view space.\n *\n * @function\n * @param {Node<vec3>} normal - The normal.\n * @param {NodeBuilder} builder - The current node builder.\n * @return {Node<vec3>} The transformed normal.\n */\nconst transformNormalToView = /*@__PURE__*/Fn(([normal], builder) => {\n  const modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;\n  if (modelNormalViewMatrix !== null) {\n    return modelNormalViewMatrix.transformDirection(normal);\n  }\n\n  //\n\n  const transformedNormal = modelNormalMatrix.mul(normal);\n  return cameraViewMatrix.transformDirection(transformedNormal);\n});\n\n/** @module MaterialProperties **/\n\n/**\n * TSL object that represents the refraction ratio of the material used for rendering the current object.\n *\n * @type {UniformNode<float>}\n */\nconst materialRefractionRatio = /*@__PURE__*/uniform(0).onReference(({\n  material\n}) => material).onRenderUpdate(({\n  material\n}) => material.refractionRatio);\n\n/** @module ReflectVector **/\n\n/**\n * The reflect vector in view space.\n *\n * @type {Node<vec3>}\n */\nconst reflectView = /*@__PURE__*/positionViewDirection.negate().reflect(transformedNormalView);\n\n/**\n * The refract vector in view space.\n *\n * @type {Node<vec3>}\n */\nconst refractView = /*@__PURE__*/positionViewDirection.negate().refract(transformedNormalView, materialRefractionRatio);\n\n/**\n * Used for sampling cube maps when using cube reflection mapping.\n *\n * @type {Node<vec3>}\n */\nconst reflectVector = /*@__PURE__*/reflectView.transformDirection(cameraViewMatrix).toVar('reflectVector');\n\n/**\n * Used for sampling cube maps when using cube refraction mapping.\n *\n * @type {Node<vec3>}\n */\nconst refractVector = /*@__PURE__*/refractView.transformDirection(cameraViewMatrix).toVar('reflectVector');\n\n/** @module CubeTextureNode **/\n\n/**\n * This type of uniform node represents a cube texture.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass CubeTextureNode extends TextureNode {\n  static get type() {\n    return 'CubeTextureNode';\n  }\n\n  /**\n   * Constructs a new cube texture node.\n   *\n   * @param {CubeTexture} value - The cube texture.\n   * @param {Node<vec3>?} [uvNode=null] - The uv node.\n   * @param {Node<int>?} [levelNode=null] - The level node.\n   * @param {Node<float>?} [biasNode=null] - The bias node.\n   */\n  constructor(value, uvNode = null, levelNode = null, biasNode = null) {\n    super(value, uvNode, levelNode, biasNode);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isCubeTextureNode = true;\n  }\n\n  /**\n   * Overwrites the default implementation to return a fixed value `'cubeTexture'`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(/*builder*/\n  ) {\n    return 'cubeTexture';\n  }\n\n  /**\n   * Returns a default uvs based on the mapping type of the cube texture.\n   *\n   * @return {Node<vec3>} The default uv attribute.\n   */\n  getDefaultUV() {\n    const texture = this.value;\n    if (texture.mapping === CubeReflectionMapping) {\n      return reflectVector;\n    } else if (texture.mapping === CubeRefractionMapping) {\n      return refractVector;\n    } else {\n      console.error('THREE.CubeTextureNode: Mapping \"%s\" not supported.', texture.mapping);\n      return vec3(0, 0, 0);\n    }\n  }\n\n  /**\n   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored\n   * for cube textures. The uv transformation matrix is not applied to cube textures.\n   *\n   * @param {Boolean} value - The update toggle.\n   */\n  setUpdateMatrix(/*updateMatrix*/) {} // Ignore .updateMatrix for CubeTextureNode\n\n  /**\n   * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary\n   * to modify the uv node for correct sampling.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {Node} uvNode - The uv node to setup.\n   * @return {Node} The updated uv node.\n   */\n  setupUV(builder, uvNode) {\n    const texture = this.value;\n    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture.isRenderTargetTexture) {\n      return vec3(uvNode.x.negate(), uvNode.yz);\n    } else {\n      return uvNode;\n    }\n  }\n\n  /**\n   * Generates the uv code snippet.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {Node} cubeUV - The uv node to generate code for.\n   * @return {String} The generated code snippet.\n   */\n  generateUV(builder, cubeUV) {\n    return cubeUV.build(builder, 'vec3');\n  }\n}\n\n/**\n * TSL function for creating a cube texture node.\n *\n * @function\n * @param {CubeTexture} value - The cube texture.\n * @param {Node<vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @param {Node<float>?} [biasNode=null] - The bias node.\n * @returns {CubeTextureNode}\n */\nconst cubeTexture = /*@__PURE__*/nodeProxy(CubeTextureNode);\n\n/** @module BufferNode **/\n\n/**\n * A special type of uniform node which represents array-like data\n * as uniform buffers. The access usually happens via `element()`\n * which returns an instance of {@link ArrayElementNode}. For example:\n *\n * ```js\n * const bufferNode = buffer( array, 'mat4', count );\n * const matrixNode = bufferNode.element( index ); // access a matrix from the buffer\n * ```\n * In general, it is recommended to use the more managed {@link UniformArrayNode}\n * since it handles more input types and automatically cares about buffer paddings.\n *\n * @augments module:UniformNode~UniformNode\n */\nclass BufferNode extends UniformNode {\n  static get type() {\n    return 'BufferNode';\n  }\n\n  /**\n   * Constructs a new buffer node.\n   *\n   * @param {Array<Number>} value - Array-like buffer data.\n   * @param {String} bufferType - The data type of the buffer.\n   * @param {Number} [bufferCount=0] - The count of buffer elements.\n   */\n  constructor(value, bufferType, bufferCount = 0) {\n    super(value, bufferType);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isBufferNode = true;\n\n    /**\n     * The data type of the buffer.\n     *\n     * @type {String}\n     */\n    this.bufferType = bufferType;\n\n    /**\n     * The uniform node that holds the value of the reference node.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.bufferCount = bufferCount;\n  }\n\n  /**\n   * The data type of the buffer elements.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The element type.\n   */\n  getElementType(builder) {\n    return this.getNodeType(builder);\n  }\n\n  /**\n   * Overwrites the default implementation to return a fixed value `'buffer'`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(/*builder*/\n  ) {\n    return 'buffer';\n  }\n}\n\n/**\n * TSL function for creating a buffer node.\n *\n * @function\n * @param {Array} value - Array-like buffer data.\n * @param {String} type - The data type of a buffer element.\n * @param {Number} count - The count of buffer elements.\n * @returns {BufferNode}\n */\nconst buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));\n\n/** @module UniformArrayNode **/\n\n/**\n * Represents the element access on uniform array nodes.\n *\n * @augments ArrayElementNode\n */\nclass UniformArrayElementNode extends ArrayElementNode {\n  static get type() {\n    return 'UniformArrayElementNode';\n  }\n\n  /**\n   * Constructs a new buffer node.\n   *\n   * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.\n   * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.\n   */\n  constructor(uniformArrayNode, indexNode) {\n    super(uniformArrayNode, indexNode);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isArrayBufferElementNode = true;\n  }\n  generate(builder) {\n    const snippet = super.generate(builder);\n    const type = this.getNodeType();\n    const paddedType = this.node.getPaddedType();\n    return builder.format(snippet, paddedType, type);\n  }\n}\n\n/**\n * Similar to {@link module:BufferNode~BufferNode} this module represents array-like data as\n * uniform buffers. Unlike {@link module:BufferNode~BufferNode}, it can handle more common\n * data types in the array (e.g `three.js` primitives) and automatically\n * manage buffer padding. It should be the first choice when working with\n * uniforms buffers.\n * ```js\n * const tintColors = uniformArray( [\n * \tnew Color( 1, 0, 0 ),\n * \tnew Color( 0, 1, 0 ),\n * \tnew Color( 0, 0, 1 )\n * ], 'color' );\n *\n * const redColor = tintColors.element( 0 );\n *\n * @augments module:BufferNode~BufferNode\n */\nclass UniformArrayNode extends BufferNode {\n  static get type() {\n    return 'UniformArrayNode';\n  }\n\n  /**\n   * Constructs a new uniform array node.\n   *\n   * @param {Array<Any>} value - Array holding the buffer data.\n   * @param {String?} [elementType=null] - The data type of a buffer element.\n   */\n  constructor(value, elementType = null) {\n    super(null);\n\n    /**\n     * Array holding the buffer data. Unlike {@link module:BufferNode~BufferNode}, the array can\n     * hold number primitives as well as three.js objects like vectors, matrices\n     * or colors.\n     *\n     * @type {Array<Any>}\n     */\n    this.array = value;\n\n    /**\n     * The data type of an array element.\n     *\n     * @type {String}\n     */\n    this.elementType = elementType === null ? getValueType(value[0]) : elementType;\n\n    /**\n     * The padded type. Uniform buffers must conform to a certain buffer layout\n     * so a separate type is computed to ensure correct buffer size.\n     *\n     * @type {String}\n     */\n    this.paddedType = this.getPaddedType();\n\n    /**\n     * Overwritten since uniform array nodes are updated per render.\n     *\n     * @type {String}\n     * @default 'render'\n     */\n    this.updateType = NodeUpdateType.RENDER;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isArrayBufferNode = true;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from the\n   * {@link module:UniformArrayNode~UniformArrayNode#paddedType}.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(/*builder*/\n  ) {\n    return this.paddedType;\n  }\n\n  /**\n   * The data type of the array elements.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The element type.\n   */\n  getElementType() {\n    return this.elementType;\n  }\n\n  /**\n   * Returns the padded type based on the element type.\n   *\n   * @return {String} The padded type.\n   */\n  getPaddedType() {\n    const elementType = this.elementType;\n    let paddedType = 'vec4';\n    if (elementType === 'mat2') {\n      paddedType = 'mat2';\n    } else if (/mat/.test(elementType) === true) {\n      paddedType = 'mat4';\n    } else if (elementType.charAt(0) === 'i') {\n      paddedType = 'ivec4';\n    } else if (elementType.charAt(0) === 'u') {\n      paddedType = 'uvec4';\n    }\n    return paddedType;\n  }\n\n  /**\n   * The update makes sure to correctly transfer the data from the (complex) objects\n   * in the array to the internal, correctly padded value buffer.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update(/*frame*/\n  ) {\n    const {\n      array,\n      value\n    } = this;\n    const elementType = this.elementType;\n    if (elementType === 'float' || elementType === 'int' || elementType === 'uint') {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        value[index] = array[i];\n      }\n    } else if (elementType === 'color') {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        const vector = array[i];\n        value[index] = vector.r;\n        value[index + 1] = vector.g;\n        value[index + 2] = vector.b || 0;\n        //value[ index + 3 ] = vector.a || 0;\n      }\n    } else if (elementType === 'mat2') {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        const matrix = array[i];\n        value[index] = matrix.elements[0];\n        value[index + 1] = matrix.elements[1];\n        value[index + 2] = matrix.elements[2];\n        value[index + 3] = matrix.elements[3];\n      }\n    } else if (elementType === 'mat3') {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 16;\n        const matrix = array[i];\n        value[index] = matrix.elements[0];\n        value[index + 1] = matrix.elements[1];\n        value[index + 2] = matrix.elements[2];\n        value[index + 4] = matrix.elements[3];\n        value[index + 5] = matrix.elements[4];\n        value[index + 6] = matrix.elements[5];\n        value[index + 8] = matrix.elements[6];\n        value[index + 9] = matrix.elements[7];\n        value[index + 10] = matrix.elements[8];\n        value[index + 15] = 1;\n      }\n    } else if (elementType === 'mat4') {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 16;\n        const matrix = array[i];\n        for (let i = 0; i < matrix.elements.length; i++) {\n          value[index + i] = matrix.elements[i];\n        }\n      }\n    } else {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        const vector = array[i];\n        value[index] = vector.x;\n        value[index + 1] = vector.y;\n        value[index + 2] = vector.z || 0;\n        value[index + 3] = vector.w || 0;\n      }\n    }\n  }\n\n  /**\n   * Implement the value buffer creation based on the array data.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @return {null}\n   */\n  setup(builder) {\n    const length = this.array.length;\n    const elementType = this.elementType;\n    let arrayType = Float32Array;\n    const paddedType = this.paddedType;\n    const paddedElementLength = builder.getTypeLength(paddedType);\n    if (elementType.charAt(0) === 'i') arrayType = Int32Array;\n    if (elementType.charAt(0) === 'u') arrayType = Uint32Array;\n    this.value = new arrayType(length * paddedElementLength);\n    this.bufferCount = length;\n    this.bufferType = paddedType;\n    return super.setup(builder);\n  }\n\n  /**\n   * Overwrites the default `element()` method to provide element access\n   * based on {@link module:UniformArrayNode~UniformArrayNode}.\n   *\n   * @param {IndexNode} indexNode - The index node.\n   * @return {UniformArrayElementNode}\n   */\n  element(indexNode) {\n    return nodeObject(new UniformArrayElementNode(this, nodeObject(indexNode)));\n  }\n}\n\n/**\n * TSL function for creating an uniform array node.\n *\n * @function\n * @param {Array<Any>} values - Array-like data.\n * @param {String} nodeType - The data type of the array elements.\n * @returns {UniformArrayNode}\n */\nconst uniformArray = (values, nodeType) => nodeObject(new UniformArrayNode(values, nodeType));\n\n//\n\nconst uniforms = (values, nodeType) => {\n  // @deprecated, r168\n\n  console.warn('TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().');\n  return nodeObject(new UniformArrayNode(values, nodeType));\n};\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/** @module ReferenceNode **/\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nclass ReferenceElementNode extends ArrayElementNode {\n  static get type() {\n    return 'ReferenceElementNode';\n  }\n\n  /**\n   * Constructs a new reference element node.\n   *\n   * @param {Node?} referenceNode - The reference node.\n   * @param {Node} indexNode - The index node that defines the element access.\n   */\n  constructor(referenceNode, indexNode) {\n    super(referenceNode, indexNode);\n\n    /**\n     * Similar to {@link module:ReferenceNode~ReferenceNode#reference}, an additional\n     * property references to the current node.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.referenceNode = referenceNode;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isReferenceElementNode = true;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from\n   * the uniform type of the reference node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType() {\n    return this.referenceNode.uniformType;\n  }\n  generate(builder) {\n    const snippet = super.generate(builder);\n    const arrayType = this.referenceNode.getNodeType();\n    const elementType = this.getNodeType();\n    return builder.format(snippet, arrayType, elementType);\n  }\n}\n\n/**\n * This type of node establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceNode extends Node {\n  static get type() {\n    return 'ReferenceNode';\n  }\n\n  /**\n   * Constructs a new reference node.\n   *\n   * @param {String} property - The name of the property the node refers to.\n   * @param {String} uniformType - The uniform type that should be used to represent the property value.\n   * @param {Object?} [object=null] - The object the property belongs to.\n   * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.\n   */\n  constructor(property, uniformType, object = null, count = null) {\n    super();\n\n    /**\n     * The name of the property the node refers to.\n     *\n     * @type {String}\n     */\n    this.property = property;\n\n    /**\n     * The uniform type that should be used to represent the property value.\n     *\n     * @type {String}\n     */\n    this.uniformType = uniformType;\n\n    /**\n     * The object the property belongs to.\n     *\n     * @type {Object?}\n     * @default null\n     */\n    this.object = object;\n\n    /**\n     * When the linked property is an array, this parameter defines its length.\n     *\n     * @type {Number?}\n     * @default null\n     */\n    this.count = count;\n\n    /**\n     * The property name might have dots so nested properties can be referred.\n     * The hierarchy of the names is stored inside this array.\n     *\n     * @type {Array<String>}\n     */\n    this.properties = property.split('.');\n\n    /**\n     * Points to the current referred object. This property exists next to {@link module:ReferenceNode~ReferenceNode#object}\n     * since the final reference might be updated from calling code.\n     *\n     * @type {Object?}\n     * @default null\n     */\n    this.reference = object;\n\n    /**\n     * The uniform node that holds the value of the reference node.\n     *\n     * @type {UniformNode}\n     * @default null\n     */\n    this.node = null;\n\n    /**\n     * The uniform group of the internal uniform.\n     *\n     * @type {UniformGroupNode}\n     * @default null\n     */\n    this.group = null;\n\n    /**\n     * An optional label of the internal uniform node.\n     *\n     * @type {String?}\n     * @default null\n     */\n    this.name = null;\n\n    /**\n     * Overwritten since reference nodes are updated per object.\n     *\n     * @type {String}\n     * @default 'object'\n     */\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n\n  /**\n   * When the referred property is array-like, this method can be used\n   * to access elements via an index node.\n   *\n   * @param {IndexNode} indexNode - indexNode.\n   * @return {ReferenceElementNode} A reference to an element.\n   */\n  element(indexNode) {\n    return nodeObject(new ReferenceElementNode(this, nodeObject(indexNode)));\n  }\n\n  /**\n   * Sets the uniform group for this reference node.\n   *\n   * @param {UniformGroupNode} group - The uniform group to set.\n   * @return {ReferenceNode} A reference to this node.\n   */\n  setGroup(group) {\n    this.group = group;\n    return this;\n  }\n\n  /**\n   * Sets the label for the internal uniform.\n   *\n   * @param {String} name - The label to set.\n   * @return {ReferenceNode} A reference to this node.\n   */\n  label(name) {\n    this.name = name;\n    return this;\n  }\n\n  /**\n   * Sets the node type which automatically defines the internal\n   * uniform type.\n   *\n   * @param {String} uniformType - The type to set.\n   */\n  setNodeType(uniformType) {\n    let node = null;\n    if (this.count !== null) {\n      node = buffer(null, uniformType, this.count);\n    } else if (Array.isArray(this.getValueFromReference())) {\n      node = uniformArray(null, uniformType);\n    } else if (uniformType === 'texture') {\n      node = texture(null);\n    } else if (uniformType === 'cubeTexture') {\n      node = cubeTexture(null);\n    } else {\n      node = uniform(null, uniformType);\n    }\n    if (this.group !== null) {\n      node.setGroup(this.group);\n    }\n    if (this.name !== null) node.label(this.name);\n    this.node = node.getSelf();\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from\n   * the type of the reference node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    if (this.node === null) {\n      this.updateReference(builder);\n      this.updateValue();\n    }\n    return this.node.getNodeType(builder);\n  }\n\n  /**\n   * Returns the property value from the given referred object.\n   *\n   * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n   * @return {Any} The value.\n   */\n  getValueFromReference(object = this.reference) {\n    const {\n      properties\n    } = this;\n    let value = object[properties[0]];\n    for (let i = 1; i < properties.length; i++) {\n      value = value[properties[i]];\n    }\n    return value;\n  }\n\n  /**\n   * Allows to update the reference based on the given state. The state is only\n   * evaluated {@link module:ReferenceNode~ReferenceNode#object} is not set.\n   *\n   * @param {(NodeFrame|NodeBuilder)} state - The current state.\n   * @return {Object} The updated reference.\n   */\n  updateReference(state) {\n    this.reference = this.object !== null ? this.object : state.object;\n    return this.reference;\n  }\n\n  /**\n   * The output of the reference node is the internal uniform node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {UniformNode} The output node.\n   */\n  setup(/* builder */\n  ) {\n    this.updateValue();\n    return this.node;\n  }\n\n  /**\n   * Overwritten to to update the internal uniform value.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update(/*frame*/\n  ) {\n    this.updateValue();\n  }\n\n  /**\n   * Retrieves the value from the referred object property and uses it\n   * to updated the internal uniform.\n   */\n  updateValue() {\n    if (this.node === null) this.setNodeType(this.uniformType);\n    const value = this.getValueFromReference();\n    if (Array.isArray(value)) {\n      this.node.array = value;\n    } else {\n      this.node.value = value;\n    }\n  }\n}\n\n/**\n * TSL function for creating a reference node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Object} object - The object the property belongs to.\n * @returns {ReferenceNode}\n */\nconst reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));\n\n/**\n * TSL function for creating a reference node. Use this function if you want need a reference\n * to an array-like property that should be represented as a uniform buffer.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Number} count - The number of value inside the array-like object.\n * @param {Object} object - An array-like object the property belongs to.\n * @returns {ReferenceNode}\n */\nconst referenceBuffer = (name, type, count, object) => nodeObject(new ReferenceNode(name, type, object, count));\n\n/** @module MaterialReferenceNode **/\n\n/**\n * This node is a special type of reference node which is intended\n * for linking material properties with node values.\n * ```js\n * const opacityNode = materialReference( 'opacity', 'float', material );\n * ```\n * When changing `material.opacity`, the node value of `opacityNode` will\n * automatically be updated.\n *\n * @augments module:ReferenceNode~ReferenceNode\n */\nclass MaterialReferenceNode extends ReferenceNode {\n  static get type() {\n    return 'MaterialReferenceNode';\n  }\n\n  /**\n   * Constructs a new material reference node.\n   *\n   * @param {String} property - The name of the property the node refers to.\n   * @param {String} inputType - The uniform type that should be used to represent the property value.\n   * @param {Material?} [material=null] - The material the property belongs to. When no material is set,\n   * the node refers to the material of the current rendered object.\n   */\n  constructor(property, inputType, material = null) {\n    super(property, inputType, material);\n\n    /**\n     * The material the property belongs to. When no material is set,\n     * the node refers to the material of the current rendered object.\n     *\n     * @type {Material?}\n     * @default null\n     */\n    this.material = material;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMaterialReferenceNode = true;\n  }\n\n  /**\n   * Updates the reference based on the given state. The state is only evaluated\n   * {@link module:MaterialReferenceNode~MaterialReferenceNode#material} is not set.\n   *\n   * @param {(NodeFrame|NodeBuilder)} state - The current state.\n   * @return {Object} The updated reference.\n   */\n  updateReference(state) {\n    this.reference = this.material !== null ? this.material : state.material;\n    return this.reference;\n  }\n}\n\n/**\n * TSL function for creating a material reference node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Material?} [material=null] - The material the property belongs to.\n * When no material is set, the node refers to the material of the current rendered object.\n * @returns {MaterialReferenceNode}\n */\nconst materialReference = (name, type, material = null) => nodeObject(new MaterialReferenceNode(name, type, material));\n\n/** @module Tangent **/\n\n/**\n * TSL object that represents the tangent attribute of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst tangentGeometry = /*@__PURE__*/Fn(builder => {\n  if (builder.geometry.hasAttribute('tangent') === false) {\n    builder.geometry.computeTangents();\n  }\n  return attribute('tangent', 'vec4');\n})();\n\n/**\n * TSL object that represents the vertex tangent in local space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst tangentLocal = /*@__PURE__*/tangentGeometry.xyz.toVar('tangentLocal');\n\n/**\n * TSL object that represents the vertex tangent in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst tangentView = /*@__PURE__*/modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz.varying('v_tangentView').normalize().toVar('tangentView');\n\n/**\n * TSL object that represents the vertex tangent in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst tangentWorld = /*@__PURE__*/tangentView.transformDirection(cameraViewMatrix).varying('v_tangentWorld').normalize().toVar('tangentWorld');\n\n/**\n * TSL object that represents the transformed vertex tangent in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedTangentView = /*@__PURE__*/tangentView.toVar('transformedTangentView');\n\n/**\n * TSL object that represents the transformed vertex tangent in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedTangentWorld = /*@__PURE__*/transformedTangentView.transformDirection(cameraViewMatrix).normalize().toVar('transformedTangentWorld');\n\n/** @module Bitangent **/\n\nconst getBitangent = crossNormalTangent => crossNormalTangent.mul(tangentGeometry.w).xyz;\n\n/**\n * TSL object that represents the bitangent attribute of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst bitangentGeometry = /*@__PURE__*/varying(getBitangent(normalGeometry.cross(tangentGeometry)), 'v_bitangentGeometry').normalize().toVar('bitangentGeometry');\n\n/**\n * TSL object that represents the vertex bitangent in local space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst bitangentLocal = /*@__PURE__*/varying(getBitangent(normalLocal.cross(tangentLocal)), 'v_bitangentLocal').normalize().toVar('bitangentLocal');\n\n/**\n * TSL object that represents the vertex bitangent in view space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst bitangentView = /*@__PURE__*/varying(getBitangent(normalView.cross(tangentView)), 'v_bitangentView').normalize().toVar('bitangentView');\n\n/**\n * TSL object that represents the vertex bitangent in world space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst bitangentWorld = /*@__PURE__*/varying(getBitangent(normalWorld.cross(tangentWorld)), 'v_bitangentWorld').normalize().toVar('bitangentWorld');\n\n/**\n * TSL object that represents the transformed vertex bitangent in view space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst transformedBitangentView = /*@__PURE__*/getBitangent(transformedNormalView.cross(transformedTangentView)).normalize().toVar('transformedBitangentView');\n\n/**\n * TSL object that represents the transformed vertex bitangent in world space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst transformedBitangentWorld = /*@__PURE__*/transformedBitangentView.transformDirection(cameraViewMatrix).normalize().toVar('transformedBitangentWorld');\n\n/** @module AccessorsUtils **/\n\n/**\n * TSL object that represents the TBN matrix in view space.\n *\n * @type {Node<mat3>}\n */\nconst TBNViewMatrix = /*@__PURE__*/mat3(tangentView, bitangentView, normalView);\n\n/**\n * TSL object that represents the parallax direction.\n *\n * @type {Node<mat3>}\n */\nconst parallaxDirection = /*@__PURE__*/positionViewDirection.mul(TBNViewMatrix) /*.normalize()*/;\n\n/**\n * TSL function for computing parallax uv coordinates.\n *\n * @function\n * @param {Node<vec2>} uv - A uv node.\n * @param {Node<vec2>} scale - A scale node.\n * @returns {Node<vec2>} Parallax uv coordinates.\n */\nconst parallaxUV = (uv, scale) => uv.sub(parallaxDirection.mul(scale));\n\n/**\n * TSL function for computing bent normals.\n *\n * @function\n * @returns {Node<vec3>} Bent normals.\n */\nconst transformedBentNormalView = /*@__PURE__*/(() => {\n  // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\n\n  let bentNormal = anisotropyB.cross(positionViewDirection);\n  bentNormal = bentNormal.cross(anisotropyB).normalize();\n  bentNormal = mix(bentNormal, transformedNormalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();\n  return bentNormal;\n})();\n\n/** @module NormalMapNode **/\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2Arb = /*@__PURE__*/Fn(inputs => {\n  const {\n    eye_pos,\n    surf_norm,\n    mapN,\n    uv\n  } = inputs;\n  const q0 = eye_pos.dFdx();\n  const q1 = eye_pos.dFdy();\n  const st0 = uv.dFdx();\n  const st1 = uv.dFdy();\n  const N = surf_norm; // normalized\n\n  const q1perp = q1.cross(N);\n  const q0perp = N.cross(q0);\n  const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));\n  const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));\n  const det = T.dot(T).max(B.dot(B));\n  const scale = faceDirection.mul(det.inverseSqrt());\n  return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();\n});\n\n/**\n * This class can be used for applying normals maps to materials.\n *\n * ```js\n * material.normalNode = normalMap( texture( normalTex ) );\n * ```\n *\n * @augments TempNode\n */\nclass NormalMapNode extends TempNode {\n  static get type() {\n    return 'NormalMapNode';\n  }\n\n  /**\n   * Constructs a new normal map node.\n   *\n   * @param {Node} node - Represents the normal map data.\n   * @param {Node?} [scaleNode=null] - Controls the intensity of the effect.\n   */\n  constructor(node, scaleNode = null) {\n    super('vec3');\n\n    /**\n     * Represents the normal map data.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * Controls the intensity of the effect.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.scaleNode = scaleNode;\n\n    /**\n     * The normal map type.\n     *\n     * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}\n     * @default TangentSpaceNormalMap\n     */\n    this.normalMapType = TangentSpaceNormalMap;\n  }\n  setup(builder) {\n    const {\n      normalMapType,\n      scaleNode\n    } = this;\n    let normalMap = this.node.mul(2.0).sub(1.0);\n    if (scaleNode !== null) {\n      normalMap = vec3(normalMap.xy.mul(scaleNode), normalMap.z);\n    }\n    let outputNode = null;\n    if (normalMapType === ObjectSpaceNormalMap) {\n      outputNode = transformNormalToView(normalMap);\n    } else if (normalMapType === TangentSpaceNormalMap) {\n      const tangent = builder.hasGeometryAttribute('tangent');\n      if (tangent === true) {\n        outputNode = TBNViewMatrix.mul(normalMap).normalize();\n      } else {\n        outputNode = perturbNormal2Arb({\n          eye_pos: positionView,\n          surf_norm: normalView,\n          mapN: normalMap,\n          uv: uv()\n        });\n      }\n    }\n    return outputNode;\n  }\n}\n\n/**\n * TSL function for creating a normal map node.\n *\n * @function\n * @param {Node} node - Represents the normal map data.\n * @param {Node?} [scaleNode=null] - Controls the intensity of the effect.\n * @returns {NormalMapNode}\n */\nconst normalMap = /*@__PURE__*/nodeProxy(NormalMapNode);\n\n/** @module BumpMapNode **/\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = Fn(({\n  textureNode,\n  bumpScale\n}) => {\n  // It's used to preserve the same TextureNode instance\n  const sampleTexture = callback => textureNode.cache().context({\n    getUV: texNode => callback(texNode.uvNode || uv()),\n    forceUVContext: true\n  });\n  const Hll = float(sampleTexture(uvNode => uvNode));\n  return vec2(float(sampleTexture(uvNode => uvNode.add(uvNode.dFdx()))).sub(Hll), float(sampleTexture(uvNode => uvNode.add(uvNode.dFdy()))).sub(Hll)).mul(bumpScale);\n});\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = Fn(inputs => {\n  const {\n    surf_pos,\n    surf_norm,\n    dHdxy\n  } = inputs;\n\n  // normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n  const vSigmaX = surf_pos.dFdx().normalize();\n  const vSigmaY = surf_pos.dFdy().normalize();\n  const vN = surf_norm; // normalized\n\n  const R1 = vSigmaY.cross(vN);\n  const R2 = vN.cross(vSigmaX);\n  const fDet = vSigmaX.dot(R1).mul(faceDirection);\n  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));\n  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();\n});\n\n/**\n * This class can be used for applying bump maps to materials.\n *\n * ```js\n * material.normalNode = bumpMap( texture( bumpTex ) );\n * ```\n *\n * @augments TempNode\n */\nclass BumpMapNode extends TempNode {\n  static get type() {\n    return 'BumpMapNode';\n  }\n\n  /**\n   * Constructs a new bump map node.\n   *\n   * @param {Node} textureNode - Represents the bump map data.\n   * @param {Node?} [scaleNode=null] - Controls the intensity of the bump effect.\n   */\n  constructor(textureNode, scaleNode = null) {\n    super('vec3');\n\n    /**\n     * Represents the bump map data.\n     *\n     * @type {Node}\n     */\n    this.textureNode = textureNode;\n\n    /**\n     * Controls the intensity of the bump effect.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.scaleNode = scaleNode;\n  }\n  setup() {\n    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n    const dHdxy = dHdxy_fwd({\n      textureNode: this.textureNode,\n      bumpScale\n    });\n    return perturbNormalArb({\n      surf_pos: positionView,\n      surf_norm: normalView,\n      dHdxy\n    });\n  }\n}\n\n/**\n * TSL function for creating a bump map node.\n *\n * @function\n * @param {Node} textureNode - Represents the bump map data.\n * @param {Node?} [scaleNode=null] - Controls the intensity of the bump effect.\n * @returns {BumpMapNode}\n */\nconst bumpMap = /*@__PURE__*/nodeProxy(BumpMapNode);\n\n/** @module MaterialNode **/\n\nconst _propertyCache = new Map();\n\n/**\n * This class should simplify the node access to material properties.\n * It internal uses reference nodes to make sure  changes to material\n * properties are automatically reflected to predefined TSL objects\n * like e.g. `materialColor`.\n *\n * @augments Node\n */\nclass MaterialNode extends Node {\n  static get type() {\n    return 'MaterialNode';\n  }\n\n  /**\n   * Constructs a new material node.\n   *\n   * @param {String} scope - The scope defines what kind of material property is referred by the node.\n   */\n  constructor(scope) {\n    super();\n\n    /**\n     * The scope defines what material property is referred by the node.\n     *\n     * @type {String}\n     */\n    this.scope = scope;\n  }\n\n  /**\n   * Returns a cached reference node for the given property and type.\n   *\n   * @param {String} property - The name of the material property.\n   * @param {String} type - The uniform type of the property.\n   * @return {MaterialReferenceNode} A material reference node representing the property access.\n   */\n  getCache(property, type) {\n    let node = _propertyCache.get(property);\n    if (node === undefined) {\n      node = materialReference(property, type);\n      _propertyCache.set(property, node);\n    }\n    return node;\n  }\n\n  /**\n   * Returns a float-typed material reference node for the given property name.\n   *\n   * @param {String} property - The name of the material property.\n   * @return {MaterialReferenceNode<float>} A material reference node representing the property access.\n   */\n  getFloat(property) {\n    return this.getCache(property, 'float');\n  }\n\n  /**\n   * Returns a color-typed material reference node for the given property name.\n   *\n   * @param {String} property - The name of the material property.\n   * @return {MaterialReferenceNode<color>} A material reference node representing the property access.\n   */\n  getColor(property) {\n    return this.getCache(property, 'color');\n  }\n\n  /**\n   * Returns a texture-typed material reference node for the given property name.\n   *\n   * @param {String} property - The name of the material property.\n   * @return {MaterialReferenceNode} A material reference node representing the property access.\n   */\n  getTexture(property) {\n    return this.getCache(property === 'map' ? 'map' : property + 'Map', 'texture');\n  }\n\n  /**\n   * The node setup is done depending on the selected scope. Multiple material properties\n   * might be grouped into a single node composition if they logically belong together.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node} The node representing the selected scope.\n   */\n  setup(builder) {\n    const material = builder.context.material;\n    const scope = this.scope;\n    let node = null;\n    if (scope === MaterialNode.COLOR) {\n      const colorNode = material.color !== undefined ? this.getColor(scope) : vec3();\n      if (material.map && material.map.isTexture === true) {\n        node = colorNode.mul(this.getTexture('map'));\n      } else {\n        node = colorNode;\n      }\n    } else if (scope === MaterialNode.OPACITY) {\n      const opacityNode = this.getFloat(scope);\n      if (material.alphaMap && material.alphaMap.isTexture === true) {\n        node = opacityNode.mul(this.getTexture('alpha'));\n      } else {\n        node = opacityNode;\n      }\n    } else if (scope === MaterialNode.SPECULAR_STRENGTH) {\n      if (material.specularMap && material.specularMap.isTexture === true) {\n        node = this.getTexture('specular').r;\n      } else {\n        node = float(1);\n      }\n    } else if (scope === MaterialNode.SPECULAR_INTENSITY) {\n      const specularIntensityNode = this.getFloat(scope);\n      if (material.specularIntensityMap && material.specularIntensityMap.isTexture === true) {\n        node = specularIntensityNode.mul(this.getTexture(scope).a);\n      } else {\n        node = specularIntensityNode;\n      }\n    } else if (scope === MaterialNode.SPECULAR_COLOR) {\n      const specularColorNode = this.getColor(scope);\n      if (material.specularColorMap && material.specularColorMap.isTexture === true) {\n        node = specularColorNode.mul(this.getTexture(scope).rgb);\n      } else {\n        node = specularColorNode;\n      }\n    } else if (scope === MaterialNode.ROUGHNESS) {\n      // TODO: cleanup similar branches\n\n      const roughnessNode = this.getFloat(scope);\n      if (material.roughnessMap && material.roughnessMap.isTexture === true) {\n        node = roughnessNode.mul(this.getTexture(scope).g);\n      } else {\n        node = roughnessNode;\n      }\n    } else if (scope === MaterialNode.METALNESS) {\n      const metalnessNode = this.getFloat(scope);\n      if (material.metalnessMap && material.metalnessMap.isTexture === true) {\n        node = metalnessNode.mul(this.getTexture(scope).b);\n      } else {\n        node = metalnessNode;\n      }\n    } else if (scope === MaterialNode.EMISSIVE) {\n      const emissiveIntensityNode = this.getFloat('emissiveIntensity');\n      const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);\n      if (material.emissiveMap && material.emissiveMap.isTexture === true) {\n        node = emissiveNode.mul(this.getTexture(scope));\n      } else {\n        node = emissiveNode;\n      }\n    } else if (scope === MaterialNode.NORMAL) {\n      if (material.normalMap) {\n        node = normalMap(this.getTexture('normal'), this.getCache('normalScale', 'vec2'));\n        node.normalMapType = material.normalMapType;\n      } else if (material.bumpMap) {\n        node = bumpMap(this.getTexture('bump').r, this.getFloat('bumpScale'));\n      } else {\n        node = normalView;\n      }\n    } else if (scope === MaterialNode.CLEARCOAT) {\n      const clearcoatNode = this.getFloat(scope);\n      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {\n        node = clearcoatNode.mul(this.getTexture(scope).r);\n      } else {\n        node = clearcoatNode;\n      }\n    } else if (scope === MaterialNode.CLEARCOAT_ROUGHNESS) {\n      const clearcoatRoughnessNode = this.getFloat(scope);\n      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {\n        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);\n      } else {\n        node = clearcoatRoughnessNode;\n      }\n    } else if (scope === MaterialNode.CLEARCOAT_NORMAL) {\n      if (material.clearcoatNormalMap) {\n        node = normalMap(this.getTexture(scope), this.getCache(scope + 'Scale', 'vec2'));\n      } else {\n        node = normalView;\n      }\n    } else if (scope === MaterialNode.SHEEN) {\n      const sheenNode = this.getColor('sheenColor').mul(this.getFloat('sheen')); // Move this mul() to CPU\n\n      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {\n        node = sheenNode.mul(this.getTexture('sheenColor').rgb);\n      } else {\n        node = sheenNode;\n      }\n    } else if (scope === MaterialNode.SHEEN_ROUGHNESS) {\n      const sheenRoughnessNode = this.getFloat(scope);\n      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {\n        node = sheenRoughnessNode.mul(this.getTexture(scope).a);\n      } else {\n        node = sheenRoughnessNode;\n      }\n      node = node.clamp(0.07, 1.0);\n    } else if (scope === MaterialNode.ANISOTROPY) {\n      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {\n        const anisotropyPolar = this.getTexture(scope);\n        const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);\n        node = anisotropyMat.mul(anisotropyPolar.rg.mul(2.0).sub(vec2(1.0)).normalize().mul(anisotropyPolar.b));\n      } else {\n        node = materialAnisotropyVector;\n      }\n    } else if (scope === MaterialNode.IRIDESCENCE_THICKNESS) {\n      const iridescenceThicknessMaximum = reference('1', 'float', material.iridescenceThicknessRange);\n      if (material.iridescenceThicknessMap) {\n        const iridescenceThicknessMinimum = reference('0', 'float', material.iridescenceThicknessRange);\n        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);\n      } else {\n        node = iridescenceThicknessMaximum;\n      }\n    } else if (scope === MaterialNode.TRANSMISSION) {\n      const transmissionNode = this.getFloat(scope);\n      if (material.transmissionMap) {\n        node = transmissionNode.mul(this.getTexture(scope).r);\n      } else {\n        node = transmissionNode;\n      }\n    } else if (scope === MaterialNode.THICKNESS) {\n      const thicknessNode = this.getFloat(scope);\n      if (material.thicknessMap) {\n        node = thicknessNode.mul(this.getTexture(scope).g);\n      } else {\n        node = thicknessNode;\n      }\n    } else if (scope === MaterialNode.IOR) {\n      node = this.getFloat(scope);\n    } else if (scope === MaterialNode.LIGHT_MAP) {\n      node = this.getTexture(scope).rgb.mul(this.getFloat('lightMapIntensity'));\n    } else if (scope === MaterialNode.AO) {\n      node = this.getTexture(scope).r.sub(1.0).mul(this.getFloat('aoMapIntensity')).add(1.0);\n    } else {\n      const outputType = this.getNodeType(builder);\n      node = this.getCache(scope, outputType);\n    }\n    return node;\n  }\n}\nMaterialNode.ALPHA_TEST = 'alphaTest';\nMaterialNode.COLOR = 'color';\nMaterialNode.OPACITY = 'opacity';\nMaterialNode.SHININESS = 'shininess';\nMaterialNode.SPECULAR = 'specular';\nMaterialNode.SPECULAR_STRENGTH = 'specularStrength';\nMaterialNode.SPECULAR_INTENSITY = 'specularIntensity';\nMaterialNode.SPECULAR_COLOR = 'specularColor';\nMaterialNode.REFLECTIVITY = 'reflectivity';\nMaterialNode.ROUGHNESS = 'roughness';\nMaterialNode.METALNESS = 'metalness';\nMaterialNode.NORMAL = 'normal';\nMaterialNode.CLEARCOAT = 'clearcoat';\nMaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';\nMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';\nMaterialNode.EMISSIVE = 'emissive';\nMaterialNode.ROTATION = 'rotation';\nMaterialNode.SHEEN = 'sheen';\nMaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';\nMaterialNode.ANISOTROPY = 'anisotropy';\nMaterialNode.IRIDESCENCE = 'iridescence';\nMaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';\nMaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';\nMaterialNode.IOR = 'ior';\nMaterialNode.TRANSMISSION = 'transmission';\nMaterialNode.THICKNESS = 'thickness';\nMaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';\nMaterialNode.ATTENUATION_COLOR = 'attenuationColor';\nMaterialNode.LINE_SCALE = 'scale';\nMaterialNode.LINE_DASH_SIZE = 'dashSize';\nMaterialNode.LINE_GAP_SIZE = 'gapSize';\nMaterialNode.LINE_WIDTH = 'linewidth';\nMaterialNode.LINE_DASH_OFFSET = 'dashOffset';\nMaterialNode.POINT_WIDTH = 'pointWidth';\nMaterialNode.DISPERSION = 'dispersion';\nMaterialNode.LIGHT_MAP = 'light';\nMaterialNode.AO = 'ao';\n\n/**\n * TSL object that represents alpha test of the current material.\n *\n * @type {Node<float>}\n */\nconst materialAlphaTest = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);\n\n/**\n * TSL object that represents the diffuse color of the current material.\n * The value is composed via `color` * `map`.\n *\n * @type {Node<vec3>}\n */\nconst materialColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.COLOR);\n\n/**\n * TSL object that represents the shininess of the current material.\n *\n * @type {Node<float>}\n */\nconst materialShininess = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHININESS);\n\n/**\n * TSL object that represents the emissive color of the current material.\n * The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.\n *\n * @type {Node<vec3>}\n */\nconst materialEmissive = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);\n\n/**\n * TSL object that represents the opacity of the current material.\n * The value is composed via `opacity` * `alphaMap`.\n *\n * @type {Node<float>}\n */\nconst materialOpacity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.OPACITY);\n\n/**\n * TSL object that represents the specular of the current material.\n *\n * @type {Node<vec3>}\n */\nconst materialSpecular = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR);\n\n/**\n * TSL object that represents the specular intensity of the current material.\n * The value is composed via `specularIntensity` * `specularMap.a`.\n *\n * @type {Node<float>}\n */\nconst materialSpecularIntensity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);\n\n/**\n * TSL object that represents the specular color of the current material.\n * The value is composed via `specularColor` * `specularMap.rgb`.\n *\n * @type {Node<vec3>}\n */\nconst materialSpecularColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);\n\n/**\n * TSL object that represents the specular strength of the current material.\n * The value is composed via `specularMap.r`.\n *\n * @type {Node<float>}\n */\nconst materialSpecularStrength = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);\n\n/**\n * TSL object that represents the reflectivity of the current material.\n *\n * @type {Node<float>}\n */\nconst materialReflectivity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);\n\n/**\n * TSL object that represents the roughness of the current material.\n * The value is composed via `roughness` * `roughnessMap.g`\n *\n * @type {Node<float>}\n */\nconst materialRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);\n\n/**\n * TSL object that represents the metalness of the current material.\n * The value is composed via `metalness` * `metalnessMap.b`\n *\n * @type {Node<float>}\n */\nconst materialMetalness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.METALNESS);\n\n/**\n * TSL object that represents the normal of the current material.\n * The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.\n *\n * @type {Node<vec3>}\n */\nconst materialNormal = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.NORMAL).context({\n  getUV: null\n});\n\n/**\n * TSL object that represents the clearcoat of the current material.\n * The value is composed via `clearcoat` * `clearcoatMap.r`\n *\n * @type {Node<float>}\n */\nconst materialClearcoat = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);\n\n/**\n * TSL object that represents the clearcoat roughness of the current material.\n * The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`\n *\n * @type {Node<float>}\n */\nconst materialClearcoatRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);\n\n/**\n * TSL object that represents the clearcoat normal of the current material.\n * The value will be either `clearcoatNormalMap` or `normalView`.\n *\n * @type {Node<vec3>}\n */\nconst materialClearcoatNormal = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL).context({\n  getUV: null\n});\n\n/**\n * TSL object that represents the rotation of the current sprite material.\n *\n * @type {Node<float>}\n */\nconst materialRotation = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ROTATION);\n\n/**\n * TSL object that represents the sheen color of the current material.\n * The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.\n *\n * @type {Node<vec3>}\n */\nconst materialSheen = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHEEN);\n\n/**\n * TSL object that represents the sheen roughness of the current material.\n * The value is composed via `sheenRoughness` * `sheenRoughnessMap.a` .\n *\n * @type {Node<float>}\n */\nconst materialSheenRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);\n\n/**\n * TSL object that represents the anisotropy of the current material.\n *\n * @type {Node<vec2>}\n */\nconst materialAnisotropy = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);\n\n/**\n * TSL object that represents the iridescence of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIridescence = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);\n\n/**\n * TSL object that represents the iridescence IOR of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIridescenceIOR = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);\n\n/**\n * TSL object that represents the iridescence thickness of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIridescenceThickness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);\n\n/**\n * TSL object that represents the transmission of the current material.\n * The value is composed via `transmission` * `transmissionMap.r`.\n *\n * @type {Node<float>}\n */\nconst materialTransmission = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);\n\n/**\n * TSL object that represents the thickness of the current material.\n * The value is composed via `thickness` * `thicknessMap.g`.\n *\n * @type {Node<float>}\n */\nconst materialThickness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.THICKNESS);\n\n/**\n * TSL object that represents the IOR of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIOR = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IOR);\n\n/**\n * TSL object that represents the attenuation distance of the current material.\n *\n * @type {Node<float>}\n */\nconst materialAttenuationDistance = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);\n\n/**\n * TSL object that represents the attenuation color of the current material.\n *\n * @type {Node<vec3>}\n */\nconst materialAttenuationColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);\n\n/**\n * TSL object that represents the scale of the current dashed line material.\n *\n * @type {Node<float>}\n */\nconst materialLineScale = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);\n\n/**\n * TSL object that represents the dash size of the current dashed line material.\n *\n * @type {Node<float>}\n */\nconst materialLineDashSize = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);\n\n/**\n * TSL object that represents the gap size of the current dashed line material.\n *\n * @type {Node<float>}\n */\nconst materialLineGapSize = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);\n\n/**\n * TSL object that represents the line width of the current line material.\n *\n * @type {Node<float>}\n */\nconst materialLineWidth = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);\n\n/**\n * TSL object that represents the dash offset of the current line material.\n *\n * @type {Node<float>}\n */\nconst materialLineDashOffset = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);\n\n/**\n * TSL object that represents the point width of the current points material.\n *\n * @type {Node<float>}\n */\nconst materialPointWidth = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.POINT_WIDTH);\n\n/**\n * TSL object that represents the dispersion of the current material.\n *\n * @type {Node<float>}\n */\nconst materialDispersion = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.DISPERSION);\n\n/**\n * TSL object that represents the light map of the current material.\n * The value is composed via `lightMapIntensity` * `lightMap.rgb`.\n *\n * @type {Node<vec3>}\n */\nconst materialLightMap = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);\n\n/**\n * TSL object that represents the ambient occlusion map of the current material.\n * The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.\n *\n * @type {Node<float>}\n */\nconst materialAO = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.AO);\n\n/**\n * TSL object that represents the anisotropy vector of the current material.\n *\n * @type {Node<vec2>}\n */\nconst materialAnisotropyVector = /*@__PURE__*/uniform(new Vector2()).onReference(function (frame) {\n  return frame.material;\n}).onRenderUpdate(function ({\n  material\n}) {\n  this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));\n});\n\n/** @module ModelViewProjectionNode **/\n\n/**\n * TSL object that represents the position in clip space after the model-view-projection transform of the current rendered object.\n *\n * @type {VaryingNode<vec4>}\n */\nconst modelViewProjection = /*@__PURE__*/Fn(builder => {\n  return builder.context.setupModelViewProjection();\n}, 'vec4').once()().varying('v_modelViewProjection');\n\n/** @module IndexNode **/\n\n/**\n * This class represents shader indices of different types. The following predefined node\n * objects cover frequent use cases:\n *\n * - `vertexIndex`: The index of a vertex within a mesh.\n * - `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.\n * - `drawIndex`: The index of a draw call.\n * - `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.\n * - `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.\n * - `subgroupIndex`: The index of the subgroup the current compute invocation belongs to.\n *\n * @augments Node\n */\nclass IndexNode extends Node {\n  static get type() {\n    return 'IndexNode';\n  }\n\n  /**\n   * Constructs a new index node.\n   *\n   * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.\n   */\n  constructor(scope) {\n    super('uint');\n\n    /**\n     * The scope of the index node.\n     *\n     * @type {String}\n     */\n    this.scope = scope;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isIndexNode = true;\n  }\n  generate(builder) {\n    const nodeType = this.getNodeType(builder);\n    const scope = this.scope;\n    let propertyName;\n    if (scope === IndexNode.VERTEX) {\n      propertyName = builder.getVertexIndex();\n    } else if (scope === IndexNode.INSTANCE) {\n      propertyName = builder.getInstanceIndex();\n    } else if (scope === IndexNode.DRAW) {\n      propertyName = builder.getDrawIndex();\n    } else if (scope === IndexNode.INVOCATION_LOCAL) {\n      propertyName = builder.getInvocationLocalIndex();\n    } else if (scope === IndexNode.INVOCATION_SUBGROUP) {\n      propertyName = builder.getInvocationSubgroupIndex();\n    } else if (scope === IndexNode.SUBGROUP) {\n      propertyName = builder.getSubgroupIndex();\n    } else {\n      throw new Error('THREE.IndexNode: Unknown scope: ' + scope);\n    }\n    let output;\n    if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {\n      output = propertyName;\n    } else {\n      const nodeVarying = varying(this);\n      output = nodeVarying.build(builder, nodeType);\n    }\n    return output;\n  }\n}\nIndexNode.VERTEX = 'vertex';\nIndexNode.INSTANCE = 'instance';\nIndexNode.SUBGROUP = 'subgroup';\nIndexNode.INVOCATION_LOCAL = 'invocationLocal';\nIndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';\nIndexNode.DRAW = 'draw';\n\n/**\n * TSL object that represents the index of a vertex within a mesh.\n *\n * @type {IndexNode}\n */\nconst vertexIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.VERTEX);\n\n/**\n * TSL object that represents the index of either a mesh instance or an invocation of a compute shader.\n *\n * @type {IndexNode}\n */\nconst instanceIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INSTANCE);\n\n/**\n * TSL object that represents the index of the subgroup the current compute invocation belongs to.\n *\n * @type {IndexNode}\n */\nconst subgroupIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.SUBGROUP);\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a subgroup.\n *\n * @type {IndexNode}\n */\nconst invocationSubgroupIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a workgroup load.\n *\n * @type {IndexNode}\n */\nconst invocationLocalIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INVOCATION_LOCAL);\n\n/**\n * TSL object that represents the index of a draw call.\n *\n * @type {IndexNode}\n */\nconst drawIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.DRAW);\n\n/** @module InstanceNode **/\n\n/**\n * This node implements the vertex shader logic which is required\n * when rendering 3D objects via instancing. The code makes sure\n * vertex positions, normals and colors can be modified via instanced\n * data.\n *\n * @augments Node\n */\nclass InstanceNode extends Node {\n  static get type() {\n    return 'InstanceNode';\n  }\n\n  /**\n   * Constructs a new instance node.\n   *\n   * @param {Number} count - The number of instances.\n   * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n   * @param {InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n   */\n  constructor(count, instanceMatrix, instanceColor) {\n    super('void');\n\n    /**\n     * The number of instances.\n     *\n     * @type {Number}\n     */\n    this.count = count;\n\n    /**\n     * Instanced buffer attribute representing the transformation of instances.\n     *\n     * @type {InstancedBufferAttribute}\n     */\n    this.instanceMatrix = instanceMatrix;\n\n    /**\n     * Instanced buffer attribute representing the color of instances.\n     *\n     * @type {InstancedBufferAttribute}\n     */\n    this.instanceColor = instanceColor;\n\n    /**\n     * The node that represents the instance matrix data.\n     *\n     * @type {Node}\n     */\n    this.instanceMatrixNode = null;\n\n    /**\n     * The node that represents the instance color data.\n     *\n     * @type {Node}\n     */\n    this.instanceColorNode = null;\n\n    /**\n     * The update type is set to `frame` since an update\n     * of instanced buffer data must be checked per frame.\n     *\n     * @type {String}\n     * @default 'frame'\n     */\n    this.updateType = NodeUpdateType.FRAME;\n\n    /**\n     * A reference to a buffer that is used by `instanceMatrixNode`.\n     *\n     * @type {InstancedInterleavedBuffer}\n     */\n    this.buffer = null;\n\n    /**\n     * A reference to a buffer that is used by `instanceColorNode`.\n     *\n     * @type {InstancedInterleavedBuffer}\n     */\n    this.bufferColor = null;\n  }\n\n  /**\n   * Setups the internal buffers and nodes and assigns the transformed vertex data\n   * to predefined node variables for accumulation. That follows the same patterns\n   * like with morph and skinning nodes.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    const {\n      count,\n      instanceMatrix,\n      instanceColor\n    } = this;\n    let {\n      instanceMatrixNode,\n      instanceColorNode\n    } = this;\n    if (instanceMatrixNode === null) {\n      // Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.\n\n      if (count <= 1000) {\n        instanceMatrixNode = buffer(instanceMatrix.array, 'mat4', Math.max(count, 1)).element(instanceIndex);\n      } else {\n        const buffer = new InstancedInterleavedBuffer(instanceMatrix.array, 16, 1);\n        this.buffer = buffer;\n        const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n        const instanceBuffers = [\n        // F.Signature -> bufferAttribute( array, type, stride, offset )\n        bufferFn(buffer, 'vec4', 16, 0), bufferFn(buffer, 'vec4', 16, 4), bufferFn(buffer, 'vec4', 16, 8), bufferFn(buffer, 'vec4', 16, 12)];\n        instanceMatrixNode = mat4(...instanceBuffers);\n      }\n      this.instanceMatrixNode = instanceMatrixNode;\n    }\n    if (instanceColor && instanceColorNode === null) {\n      const buffer = new InstancedBufferAttribute(instanceColor.array, 3);\n      const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n      this.bufferColor = buffer;\n      instanceColorNode = vec3(bufferFn(buffer, 'vec3', 3, 0));\n      this.instanceColorNode = instanceColorNode;\n    }\n\n    // POSITION\n\n    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;\n    positionLocal.assign(instancePosition);\n\n    // NORMAL\n\n    if (builder.hasGeometryAttribute('normal')) {\n      const instanceNormal = transformNormal(normalLocal, instanceMatrixNode);\n\n      // ASSIGNS\n\n      normalLocal.assign(instanceNormal);\n    }\n\n    // COLOR\n\n    if (this.instanceColorNode !== null) {\n      varyingProperty('vec3', 'vInstanceColor').assign(this.instanceColorNode);\n    }\n  }\n\n  /**\n   * Checks if the internal buffers required an update.\n   *\n   * @param {NodeFrame} frame - The current node frame.\n   */\n  update(/*frame*/\n  ) {\n    if (this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version) {\n      this.buffer.version = this.instanceMatrix.version;\n    }\n    if (this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version) {\n      this.bufferColor.version = this.instanceColor.version;\n    }\n  }\n}\n\n/**\n * TSL function for creating an instance node.\n *\n * @function\n * @param {Number} count - The number of instances.\n * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n * @param {InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n * @returns {InstanceNode}\n */\nconst instance = /*@__PURE__*/nodeProxy(InstanceNode);\n\n/** @module InstancedMeshNode **/\n\n/**\n * This is a special version of `InstanceNode` which requires the usage of {@link InstancedMesh}.\n * It allows an easier setup of the instance node.\n *\n * @augments module:InstanceNode~InstanceNode\n */\nclass InstancedMeshNode extends InstanceNode {\n  static get type() {\n    return 'InstancedMeshNode';\n  }\n\n  /**\n   * Constructs a new instanced mesh node.\n   *\n   * @param {InstancedMesh} instancedMesh - The instanced mesh.\n   */\n  constructor(instancedMesh) {\n    const {\n      count,\n      instanceMatrix,\n      instanceColor\n    } = instancedMesh;\n    super(count, instanceMatrix, instanceColor);\n\n    /**\n     * A reference to the instanced mesh.\n     *\n     * @type {InstancedMesh}\n     */\n    this.instancedMesh = instancedMesh;\n  }\n}\n\n/**\n * TSL function for creating an instanced mesh node.\n *\n * @function\n * @param {InstancedMesh} instancedMesh - The instancedMesh.\n * @returns {InstancedMeshNode}\n */\nconst instancedMesh = /*@__PURE__*/nodeProxy(InstancedMeshNode);\n\n/** @module BatchNode **/\n\n/**\n * This node implements the vertex shader logic which is required\n * when rendering 3D objects via batching. `BatchNode` must be used\n * with instances of {@link BatchedMesh}.\n *\n * @augments Node\n */\nclass BatchNode extends Node {\n  static get type() {\n    return 'BatchNode';\n  }\n\n  /**\n   * Constructs a new batch node.\n   *\n   * @param {BatchedMesh} batchMesh - A reference to batched mesh.\n   */\n  constructor(batchMesh) {\n    super('void');\n\n    /**\n     * A reference to batched mesh.\n     *\n     * @type {BatchedMesh}\n     */\n    this.batchMesh = batchMesh;\n\n    /**\n     * The batching index node.\n     *\n     * @type {IndexNode?}\n     * @default null\n     */\n    this.batchingIdNode = null;\n  }\n\n  /**\n   * Setups the internal buffers and nodes and assigns the transformed vertex data\n   * to predefined node variables for accumulation. That follows the same patterns\n   * like with morph and skinning nodes.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    if (this.batchingIdNode === null) {\n      if (builder.getDrawIndex() === null) {\n        this.batchingIdNode = instanceIndex;\n      } else {\n        this.batchingIdNode = drawIndex;\n      }\n    }\n    const getIndirectIndex = Fn(([id]) => {\n      const size = textureSize(textureLoad(this.batchMesh._indirectTexture), 0);\n      const x = int(id).modInt(int(size));\n      const y = int(id).div(int(size));\n      return textureLoad(this.batchMesh._indirectTexture, ivec2(x, y)).x;\n    }).setLayout({\n      name: 'getIndirectIndex',\n      type: 'uint',\n      inputs: [{\n        name: 'id',\n        type: 'int'\n      }]\n    });\n    const indirectId = getIndirectIndex(int(this.batchingIdNode));\n    const matricesTexture = this.batchMesh._matricesTexture;\n    const size = textureSize(textureLoad(matricesTexture), 0);\n    const j = float(indirectId).mul(4).toInt().toVar();\n    const x = j.modInt(size);\n    const y = j.div(int(size));\n    const batchingMatrix = mat4(textureLoad(matricesTexture, ivec2(x, y)), textureLoad(matricesTexture, ivec2(x.add(1), y)), textureLoad(matricesTexture, ivec2(x.add(2), y)), textureLoad(matricesTexture, ivec2(x.add(3), y)));\n    const colorsTexture = this.batchMesh._colorsTexture;\n    if (colorsTexture !== null) {\n      const getBatchingColor = Fn(([id]) => {\n        const size = textureSize(textureLoad(colorsTexture), 0).x;\n        const j = id;\n        const x = j.modInt(size);\n        const y = j.div(size);\n        return textureLoad(colorsTexture, ivec2(x, y)).rgb;\n      }).setLayout({\n        name: 'getBatchingColor',\n        type: 'vec3',\n        inputs: [{\n          name: 'id',\n          type: 'int'\n        }]\n      });\n      const color = getBatchingColor(indirectId);\n      varyingProperty('vec3', 'vBatchColor').assign(color);\n    }\n    const bm = mat3(batchingMatrix);\n    positionLocal.assign(batchingMatrix.mul(positionLocal));\n    const transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));\n    const batchingNormal = bm.mul(transformedNormal).xyz;\n    normalLocal.assign(batchingNormal);\n    if (builder.hasGeometryAttribute('tangent')) {\n      tangentLocal.mulAssign(bm);\n    }\n  }\n}\n\n/**\n * TSL function for creating a batch node.\n *\n * @function\n * @param {BatchedMesh} batchMesh - A reference to batched mesh.\n * @returns {BatchNode}\n */\nconst batch = /*@__PURE__*/nodeProxy(BatchNode);\n\n/** @module SkinningNode **/\n\nconst _frameId = new WeakMap();\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for skinning/skeletal animation.\n *\n * @augments Node\n */\nclass SkinningNode extends Node {\n  static get type() {\n    return 'SkinningNode';\n  }\n\n  /**\n   * Constructs a new skinning node.\n   *\n   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n   * @param {Boolean} [useReference=false] - Whether to use reference nodes for internal skinned mesh related data or not.\n   */\n  constructor(skinnedMesh, useReference = false) {\n    super('void');\n\n    /**\n     * The skinned mesh.\n     *\n     * @type {SkinnedMesh}\n     */\n    this.skinnedMesh = skinnedMesh;\n\n    /**\n     * Whether to use reference nodes for internal skinned mesh related data or not.\n     * TODO: Explain the purpose of the property.\n     *\n     * @type {Boolean}\n     */\n    this.useReference = useReference;\n\n    /**\n     * The update type overwritten since skinning nodes are updated per object.\n     *\n     * @type {String}\n     */\n    this.updateType = NodeUpdateType.OBJECT;\n\n    //\n\n    /**\n     * The skin index attribute.\n     *\n     * @type {AttributeNode}\n     */\n    this.skinIndexNode = attribute('skinIndex', 'uvec4');\n\n    /**\n     * The skin weight attribute.\n     *\n     * @type {AttributeNode}\n     */\n    this.skinWeightNode = attribute('skinWeight', 'vec4');\n    let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;\n    if (useReference) {\n      bindMatrixNode = reference('bindMatrix', 'mat4');\n      bindMatrixInverseNode = reference('bindMatrixInverse', 'mat4');\n      boneMatricesNode = referenceBuffer('skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);\n    } else {\n      bindMatrixNode = uniform(skinnedMesh.bindMatrix, 'mat4');\n      bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, 'mat4');\n      boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length);\n    }\n\n    /**\n     * The bind matrix node.\n     *\n     * @type {Node<mat4>}\n     */\n    this.bindMatrixNode = bindMatrixNode;\n\n    /**\n     * The bind matrix inverse node.\n     *\n     * @type {Node<mat4>}\n     */\n    this.bindMatrixInverseNode = bindMatrixInverseNode;\n\n    /**\n     * The bind matrices as a uniform buffer node.\n     *\n     * @type {Node}\n     */\n    this.boneMatricesNode = boneMatricesNode;\n\n    /**\n     * The previous bind matrices as a uniform buffer node.\n     * Required for computing motion vectors.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.previousBoneMatricesNode = null;\n  }\n\n  /**\n   * Transforms the given vertex position via skinning.\n   *\n   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n   * @param {Node<vec3>} [position=positionLocal] - The vertex position in local space.\n   * @return {Node<vec3>} The transformed vertex position.\n   */\n  getSkinnedPosition(boneMatrices = this.boneMatricesNode, position = positionLocal) {\n    const {\n      skinIndexNode,\n      skinWeightNode,\n      bindMatrixNode,\n      bindMatrixInverseNode\n    } = this;\n    const boneMatX = boneMatrices.element(skinIndexNode.x);\n    const boneMatY = boneMatrices.element(skinIndexNode.y);\n    const boneMatZ = boneMatrices.element(skinIndexNode.z);\n    const boneMatW = boneMatrices.element(skinIndexNode.w);\n\n    // POSITION\n\n    const skinVertex = bindMatrixNode.mul(position);\n    const skinned = add(boneMatX.mul(skinWeightNode.x).mul(skinVertex), boneMatY.mul(skinWeightNode.y).mul(skinVertex), boneMatZ.mul(skinWeightNode.z).mul(skinVertex), boneMatW.mul(skinWeightNode.w).mul(skinVertex));\n    return bindMatrixInverseNode.mul(skinned).xyz;\n  }\n\n  /**\n   * Transforms the given vertex normal via skinning.\n   *\n   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n   * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.\n   * @return {Node<vec3>} The transformed vertex normal.\n   */\n  getSkinnedNormal(boneMatrices = this.boneMatricesNode, normal = normalLocal) {\n    const {\n      skinIndexNode,\n      skinWeightNode,\n      bindMatrixNode,\n      bindMatrixInverseNode\n    } = this;\n    const boneMatX = boneMatrices.element(skinIndexNode.x);\n    const boneMatY = boneMatrices.element(skinIndexNode.y);\n    const boneMatZ = boneMatrices.element(skinIndexNode.z);\n    const boneMatW = boneMatrices.element(skinIndexNode.w);\n\n    // NORMAL\n\n    let skinMatrix = add(skinWeightNode.x.mul(boneMatX), skinWeightNode.y.mul(boneMatY), skinWeightNode.z.mul(boneMatZ), skinWeightNode.w.mul(boneMatW));\n    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);\n    return skinMatrix.transformDirection(normal).xyz;\n  }\n\n  /**\n   * Transforms the given vertex normal via skinning.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node<vec3>} The skinned position from the previous frame.\n   */\n  getPreviousSkinnedPosition(builder) {\n    const skinnedMesh = builder.object;\n    if (this.previousBoneMatricesNode === null) {\n      skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);\n      this.previousBoneMatricesNode = referenceBuffer('skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);\n    }\n    return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);\n  }\n\n  /**\n   * Returns `true` if bone matrices from the previous frame are required.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Boolean} Whether bone matrices from the previous frame are required or not.\n   */\n  needsPreviousBoneMatrices(builder) {\n    const mrt = builder.renderer.getMRT();\n    return mrt && mrt.has('velocity') || getDataFromObject(builder.object).useVelocity === true;\n  }\n\n  /**\n   * Setups the skinning node by assigning the transformed vertex data to predefined node variables.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    if (this.needsPreviousBoneMatrices(builder)) {\n      positionPrevious.assign(this.getPreviousSkinnedPosition(builder));\n    }\n    const skinPosition = this.getSkinnedPosition();\n    positionLocal.assign(skinPosition);\n    if (builder.hasGeometryAttribute('normal')) {\n      const skinNormal = this.getSkinnedNormal();\n      normalLocal.assign(skinNormal);\n      if (builder.hasGeometryAttribute('tangent')) {\n        tangentLocal.assign(skinNormal);\n      }\n    }\n  }\n\n  /**\n   * Generates the code snippet of the skinning node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {String} output - The current output.\n   * @return {String} The generated code snippet.\n   */\n  generate(builder, output) {\n    if (output !== 'void') {\n      return positionLocal.build(builder, output);\n    }\n  }\n\n  /**\n   * Updates the state of the skinned mesh by updating the skeleton once per frame.\n   *\n   * @param {NodeFrame} frame - The current node frame.\n   */\n  update(frame) {\n    const object = this.useReference ? frame.object : this.skinnedMesh;\n    const skeleton = object.skeleton;\n    if (_frameId.get(skeleton) === frame.frameId) return;\n    _frameId.set(skeleton, frame.frameId);\n    if (this.previousBoneMatricesNode !== null) skeleton.previousBoneMatrices.set(skeleton.boneMatrices);\n    skeleton.update();\n  }\n}\n\n/**\n * TSL function for creating a skinning node.\n *\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @returns {SkinningNode}\n */\nconst skinning = skinnedMesh => nodeObject(new SkinningNode(skinnedMesh));\n\n/**\n * TSL function for creating a skinning node with reference usage.\n *\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @returns {SkinningNode}\n */\nconst skinningReference = skinnedMesh => nodeObject(new SkinningNode(skinnedMesh, true));\n\n/** @module LoopNode **/\n\n/**\n * This module offers a variety of ways to implement loops in TSL. In it's basic form it's:\n * ```js\n * Loop( count, ( { i } ) => {\n *\n * } );\n * ```\n * However, it is also possible to define a start and end ranges, data types and loop conditions:\n * ```js\n * Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {\n *\n * } );\n *```\n * Nested loops can be defined in a compacted form:\n * ```js\n * Loop( 10, 5, ( { i, j } ) => {\n *\n * } );\n * ```\n * Loops that should run backwards can be defined like so:\n * ```js\n * Loop( { start: 10 }, () => {} );\n * ```\n * The module also provides `Break()` and `Continue()` TSL expression for loop control.\n * @augments Node\n */\nclass LoopNode extends Node {\n  static get type() {\n    return 'LoopNode';\n  }\n\n  /**\n   * Constructs a new loop node.\n   *\n   * @param {Array<Any>} params - Depending on the loop type, array holds different parameterization values for the loop.\n   */\n  constructor(params = []) {\n    super();\n    this.params = params;\n  }\n\n  /**\n   * Returns a loop variable name based on an index. The pattern is\n   * `0` = `i`, `1`= `j`, `2`= `k` and so on.\n   *\n   * @param {Number} index - The index.\n   * @return {String} The loop variable name.\n   */\n  getVarName(index) {\n    return String.fromCharCode('i'.charCodeAt(0) + index);\n  }\n\n  /**\n   * Returns properties about this node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Object} The node properties.\n   */\n  getProperties(builder) {\n    const properties = builder.getNodeProperties(this);\n    if (properties.stackNode !== undefined) return properties;\n\n    //\n\n    const inputs = {};\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      const param = this.params[i];\n      const name = param.isNode !== true && param.name || this.getVarName(i);\n      const type = param.isNode !== true && param.type || 'int';\n      inputs[name] = expression(name, type);\n    }\n    const stack = builder.addStack(); // TODO: cache() it\n\n    properties.returnsNode = this.params[this.params.length - 1](inputs, stack, builder);\n    properties.stackNode = stack;\n    builder.removeStack();\n    return properties;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred based on the loop configuration.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    const {\n      returnsNode\n    } = this.getProperties(builder);\n    return returnsNode ? returnsNode.getNodeType(builder) : 'void';\n  }\n  setup(builder) {\n    // setup properties\n\n    this.getProperties(builder);\n  }\n  generate(builder) {\n    const properties = this.getProperties(builder);\n    const params = this.params;\n    const stackNode = properties.stackNode;\n    for (let i = 0, l = params.length - 1; i < l; i++) {\n      const param = params[i];\n      let start = null,\n        end = null,\n        name = null,\n        type = null,\n        condition = null,\n        update = null;\n      if (param.isNode) {\n        type = 'int';\n        name = this.getVarName(i);\n        start = '0';\n        end = param.build(builder, type);\n        condition = '<';\n      } else {\n        type = param.type || 'int';\n        name = param.name || this.getVarName(i);\n        start = param.start;\n        end = param.end;\n        condition = param.condition;\n        update = param.update;\n        if (typeof start === 'number') start = builder.generateConst(type, start);else if (start && start.isNode) start = start.build(builder, type);\n        if (typeof end === 'number') end = builder.generateConst(type, end);else if (end && end.isNode) end = end.build(builder, type);\n        if (start !== undefined && end === undefined) {\n          start = start + ' - 1';\n          end = '0';\n          condition = '>=';\n        } else if (end !== undefined && start === undefined) {\n          start = '0';\n          condition = '<';\n        }\n        if (condition === undefined) {\n          if (Number(start) > Number(end)) {\n            condition = '>=';\n          } else {\n            condition = '<';\n          }\n        }\n      }\n      const internalParam = {\n        start,\n        end,\n        condition\n      };\n\n      //\n\n      const startSnippet = internalParam.start;\n      const endSnippet = internalParam.end;\n      let declarationSnippet = '';\n      let conditionalSnippet = '';\n      let updateSnippet = '';\n      if (!update) {\n        if (type === 'int' || type === 'uint') {\n          if (condition.includes('<')) update = '++';else update = '--';\n        } else {\n          if (condition.includes('<')) update = '+= 1.';else update = '-= 1.';\n        }\n      }\n      declarationSnippet += builder.getVar(type, name) + ' = ' + startSnippet;\n      conditionalSnippet += name + ' ' + condition + ' ' + endSnippet;\n      updateSnippet += name + ' ' + update;\n      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;\n      builder.addFlowCode((i === 0 ? '\\n' : '') + builder.tab + forSnippet + ' {\\n\\n').addFlowTab();\n    }\n    const stackSnippet = stackNode.build(builder, 'void');\n    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : '';\n    builder.removeFlowTab().addFlowCode('\\n' + builder.tab + stackSnippet);\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      builder.addFlowCode((i === 0 ? '' : builder.tab) + '}\\n\\n').removeFlowTab();\n    }\n    builder.addFlowTab();\n    return returnsSnippet;\n  }\n}\n\n/**\n * TSL function for creating a loop node.\n *\n * @function\n * @param {...Any} params - A list of parameters.\n * @returns {LoopNode}\n */\nconst Loop = (...params) => nodeObject(new LoopNode(nodeArray(params, 'int'))).append();\n\n/**\n * TSL function for creating a `Continue()` expression.\n *\n * @function\n * @returns {ExpressionNode}\n */\nconst Continue = () => expression('continue').append();\n\n/**\n * TSL function for creating a `Break()` expression.\n *\n * @function\n * @returns {ExpressionNode}\n */\nconst Break = () => expression('break').append();\n\n//\n\nconst loop = (...params) => {\n  // @deprecated, r168\n\n  console.warn('TSL.LoopNode: loop() has been renamed to Loop().');\n  return Loop(...params);\n};\n\n/** @module MorphNode **/\n\nconst _morphTextures = /*@__PURE__*/new WeakMap();\nconst _morphVec4 = /*@__PURE__*/new Vector4();\nconst getMorph = /*@__PURE__*/Fn(({\n  bufferMap,\n  influence,\n  stride,\n  width,\n  depth,\n  offset\n}) => {\n  const texelIndex = int(vertexIndex).mul(stride).add(offset);\n  const y = texelIndex.div(width);\n  const x = texelIndex.sub(y.mul(width));\n  const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth);\n  return bufferAttrib.mul(influence);\n});\nfunction getEntry(geometry) {\n  const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n  const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n  const hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n  // instead of using attributes, the WebGL 2 code path encodes morph targets\n  // into an array of data textures. Each layer represents a single morph target.\n\n  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n  const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n  let entry = _morphTextures.get(geometry);\n  if (entry === undefined || entry.count !== morphTargetsCount) {\n    if (entry !== undefined) entry.texture.dispose();\n    const morphTargets = geometry.morphAttributes.position || [];\n    const morphNormals = geometry.morphAttributes.normal || [];\n    const morphColors = geometry.morphAttributes.color || [];\n    let vertexDataCount = 0;\n    if (hasMorphPosition === true) vertexDataCount = 1;\n    if (hasMorphNormals === true) vertexDataCount = 2;\n    if (hasMorphColors === true) vertexDataCount = 3;\n    let width = geometry.attributes.position.count * vertexDataCount;\n    let height = 1;\n    const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n    if (width > maxTextureSize) {\n      height = Math.ceil(width / maxTextureSize);\n      width = maxTextureSize;\n    }\n    const buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n    const bufferTexture = new DataArrayTexture(buffer, width, height, morphTargetsCount);\n    bufferTexture.type = FloatType;\n    bufferTexture.needsUpdate = true;\n\n    // fill buffer\n\n    const vertexDataStride = vertexDataCount * 4;\n    for (let i = 0; i < morphTargetsCount; i++) {\n      const morphTarget = morphTargets[i];\n      const morphNormal = morphNormals[i];\n      const morphColor = morphColors[i];\n      const offset = width * height * 4 * i;\n      for (let j = 0; j < morphTarget.count; j++) {\n        const stride = j * vertexDataStride;\n        if (hasMorphPosition === true) {\n          _morphVec4.fromBufferAttribute(morphTarget, j);\n          buffer[offset + stride + 0] = _morphVec4.x;\n          buffer[offset + stride + 1] = _morphVec4.y;\n          buffer[offset + stride + 2] = _morphVec4.z;\n          buffer[offset + stride + 3] = 0;\n        }\n        if (hasMorphNormals === true) {\n          _morphVec4.fromBufferAttribute(morphNormal, j);\n          buffer[offset + stride + 4] = _morphVec4.x;\n          buffer[offset + stride + 5] = _morphVec4.y;\n          buffer[offset + stride + 6] = _morphVec4.z;\n          buffer[offset + stride + 7] = 0;\n        }\n        if (hasMorphColors === true) {\n          _morphVec4.fromBufferAttribute(morphColor, j);\n          buffer[offset + stride + 8] = _morphVec4.x;\n          buffer[offset + stride + 9] = _morphVec4.y;\n          buffer[offset + stride + 10] = _morphVec4.z;\n          buffer[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w : 1;\n        }\n      }\n    }\n    entry = {\n      count: morphTargetsCount,\n      texture: bufferTexture,\n      stride: vertexDataCount,\n      size: new Vector2(width, height)\n    };\n    _morphTextures.set(geometry, entry);\n    function disposeTexture() {\n      bufferTexture.dispose();\n      _morphTextures.delete(geometry);\n      geometry.removeEventListener('dispose', disposeTexture);\n    }\n    geometry.addEventListener('dispose', disposeTexture);\n  }\n  return entry;\n}\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for morph target animation.\n *\n * @augments Node\n */\nclass MorphNode extends Node {\n  static get type() {\n    return 'MorphNode';\n  }\n\n  /**\n   * Constructs a new morph node.\n   *\n   * @param {Mesh} mesh - The mesh holding the morph targets.\n   */\n  constructor(mesh) {\n    super('void');\n\n    /**\n     * The mesh holding the morph targets.\n     *\n     * @type {Mesh}\n     */\n    this.mesh = mesh;\n\n    /**\n     * A uniform node which represents the morph base influence value.\n     *\n     * @type {UniformNode<float>}\n     */\n    this.morphBaseInfluence = uniform(1);\n\n    /**\n     * The update type overwritten since morph nodes are updated per object.\n     *\n     * @type {String}\n     */\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n\n  /**\n   * Setups the morph node by assigning the transformed vertex data to predefined node variables.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    const {\n      geometry\n    } = builder;\n    const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n    const hasMorphNormals = geometry.hasAttribute('normal') && geometry.morphAttributes.normal !== undefined;\n    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n\n    // nodes\n\n    const {\n      texture: bufferMap,\n      stride,\n      size\n    } = getEntry(geometry);\n    if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);\n    if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);\n    const width = int(size.width);\n    Loop(morphTargetsCount, ({\n      i\n    }) => {\n      const influence = float(0).toVar();\n      if (this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined) {\n        influence.assign(textureLoad(this.mesh.morphTexture, ivec2(int(i).add(1), int(instanceIndex))).r);\n      } else {\n        influence.assign(reference('morphTargetInfluences', 'float').element(i).toVar());\n      }\n      if (hasMorphPosition === true) {\n        positionLocal.addAssign(getMorph({\n          bufferMap,\n          influence,\n          stride,\n          width,\n          depth: i,\n          offset: int(0)\n        }));\n      }\n      if (hasMorphNormals === true) {\n        normalLocal.addAssign(getMorph({\n          bufferMap,\n          influence,\n          stride,\n          width,\n          depth: i,\n          offset: int(1)\n        }));\n      }\n    });\n  }\n\n  /**\n   * Updates the state of the morphed mesh by updating the base influence.\n   *\n   * @param {NodeFrame} frame - The current node frame.\n   */\n  update(/*frame*/\n  ) {\n    const morphBaseInfluence = this.morphBaseInfluence;\n    if (this.mesh.geometry.morphTargetsRelative) {\n      morphBaseInfluence.value = 1;\n    } else {\n      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);\n    }\n  }\n}\n\n/**\n * TSL function for creating a morph node.\n *\n * @function\n * @param {Mesh} mesh - The mesh holding the morph targets.\n * @returns {MorphNode}\n */\nconst morphReference = /*@__PURE__*/nodeProxy(MorphNode);\n\n/**\n * Base class for lighting nodes.\n *\n * @augments Node\n */\nclass LightingNode extends Node {\n  static get type() {\n    return 'LightingNode';\n  }\n\n  /**\n   * Constructs a new lighting node.\n   */\n  constructor() {\n    super('vec3');\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isLightingNode = true;\n  }\n}\n\n/**\n * A generic class that can be used by nodes which contribute\n * ambient occlusion to the scene. E.g. an ambient occlusion map\n * node can be used as input for this module. Used in {@link NodeMaterial}.\n *\n * @augments LightingNode\n */\nclass AONode extends LightingNode {\n  static get type() {\n    return 'AONode';\n  }\n\n  /**\n   * Constructs a new AO node.\n   *\n   * @param {Node<float>?} [aoNode=null] - The ambient occlusion node.\n   */\n  constructor(aoNode = null) {\n    super();\n\n    /**\n     * The ambient occlusion node.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.aoNode = aoNode;\n  }\n  setup(builder) {\n    builder.context.ambientOcclusion.mulAssign(this.aoNode);\n  }\n}\n\n/**\n * `LightingContextNode` represents an extension of the {@link module:ContextNode~ContextNode} module\n * by adding lighting specific context data. It represents the runtime context of\n * {@link LightsNode}.\n *\n * @augments ContextNode\n */\nclass LightingContextNode extends ContextNode {\n  static get type() {\n    return 'LightingContextNode';\n  }\n\n  /**\n   * Constructs a new lighting context node.\n   *\n   * @param {LightsNode} node - The lights node.\n   * @param {LightingModel?} [lightingModel=null] - The current lighting model.\n   * @param {Node<vec3>?} [backdropNode=null] - A backdrop node.\n   * @param {Node<float>?} [backdropAlphaNode=null] - A backdrop alpha node.\n   */\n  constructor(node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {\n    super(node);\n\n    /**\n     * The current lighting model.\n     *\n     * @type {LightingModel?}\n     * @default null\n     */\n    this.lightingModel = lightingModel;\n\n    /**\n     * A backdrop node.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.backdropNode = backdropNode;\n\n    /**\n     * A backdrop alpha node.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.backdropAlphaNode = backdropAlphaNode;\n    this._value = null;\n  }\n\n  /**\n   * Returns a lighting context object.\n   *\n   * @return {{\n   * radiance: Node<vec3>,\n   * irradiance: Node<vec3>,\n   * iblIrradiance: Node<vec3>,\n   * ambientOcclusion: Node<float>,\n   * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},\n   * backdrop: Node<vec3>,\n   * backdropAlpha: Node<float>\n   * }} The lighting context object.\n   */\n  getContext() {\n    const {\n      backdropNode,\n      backdropAlphaNode\n    } = this;\n    const directDiffuse = vec3().toVar('directDiffuse'),\n      directSpecular = vec3().toVar('directSpecular'),\n      indirectDiffuse = vec3().toVar('indirectDiffuse'),\n      indirectSpecular = vec3().toVar('indirectSpecular');\n    const reflectedLight = {\n      directDiffuse,\n      directSpecular,\n      indirectDiffuse,\n      indirectSpecular\n    };\n    const context = {\n      radiance: vec3().toVar('radiance'),\n      irradiance: vec3().toVar('irradiance'),\n      iblIrradiance: vec3().toVar('iblIrradiance'),\n      ambientOcclusion: float(1).toVar('ambientOcclusion'),\n      reflectedLight,\n      backdrop: backdropNode,\n      backdropAlpha: backdropAlphaNode\n    };\n    return context;\n  }\n  setup(builder) {\n    this.value = this._value || (this._value = this.getContext());\n    this.value.lightingModel = this.lightingModel || builder.context.lightingModel;\n    return super.setup(builder);\n  }\n}\nconst lightingContext = /*@__PURE__*/nodeProxy(LightingContextNode);\n\n/**\n * A generic class that can be used by nodes which contribute\n * irradiance to the scene. E.g. a light map node can be used\n * as input for this module. Used in {@link NodeMaterial}.\n *\n * @augments LightingNode\n */\nclass IrradianceNode extends LightingNode {\n  static get type() {\n    return 'IrradianceNode';\n  }\n\n  /**\n   * Constructs a new irradiance node.\n   *\n   * @param {Node<vec3>} node - A node contributing irradiance.\n   */\n  constructor(node) {\n    super();\n\n    /**\n     * A node contributing irradiance.\n     *\n     * @type {Node<vec3>}\n     */\n    this.node = node;\n  }\n  setup(builder) {\n    builder.context.irradiance.addAssign(this.node);\n  }\n}\n\n/** @module ScreenNode **/\n\nlet screenSizeVec, viewportVec;\n\n/**\n * This node provides a collection of screen related metrics.\n * Depending on {@link module:ScreenNode~ScreenNode#scope}, the nodes can represent\n * resolution or viewport data as well as fragment or uv coordinates.\n *\n * @augments Node\n */\nclass ScreenNode extends Node {\n  static get type() {\n    return 'ScreenNode';\n  }\n\n  /**\n   * Constructs a new screen node.\n   *\n   * @param {('coordinate'|'viewport'|'size'|'uv')} scope - The node's scope.\n   */\n  constructor(scope) {\n    super();\n\n    /**\n     * The node represents different metric depending on which scope is selected.\n     *\n     * - `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.\n     * - `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.\n     * - `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.\n     * - `ScreenNode.UV`: Normalized coordinates.\n     *\n     * @type {('coordinate'|'viewport'|'size'|'uv')}\n     */\n    this.scope = scope;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isViewportNode = true;\n  }\n\n  /**\n   * This method is overwritten since the node type depends on the selected scope.\n   *\n   * @return {('vec2'|'vec4')} The node type.\n   */\n  getNodeType() {\n    if (this.scope === ScreenNode.VIEWPORT) return 'vec4';else return 'vec2';\n  }\n\n  /**\n   * This method is overwritten since the node's update type depends on the selected scope.\n   *\n   * @return {NodeUpdateType} The update type.\n   */\n  getUpdateType() {\n    let updateType = NodeUpdateType.NONE;\n    if (this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT) {\n      updateType = NodeUpdateType.RENDER;\n    }\n    this.updateType = updateType;\n    return updateType;\n  }\n\n  /**\n   * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information\n   * from the current renderer.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update({\n    renderer\n  }) {\n    const renderTarget = renderer.getRenderTarget();\n    if (this.scope === ScreenNode.VIEWPORT) {\n      if (renderTarget !== null) {\n        viewportVec.copy(renderTarget.viewport);\n      } else {\n        renderer.getViewport(viewportVec);\n        viewportVec.multiplyScalar(renderer.getPixelRatio());\n      }\n    } else {\n      if (renderTarget !== null) {\n        screenSizeVec.width = renderTarget.width;\n        screenSizeVec.height = renderTarget.height;\n      } else {\n        renderer.getDrawingBufferSize(screenSizeVec);\n      }\n    }\n  }\n  setup(/*builder*/\n  ) {\n    const scope = this.scope;\n    let output = null;\n    if (scope === ScreenNode.SIZE) {\n      output = uniform(screenSizeVec || (screenSizeVec = new Vector2()));\n    } else if (scope === ScreenNode.VIEWPORT) {\n      output = uniform(viewportVec || (viewportVec = new Vector4()));\n    } else {\n      output = vec2(screenCoordinate.div(screenSize));\n    }\n    return output;\n  }\n  generate(builder) {\n    if (this.scope === ScreenNode.COORDINATE) {\n      let coord = builder.getFragCoord();\n      if (builder.isFlipY()) {\n        // follow webgpu standards\n\n        const size = builder.getNodeProperties(screenSize).outputNode.build(builder);\n        coord = `${builder.getType('vec2')}( ${coord}.x, ${size}.y - ${coord}.y )`;\n      }\n      return coord;\n    }\n    return super.generate(builder);\n  }\n}\nScreenNode.COORDINATE = 'coordinate';\nScreenNode.VIEWPORT = 'viewport';\nScreenNode.SIZE = 'size';\nScreenNode.UV = 'uv';\n\n// Screen\n\n/**\n * TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.\n *\n * @type {ScreenNode<vec2>}\n */\nconst screenUV = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.UV);\n\n/**\n * TSL object that represents the screen resolution in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst screenSize = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.SIZE);\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst screenCoordinate = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.COORDINATE);\n\n// Viewport\n\n/**\n * TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.\n *\n * @type {ScreenNode<vec4>}\n */\nconst viewport = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);\n\n/**\n * TSL object that represents the viewport resolution in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst viewportSize = viewport.zw;\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst viewportCoordinate = /*@__PURE__*/screenCoordinate.sub(viewport.xy);\n\n/**\n * TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.\n *\n * @type {ScreenNode<vec2>}\n */\nconst viewportUV = /*@__PURE__*/viewportCoordinate.div(viewportSize);\n\n// Deprecated\n\nconst viewportResolution = /*@__PURE__*/Fn(() => {\n  // @deprecated, r169\n\n  console.warn('TSL.ViewportNode: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.');\n  return screenSize;\n}, 'vec2').once()();\nconst viewportTopLeft = /*@__PURE__*/Fn(() => {\n  // @deprecated, r168\n\n  console.warn('TSL.ViewportNode: \"viewportTopLeft\" is deprecated. Use \"screenUV\" instead.');\n  return screenUV;\n}, 'vec2').once()();\nconst viewportBottomLeft = /*@__PURE__*/Fn(() => {\n  // @deprecated, r168\n\n  console.warn('TSL.ViewportNode: \"viewportBottomLeft\" is deprecated. Use \"screenUV.flipY()\" instead.');\n  return screenUV.flipY();\n}, 'vec2').once()();\n\n/** @module ViewportTextureNode **/\n\nconst _size$4 = /*@__PURE__*/new Vector2();\n\n/**\n * A special type of texture node which represents the data of the current viewport\n * as a texture. The module extracts data from the current bound framebuffer with\n * a copy operation so no extra render pass is required to produce the texture data\n * (which is good for performance). `ViewportTextureNode` can be used as an input for a\n * variety of effects like refractive or transmissive materials.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass ViewportTextureNode extends TextureNode {\n  static get type() {\n    return 'ViewportTextureNode';\n  }\n\n  /**\n   * Constructs a new viewport texture node.\n   *\n   * @param {Node} [uvNode=screenUV] - The uv node.\n   * @param {Node?} [levelNode=null] - The level node.\n   * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n   */\n  constructor(uvNode = screenUV, levelNode = null, framebufferTexture = null) {\n    if (framebufferTexture === null) {\n      framebufferTexture = new FramebufferTexture();\n      framebufferTexture.minFilter = LinearMipmapLinearFilter;\n    }\n    super(framebufferTexture, uvNode, levelNode);\n\n    /**\n     * Whether to generate mipmaps or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.generateMipmaps = false;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isOutputTextureNode = true;\n\n    /**\n     * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the\n     * scene once per frame in its {@link ViewportTextureNode#updateBefore} method.\n     *\n     * @type {String}\n     * @default 'frame'\n     */\n    this.updateBeforeType = NodeUpdateType.FRAME;\n  }\n  updateBefore(frame) {\n    const renderer = frame.renderer;\n    renderer.getDrawingBufferSize(_size$4);\n\n    //\n\n    const framebufferTexture = this.value;\n    if (framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height) {\n      framebufferTexture.image.width = _size$4.width;\n      framebufferTexture.image.height = _size$4.height;\n      framebufferTexture.needsUpdate = true;\n    }\n\n    //\n\n    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n    framebufferTexture.generateMipmaps = this.generateMipmaps;\n    renderer.copyFramebufferToTexture(framebufferTexture);\n    framebufferTexture.generateMipmaps = currentGenerateMipmaps;\n  }\n  clone() {\n    const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);\n    viewportTextureNode.generateMipmaps = this.generateMipmaps;\n    return viewportTextureNode;\n  }\n}\n\n/**\n * TSL function for creating a viewport texture node.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nconst viewportTexture = /*@__PURE__*/nodeProxy(ViewportTextureNode);\n\n/**\n * TSL function for creating a viewport texture node with enabled mipmap generation.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nconst viewportMipTexture = /*@__PURE__*/nodeProxy(ViewportTextureNode, null, null, {\n  generateMipmaps: true\n});\n\n/** @module ViewportDepthTextureNode **/\n\nlet sharedDepthbuffer = null;\n\n/**\n * Represents the depth of the current viewport as a texture. This module\n * can be used in combination with viewport texture to achieve effects\n * that require depth evaluation.\n *\n * @augments module:ViewportTextureNode~ViewportTextureNode\n */\nclass ViewportDepthTextureNode extends ViewportTextureNode {\n  static get type() {\n    return 'ViewportDepthTextureNode';\n  }\n\n  /**\n   * Constructs a new viewport depth texture node.\n   *\n   * @param {Node} [uvNode=screenUV] - The uv node.\n   * @param {Node?} [levelNode=null] - The level node.\n   */\n  constructor(uvNode = screenUV, levelNode = null) {\n    if (sharedDepthbuffer === null) {\n      sharedDepthbuffer = new DepthTexture();\n    }\n    super(uvNode, levelNode, sharedDepthbuffer);\n  }\n}\n\n/**\n * TSL function for a viewport depth texture node.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @returns {ViewportDepthTextureNode}\n */\nconst viewportDepthTexture = /*@__PURE__*/nodeProxy(ViewportDepthTextureNode);\n\n/** @module ViewportDepthNode **/\n\n/**\n * This node offers a collection of features in context of the depth logic in the fragment shader.\n * Depending on {@link ViewportDepthNode#scope}, it can be used to define a depth value for the current\n * fragment or for depth evaluation purposes.\n *\n * @augments Node\n */\nclass ViewportDepthNode extends Node {\n  static get type() {\n    return 'ViewportDepthNode';\n  }\n\n  /**\n   * Constructs a new viewport depth node.\n   *\n   * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.\n   * @param {Node?} [valueNode=null] - The value node.\n   */\n  constructor(scope, valueNode = null) {\n    super('float');\n\n    /**\n     * The node behaves differently depending on which scope is selected.\n     *\n     * - `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.\n     * - `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).\n     * - `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.\n     * If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.\n     *\n     * @type {('depth'|'depthBase'|'linearDepth')}\n     */\n    this.scope = scope;\n\n    /**\n     * Can be used to define a custom depth value.\n     * The property is ignored in the `ViewportDepthNode.DEPTH` scope.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.valueNode = valueNode;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isViewportDepthNode = true;\n  }\n  generate(builder) {\n    const {\n      scope\n    } = this;\n    if (scope === ViewportDepthNode.DEPTH_BASE) {\n      return builder.getFragDepth();\n    }\n    return super.generate(builder);\n  }\n  setup({\n    camera\n  }) {\n    const {\n      scope\n    } = this;\n    const value = this.valueNode;\n    let node = null;\n    if (scope === ViewportDepthNode.DEPTH_BASE) {\n      if (value !== null) {\n        node = depthBase().assign(value);\n      }\n    } else if (scope === ViewportDepthNode.DEPTH) {\n      if (camera.isPerspectiveCamera) {\n        node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);\n      } else {\n        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n      }\n    } else if (scope === ViewportDepthNode.LINEAR_DEPTH) {\n      if (value !== null) {\n        if (camera.isPerspectiveCamera) {\n          const viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);\n          node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n        } else {\n          node = value;\n        }\n      } else {\n        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n      }\n    }\n    return node;\n  }\n}\nViewportDepthNode.DEPTH_BASE = 'depthBase';\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.LINEAR_DEPTH = 'linearDepth';\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n/**\n * TSL function for converting a viewZ value to an orthographic depth value.\n *\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));\n\n/**\n * TSL function for converting an orthographic depth value to a viewZ value.\n *\n * @function\n * @param {Node<float>} depth - The orthographic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst orthographicDepthToViewZ = (depth, near, far) => near.sub(far).mul(depth).sub(near);\n\n/**\n * TSL function for converting a viewZ value to a perspective depth value.\n *\n * Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.\n *\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));\n\n/**\n * TSL function for converting a perspective depth value to a viewZ value.\n *\n * @function\n * @param {Node<float>} depth - The perspective depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst perspectiveDepthToViewZ = (depth, near, far) => near.mul(far).div(far.sub(near).mul(depth).sub(far));\n\n/**\n * TSL function for converting a viewZ value to a logarithmic depth value.\n *\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToLogarithmicDepth = (viewZ, near, far) => {\n  // NOTE: viewZ must be negative--see explanation at the end of this comment block.\n  // The final logarithmic depth formula used here is adapted from one described in an\n  // article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),\n  // which was an improvement upon an earlier formula one described in an\n  // Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).\n  // Ulrich's formula is the following:\n  //     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )\n  //     where K = 2^k - 1, and k is the number of bits in the depth buffer.\n  // The Outerra variant ignored the camera near plane (it assumed it was 0) and instead\n  // opted for a \"C-constant\" for resolution adjustment of objects near the camera.\n  // Outerra states: \"Notice that the 'C' variant doesn\u2019t use a near plane distance, it has it\n  // set at 0\" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).\n  // Ulrich's variant has the benefit of constant relative precision over the whole near-far range.\n  // It was debated here whether Outerra's \"C-constant\" or Ulrich's \"near plane\" variant should\n  // be used, and ultimately Ulrich's \"near plane\" version was chosen.\n  // Outerra eventually made another improvement to their original \"C-constant\" variant,\n  // but it still does not incorporate the camera near plane (for this version,\n  // see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).\n  // Here we make 4 changes to Ulrich's formula:\n  // 1. Clamp the camera near plane so we don't divide by 0.\n  // 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).\n  // 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).\n  // 4. To maintain consistency with the functions \"viewZToOrthographicDepth\" and \"viewZToPerspectiveDepth\",\n  //    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,\n  //    so we do the same here, hence the 'viewZ.negate()' call.\n  // For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u\n  near = near.max(1e-6).toVar();\n  const numerator = log2(viewZ.negate().div(near));\n  const denominator = log2(far.div(near));\n  return numerator.div(denominator);\n};\n\n/**\n * TSL function for converting a logarithmic depth value to a viewZ value.\n *\n * @function\n * @param {Node<float>} depth - The logarithmic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst logarithmicDepthToViewZ = (depth, near, far) => {\n  // NOTE: we add a 'negate()' call to the return value here to maintain consistency with\n  // the functions \"orthographicDepthToViewZ\" and \"perspectiveDepthToViewZ\" (they return\n  // a negative viewZ).\n  const exponent = depth.mul(log(far.div(near)));\n  return float(Math.E).pow(exponent).mul(near).negate();\n};\n\n/**\n * TSL function for defining a value for the current fragment's depth.\n *\n * @function\n * @param {Node<float>} value - The depth value to set.\n * @returns {ViewportDepthNode<float>}\n */\nconst depthBase = /*@__PURE__*/nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);\n\n/**\n * TSL object that represents the depth value for the current fragment.\n *\n * @type {ViewportDepthNode}\n */\nconst depth = /*@__PURE__*/nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);\n\n/**\n * TSL function for converting a perspective depth value to linear depth.\n *\n * @function\n * @param {Node<float>} value - The perspective depth.\n * @returns {ViewportDepthNode<float>}\n */\nconst linearDepth = /*@__PURE__*/nodeProxy(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH);\n\n/**\n * TSL object that represents the linear (orthographic) depth value of the current fragment\n *\n * @type {ViewportDepthNode}\n */\nconst viewportLinearDepth = /*@__PURE__*/linearDepth(viewportDepthTexture());\ndepth.assign = value => depthBase(value);\n\n/** @module BuiltinNode **/\n\n/**\n * The node allows to set values for built-in shader variables. That is\n * required for features like hardware-accelerated vertex clipping.\n *\n * @augments Node\n */\nclass BuiltinNode extends Node {\n  /**\n   * Constructs a new builtin node.\n   *\n   * @param {String} name - The name of the built-in shader variable.\n   */\n  constructor(name) {\n    super('float');\n\n    /**\n     * The name of the built-in shader variable.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isBuiltinNode = true;\n  }\n\n  /**\n   * Generates the code snippet of the builtin node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The generated code snippet.\n   */\n  generate(/* builder */\n  ) {\n    return this.name;\n  }\n}\n\n/**\n * TSL function for creating a builtin node.\n *\n * @function\n * @param {String} name - The name of the built-in shader variable.\n * @returns {BuiltinNode}\n */\nconst builtin = nodeProxy(BuiltinNode);\n\n/** @module ClippingNode **/\n\n/**\n * ```\n * This node is used in {@link NodeMaterial} to setup the clipping\n * which can happen hardware-accelerated (if supported) and optionally\n * use alpha-to-coverage for anti-aliasing clipped edges.\n * ```\n * @augments Node\n */\nclass ClippingNode extends Node {\n  static get type() {\n    return 'ClippingNode';\n  }\n\n  /**\n   * Constructs a new clipping node.\n   *\n   * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,\n   * the selected scope influences the behavior of the node and what type of code is generated.\n   */\n  constructor(scope = ClippingNode.DEFAULT) {\n    super();\n\n    /**\n     * The node's scope. Similar to other nodes, the selected scope influences\n     * the behavior of the node and what type of code is generated.\n     *\n     * @type {('default'|'hardware'|'alphaToCoverage')}\n     */\n    this.scope = scope;\n  }\n\n  /**\n   * Setups the node depending on the selected scope.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node} The result node.\n   */\n  setup(builder) {\n    super.setup(builder);\n    const clippingContext = builder.clippingContext;\n    const {\n      intersectionPlanes,\n      unionPlanes\n    } = clippingContext;\n    this.hardwareClipping = builder.material.hardwareClipping;\n    if (this.scope === ClippingNode.ALPHA_TO_COVERAGE) {\n      return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);\n    } else if (this.scope === ClippingNode.HARDWARE) {\n      return this.setupHardwareClipping(unionPlanes, builder);\n    } else {\n      return this.setupDefault(intersectionPlanes, unionPlanes);\n    }\n  }\n\n  /**\n   * Setups alpha to coverage.\n   *\n   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.\n   * @param {Array<Vector4>} unionPlanes - The union planes.\n   * @return {Node} The result node.\n   */\n  setupAlphaToCoverage(intersectionPlanes, unionPlanes) {\n    return Fn(() => {\n      const distanceToPlane = float().toVar('distanceToPlane');\n      const distanceGradient = float().toVar('distanceToGradient');\n      const clipOpacity = float(1).toVar('clipOpacity');\n      const numUnionPlanes = unionPlanes.length;\n      if (this.hardwareClipping === false && numUnionPlanes > 0) {\n        const clippingPlanes = uniformArray(unionPlanes);\n        Loop(numUnionPlanes, ({\n          i\n        }) => {\n          const plane = clippingPlanes.element(i);\n          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));\n          distanceGradient.assign(distanceToPlane.fwidth().div(2.0));\n          clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));\n        });\n      }\n      const numIntersectionPlanes = intersectionPlanes.length;\n      if (numIntersectionPlanes > 0) {\n        const clippingPlanes = uniformArray(intersectionPlanes);\n        const intersectionClipOpacity = float(1).toVar('intersectionClipOpacity');\n        Loop(numIntersectionPlanes, ({\n          i\n        }) => {\n          const plane = clippingPlanes.element(i);\n          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));\n          distanceGradient.assign(distanceToPlane.fwidth().div(2.0));\n          intersectionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());\n        });\n        clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());\n      }\n      diffuseColor.a.mulAssign(clipOpacity);\n      diffuseColor.a.equal(0.0).discard();\n    })();\n  }\n\n  /**\n   * Setups the default clipping.\n   *\n   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.\n   * @param {Array<Vector4>} unionPlanes - The union planes.\n   * @return {Node} The result node.\n   */\n  setupDefault(intersectionPlanes, unionPlanes) {\n    return Fn(() => {\n      const numUnionPlanes = unionPlanes.length;\n      if (this.hardwareClipping === false && numUnionPlanes > 0) {\n        const clippingPlanes = uniformArray(unionPlanes);\n        Loop(numUnionPlanes, ({\n          i\n        }) => {\n          const plane = clippingPlanes.element(i);\n          positionView.dot(plane.xyz).greaterThan(plane.w).discard();\n        });\n      }\n      const numIntersectionPlanes = intersectionPlanes.length;\n      if (numIntersectionPlanes > 0) {\n        const clippingPlanes = uniformArray(intersectionPlanes);\n        const clipped = bool(true).toVar('clipped');\n        Loop(numIntersectionPlanes, ({\n          i\n        }) => {\n          const plane = clippingPlanes.element(i);\n          clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));\n        });\n        clipped.discard();\n      }\n    })();\n  }\n\n  /**\n   * Setups hardware clipping.\n   *\n   * @param {Array<Vector4>} unionPlanes - The union planes.\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node} The result node.\n   */\n  setupHardwareClipping(unionPlanes, builder) {\n    const numUnionPlanes = unionPlanes.length;\n    builder.enableHardwareClipping(numUnionPlanes);\n    return Fn(() => {\n      const clippingPlanes = uniformArray(unionPlanes);\n      const hw_clip_distances = builtin(builder.getClipDistance());\n      Loop(numUnionPlanes, ({\n        i\n      }) => {\n        const plane = clippingPlanes.element(i);\n        const distance = positionView.dot(plane.xyz).sub(plane.w).negate();\n        hw_clip_distances.element(i).assign(distance);\n      });\n    })();\n  }\n}\nClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';\nClippingNode.DEFAULT = 'default';\nClippingNode.HARDWARE = 'hardware';\n\n/**\n * TSL function for setting up the default clipping logic.\n *\n * @function\n * @returns {ClippingNode}\n */\nconst clipping = () => nodeObject(new ClippingNode());\n\n/**\n * TSL function for setting up alpha to coverage.\n *\n * @function\n * @returns {ClippingNode}\n */\nconst clippingAlpha = () => nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));\n\n/**\n * TSL function for setting up hardware-based clipping.\n *\n * @function\n * @returns {ClippingNode}\n */\nconst hardwareClipping = () => nodeObject(new ClippingNode(ClippingNode.HARDWARE));\n\n// See: https://casual-effects.com/research/Wyman2017Hashed/index.html\n\nconst ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.\n\nconst hash2D = /*@__PURE__*/Fn(([value]) => {\n  return fract(mul(1.0e4, sin(mul(17.0, value.x).add(mul(0.1, value.y)))).mul(add(0.1, abs(sin(mul(13.0, value.y).add(value.x))))));\n});\nconst hash3D = /*@__PURE__*/Fn(([value]) => {\n  return hash2D(vec2(hash2D(value.xy), value.z));\n});\nconst getAlphaHashThreshold = /*@__PURE__*/Fn(([position]) => {\n  // Find the discretized derivatives of our coordinates\n  const maxDeriv = max$1(length(dFdx(position.xyz)), length(dFdy(position.xyz)));\n  const pixScale = float(1).div(float(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar('pixScale');\n\n  // Find two nearest log-discretized noise scales\n  const pixScales = vec2(exp2(floor(log2(pixScale))), exp2(ceil(log2(pixScale))));\n\n  // Compute alpha thresholds at our two noise scales\n  const alpha = vec2(hash3D(floor(pixScales.x.mul(position.xyz))), hash3D(floor(pixScales.y.mul(position.xyz))));\n\n  // Factor to interpolate lerp with\n  const lerpFactor = fract(log2(pixScale));\n\n  // Interpolate alpha threshold from noise at two scales\n  const x = add(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, alpha.y));\n\n  // Pass into CDF to compute uniformly distrib threshold\n  const a = min$1(lerpFactor, lerpFactor.oneMinus());\n  const cases = vec3(x.mul(x).div(mul(2.0, a).mul(sub(1.0, a))), x.sub(mul(0.5, a)).div(sub(1.0, a)), sub(1.0, sub(1.0, x).mul(sub(1.0, x)).div(mul(2.0, a).mul(sub(1.0, a)))));\n\n  // Find our final, uniformly distributed alpha threshold (\u03B1\u03C4)\n  const threshold = x.lessThan(a.oneMinus()).select(x.lessThan(a).select(cases.x, cases.y), cases.z);\n\n  // Avoids \u03B1\u03C4 == 0. Could also do \u03B1\u03C4 =1-\u03B1\u03C4\n  return clamp(threshold, 1.0e-6, 1.0);\n}).setLayout({\n  name: 'getAlphaHashThreshold',\n  type: 'float',\n  inputs: [{\n    name: 'position',\n    type: 'vec3'\n  }]\n});\n\n/**\n * Base class for all node materials.\n *\n * @augments Material\n */\nclass NodeMaterial extends Material {\n  static get type() {\n    return 'NodeMaterial';\n  }\n\n  /**\n   * Represents the type of the node material.\n   *\n   * @type {String}\n   */\n  get type() {\n    return this.constructor.type;\n  }\n  set type(_value) {/* */}\n\n  /**\n   * Constructs a new node material.\n   */\n  constructor() {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isNodeMaterial = true;\n\n    /**\n     * Whether this material is affected by fog or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.fog = true;\n\n    /**\n     * Whether this material is affected by lights or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.lights = false;\n\n    /**\n     * Whether this material uses hardware clipping or not.\n     * This property is managed by the engine and should not be\n     * modified by apps.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.hardwareClipping = false;\n\n    /**\n     * Node materials which set their `lights` property to `true`\n     * are affected by all lights of the scene. Sometimes selective\n     * lighting is wanted which means only _some_ lights in the scene\n     * affect a material. This can be achieved by creating an instance\n     * of {@link module:LightsNode~LightsNode} with a list of selective\n     * lights and assign the node to this property.\n     *\n     * ```js\n     * const customLightsNode = lights( [ light1, light2 ] );\n     * material.lightsNode = customLightsNode;\n     * ```\n     *\n     * @type {LightsNode?}\n     * @default null\n     */\n    this.lightsNode = null;\n\n    /**\n     * The environment of node materials can be defined by an environment\n     * map assigned to the `envMap` property or by `Scene.environment`\n     * if the node material is a PBR material. This node property allows to overwrite\n     * the default behavior and define the environment with a custom node.\n     *\n     * ```js\n     * material.envNode = pmremTexture( renderTarget.texture );\n     * ```\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.envNode = null;\n\n    /**\n     * The lighting of node materials might be influenced by ambient occlusion.\n     * The default AO is inferred from an ambient occlusion map assigned to `aoMap`\n     * and the respective `aoMapIntensity`. This node property allows to overwrite\n     * the default and define the ambient occlusion with a custom node instead.\n     *\n     * If you don't want to overwrite the diffuse color but modify the existing\n     * values instead, use {@link module:MaterialNode.materialAO}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.aoNode = null;\n\n    /**\n     * The diffuse color of node materials is by default inferred from the\n     * `color` and `map` properties. This node property allows to overwrite the default\n     * and define the diffuse color with a node instead.\n     *\n     * ```js\n     * material.colorNode = color( 0xff0000 ); // define red color\n     * ```\n     *\n     * If you don't want to overwrite the diffuse color but modify the existing\n     * values instead, use {@link module:MaterialNode.materialColor}.\n     *\n     * ```js\n     * material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint\n     * ```\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.colorNode = null;\n\n    /**\n     * The normals of node materials are by default inferred from the `normalMap`/`normalScale`\n     * or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default\n     * and define the normals with a node instead.\n     *\n     * If you don't want to overwrite the normals but modify the existing values instead,\n     * use {@link module:MaterialNode.materialNormal}.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.normalNode = null;\n\n    /**\n     * The opacity of node materials is by default inferred from the `opacity`\n     * and `alphaMap` properties. This node property allows to overwrite the default\n     * and define the opacity with a node instead.\n     *\n     * If you don't want to overwrite the normals but modify the existing\n     * value instead, use {@link module:MaterialNode.materialOpacity}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.opacityNode = null;\n\n    /**\n     * This node can be used to to implement a variety of filter-like effects. The idea is\n     * to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it\n     * to create an arbitrary effect and then assign the node composition to this property.\n     * Everything behind the object using this material will now be affected by a filter.\n     *\n     * ```js\n     * const material = new NodeMaterial()\n     * material.transparent = true;\n     *\n     * // everything behind the object will be monochromatic\n     * material.backdropNode = viewportSharedTexture().rgb.saturation( 0 );\n     * ```\n     *\n     * Backdrop computations are part of the lighting so only lit materials can use this property.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.backdropNode = null;\n\n    /**\n     * This node allows to modulate the influence of `backdropNode` to the outgoing light.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.backdropAlphaNode = null;\n\n    /**\n     * The alpha test of node materials is by default inferred from the `alphaTest`\n     * property. This node property allows to overwrite the default and define the\n     * alpha test with a node instead.\n     *\n     * If you don't want to overwrite the alpha test but modify the existing\n     * value instead, use {@link module:MaterialNode.materialAlphaTest}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.alphaTestNode = null;\n\n    /**\n     * The local vertex positions are computed based on multiple factors like the\n     * attribute data, morphing or skinning. This node property allows to overwrite\n     * the default and define local vertex positions with nodes instead.\n     *\n     * If you don't want to overwrite the vertex positions but modify the existing\n     * values instead, use {@link module:Position.positionLocal}.\n     *\n     *```js\n     * material.positionNode = positionLocal.add( displace );\n     * ```\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.positionNode = null;\n\n    /**\n     * This node property is intended for logic which modifies geometry data once or per animation step.\n     * Apps usually place such logic randomly in initialization routines or in the animation loop.\n     * `geometryNode` is intended as a dedicated API so there is an intended spot where goemetry modiciations\n     * can be implemented.\n     *\n     * The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example\n     * would be a GPU based particle system that provides a node material for usage on app level. The particle\n     * simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is\n     * eventually assigned to `geometryNode`.\n     *\n     * @type {Function}\n     * @default null\n     */\n    this.geometryNode = null;\n\n    /**\n     * Allows to overwrite depth values in the fragment shader.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.depthNode = null;\n\n    /**\n     * Allows to overwrite the position used for shadow map rendering which\n     * is by default {@link module:Position.positionWorld}, the vertex position\n     * in world space.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.shadowPositionNode = null;\n\n    /**\n     * This node can be used to influence how an object using this node material\n     * receive shadows.\n     *\n     * ```js\n     * const totalShadows = float( 1 ).toVar();\n     * material.receivedShadowNode = Fn( ( [ shadow ] ) => {\n     * \ttotalShadows.mulAssign( shadow );\n     * \t//return float( 1 ); // bypass received shadows\n     * \treturn shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color\n     * } );\n     *\n     * @type {Node<vec4>?}\n     * @default null\n     */\n    this.receivedShadowNode = null;\n\n    /**\n     * This node can be used to influence how an object using this node material\n     * casts shadows. To apply a color to shadows, you can simply do:\n     *\n     * ```js\n     * material.castShadowNode = vec4( 1, 0, 0, 1 );\n     * ```\n     *\n     * Which can be nice to fake colored shadows of semi-transparent objects. It\n     * is also common to use the property with `Fn` function so checks are performed\n     * per fragment.\n     *\n     * ```js\n     * materialCustomShadow.castShadowNode = Fn( () => {\n     * \thash( vertexIndex ).greaterThan( 0.5 ).discard();\n     * \treturn materialColor;\n     * } )();\n     *  ```\n     *\n     * @type {Node<vec4>?}\n     * @default null\n     */\n    this.castShadowNode = null;\n\n    /**\n     * This node can be used to define the final output of the material.\n     *\n     * TODO: Explain the differences to `fragmentNode`.\n     *\n     * @type {Node<vec4>?}\n     * @default null\n     */\n    this.outputNode = null;\n\n    /**\n     * MRT configuration is done on renderer or pass level. This node allows to\n     * overwrite what values are written into MRT targets on material level. This\n     * can be useful for implementing selective FX features that should only affect\n     * specific objects.\n     *\n     * @type {MRTNode?}\n     * @default null\n     */\n    this.mrtNode = null;\n\n    /**\n     * This node property can be used if you need complete freedom in implementing\n     * the fragment shader. Assigning a node will replace the built-in material\n     * logic used in the fragment stage.\n     *\n     * @type {Node<vec4>?}\n     * @default null\n     */\n    this.fragmentNode = null;\n\n    /**\n     * This node property can be used if you need complete freedom in implementing\n     * the vertex shader. Assigning a node will replace the built-in material logic\n     * used in the vertex stage.\n     *\n     * @type {Node<vec4>?}\n     * @default null\n     */\n    this.vertexNode = null;\n  }\n\n  /**\n   * Allows to define a custom cache key that influence the material key computation\n   * for render objects.\n   *\n   * @return {String} The custom cache key.\n   */\n  customProgramCacheKey() {\n    return this.type + getCacheKey$1(this);\n  }\n\n  /**\n   * Builds this material with the given node builder.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  build(builder) {\n    this.setup(builder);\n  }\n\n  /**\n   * Setups a node material observer with the given builder.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {NodeMaterialObserver} The node material observer.\n   */\n  setupObserver(builder) {\n    return new NodeMaterialObserver(builder);\n  }\n\n  /**\n   * Setups the vertex and fragment stage of this node material.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    builder.context.setupNormal = () => this.setupNormal(builder);\n    builder.context.setupPositionView = () => this.setupPositionView(builder);\n    builder.context.setupModelViewProjection = () => this.setupModelViewProjection(builder);\n    const renderer = builder.renderer;\n    const renderTarget = renderer.getRenderTarget();\n\n    // < VERTEX STAGE >\n\n    builder.addStack();\n    const vertexNode = this.vertexNode || this.setupVertex(builder);\n    builder.stack.outputNode = vertexNode;\n    this.setupHardwareClipping(builder);\n    if (this.geometryNode !== null) {\n      builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);\n    }\n    builder.addFlow('vertex', builder.removeStack());\n\n    // < FRAGMENT STAGE >\n\n    builder.addStack();\n    let resultNode;\n    const clippingNode = this.setupClipping(builder);\n    if (this.depthWrite === true || this.depthTest === true) {\n      // only write depth if depth buffer is configured\n\n      if (renderTarget !== null) {\n        if (renderTarget.depthBuffer === true) this.setupDepth(builder);\n      } else {\n        if (renderer.depth === true) this.setupDepth(builder);\n      }\n    }\n    if (this.fragmentNode === null) {\n      this.setupDiffuseColor(builder);\n      this.setupVariants(builder);\n      const outgoingLightNode = this.setupLighting(builder);\n      if (clippingNode !== null) builder.stack.add(clippingNode);\n\n      // force unsigned floats - useful for RenderTargets\n\n      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);\n      resultNode = this.setupOutput(builder, basicOutput);\n\n      // OUTPUT NODE\n\n      output.assign(resultNode);\n\n      //\n\n      if (this.outputNode !== null) resultNode = this.outputNode;\n\n      // MRT\n\n      if (renderTarget !== null) {\n        const mrt = renderer.getMRT();\n        const materialMRT = this.mrtNode;\n        if (mrt !== null) {\n          resultNode = mrt;\n          if (materialMRT !== null) {\n            resultNode = mrt.merge(materialMRT);\n          }\n        } else if (materialMRT !== null) {\n          resultNode = materialMRT;\n        }\n      }\n    } else {\n      let fragmentNode = this.fragmentNode;\n      if (fragmentNode.isOutputStructNode !== true) {\n        fragmentNode = vec4(fragmentNode);\n      }\n      resultNode = this.setupOutput(builder, fragmentNode);\n    }\n    builder.stack.outputNode = resultNode;\n    builder.addFlow('fragment', builder.removeStack());\n\n    // < MONITOR >\n\n    builder.monitor = this.setupObserver(builder);\n  }\n\n  /**\n   * Setups the clipping node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {ClippingNode} The clipping node.\n   */\n  setupClipping(builder) {\n    if (builder.clippingContext === null) return null;\n    const {\n      unionPlanes,\n      intersectionPlanes\n    } = builder.clippingContext;\n    let result = null;\n    if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {\n      const samples = builder.renderer.samples;\n      if (this.alphaToCoverage && samples > 1) {\n        // to be added to flow when the color/alpha value has been determined\n        result = clippingAlpha();\n      } else {\n        builder.stack.add(clipping());\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Setups the hardware clipping if available on the current device.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setupHardwareClipping(builder) {\n    this.hardwareClipping = false;\n    if (builder.clippingContext === null) return;\n    const candidateCount = builder.clippingContext.unionPlanes.length;\n\n    // 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances\n\n    if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable('clipDistance')) {\n      builder.stack.add(hardwareClipping());\n      this.hardwareClipping = true;\n    }\n    return;\n  }\n\n  /**\n   * Setups the depth of this material.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setupDepth(builder) {\n    const {\n      renderer,\n      camera\n    } = builder;\n\n    // Depth\n\n    let depthNode = this.depthNode;\n    if (depthNode === null) {\n      const mrt = renderer.getMRT();\n      if (mrt && mrt.has('depth')) {\n        depthNode = mrt.get('depth');\n      } else if (renderer.logarithmicDepthBuffer === true) {\n        if (camera.isPerspectiveCamera) {\n          depthNode = viewZToLogarithmicDepth(positionView.z, cameraNear, cameraFar);\n        } else {\n          depthNode = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n        }\n      }\n    }\n    if (depthNode !== null) {\n      depth.assign(depthNode).append();\n    }\n  }\n\n  /**\n   * Setups the position node in view space. This method exists\n   * so derived node materials can modifiy the implementation e.g. sprite materials.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node<vec3>} The position in view space.\n   */\n  setupPositionView(/*builder*/\n  ) {\n    return modelViewMatrix.mul(positionLocal).xyz;\n  }\n\n  /**\n   * Setups the position in clip space.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node<vec4>} The position in view space.\n   */\n  setupModelViewProjection(/*builder*/\n  ) {\n    return cameraProjectionMatrix.mul(positionView);\n  }\n\n  /**\n   * Setups the logic for the vertex stage.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node<vec4>} The position in clip space.\n   */\n  setupVertex(builder) {\n    builder.addStack();\n    this.setupPosition(builder);\n    builder.context.vertex = builder.removeStack();\n    return modelViewProjection;\n  }\n\n  /**\n   * Setups the computation of the position in local space.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node<vec3>} The position in local space.\n   */\n  setupPosition(builder) {\n    const {\n      object,\n      geometry\n    } = builder;\n    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {\n      morphReference(object).append();\n    }\n    if (object.isSkinnedMesh === true) {\n      skinningReference(object).append();\n    }\n    if (this.displacementMap) {\n      const displacementMap = materialReference('displacementMap', 'texture');\n      const displacementScale = materialReference('displacementScale', 'float');\n      const displacementBias = materialReference('displacementBias', 'float');\n      positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));\n    }\n    if (object.isBatchedMesh) {\n      batch(object).append();\n    }\n    if (object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true) {\n      instancedMesh(object).append();\n    }\n    if (this.positionNode !== null) {\n      positionLocal.assign(this.positionNode.context({\n        isPositionNodeInput: true\n      }));\n    }\n    return positionLocal;\n  }\n\n  /**\n   * Setups the computation of the material's diffuse color.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {BufferGeometry} geometry - The geometry.\n   */\n  setupDiffuseColor({\n    object,\n    geometry\n  }) {\n    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;\n\n    // VERTEX COLORS\n\n    if (this.vertexColors === true && geometry.hasAttribute('color')) {\n      colorNode = vec4(colorNode.xyz.mul(attribute('color', 'vec3')), colorNode.a);\n    }\n\n    // Instanced colors\n\n    if (object.instanceColor) {\n      const instanceColor = varyingProperty('vec3', 'vInstanceColor');\n      colorNode = instanceColor.mul(colorNode);\n    }\n    if (object.isBatchedMesh && object._colorsTexture) {\n      const batchColor = varyingProperty('vec3', 'vBatchColor');\n      colorNode = batchColor.mul(colorNode);\n    }\n\n    // COLOR\n\n    diffuseColor.assign(colorNode);\n\n    // OPACITY\n\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));\n\n    // ALPHA TEST\n\n    if (this.alphaTestNode !== null || this.alphaTest > 0) {\n      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;\n      diffuseColor.a.lessThanEqual(alphaTestNode).discard();\n    }\n\n    // ALPHA HASH\n\n    if (this.alphaHash === true) {\n      diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();\n    }\n    if (this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false) {\n      diffuseColor.a.assign(1.0);\n    }\n  }\n\n  /**\n   * Abstract interface method that can be implemented by derived materials\n   * to setup material-specific node variables.\n   *\n   * @abstract\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setupVariants(/*builder*/\n  ) {\n\n    // Interface function.\n  }\n\n  /**\n   * Setups the outgoing light node variable\n   *\n   * @return {Node<vec3>} The outgoing light node.\n   */\n  setupOutgoingLight() {\n    return this.lights === true ? vec3(0) : diffuseColor.rgb;\n  }\n\n  /**\n   * Setups the normal node from the material.\n   *\n   * @return {Node<vec3>} The normal node.\n   */\n  setupNormal() {\n    return this.normalNode ? vec3(this.normalNode) : materialNormal;\n  }\n\n  /**\n   * Setups the environment node from the material.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node<vec4>} The environment node.\n   */\n  setupEnvironment(/*builder*/\n  ) {\n    let node = null;\n    if (this.envNode) {\n      node = this.envNode;\n    } else if (this.envMap) {\n      node = this.envMap.isCubeTexture ? materialReference('envMap', 'cubeTexture') : materialReference('envMap', 'texture');\n    }\n    return node;\n  }\n\n  /**\n   * Setups the light map node from the material.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node<vec3>} The light map node.\n   */\n  setupLightMap(builder) {\n    let node = null;\n    if (builder.material.lightMap) {\n      node = new IrradianceNode(materialLightMap);\n    }\n    return node;\n  }\n\n  /**\n   * Setups the lights node based on the scene, environment and material.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {LightsNode} The lights node.\n   */\n  setupLights(builder) {\n    const materialLightsNode = [];\n\n    //\n\n    const envNode = this.setupEnvironment(builder);\n    if (envNode && envNode.isLightingNode) {\n      materialLightsNode.push(envNode);\n    }\n    const lightMapNode = this.setupLightMap(builder);\n    if (lightMapNode && lightMapNode.isLightingNode) {\n      materialLightsNode.push(lightMapNode);\n    }\n    if (this.aoNode !== null || builder.material.aoMap) {\n      const aoNode = this.aoNode !== null ? this.aoNode : materialAO;\n      materialLightsNode.push(new AONode(aoNode));\n    }\n    let lightsN = this.lightsNode || builder.lightsNode;\n    if (materialLightsNode.length > 0) {\n      lightsN = builder.renderer.lighting.createNode([...lightsN.getLights(), ...materialLightsNode]);\n    }\n    return lightsN;\n  }\n\n  /**\n   * This method should be implemented by most derived materials\n   * since it defines the material's lighting model.\n   *\n   * @abstract\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {LightingModel} The lighting model.\n   */\n  setupLightingModel(/*builder*/\n  ) {\n\n    // Interface function.\n  }\n\n  /**\n   * Setups the outgoing light node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node<vec3>} The outgoing light node.\n   */\n  setupLighting(builder) {\n    const {\n      material\n    } = builder;\n    const {\n      backdropNode,\n      backdropAlphaNode,\n      emissiveNode\n    } = this;\n\n    // OUTGOING LIGHT\n\n    const lights = this.lights === true || this.lightsNode !== null;\n    const lightsNode = lights ? this.setupLights(builder) : null;\n    let outgoingLightNode = this.setupOutgoingLight(builder);\n    if (lightsNode && lightsNode.getScope().hasLights) {\n      const lightingModel = this.setupLightingModel(builder);\n      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);\n    } else if (backdropNode !== null) {\n      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);\n    }\n\n    // EMISSIVE\n\n    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {\n      emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));\n      outgoingLightNode = outgoingLightNode.add(emissive);\n    }\n    return outgoingLightNode;\n  }\n\n  /**\n   * Setups the output node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {Node<vec4>} outputNode - The existing output node.\n   * @return {Node<vec4>} The output node.\n   */\n  setupOutput(builder, outputNode) {\n    // FOG\n\n    if (this.fog === true) {\n      const fogNode = builder.fogNode;\n      if (fogNode) {\n        output.assign(outputNode);\n        outputNode = vec4(fogNode);\n      }\n    }\n    return outputNode;\n  }\n\n  /**\n   * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`\n   * there is `MeshBasicNodeMaterial`. This utility method is intended for\n   * defining all material properties of the classic type in the node type.\n   *\n   * @param {Material} material - The material to copy properties with their values to this node material.\n   */\n  setDefaultValues(material) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n\n    for (const property in material) {\n      const value = material[property];\n      if (this[property] === undefined) {\n        this[property] = value;\n        if (value && value.clone) this[property] = value.clone();\n      }\n    }\n    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);\n    for (const key in descriptors) {\n      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined && descriptors[key].get !== undefined) {\n        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);\n      }\n    }\n  }\n\n  /**\n   * Serializes this material to JSON.\n   *\n   * @param {(Object|String)?} meta - The meta information for serialization.\n   * @return {Object} The serialized node.\n   */\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeChildren = getNodeChildren(this);\n    data.inputNodes = {};\n    for (const {\n      property,\n      childNode\n    } of nodeChildren) {\n      data.inputNodes[property] = childNode.toJSON(meta).uuid;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n\n  /**\n   * Copies the properties of the given node material to this instance.\n   *\n   * @param {NodeMaterial} source - The material to copy.\n   * @return {NodeMaterial} A reference to this node material.\n   */\n  copy(source) {\n    this.lightsNode = source.lightsNode;\n    this.envNode = source.envNode;\n    this.colorNode = source.colorNode;\n    this.normalNode = source.normalNode;\n    this.opacityNode = source.opacityNode;\n    this.backdropNode = source.backdropNode;\n    this.backdropAlphaNode = source.backdropAlphaNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.positionNode = source.positionNode;\n    this.geometryNode = source.geometryNode;\n    this.depthNode = source.depthNode;\n    this.shadowPositionNode = source.shadowPositionNode;\n    this.receivedShadowNode = source.receivedShadowNode;\n    this.castShadowNode = source.castShadowNode;\n    this.outputNode = source.outputNode;\n    this.mrtNode = source.mrtNode;\n    this.fragmentNode = source.fragmentNode;\n    this.vertexNode = source.vertexNode;\n    return super.copy(source);\n  }\n}\nconst _defaultValues$e = /*@__PURE__*/new PointsMaterial();\n\n/**\n * Unlike WebGL, WebGPU can render point primitives only with a size\n * of one pixel. This type node material can be used to mimic the WebGL\n * points rendering by rendering small planes via instancing.\n *\n * This material should be used with {@link InstancedPointsGeometry}.\n *\n * @augments NodeMaterial\n */\nclass InstancedPointsNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'InstancedPointsNodeMaterial';\n  }\n\n  /**\n   * Constructs a new instanced points node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters = {}) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isInstancedPointsNodeMaterial = true;\n\n    /**\n     * Whether vertex colors should be used or not. If set to `true`,\n     * each point instance can receive a custom color value.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.useColor = parameters.vertexColors;\n\n    /**\n     * The points width in pixels.\n     *\n     * @type {Number}\n     * @default 1\n     */\n    this.pointWidth = 1;\n\n    /**\n     * This node can be used to define the colors for each instance.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.pointColorNode = null;\n\n    /**\n     * This node can be used to define the width for each point instance.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.pointWidthNode = null;\n    this._useAlphaToCoverage = true;\n    this.setDefaultValues(_defaultValues$e);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Setups the vertex and fragment stage of this node material.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    const {\n      renderer\n    } = builder;\n    const useAlphaToCoverage = this._useAlphaToCoverage;\n    const useColor = this.useColor;\n    this.vertexNode = Fn(() => {\n      const instancePosition = attribute('instancePosition').xyz;\n\n      // camera space\n      const mvPos = vec4(modelViewMatrix.mul(vec4(instancePosition, 1.0)));\n      const aspect = viewport.z.div(viewport.w);\n\n      // clip space\n      const clipPos = cameraProjectionMatrix.mul(mvPos);\n\n      // offset in ndc space\n      const offset = positionGeometry.xy.toVar();\n      offset.mulAssign(this.pointWidthNode ? this.pointWidthNode : materialPointWidth);\n      offset.assign(offset.div(viewport.z));\n      offset.y.assign(offset.y.mul(aspect));\n\n      // back to clip space\n      offset.assign(offset.mul(clipPos.w));\n\n      //clipPos.xy += offset;\n      clipPos.addAssign(vec4(offset, 0, 0));\n      return clipPos;\n    })();\n    this.fragmentNode = Fn(() => {\n      const alpha = float(1).toVar();\n      const len2 = lengthSq(uv().mul(2).sub(1));\n      if (useAlphaToCoverage && renderer.samples > 1) {\n        const dlen = float(len2.fwidth()).toVar();\n        alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n      } else {\n        len2.greaterThan(1.0).discard();\n      }\n      let pointColorNode;\n      if (this.pointColorNode) {\n        pointColorNode = this.pointColorNode;\n      } else {\n        if (useColor) {\n          const instanceColor = attribute('instanceColor');\n          pointColorNode = instanceColor.mul(materialColor);\n        } else {\n          pointColorNode = materialColor;\n        }\n      }\n      alpha.mulAssign(materialOpacity);\n      return vec4(pointColorNode, alpha);\n    })();\n    super.setup(builder);\n  }\n\n  /**\n   * Whether alpha to coverage should be used or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get alphaToCoverage() {\n    return this._useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this._useAlphaToCoverage !== value) {\n      this._useAlphaToCoverage = value;\n      this.needsUpdate = true;\n    }\n  }\n}\nconst _defaultValues$d = /*@__PURE__*/new LineBasicMaterial();\n\n/**\n * Node material version of `LineBasicMaterial`.\n *\n * @augments NodeMaterial\n */\nclass LineBasicNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'LineBasicNodeMaterial';\n  }\n\n  /**\n   * Constructs a new line basic node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isLineBasicNodeMaterial = true;\n    this.setDefaultValues(_defaultValues$d);\n    this.setValues(parameters);\n  }\n}\nconst _defaultValues$c = /*@__PURE__*/new LineDashedMaterial();\n\n/**\n * Node material version of `LineDashedMaterial`.\n *\n * @augments NodeMaterial\n */\nclass LineDashedNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'LineDashedNodeMaterial';\n  }\n\n  /**\n   * Constructs a new line dashed node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isLineDashedNodeMaterial = true;\n    this.setDefaultValues(_defaultValues$c);\n\n    /**\n     * The dash offset.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.dashOffset = 0;\n\n    /**\n     * The offset of dash materials is by default inferred from the `dashOffset`\n     * property. This node property allows to overwrite the default\n     * and define the offset with a node instead.\n     *\n     * If you don't want to overwrite the offset but modify the existing\n     * value instead, use {@link module:MaterialNode.materialLineDashOffset}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.offsetNode = null;\n\n    /**\n     * The scale of dash materials is by default inferred from the `scale`\n     * property. This node property allows to overwrite the default\n     * and define the scale with a node instead.\n     *\n     * If you don't want to overwrite the scale but modify the existing\n     * value instead, use {@link module:MaterialNode.materialLineScale}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.dashScaleNode = null;\n\n    /**\n     * The dash size of dash materials is by default inferred from the `dashSize`\n     * property. This node property allows to overwrite the default\n     * and define the dash size with a node instead.\n     *\n     * If you don't want to overwrite the dash size but modify the existing\n     * value instead, use {@link module:MaterialNode.materialLineDashSize}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.dashSizeNode = null;\n\n    /**\n     * The gap size of dash materials is by default inferred from the `gapSize`\n     * property. This node property allows to overwrite the default\n     * and define the gap size with a node instead.\n     *\n     * If you don't want to overwrite the gap size but modify the existing\n     * value instead, use {@link module:MaterialNode.materialLineGapSize}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.gapSizeNode = null;\n    this.setValues(parameters);\n  }\n\n  /**\n   * Setups the dash specific node variables.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setupVariants(/* builder */\n  ) {\n    const offsetNode = this.offsetNode ? float(this.offsetNode) : materialLineDashOffset;\n    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;\n    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;\n    const gapSizeNode = this.gapSizeNode ? float(this.gapSizeNode) : materialLineGapSize;\n    dashSize.assign(dashSizeNode);\n    gapSize.assign(gapSizeNode);\n    const vLineDistance = varying(attribute('lineDistance').mul(dashScaleNode));\n    const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;\n    vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();\n  }\n}\n\n/** @module ViewportSharedTextureNode **/\n\nlet _sharedFramebuffer = null;\n\n/**\n * `ViewportTextureNode` creates an internal texture for each node instance. This module\n * shares a texture across all instances of `ViewportSharedTextureNode`. It should\n * be the first choice when using data of the default/screen framebuffer for performance reasons.\n *\n * @augments module:ViewportTextureNode~ViewportTextureNode\n */\nclass ViewportSharedTextureNode extends ViewportTextureNode {\n  static get type() {\n    return 'ViewportSharedTextureNode';\n  }\n\n  /**\n   * Constructs a new viewport shared texture node.\n   *\n   * @param {Node} [uvNode=screenUV] - The uv node.\n   * @param {Node?} [levelNode=null] - The level node.\n   */\n  constructor(uvNode = screenUV, levelNode = null) {\n    if (_sharedFramebuffer === null) {\n      _sharedFramebuffer = new FramebufferTexture();\n    }\n    super(uvNode, levelNode, _sharedFramebuffer);\n  }\n  updateReference() {\n    return this;\n  }\n}\n\n/**\n * TSL function for creating a shared viewport texture node.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @returns {ViewportSharedTextureNode}\n */\nconst viewportSharedTexture = /*@__PURE__*/nodeProxy(ViewportSharedTextureNode);\nconst _defaultValues$b = /*@__PURE__*/new LineDashedMaterial();\n\n/**\n * This node material can be used to render lines with a size larger than one\n * by representing them as instanced meshes.\n *\n * @augments NodeMaterial\n */\nclass Line2NodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'Line2NodeMaterial';\n  }\n\n  /**\n   * Constructs a new node material for wide line rendering.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters = {}) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isLine2NodeMaterial = true;\n    this.setDefaultValues(_defaultValues$b);\n\n    /**\n     * Whether vertex colors should be used or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.useColor = parameters.vertexColors;\n\n    /**\n     * The dash offset.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.dashOffset = 0;\n\n    /**\n     * The line width.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.lineWidth = 1;\n\n    /**\n     * Defines the lines color.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.lineColorNode = null;\n\n    /**\n     * Defines the offset.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.offsetNode = null;\n\n    /**\n     * Defines the dash scale.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.dashScaleNode = null;\n\n    /**\n     * Defines the dash size.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.dashSizeNode = null;\n\n    /**\n     * Defines the gap size.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.gapSizeNode = null;\n\n    /**\n     * Blending is set to `NoBlending` since transparency\n     * is not supported, yet.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.blending = NoBlending;\n    this._useDash = parameters.dashed;\n    this._useAlphaToCoverage = true;\n    this._useWorldUnits = false;\n    this.setValues(parameters);\n  }\n\n  /**\n   * Setups the vertex and fragment stage of this node material.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    const {\n      renderer\n    } = builder;\n    const useAlphaToCoverage = this._useAlphaToCoverage;\n    const useColor = this.useColor;\n    const useDash = this._useDash;\n    const useWorldUnits = this._useWorldUnits;\n    const trimSegment = Fn(({\n      start,\n      end\n    }) => {\n      const a = cameraProjectionMatrix.element(2).element(2); // 3nd entry in 3th column\n      const b = cameraProjectionMatrix.element(3).element(2); // 3nd entry in 4th column\n      const nearEstimate = b.mul(-0.5).div(a);\n      const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));\n      return vec4(mix(start.xyz, end.xyz, alpha), end.w);\n    }).setLayout({\n      name: 'trimSegment',\n      type: 'vec4',\n      inputs: [{\n        name: 'start',\n        type: 'vec4'\n      }, {\n        name: 'end',\n        type: 'vec4'\n      }]\n    });\n    this.vertexNode = Fn(() => {\n      const instanceStart = attribute('instanceStart');\n      const instanceEnd = attribute('instanceEnd');\n\n      // camera space\n\n      const start = vec4(modelViewMatrix.mul(vec4(instanceStart, 1.0))).toVar('start');\n      const end = vec4(modelViewMatrix.mul(vec4(instanceEnd, 1.0))).toVar('end');\n      if (useDash) {\n        const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;\n        const offsetNode = this.offsetNode ? float(this.offsetNode) : materialLineDashOffset;\n        const instanceDistanceStart = attribute('instanceDistanceStart');\n        const instanceDistanceEnd = attribute('instanceDistanceEnd');\n        let lineDistance = positionGeometry.y.lessThan(0.5).select(dashScaleNode.mul(instanceDistanceStart), dashScaleNode.mul(instanceDistanceEnd));\n        lineDistance = lineDistance.add(offsetNode);\n        varyingProperty('float', 'lineDistance').assign(lineDistance);\n      }\n      if (useWorldUnits) {\n        varyingProperty('vec3', 'worldStart').assign(start.xyz);\n        varyingProperty('vec3', 'worldEnd').assign(end.xyz);\n      }\n      const aspect = viewport.z.div(viewport.w);\n\n      // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n      // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n      // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n      // perhaps there is a more elegant solution -- WestLangley\n\n      const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1.0); // 4th entry in the 3rd column\n\n      If(perspective, () => {\n        If(start.z.lessThan(0.0).and(end.z.greaterThan(0.0)), () => {\n          end.assign(trimSegment({\n            start: start,\n            end: end\n          }));\n        }).ElseIf(end.z.lessThan(0.0).and(start.z.greaterThanEqual(0.0)), () => {\n          start.assign(trimSegment({\n            start: end,\n            end: start\n          }));\n        });\n      });\n\n      // clip space\n      const clipStart = cameraProjectionMatrix.mul(start);\n      const clipEnd = cameraProjectionMatrix.mul(end);\n\n      // ndc space\n      const ndcStart = clipStart.xyz.div(clipStart.w);\n      const ndcEnd = clipEnd.xyz.div(clipEnd.w);\n\n      // direction\n      const dir = ndcEnd.xy.sub(ndcStart.xy).toVar();\n\n      // account for clip-space aspect ratio\n      dir.x.assign(dir.x.mul(aspect));\n      dir.assign(dir.normalize());\n      const clip = vec4().toVar();\n      if (useWorldUnits) {\n        // get the offset direction as perpendicular to the view vector\n\n        const worldDir = end.xyz.sub(start.xyz).normalize();\n        const tmpFwd = mix(start.xyz, end.xyz, 0.5).normalize();\n        const worldUp = worldDir.cross(tmpFwd).normalize();\n        const worldFwd = worldDir.cross(worldUp);\n        const worldPos = varyingProperty('vec4', 'worldPos');\n        worldPos.assign(positionGeometry.y.lessThan(0.5).select(start, end));\n\n        // height offset\n        const hw = materialLineWidth.mul(0.5);\n        worldPos.addAssign(vec4(positionGeometry.x.lessThan(0.0).select(worldUp.mul(hw), worldUp.mul(hw).negate()), 0));\n\n        // don't extend the line if we're rendering dashes because we\n        // won't be rendering the endcaps\n        if (!useDash) {\n          // cap extension\n          worldPos.addAssign(vec4(positionGeometry.y.lessThan(0.5).select(worldDir.mul(hw).negate(), worldDir.mul(hw)), 0));\n\n          // add width to the box\n          worldPos.addAssign(vec4(worldFwd.mul(hw), 0));\n\n          // endcaps\n          If(positionGeometry.y.greaterThan(1.0).or(positionGeometry.y.lessThan(0.0)), () => {\n            worldPos.subAssign(vec4(worldFwd.mul(2.0).mul(hw), 0));\n          });\n        }\n\n        // project the worldpos\n        clip.assign(cameraProjectionMatrix.mul(worldPos));\n\n        // shift the depth of the projected points so the line\n        // segments overlap neatly\n        const clipPose = vec3().toVar();\n        clipPose.assign(positionGeometry.y.lessThan(0.5).select(ndcStart, ndcEnd));\n        clip.z.assign(clipPose.z.mul(clip.w));\n      } else {\n        const offset = vec2(dir.y, dir.x.negate()).toVar('offset');\n\n        // undo aspect ratio adjustment\n        dir.x.assign(dir.x.div(aspect));\n        offset.x.assign(offset.x.div(aspect));\n\n        // sign flip\n        offset.assign(positionGeometry.x.lessThan(0.0).select(offset.negate(), offset));\n\n        // endcaps\n        If(positionGeometry.y.lessThan(0.0), () => {\n          offset.assign(offset.sub(dir));\n        }).ElseIf(positionGeometry.y.greaterThan(1.0), () => {\n          offset.assign(offset.add(dir));\n        });\n\n        // adjust for linewidth\n        offset.assign(offset.mul(materialLineWidth));\n\n        // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n        offset.assign(offset.div(viewport.w));\n\n        // select end\n        clip.assign(positionGeometry.y.lessThan(0.5).select(clipStart, clipEnd));\n\n        // back to clip space\n        offset.assign(offset.mul(clip.w));\n        clip.assign(clip.add(vec4(offset, 0, 0)));\n      }\n      return clip;\n    })();\n    const closestLineToLine = Fn(({\n      p1,\n      p2,\n      p3,\n      p4\n    }) => {\n      const p13 = p1.sub(p3);\n      const p43 = p4.sub(p3);\n      const p21 = p2.sub(p1);\n      const d1343 = p13.dot(p43);\n      const d4321 = p43.dot(p21);\n      const d1321 = p13.dot(p21);\n      const d4343 = p43.dot(p43);\n      const d2121 = p21.dot(p21);\n      const denom = d2121.mul(d4343).sub(d4321.mul(d4321));\n      const numer = d1343.mul(d4321).sub(d1321.mul(d4343));\n      const mua = numer.div(denom).clamp();\n      const mub = d1343.add(d4321.mul(mua)).div(d4343).clamp();\n      return vec2(mua, mub);\n    });\n    this.colorNode = Fn(() => {\n      const vUv = uv();\n      if (useDash) {\n        const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;\n        const gapSizeNode = this.gapSizeNode ? float(this.gapSizeNode) : materialLineGapSize;\n        dashSize.assign(dashSizeNode);\n        gapSize.assign(gapSizeNode);\n        const vLineDistance = varyingProperty('float', 'lineDistance');\n        vUv.y.lessThan(-1.0).or(vUv.y.greaterThan(1.0)).discard(); // discard endcaps\n        vLineDistance.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard(); // todo - FIX\n      }\n      const alpha = float(1).toVar('alpha');\n      if (useWorldUnits) {\n        const worldStart = varyingProperty('vec3', 'worldStart');\n        const worldEnd = varyingProperty('vec3', 'worldEnd');\n\n        // Find the closest points on the view ray and the line segment\n        const rayEnd = varyingProperty('vec4', 'worldPos').xyz.normalize().mul(1e5);\n        const lineDir = worldEnd.sub(worldStart);\n        const params = closestLineToLine({\n          p1: worldStart,\n          p2: worldEnd,\n          p3: vec3(0.0, 0.0, 0.0),\n          p4: rayEnd\n        });\n        const p1 = worldStart.add(lineDir.mul(params.x));\n        const p2 = rayEnd.mul(params.y);\n        const delta = p1.sub(p2);\n        const len = delta.length();\n        const norm = len.div(materialLineWidth);\n        if (!useDash) {\n          if (useAlphaToCoverage && renderer.samples > 1) {\n            const dnorm = norm.fwidth();\n            alpha.assign(smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());\n          } else {\n            norm.greaterThan(0.5).discard();\n          }\n        }\n      } else {\n        // round endcaps\n\n        if (useAlphaToCoverage && renderer.samples > 1) {\n          const a = vUv.x;\n          const b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));\n          const len2 = a.mul(a).add(b.mul(b));\n          const dlen = float(len2.fwidth()).toVar('dlen');\n          If(vUv.y.abs().greaterThan(1.0), () => {\n            alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n          });\n        } else {\n          If(vUv.y.abs().greaterThan(1.0), () => {\n            const a = vUv.x;\n            const b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));\n            const len2 = a.mul(a).add(b.mul(b));\n            len2.greaterThan(1.0).discard();\n          });\n        }\n      }\n      let lineColorNode;\n      if (this.lineColorNode) {\n        lineColorNode = this.lineColorNode;\n      } else {\n        if (useColor) {\n          const instanceColorStart = attribute('instanceColorStart');\n          const instanceColorEnd = attribute('instanceColorEnd');\n          const instanceColor = positionGeometry.y.lessThan(0.5).select(instanceColorStart, instanceColorEnd);\n          lineColorNode = instanceColor.mul(materialColor);\n        } else {\n          lineColorNode = materialColor;\n        }\n      }\n      return vec4(lineColorNode, alpha);\n    })();\n    if (this.transparent) {\n      const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n      this.outputNode = vec4(this.colorNode.rgb.mul(opacityNode).add(viewportSharedTexture().rgb.mul(opacityNode.oneMinus())), this.colorNode.a);\n    }\n    super.setup(builder);\n  }\n\n  /**\n   * Whether the lines should sized in world units or not.\n   * When set to `false` the unit is pixel.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  get worldUnits() {\n    return this._useWorldUnits;\n  }\n  set worldUnits(value) {\n    if (this._useWorldUnits !== value) {\n      this._useWorldUnits = value;\n      this.needsUpdate = true;\n    }\n  }\n\n  /**\n   * Whether the lines should be dashed or not.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  get dashed() {\n    return this._useDash;\n  }\n  set dashed(value) {\n    if (this._useDash !== value) {\n      this._useDash = value;\n      this.needsUpdate = true;\n    }\n  }\n\n  /**\n   * Whether alpha to coverage should be used or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get alphaToCoverage() {\n    return this._useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this._useAlphaToCoverage !== value) {\n      this._useAlphaToCoverage = value;\n      this.needsUpdate = true;\n    }\n  }\n}\n\n/** @module Packing **/\n\n/**\n * Packs a direction vector into a color value.\n *\n * @method\n * @param {Node<vec3>} node - The direction to pack.\n * @return {Node<vec3>} The color.\n */\nconst directionToColor = node => nodeObject(node).mul(0.5).add(0.5);\n\n/**\n * Unpacks a color value into a direction vector.\n *\n * @method\n * @param {Node<vec3>} node - The color to unpack.\n * @return {Node<vec3>} The direction.\n */\nconst colorToDirection = node => nodeObject(node).mul(2.0).sub(1);\nconst _defaultValues$a = /*@__PURE__*/new MeshNormalMaterial();\n\n/**\n * Node material version of `MeshNormalMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshNormalNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshNormalNodeMaterial';\n  }\n\n  /**\n   * Constructs a new mesh normal node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMeshNormalNodeMaterial = true;\n    this.setDefaultValues(_defaultValues$a);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Overwrites the default implementation by computing the diffuse color\n   * based on the normal data.\n   */\n  setupDiffuseColor() {\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    diffuseColor.assign(vec4(directionToColor(transformedNormalView), opacityNode));\n  }\n}\n\n/** @module EquirectUVNode **/\n\n/**\n * Can be used to compute texture coordinates for projecting an\n * equirectangular texture onto a mesh for using it as the scene's\n * background.\n *\n * ```js\n * scene.backgroundNode = texture( equirectTexture, equirectUV() );\n * ```\n *\n * @augments TempNode\n */\nclass EquirectUVNode extends TempNode {\n  static get type() {\n    return 'EquirectUVNode';\n  }\n\n  /**\n   * Constructs a new equirect uv node.\n   *\n   * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.\n   */\n  constructor(dirNode = positionWorldDirection) {\n    super('vec2');\n\n    /**\n     * A direction vector for sampling why is by default `positionWorldDirection`.\n     *\n     * @type {Node<vec3>}\n     */\n    this.dirNode = dirNode;\n  }\n  setup() {\n    const dir = this.dirNode;\n    const u = dir.z.atan(dir.x).mul(1 / (Math.PI * 2)).add(0.5);\n    const v = dir.y.clamp(-1.0, 1.0).asin().mul(1 / Math.PI).add(0.5);\n    return vec2(u, v);\n  }\n}\n\n/**\n * TSL function for creating an equirect uv node.\n *\n * @function\n * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.\n * @returns {EquirectUVNode}\n */\nconst equirectUV = /*@__PURE__*/nodeProxy(EquirectUVNode);\n\n// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget\n\n/**\n * This class represents a cube render target. It is a special version\n * of `WebGLCubeRenderTarget` which is compatible with `WebGPURenderer`.\n *\n * @augments WebGLCubeRenderTarget\n */\nclass CubeRenderTarget extends WebGLCubeRenderTarget {\n  constructor(size = 1, options = {}) {\n    super(size, options);\n    this.isCubeRenderTarget = true;\n  }\n\n  /**\n   * Converts the given equirectangular texture to a cube map.\n   *\n   * @param {Renderer} renderer - The renderer.\n   * @param {Texture} texture - The equirectangular texture.\n   * @return {CubeRenderTarget} A reference to this cube render target.\n   */\n  fromEquirectangularTexture(renderer, texture$1) {\n    const currentMinFilter = texture$1.minFilter;\n    const currentGenerateMipmaps = texture$1.generateMipmaps;\n    texture$1.generateMipmaps = true;\n    this.texture.type = texture$1.type;\n    this.texture.colorSpace = texture$1.colorSpace;\n    this.texture.generateMipmaps = texture$1.generateMipmaps;\n    this.texture.minFilter = texture$1.minFilter;\n    this.texture.magFilter = texture$1.magFilter;\n    const geometry = new BoxGeometry(5, 5, 5);\n    const uvNode = equirectUV(positionWorldDirection);\n    const material = new NodeMaterial();\n    material.colorNode = texture(texture$1, uvNode, 0);\n    material.side = BackSide;\n    material.blending = NoBlending;\n    const mesh = new Mesh(geometry, material);\n    const scene = new Scene();\n    scene.add(mesh);\n\n    // Avoid blurred poles\n    if (texture$1.minFilter === LinearMipmapLinearFilter) texture$1.minFilter = LinearFilter;\n    const camera = new CubeCamera(1, 10, this);\n    const currentMRT = renderer.getMRT();\n    renderer.setMRT(null);\n    camera.update(renderer, scene);\n    renderer.setMRT(currentMRT);\n    texture$1.minFilter = currentMinFilter;\n    texture$1.currentGenerateMipmaps = currentGenerateMipmaps;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n}\n\n/** @module CubeMapNode **/\n\nconst _cache$1 = new WeakMap();\n\n/**\n * This node can be used to automatically convert environment maps in the\n * equirectangular format into the cube map format.\n *\n * @augments TempNode\n */\nclass CubeMapNode extends TempNode {\n  static get type() {\n    return 'CubeMapNode';\n  }\n\n  /**\n   * Constructs a new cube map node.\n   *\n   * @param {Node} envNode - The node representing the environment map.\n   */\n  constructor(envNode) {\n    super('vec3');\n\n    /**\n     * The node representing the environment map.\n     *\n     * @type {Node}\n     */\n    this.envNode = envNode;\n\n    /**\n     * A reference to the internal cube texture.\n     *\n     * @private\n     * @type {CubeTexture}\n     * @default null\n     */\n    this._cubeTexture = null;\n\n    /**\n     * A reference to the internal cube texture node.\n     *\n     * @private\n     * @type {CubeTextureNode}\n     */\n    this._cubeTextureNode = cubeTexture();\n    const defaultTexture = new CubeTexture();\n    defaultTexture.isRenderTargetTexture = true;\n\n    /**\n     * A default cube texture that acts as a placeholder.\n     * It is used when the conversion from equirectangular to cube\n     * map has not finished yet for a given texture.\n     *\n     * @private\n     * @type {CubeTexture}\n     */\n    this._defaultTexture = defaultTexture;\n\n    /**\n     * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n     * the texture once per render in its {@link CubeMapNode#updateBefore} method.\n     *\n     * @type {String}\n     * @default 'render'\n     */\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  updateBefore(frame) {\n    const {\n      renderer,\n      material\n    } = frame;\n    const envNode = this.envNode;\n    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {\n      const texture = envNode.isTextureNode ? envNode.value : material[envNode.property];\n      if (texture && texture.isTexture) {\n        const mapping = texture.mapping;\n        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n          // check for converted cubemap map\n\n          if (_cache$1.has(texture)) {\n            const cubeMap = _cache$1.get(texture);\n            mapTextureMapping(cubeMap, texture.mapping);\n            this._cubeTexture = cubeMap;\n          } else {\n            // create cube map from equirectangular map\n\n            const image = texture.image;\n            if (isEquirectangularMapReady$1(image)) {\n              const renderTarget = new CubeRenderTarget(image.height);\n              renderTarget.fromEquirectangularTexture(renderer, texture);\n              mapTextureMapping(renderTarget.texture, texture.mapping);\n              this._cubeTexture = renderTarget.texture;\n              _cache$1.set(texture, renderTarget.texture);\n              texture.addEventListener('dispose', onTextureDispose);\n            } else {\n              // default cube texture as fallback when equirectangular texture is not yet loaded\n\n              this._cubeTexture = this._defaultTexture;\n            }\n          }\n\n          //\n\n          this._cubeTextureNode.value = this._cubeTexture;\n        } else {\n          // envNode already refers to a cube map\n\n          this._cubeTextureNode = this.envNode;\n        }\n      }\n    }\n  }\n  setup(builder) {\n    this.updateBefore(builder);\n    return this._cubeTextureNode;\n  }\n}\n\n/**\n * Returns true if the given equirectangular image has been fully loaded\n * and is ready for further processing.\n *\n * @private\n * @param {Image} image - The equirectangular image to check.\n * @return {Boolean} Whether the image is ready or not.\n */\nfunction isEquirectangularMapReady$1(image) {\n  if (image === null || image === undefined) return false;\n  return image.height > 0;\n}\n\n/**\n * This function is executed when `dispose()` is called on the equirectangular\n * texture. In this case, the generated cube map with its render target\n * is deleted as well.\n *\n * @private\n * @param {Object} event - The event object.\n */\nfunction onTextureDispose(event) {\n  const texture = event.target;\n  texture.removeEventListener('dispose', onTextureDispose);\n  const renderTarget = _cache$1.get(texture);\n  if (renderTarget !== undefined) {\n    _cache$1.delete(texture);\n    renderTarget.dispose();\n  }\n}\n\n/**\n * This function makes sure the generated cube map uses the correct\n * texture mapping that corresponds to the equirectangular original.\n *\n * @private\n * @param {Texture} texture - The cube texture.\n * @param {Number} mapping - The original texture mapping.\n */\nfunction mapTextureMapping(texture, mapping) {\n  if (mapping === EquirectangularReflectionMapping) {\n    texture.mapping = CubeReflectionMapping;\n  } else if (mapping === EquirectangularRefractionMapping) {\n    texture.mapping = CubeRefractionMapping;\n  }\n}\n\n/**\n * TSL function for creating a cube map node.\n *\n * @function\n * @param {Node} envNode - The node representing the environment map.\n * @returns {CubeMapNode}\n */\nconst cubeMapNode = /*@__PURE__*/nodeProxy(CubeMapNode);\n\n/**\n * Represents a basic model for Image-based lighting (IBL). The environment\n * is defined via environment maps in the equirectangular or cube map format.\n * `BasicEnvironmentNode` is intended for non-PBR materials like {@link MeshBasicNodeMaterial}\n * or {@link MeshPhongNodeMaterial}.\n *\n * @augments LightingNode\n */\nclass BasicEnvironmentNode extends LightingNode {\n  static get type() {\n    return 'BasicEnvironmentNode';\n  }\n\n  /**\n   * Constructs a new basic environment node.\n   *\n   * @param {Node} [envNode=null] - A node representing the environment.\n   */\n  constructor(envNode = null) {\n    super();\n\n    /**\n     * A node representing the environment.\n     *\n     * @type {Node}\n     * @default null\n     */\n    this.envNode = envNode;\n  }\n  setup(builder) {\n    // environment property is used in the finish() method of BasicLightingModel\n\n    builder.context.environment = cubeMapNode(this.envNode);\n  }\n}\n\n/**\n * A specific version of {@link IrradianceNode} that is only relevant\n * for {@link MeshBasicNodeMaterial}. Since the material is unlit, it\n * requires a special scaling factor for the light map.\n *\n * @augments LightingNode\n */\nclass BasicLightMapNode extends LightingNode {\n  static get type() {\n    return 'BasicLightMapNode';\n  }\n\n  /**\n   * Constructs a new basic light map node.\n   *\n   * @param {Node<vec3>?} [lightMapNode=null] - The light map node.\n   */\n  constructor(lightMapNode = null) {\n    super();\n\n    /**\n     * The light map node.\n     *\n     * @type {Node<vec3>?}\n     */\n    this.lightMapNode = lightMapNode;\n  }\n  setup(builder) {\n    // irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel\n\n    const RECIPROCAL_PI = float(1 / Math.PI);\n    builder.context.irradianceLightMap = this.lightMapNode.mul(RECIPROCAL_PI);\n  }\n}\n\n/**\n * Abstract class for implementing lighting models. The module defines\n * multiple methods that concrete lighting models can implement. These\n * methods are executed at different points during the light evaluation\n * process.\n */\nclass LightingModel {\n  /**\n   * This method is intended for setting up lighting model and context data\n   * which are later used in the evaluation process.\n   *\n   * @abstract\n   * @param {ContextNode} input - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  start(/*input, stack, builder*/) {}\n\n  /**\n   * This method is intended for executing final tasks like final updates\n   * to the outgoing light.\n   *\n   * @abstract\n   * @param {ContextNode} input - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  finish(/*input, stack, builder*/) {}\n\n  /**\n   * This method is intended for implementing the direct light term and\n   * executed during the build process of directional, point and spot light nodes.\n   *\n   * @abstract\n   * @param {Object} input - The input data.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  direct(/*input, stack, builder*/) {}\n\n  /**\n   * This method is intended for implementing the direct light term for\n   * rect area light nodes.\n   *\n   * @abstract\n   * @param {Object} input - The input data.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  directRectArea(/*input, stack, builder*/) {}\n\n  /**\n   * This method is intended for implementing the indirect light term.\n   *\n   * @abstract\n   * @param {ContextNode} input - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  indirect(/*input, stack, builder*/) {}\n\n  /**\n   * This method is intended for implementing the ambient occlusion term.\n   * Unlike other methods, this method must be called manually by the lighting\n   * model in its indirect term.\n   *\n   * @abstract\n   * @param {ContextNode} input - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  ambientOcclusion(/*input, stack, builder*/) {}\n}\n\n/**\n * Represents the lighting model for unlit materials. The only light contribution\n * is baked indirect lighting modulated with ambient occlusion and the material's\n * diffuse color. Environment mapping is supported. Used in {@link MeshBasicNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass BasicLightingModel extends LightingModel {\n  /**\n   * Constructs a new basic lighting model.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Implements the baked indirect lighting with its modulation.\n   *\n   * @param {ContextNode} context - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  indirect(context, stack, builder) {\n    const ambientOcclusion = context.ambientOcclusion;\n    const reflectedLight = context.reflectedLight;\n    const irradianceLightMap = builder.context.irradianceLightMap;\n    reflectedLight.indirectDiffuse.assign(vec4(0.0));\n\n    // accumulation (baked indirect lighting only)\n\n    if (irradianceLightMap) {\n      reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);\n    } else {\n      reflectedLight.indirectDiffuse.addAssign(vec4(1.0, 1.0, 1.0, 0.0));\n    }\n\n    // modulation\n\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n    reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb);\n  }\n\n  /**\n   * Implements the environment mapping.\n   *\n   * @param {ContextNode} context - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  finish(context, stack, builder) {\n    const material = builder.material;\n    const outgoingLight = context.outgoingLight;\n    const envNode = builder.context.environment;\n    if (envNode) {\n      switch (material.combine) {\n        case MultiplyOperation:\n          outgoingLight.rgb.assign(mix(outgoingLight.rgb, outgoingLight.rgb.mul(envNode.rgb), materialSpecularStrength.mul(materialReflectivity)));\n          break;\n        case MixOperation:\n          outgoingLight.rgb.assign(mix(outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul(materialReflectivity)));\n          break;\n        case AddOperation:\n          outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength.mul(materialReflectivity)));\n          break;\n        default:\n          console.warn('THREE.BasicLightingModel: Unsupported .combine value:', material.combine);\n          break;\n      }\n    }\n  }\n}\nconst _defaultValues$9 = /*@__PURE__*/new MeshBasicMaterial();\n\n/**\n * Node material version of `MeshBasicMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshBasicNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshBasicNodeMaterial';\n  }\n\n  /**\n   * Constructs a new mesh basic node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMeshBasicNodeMaterial = true;\n\n    /**\n     * Although the basic material is by definition unlit, we set\n     * this property to `true` since we use a lighting model to compute\n     * the outgoing light of the fragment shader.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.lights = true;\n    this.setDefaultValues(_defaultValues$9);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Basic materials are not affected by normal and bump maps so we\n   * return by default {@link module:Normal.normalView}.\n   *\n   * @return {Node<vec3>} The normal node.\n   */\n  setupNormal() {\n    return normalView; // see #28839\n  }\n\n  /**\n   * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n   * to implement the default environment mapping.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {BasicEnvironmentNode<vec3>?} The environment node.\n   */\n  setupEnvironment(builder) {\n    const envNode = super.setupEnvironment(builder);\n    return envNode ? new BasicEnvironmentNode(envNode) : null;\n  }\n\n  /**\n   * This method must be overwriten since light maps are evaluated\n   * with a special scaling factor for basic materials.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {BasicLightMapNode<vec3>?} The light map node.\n   */\n  setupLightMap(builder) {\n    let node = null;\n    if (builder.material.lightMap) {\n      node = new BasicLightMapNode(materialLightMap);\n    }\n    return node;\n  }\n\n  /**\n   * The material overwrites this method because `lights` is set to `true` but\n   * we still want to return the diffuse color as the outgoing light.\n   *\n   * @return {Node<vec3>} The outgoing light node.\n   */\n  setupOutgoingLight() {\n    return diffuseColor.rgb;\n  }\n\n  /**\n   * Setups the lighting model.\n   *\n   * @return {BasicLightingModel} The lighting model.\n   */\n  setupLightingModel() {\n    return new BasicLightingModel();\n  }\n}\nconst F_Schlick = /*@__PURE__*/Fn(({\n  f0,\n  f90,\n  dotVH\n}) => {\n  // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();\n  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));\n}); // validated\n\nconst BRDF_Lambert = /*@__PURE__*/Fn(inputs => {\n  return inputs.diffuseColor.mul(1 / Math.PI); // punctual light\n}); // validated\n\nconst G_BlinnPhong_Implicit = () => float(0.25);\nconst D_BlinnPhong = /*@__PURE__*/Fn(({\n  dotNH\n}) => {\n  return shininess.mul(float(0.5)).add(1.0).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));\n});\nconst BRDF_BlinnPhong = /*@__PURE__*/Fn(({\n  lightDirection\n}) => {\n  const halfDir = lightDirection.add(positionViewDirection).normalize();\n  const dotNH = transformedNormalView.dot(halfDir).clamp();\n  const dotVH = positionViewDirection.dot(halfDir).clamp();\n  const F = F_Schlick({\n    f0: specularColor,\n    f90: 1.0,\n    dotVH\n  });\n  const G = G_BlinnPhong_Implicit();\n  const D = D_BlinnPhong({\n    dotNH\n  });\n  return F.mul(G).mul(D);\n});\n\n/**\n * Represents the lighting model for a phong material. Used in {@link MeshPhongNodeMaterial}.\n *\n * @augments BasicLightingModel\n */\nclass PhongLightingModel extends BasicLightingModel {\n  /**\n   * Constructs a new phong lighting model.\n   *\n   * @param {Boolean} [specular=true] - Whether specular is supported or not.\n   */\n  constructor(specular = true) {\n    super();\n\n    /**\n     * Whether specular is supported or not. Set this to `false` if you are\n     * looking for a Lambert-like material meaning a material for non-shiny\n     * surfaces, without specular highlights.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.specular = specular;\n  }\n\n  /**\n   * Implements the direct lighting. The specular portion is optional an can be controlled\n   * with the {@link PhongLightingModel#specular} flag.\n   *\n   * @param {Object} input - The input data.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }) {\n    const dotNL = transformedNormalView.dot(lightDirection).clamp();\n    const irradiance = dotNL.mul(lightColor);\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n    if (this.specular === true) {\n      reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({\n        lightDirection\n      })).mul(materialSpecularStrength));\n    }\n  }\n\n  /**\n   * Implements the indirect lighting.\n   *\n   * @param {ContextNode} input - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  indirect({\n    ambientOcclusion,\n    irradiance,\n    reflectedLight\n  }) {\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n  }\n}\nconst _defaultValues$8 = /*@__PURE__*/new MeshLambertMaterial();\n\n/**\n * Node material version of `MeshLambertMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshLambertNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshLambertNodeMaterial';\n  }\n\n  /**\n   * Constructs a new mesh lambert node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMeshLambertNodeMaterial = true;\n\n    /**\n     * Set to `true` because lambert materials react on lights.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.lights = true;\n    this.setDefaultValues(_defaultValues$8);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n   * to implement the default environment mapping.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {BasicEnvironmentNode<vec3>?} The environment node.\n   */\n  setupEnvironment(builder) {\n    const envNode = super.setupEnvironment(builder);\n    return envNode ? new BasicEnvironmentNode(envNode) : null;\n  }\n\n  /**\n   * Setups the lighting model.\n   *\n   * @return {PhongLightingModel} The lighting model.\n   */\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhongLightingModel(false); // ( specular ) -> force lambert\n  }\n}\nconst _defaultValues$7 = /*@__PURE__*/new MeshPhongMaterial();\n\n/**\n * Node material version of `MeshPhongMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshPhongNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshPhongNodeMaterial';\n  }\n\n  /**\n   * Constructs a new mesh lambert node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMeshPhongNodeMaterial = true;\n\n    /**\n     * Set to `true` because phong materials react on lights.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.lights = true;\n\n    /**\n     * The shininess of phong materials is by default inferred from the `shininess`\n     * property. This node property allows to overwrite the default\n     * and define the shininess with a node instead.\n     *\n     * If you don't want to overwrite the shininess but modify the existing\n     * value instead, use {@link module:MaterialNode.materialShininess}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.shininessNode = null;\n\n    /**\n     * The specular color of phong materials is by default inferred from the\n     * `specular` property. This node property allows to overwrite the default\n     * and define the specular color with a node instead.\n     *\n     * If you don't want to overwrite the specular color but modify the existing\n     * value instead, use {@link module:MaterialNode.materialSpecular}.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.specularNode = null;\n    this.setDefaultValues(_defaultValues$7);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n   * to implement the default environment mapping.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {BasicEnvironmentNode<vec3>?} The environment node.\n   */\n  setupEnvironment(builder) {\n    const envNode = super.setupEnvironment(builder);\n    return envNode ? new BasicEnvironmentNode(envNode) : null;\n  }\n\n  /**\n   * Setups the lighting model.\n   *\n   * @return {PhongLightingModel} The lighting model.\n   */\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhongLightingModel();\n  }\n\n  /**\n   * Setups the phong specific node variables.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setupVariants(/*builder*/\n  ) {\n    // SHININESS\n\n    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4); // to prevent pow( 0.0, 0.0 )\n\n    shininess.assign(shininessNode);\n\n    // SPECULAR COLOR\n\n    const specularNode = this.specularNode || materialSpecular;\n    specularColor.assign(specularNode);\n  }\n  copy(source) {\n    this.shininessNode = source.shininessNode;\n    this.specularNode = source.specularNode;\n    return super.copy(source);\n  }\n}\nconst getGeometryRoughness = /*@__PURE__*/Fn(builder => {\n  if (builder.geometry.hasAttribute('normal') === false) {\n    return float(0);\n  }\n  const dxy = normalView.dFdx().abs().max(normalView.dFdy().abs());\n  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);\n  return geometryRoughness;\n});\nconst getRoughness = /*@__PURE__*/Fn(inputs => {\n  const {\n    roughness\n  } = inputs;\n  const geometryRoughness = getGeometryRoughness();\n  let roughnessFactor = roughness.max(0.0525); // 0.0525 corresponds to the base mip of a 256 cubemap.\n  roughnessFactor = roughnessFactor.add(geometryRoughness);\n  roughnessFactor = roughnessFactor.min(1.0);\n  return roughnessFactor;\n});\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = /*@__PURE__*/Fn(({\n  alpha,\n  dotNL,\n  dotNV\n}) => {\n  const a2 = alpha.pow2();\n  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());\n  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());\n  return div(0.5, gv.add(gl).max(EPSILON));\n}).setLayout({\n  name: 'V_GGX_SmithCorrelated',\n  type: 'float',\n  inputs: [{\n    name: 'alpha',\n    type: 'float'\n  }, {\n    name: 'dotNL',\n    type: 'float'\n  }, {\n    name: 'dotNV',\n    type: 'float'\n  }]\n}); // validated\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/Fn(({\n  alphaT,\n  alphaB,\n  dotTV,\n  dotBV,\n  dotTL,\n  dotBL,\n  dotNV,\n  dotNL\n}) => {\n  const gv = dotNL.mul(vec3(alphaT.mul(dotTV), alphaB.mul(dotBV), dotNV).length());\n  const gl = dotNV.mul(vec3(alphaT.mul(dotTL), alphaB.mul(dotBL), dotNL).length());\n  const v = div(0.5, gv.add(gl));\n  return v.saturate();\n}).setLayout({\n  name: 'V_GGX_SmithCorrelated_Anisotropic',\n  type: 'float',\n  inputs: [{\n    name: 'alphaT',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'alphaB',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotTV',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotBV',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotTL',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotBL',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotNV',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotNL',\n    type: 'float',\n    qualifier: 'in'\n  }]\n});\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney\u2019s reparameterization\nconst D_GGX = /*@__PURE__*/Fn(({\n  alpha,\n  dotNH\n}) => {\n  const a2 = alpha.pow2();\n  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus(); // avoid alpha = 0 with dotNH = 1\n\n  return a2.div(denom.pow2()).mul(1 / Math.PI);\n}).setLayout({\n  name: 'D_GGX',\n  type: 'float',\n  inputs: [{\n    name: 'alpha',\n    type: 'float'\n  }, {\n    name: 'dotNH',\n    type: 'float'\n  }]\n}); // validated\n\nconst RECIPROCAL_PI = /*@__PURE__*/float(1 / Math.PI);\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst D_GGX_Anisotropic = /*@__PURE__*/Fn(({\n  alphaT,\n  alphaB,\n  dotNH,\n  dotTH,\n  dotBH\n}) => {\n  const a2 = alphaT.mul(alphaB);\n  const v = vec3(alphaB.mul(dotTH), alphaT.mul(dotBH), a2.mul(dotNH));\n  const v2 = v.dot(v);\n  const w2 = a2.div(v2);\n  return RECIPROCAL_PI.mul(a2.mul(w2.pow2()));\n}).setLayout({\n  name: 'D_GGX_Anisotropic',\n  type: 'float',\n  inputs: [{\n    name: 'alphaT',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'alphaB',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotNH',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotTH',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotBH',\n    type: 'float',\n    qualifier: 'in'\n  }]\n});\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = /*@__PURE__*/Fn(inputs => {\n  const {\n    lightDirection,\n    f0,\n    f90,\n    roughness,\n    f,\n    USE_IRIDESCENCE,\n    USE_ANISOTROPY\n  } = inputs;\n  const normalView = inputs.normalView || transformedNormalView;\n  const alpha = roughness.pow2(); // UE4's roughness\n\n  const halfDir = lightDirection.add(positionViewDirection).normalize();\n  const dotNL = normalView.dot(lightDirection).clamp();\n  const dotNV = normalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n  const dotNH = normalView.dot(halfDir).clamp();\n  const dotVH = positionViewDirection.dot(halfDir).clamp();\n  let F = F_Schlick({\n    f0,\n    f90,\n    dotVH\n  });\n  let V, D;\n  if (defined(USE_IRIDESCENCE)) {\n    F = iridescence.mix(F, f);\n  }\n  if (defined(USE_ANISOTROPY)) {\n    const dotTL = anisotropyT.dot(lightDirection);\n    const dotTV = anisotropyT.dot(positionViewDirection);\n    const dotTH = anisotropyT.dot(halfDir);\n    const dotBL = anisotropyB.dot(lightDirection);\n    const dotBV = anisotropyB.dot(positionViewDirection);\n    const dotBH = anisotropyB.dot(halfDir);\n    V = V_GGX_SmithCorrelated_Anisotropic({\n      alphaT,\n      alphaB: alpha,\n      dotTV,\n      dotBV,\n      dotTL,\n      dotBL,\n      dotNV,\n      dotNL\n    });\n    D = D_GGX_Anisotropic({\n      alphaT,\n      alphaB: alpha,\n      dotNH,\n      dotTH,\n      dotBH\n    });\n  } else {\n    V = V_GGX_SmithCorrelated({\n      alpha,\n      dotNL,\n      dotNV\n    });\n    D = D_GGX({\n      alpha,\n      dotNH\n    });\n  }\n  return F.mul(V).mul(D);\n}); // validated\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nconst DFGApprox = /*@__PURE__*/Fn(({\n  roughness,\n  dotNV\n}) => {\n  const c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const c1 = vec4(1, 0.0425, 1.04, -0.04);\n  const r = roughness.mul(c0).add(c1);\n  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);\n  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);\n  return fab;\n}).setLayout({\n  name: 'DFGApprox',\n  type: 'vec2',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }, {\n    name: 'dotNV',\n    type: 'vec3'\n  }]\n});\nconst EnvironmentBRDF = /*@__PURE__*/Fn(inputs => {\n  const {\n    dotNV,\n    specularColor,\n    specularF90,\n    roughness\n  } = inputs;\n  const fab = DFGApprox({\n    dotNV,\n    roughness\n  });\n  return specularColor.mul(fab.x).add(specularF90.mul(fab.y));\n});\nconst Schlick_to_F0 = /*@__PURE__*/Fn(({\n  f,\n  f90,\n  dotVH\n}) => {\n  const x = dotVH.oneMinus().saturate();\n  const x2 = x.mul(x);\n  const x5 = x.mul(x2, x2).clamp(0, .9999);\n  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());\n}).setLayout({\n  name: 'Schlick_to_F0',\n  type: 'vec3',\n  inputs: [{\n    name: 'f',\n    type: 'vec3'\n  }, {\n    name: 'f90',\n    type: 'float'\n  }, {\n    name: 'dotVH',\n    type: 'float'\n  }]\n});\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst D_Charlie = /*@__PURE__*/Fn(({\n  roughness,\n  dotNH\n}) => {\n  const alpha = roughness.pow2();\n\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  const invAlpha = float(1.0).div(alpha);\n  const cos2h = dotNH.pow2();\n  const sin2h = cos2h.oneMinus().max(0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n  return float(2.0).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2.0 * Math.PI);\n}).setLayout({\n  name: 'D_Charlie',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }, {\n    name: 'dotNH',\n    type: 'float'\n  }]\n});\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst V_Neubelt = /*@__PURE__*/Fn(({\n  dotNV,\n  dotNL\n}) => {\n  // Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n  return float(1.0).div(float(4.0).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));\n}).setLayout({\n  name: 'V_Neubelt',\n  type: 'float',\n  inputs: [{\n    name: 'dotNV',\n    type: 'float'\n  }, {\n    name: 'dotNL',\n    type: 'float'\n  }]\n});\nconst BRDF_Sheen = /*@__PURE__*/Fn(({\n  lightDirection\n}) => {\n  const halfDir = lightDirection.add(positionViewDirection).normalize();\n  const dotNL = transformedNormalView.dot(lightDirection).clamp();\n  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();\n  const dotNH = transformedNormalView.dot(halfDir).clamp();\n  const D = D_Charlie({\n    roughness: sheenRoughness,\n    dotNH\n  });\n  const V = V_Neubelt({\n    dotNV,\n    dotNL\n  });\n  return sheen.mul(D).mul(V);\n});\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nconst LTC_Uv = /*@__PURE__*/Fn(({\n  N,\n  V,\n  roughness\n}) => {\n  const LUT_SIZE = 64.0;\n  const LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;\n  const LUT_BIAS = 0.5 / LUT_SIZE;\n  const dotNV = N.dot(V).saturate();\n\n  // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n  const uv = vec2(roughness, dotNV.oneMinus().sqrt());\n  uv.assign(uv.mul(LUT_SCALE).add(LUT_BIAS));\n  return uv;\n}).setLayout({\n  name: 'LTC_Uv',\n  type: 'vec2',\n  inputs: [{\n    name: 'N',\n    type: 'vec3'\n  }, {\n    name: 'V',\n    type: 'vec3'\n  }, {\n    name: 'roughness',\n    type: 'float'\n  }]\n});\nconst LTC_ClippedSphereFormFactor = /*@__PURE__*/Fn(({\n  f\n}) => {\n  // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n  // An approximation of the form factor of a horizon-clipped rectangle.\n\n  const l = f.length();\n  return max$1(l.mul(l).add(f.z).div(l.add(1.0)), 0);\n}).setLayout({\n  name: 'LTC_ClippedSphereFormFactor',\n  type: 'float',\n  inputs: [{\n    name: 'f',\n    type: 'vec3'\n  }]\n});\nconst LTC_EdgeVectorFormFactor = /*@__PURE__*/Fn(({\n  v1,\n  v2\n}) => {\n  const x = v1.dot(v2);\n  const y = x.abs().toVar();\n\n  // rational polynomial approximation to theta / sin( theta ) / 2PI\n  const a = y.mul(0.0145206).add(0.4965155).mul(y).add(0.8543985).toVar();\n  const b = y.add(4.1616724).mul(y).add(3.4175940).toVar();\n  const v = a.div(b);\n  const theta_sintheta = x.greaterThan(0.0).select(v, max$1(x.mul(x).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v));\n  return v1.cross(v2).mul(theta_sintheta);\n}).setLayout({\n  name: 'LTC_EdgeVectorFormFactor',\n  type: 'vec3',\n  inputs: [{\n    name: 'v1',\n    type: 'vec3'\n  }, {\n    name: 'v2',\n    type: 'vec3'\n  }]\n});\nconst LTC_Evaluate = /*@__PURE__*/Fn(({\n  N,\n  V,\n  P,\n  mInv,\n  p0,\n  p1,\n  p2,\n  p3\n}) => {\n  // bail if point is on back side of plane of light\n  // assumes ccw winding order of light vertices\n  const v1 = p1.sub(p0).toVar();\n  const v2 = p3.sub(p0).toVar();\n  const lightNormal = v1.cross(v2);\n  const result = vec3().toVar();\n  If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0.0), () => {\n    // construct orthonormal basis around N\n    const T1 = V.sub(N.mul(V.dot(N))).normalize();\n    const T2 = N.cross(T1).negate(); // negated from paper; possibly due to a different handedness of world coordinate system\n\n    // compute transform\n    const mat = mInv.mul(mat3(T1, T2, N).transpose()).toVar();\n\n    // transform rect\n    // & project rect onto sphere\n    const coords0 = mat.mul(p0.sub(P)).normalize().toVar();\n    const coords1 = mat.mul(p1.sub(P)).normalize().toVar();\n    const coords2 = mat.mul(p2.sub(P)).normalize().toVar();\n    const coords3 = mat.mul(p3.sub(P)).normalize().toVar();\n\n    // calculate vector form factor\n    const vectorFormFactor = vec3(0).toVar();\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords0,\n      v2: coords1\n    }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords1,\n      v2: coords2\n    }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords2,\n      v2: coords3\n    }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords3,\n      v2: coords0\n    }));\n\n    // adjust for horizon clipping\n    result.assign(vec3(LTC_ClippedSphereFormFactor({\n      f: vectorFormFactor\n    })));\n  });\n  return result;\n}).setLayout({\n  name: 'LTC_Evaluate',\n  type: 'vec3',\n  inputs: [{\n    name: 'N',\n    type: 'vec3'\n  }, {\n    name: 'V',\n    type: 'vec3'\n  }, {\n    name: 'P',\n    type: 'vec3'\n  }, {\n    name: 'mInv',\n    type: 'mat3'\n  }, {\n    name: 'p0',\n    type: 'vec3'\n  }, {\n    name: 'p1',\n    type: 'vec3'\n  }, {\n    name: 'p2',\n    type: 'vec3'\n  }, {\n    name: 'p3',\n    type: 'vec3'\n  }]\n});\n\n/** @module TextureBicubic **/\n\n// Mipped Bicubic Texture Filtering by N8\n// https://www.shadertoy.com/view/Dl2SDW\n\nconst bC = 1.0 / 6.0;\nconst w0 = a => mul(bC, mul(a, mul(a, a.negate().add(3.0)).sub(3.0)).add(1.0));\nconst w1 = a => mul(bC, mul(a, mul(a, mul(3.0, a).sub(6.0))).add(4.0));\nconst w2 = a => mul(bC, mul(a, mul(a, mul(-3.0, a).add(3.0)).add(3.0)).add(1.0));\nconst w3 = a => mul(bC, pow(a, 3));\nconst g0 = a => w0(a).add(w1(a));\nconst g1 = a => w2(a).add(w3(a));\n\n// h0 and h1 are the two offset functions\nconst h0 = a => add(-1.0, w1(a).div(w0(a).add(w1(a))));\nconst h1 = a => add(1.0, w3(a).div(w2(a).add(w3(a))));\nconst bicubic = (textureNode, texelSize, lod) => {\n  const uv = textureNode.uvNode;\n  const uvScaled = mul(uv, texelSize.zw).add(0.5);\n  const iuv = floor(uvScaled);\n  const fuv = fract(uvScaled);\n  const g0x = g0(fuv.x);\n  const g1x = g1(fuv.x);\n  const h0x = h0(fuv.x);\n  const h1x = h1(fuv.x);\n  const h0y = h0(fuv.y);\n  const h1y = h1(fuv.y);\n  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);\n  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);\n  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);\n  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);\n  const a = g0(fuv.y).mul(add(g0x.mul(textureNode.sample(p0).level(lod)), g1x.mul(textureNode.sample(p1).level(lod))));\n  const b = g1(fuv.y).mul(add(g0x.mul(textureNode.sample(p2).level(lod)), g1x.mul(textureNode.sample(p3).level(lod))));\n  return a.add(b);\n};\n\n/**\n * Applies mipped bicubic texture filtering to the given texture node.\n *\n * @method\n * @param {TextureNode} textureNode - The texture node that should be filtered.\n * @param {Node<float>} [lodNode=float(3)] - Defines the LOD to sample from.\n * @return {Node} The filtered texture sample.\n */\nconst textureBicubic = /*@__PURE__*/Fn(([textureNode, lodNode = float(3)]) => {\n  const fLodSize = vec2(textureNode.size(int(lodNode)));\n  const cLodSize = vec2(textureNode.size(int(lodNode.add(1.0))));\n  const fLodSizeInv = div(1.0, fLodSize);\n  const cLodSizeInv = div(1.0, cLodSize);\n  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));\n  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));\n  return fract(lodNode).mix(fSample, cSample);\n});\n\n//\n// Transmission\n//\n\nconst getVolumeTransmissionRay = /*@__PURE__*/Fn(([n, v, thickness, ior, modelMatrix]) => {\n  // Direction of refracted light.\n  const refractionVector = vec3(refract(v.negate(), normalize(n), div(1.0, ior)));\n\n  // Compute rotation-independent scaling of the model matrix.\n  const modelScale = vec3(length(modelMatrix[0].xyz), length(modelMatrix[1].xyz), length(modelMatrix[2].xyz));\n\n  // The thickness is specified in local space.\n  return normalize(refractionVector).mul(thickness.mul(modelScale));\n}).setLayout({\n  name: 'getVolumeTransmissionRay',\n  type: 'vec3',\n  inputs: [{\n    name: 'n',\n    type: 'vec3'\n  }, {\n    name: 'v',\n    type: 'vec3'\n  }, {\n    name: 'thickness',\n    type: 'float'\n  }, {\n    name: 'ior',\n    type: 'float'\n  }, {\n    name: 'modelMatrix',\n    type: 'mat4'\n  }]\n});\nconst applyIorToRoughness = /*@__PURE__*/Fn(([roughness, ior]) => {\n  // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n  // an IOR of 1.5 results in the default amount of microfacet refraction.\n  return roughness.mul(clamp(ior.mul(2.0).sub(2.0), 0.0, 1.0));\n}).setLayout({\n  name: 'applyIorToRoughness',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }, {\n    name: 'ior',\n    type: 'float'\n  }]\n});\nconst viewportBackSideTexture = /*@__PURE__*/viewportMipTexture();\nconst viewportFrontSideTexture = /*@__PURE__*/viewportMipTexture();\nconst getTransmissionSample = /*@__PURE__*/Fn(([fragCoord, roughness, ior], {\n  material\n}) => {\n  const vTexture = material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture;\n  const transmissionSample = vTexture.sample(fragCoord);\n  //const transmissionSample = viewportMipTexture( fragCoord );\n\n  const lod = log2(screenSize.x).mul(applyIorToRoughness(roughness, ior));\n  return textureBicubic(transmissionSample, lod);\n});\nconst volumeAttenuation = /*@__PURE__*/Fn(([transmissionDistance, attenuationColor, attenuationDistance]) => {\n  If(attenuationDistance.notEqual(0), () => {\n    // Compute light attenuation using Beer's law.\n    const attenuationCoefficient = log(attenuationColor).negate().div(attenuationDistance);\n    const transmittance = exp(attenuationCoefficient.negate().mul(transmissionDistance));\n    return transmittance;\n  });\n\n  // Attenuation distance is +\u221E, i.e. the transmitted color is not attenuated at all.\n  return vec3(1.0);\n}).setLayout({\n  name: 'volumeAttenuation',\n  type: 'vec3',\n  inputs: [{\n    name: 'transmissionDistance',\n    type: 'float'\n  }, {\n    name: 'attenuationColor',\n    type: 'vec3'\n  }, {\n    name: 'attenuationDistance',\n    type: 'float'\n  }]\n});\nconst getIBLVolumeRefraction = /*@__PURE__*/Fn(([n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion]) => {\n  let transmittedLight, transmittance;\n  if (dispersion) {\n    transmittedLight = vec4().toVar();\n    transmittance = vec3().toVar();\n    const halfSpread = ior.sub(1.0).mul(dispersion.mul(0.025));\n    const iors = vec3(ior.sub(halfSpread), ior, ior.add(halfSpread));\n    Loop({\n      start: 0,\n      end: 3\n    }, ({\n      i\n    }) => {\n      const ior = iors.element(i);\n      const transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n      const refractedRayExit = position.add(transmissionRay);\n\n      // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n      const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));\n      const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();\n      refractionCoords.addAssign(1.0);\n      refractionCoords.divAssign(2.0);\n      refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu\n\n      // Sample framebuffer to get pixel the refracted ray hits.\n      const transmissionSample = getTransmissionSample(refractionCoords, roughness, ior);\n      transmittedLight.element(i).assign(transmissionSample.element(i));\n      transmittedLight.a.addAssign(transmissionSample.a);\n      transmittance.element(i).assign(diffuseColor.element(i).mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance).element(i)));\n    });\n    transmittedLight.a.divAssign(3.0);\n  } else {\n    const transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n    const refractedRayExit = position.add(transmissionRay);\n\n    // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n    const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));\n    const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();\n    refractionCoords.addAssign(1.0);\n    refractionCoords.divAssign(2.0);\n    refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu\n\n    // Sample framebuffer to get pixel the refracted ray hits.\n    transmittedLight = getTransmissionSample(refractionCoords, roughness, ior);\n    transmittance = diffuseColor.mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance));\n  }\n  const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);\n  const dotNV = n.dot(v).clamp();\n\n  // Get the specular component.\n  const F = vec3(EnvironmentBRDF({\n    // n, v, specularColor, specularF90, roughness\n    dotNV,\n    specularColor,\n    specularF90,\n    roughness\n  }));\n\n  // As less light is transmitted, the opacity should be increased. This simple approximation does a decent job\n  // of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.\n  const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3.0);\n  return vec4(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());\n});\n\n//\n// Iridescence\n//\n\n// XYZ to linear-sRGB color space\nconst XYZ_TO_REC709 = /*@__PURE__*/mat3(3.2404542, -0.9692660, 0.0556434, -1.5371385, 1.8760108, -0.2040259, -0.4985314, 0.0415560, 1.0572252);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nconst Fresnel0ToIor = fresnel0 => {\n  const sqrtF0 = fresnel0.sqrt();\n  return vec3(1.0).add(sqrtF0).div(vec3(1.0).sub(sqrtF0));\n};\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nconst IorToFresnel0 = (transmittedIor, incidentIor) => {\n  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();\n};\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nconst evalSensitivity = (OPD, shift) => {\n  const phase = OPD.mul(2.0 * Math.PI * 1.0e-9);\n  const val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n  const pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n  const VAR = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n  const x = float(9.7470e-14 * Math.sqrt(2.0 * Math.PI * 4.5282e+09)).mul(phase.mul(2.2399e+06).add(shift.x).cos()).mul(phase.pow2().mul(-4.5282e+09).exp());\n  let xyz = val.mul(VAR.mul(2.0 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());\n  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(1.0685e-7);\n  const rgb = XYZ_TO_REC709.mul(xyz);\n  return rgb;\n};\nconst evalIridescence = /*@__PURE__*/Fn(({\n  outsideIOR,\n  eta2,\n  cosTheta1,\n  thinFilmThickness,\n  baseF0\n}) => {\n  // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n  const iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n  // Evaluate the cosTheta on the base layer (Snell law)\n  const sinTheta2Sq = outsideIOR.div(iridescenceIOR).pow2().mul(cosTheta1.pow2().oneMinus());\n\n  // Handle TIR:\n  const cosTheta2Sq = sinTheta2Sq.oneMinus();\n  If(cosTheta2Sq.lessThan(0), () => {\n    return vec3(1.0);\n  });\n  const cosTheta2 = cosTheta2Sq.sqrt();\n\n  // First interface\n  const R0 = IorToFresnel0(iridescenceIOR, outsideIOR);\n  const R12 = F_Schlick({\n    f0: R0,\n    f90: 1.0,\n    dotVH: cosTheta1\n  });\n  //const R21 = R12;\n  const T121 = R12.oneMinus();\n  const phi12 = iridescenceIOR.lessThan(outsideIOR).select(Math.PI, 0.0);\n  const phi21 = float(Math.PI).sub(phi12);\n\n  // Second interface\n  const baseIOR = Fresnel0ToIor(baseF0.clamp(0.0, 0.9999)); // guard against 1.0\n  const R1 = IorToFresnel0(baseIOR, iridescenceIOR.toVec3());\n  const R23 = F_Schlick({\n    f0: R1,\n    f90: 1.0,\n    dotVH: cosTheta2\n  });\n  const phi23 = vec3(baseIOR.x.lessThan(iridescenceIOR).select(Math.PI, 0.0), baseIOR.y.lessThan(iridescenceIOR).select(Math.PI, 0.0), baseIOR.z.lessThan(iridescenceIOR).select(Math.PI, 0.0));\n\n  // Phase shift\n  const OPD = iridescenceIOR.mul(thinFilmThickness, cosTheta2, 2.0);\n  const phi = vec3(phi21).add(phi23);\n\n  // Compound terms\n  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);\n  const r123 = R123.sqrt();\n  const Rs = T121.pow2().mul(R23).div(vec3(1.0).sub(R123));\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  const C0 = R12.add(Rs);\n  const I = C0.toVar();\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  const Cm = Rs.sub(T121).toVar();\n  Loop({\n    start: 1,\n    end: 2,\n    condition: '<=',\n    name: 'm'\n  }, ({\n    m\n  }) => {\n    Cm.mulAssign(r123);\n    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2.0);\n    I.addAssign(Cm.mul(Sm));\n  });\n\n  // Since out of gamut colors might be produced, negative color values are clamped to 0.\n  return I.max(vec3(0.0));\n}).setLayout({\n  name: 'evalIridescence',\n  type: 'vec3',\n  inputs: [{\n    name: 'outsideIOR',\n    type: 'float'\n  }, {\n    name: 'eta2',\n    type: 'float'\n  }, {\n    name: 'cosTheta1',\n    type: 'float'\n  }, {\n    name: 'thinFilmThickness',\n    type: 'float'\n  }, {\n    name: 'baseF0',\n    type: 'vec3'\n  }]\n});\n\n//\n//\tSheen\n//\n\n// This is a curve-fit approximation to the \"Charlie sheen\" BRDF integrated over the hemisphere from\n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nconst IBLSheenBRDF = /*@__PURE__*/Fn(({\n  normal,\n  viewDir,\n  roughness\n}) => {\n  const dotNV = normal.dot(viewDir).saturate();\n  const r2 = roughness.pow2();\n  const a = select(roughness.lessThan(0.25), float(-339.2).mul(r2).add(float(161.4).mul(roughness)).sub(25.9), float(-8.48).mul(r2).add(float(14.3).mul(roughness)).sub(9.95));\n  const b = select(roughness.lessThan(0.25), float(44.0).mul(r2).sub(float(23.7).mul(roughness)).add(3.26), float(1.97).mul(r2).sub(float(3.27).mul(roughness)).add(0.72));\n  const DG = select(roughness.lessThan(0.25), 0.0, float(0.1).mul(roughness).sub(0.025)).add(a.mul(dotNV).add(b).exp());\n  return DG.mul(1.0 / Math.PI).saturate();\n});\nconst clearcoatF0 = vec3(0.04);\nconst clearcoatF90 = float(1);\n\n/**\n * Represents the lighting model for a PBR material.\n *\n * @augments LightingModel\n */\nclass PhysicalLightingModel extends LightingModel {\n  /**\n   * Constructs a new physical lighting model.\n   *\n   * @param {Boolean} [clearcoat=false] - Whether clearcoat is supported or not.\n   * @param {Boolean} [sheen=false] - Whether sheen is supported or not.\n   * @param {Boolean} [iridescence=false] - Whether iridescence is supported or not.\n   * @param {Boolean} [anisotropy=false] - Whether anisotropy is supported or not.\n   * @param {Boolean} [transmission=false] - Whether transmission is supported or not.\n   * @param {Boolean} [dispersion=false] - Whether dispersion is supported or not.\n   */\n  constructor(clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false) {\n    super();\n\n    /**\n     * Whether clearcoat is supported or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.clearcoat = clearcoat;\n\n    /**\n     * Whether sheen is supported or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.sheen = sheen;\n\n    /**\n     * Whether iridescence is supported or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.iridescence = iridescence;\n\n    /**\n     * Whether anisotropy is supported or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.anisotropy = anisotropy;\n\n    /**\n     * Whether transmission is supported or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.transmission = transmission;\n\n    /**\n     * Whether dispersion is supported or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.dispersion = dispersion;\n\n    /**\n     * The clear coat radiance.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.clearcoatRadiance = null;\n\n    /**\n     * The clear coat specular direct.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.clearcoatSpecularDirect = null;\n\n    /**\n     * The clear coat specular indirect.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.clearcoatSpecularIndirect = null;\n\n    /**\n     * The sheen specular direct.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.sheenSpecularDirect = null;\n\n    /**\n     * The sheen specular indirect.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.sheenSpecularIndirect = null;\n\n    /**\n     * The iridescence Fresnel.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.iridescenceFresnel = null;\n\n    /**\n     * The iridescence F0.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.iridescenceF0 = null;\n  }\n\n  /**\n   * Depending on what features are requested, the method prepares certain node variables\n   * which are later used for lighting computations.\n   *\n   * @param {ContextNode} context - The current node context.\n   */\n  start(context) {\n    if (this.clearcoat === true) {\n      this.clearcoatRadiance = vec3().toVar('clearcoatRadiance');\n      this.clearcoatSpecularDirect = vec3().toVar('clearcoatSpecularDirect');\n      this.clearcoatSpecularIndirect = vec3().toVar('clearcoatSpecularIndirect');\n    }\n    if (this.sheen === true) {\n      this.sheenSpecularDirect = vec3().toVar('sheenSpecularDirect');\n      this.sheenSpecularIndirect = vec3().toVar('sheenSpecularIndirect');\n    }\n    if (this.iridescence === true) {\n      const dotNVi = transformedNormalView.dot(positionViewDirection).clamp();\n      this.iridescenceFresnel = evalIridescence({\n        outsideIOR: float(1.0),\n        eta2: iridescenceIOR,\n        cosTheta1: dotNVi,\n        thinFilmThickness: iridescenceThickness,\n        baseF0: specularColor\n      });\n      this.iridescenceF0 = Schlick_to_F0({\n        f: this.iridescenceFresnel,\n        f90: 1.0,\n        dotVH: dotNVi\n      });\n    }\n    if (this.transmission === true) {\n      const position = positionWorld;\n      const v = cameraPosition.sub(positionWorld).normalize(); // TODO: Create Node for this, same issue in MaterialX\n      const n = transformedNormalWorld;\n      context.backdrop = getIBLVolumeRefraction(n, v, roughness, diffuseColor, specularColor, specularF90,\n      // specularF90\n      position,\n      // positionWorld\n      modelWorldMatrix,\n      // modelMatrix\n      cameraViewMatrix,\n      // viewMatrix\n      cameraProjectionMatrix,\n      // projMatrix\n      ior, thickness, attenuationColor, attenuationDistance, this.dispersion ? dispersion : null);\n      context.backdropAlpha = transmission;\n      diffuseColor.a.mulAssign(mix(1, context.backdrop.a, transmission));\n    }\n  }\n\n  // Fdez-Ag\u00FCera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n  // Approximates multi-scattering in order to preserve energy.\n  // http://www.jcgt.org/published/0008/01/03/\n\n  computeMultiscattering(singleScatter, multiScatter, specularF90) {\n    const dotNV = transformedNormalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n\n    const fab = DFGApprox({\n      roughness,\n      dotNV\n    });\n    const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;\n    const FssEss = Fr.mul(fab.x).add(specularF90.mul(fab.y));\n    const Ess = fab.x.add(fab.y);\n    const Ems = Ess.oneMinus();\n    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619)); // 1/21\n    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());\n    singleScatter.addAssign(FssEss);\n    multiScatter.addAssign(Fms.mul(Ems));\n  }\n\n  /**\n   * Implements the direct light.\n   *\n   * @param {Object} input - The input data.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }) {\n    const dotNL = transformedNormalView.dot(lightDirection).clamp();\n    const irradiance = dotNL.mul(lightColor);\n    if (this.sheen === true) {\n      this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({\n        lightDirection\n      })));\n    }\n    if (this.clearcoat === true) {\n      const dotNLcc = transformedClearcoatNormalView.dot(lightDirection).clamp();\n      const ccIrradiance = dotNLcc.mul(lightColor);\n      this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX({\n        lightDirection,\n        f0: clearcoatF0,\n        f90: clearcoatF90,\n        roughness: clearcoatRoughness,\n        normalView: transformedClearcoatNormalView\n      })));\n    }\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX({\n      lightDirection,\n      f0: specularColor,\n      f90: 1,\n      roughness,\n      iridescence: this.iridescence,\n      f: this.iridescenceFresnel,\n      USE_IRIDESCENCE: this.iridescence,\n      USE_ANISOTROPY: this.anisotropy\n    })));\n  }\n\n  /**\n   * This method is intended for implementing the direct light term for\n   * rect area light nodes.\n   *\n   * @param {Object} input - The input data.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  directRectArea({\n    lightColor,\n    lightPosition,\n    halfWidth,\n    halfHeight,\n    reflectedLight,\n    ltc_1,\n    ltc_2\n  }) {\n    const p0 = lightPosition.add(halfWidth).sub(halfHeight); // counterclockwise; light shines in local neg z direction\n    const p1 = lightPosition.sub(halfWidth).sub(halfHeight);\n    const p2 = lightPosition.sub(halfWidth).add(halfHeight);\n    const p3 = lightPosition.add(halfWidth).add(halfHeight);\n    const N = transformedNormalView;\n    const V = positionViewDirection;\n    const P = positionView.toVar();\n    const uv = LTC_Uv({\n      N,\n      V,\n      roughness\n    });\n    const t1 = ltc_1.sample(uv).toVar();\n    const t2 = ltc_2.sample(uv).toVar();\n    const mInv = mat3(vec3(t1.x, 0, t1.y), vec3(0, 1, 0), vec3(t1.z, 0, t1.w)).toVar();\n\n    // LTC Fresnel Approximation by Stephen Hill\n    // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n    const fresnel = specularColor.mul(t2.x).add(specularColor.oneMinus().mul(t2.y)).toVar();\n    reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evaluate({\n      N,\n      V,\n      P,\n      mInv,\n      p0,\n      p1,\n      p2,\n      p3\n    })));\n    reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseColor).mul(LTC_Evaluate({\n      N,\n      V,\n      P,\n      mInv: mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),\n      p0,\n      p1,\n      p2,\n      p3\n    })));\n  }\n\n  /**\n   * Implements the indirect lighting.\n   *\n   * @param {ContextNode} context - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  indirect(context, stack, builder) {\n    this.indirectDiffuse(context, stack, builder);\n    this.indirectSpecular(context, stack, builder);\n    this.ambientOcclusion(context, stack, builder);\n  }\n\n  /**\n   * Implements the indirect diffuse term.\n   *\n   * @param {ContextNode} input - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  indirectDiffuse({\n    irradiance,\n    reflectedLight\n  }) {\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n  }\n\n  /**\n   * Implements the indirect specular term.\n   *\n   * @param {ContextNode} input - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  indirectSpecular({\n    radiance,\n    iblIrradiance,\n    reflectedLight\n  }) {\n    if (this.sheen === true) {\n      this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(sheen, IBLSheenBRDF({\n        normal: transformedNormalView,\n        viewDir: positionViewDirection,\n        roughness: sheenRoughness\n      })));\n    }\n    if (this.clearcoat === true) {\n      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      const clearcoatEnv = EnvironmentBRDF({\n        dotNV: dotNVcc,\n        specularColor: clearcoatF0,\n        specularF90: clearcoatF90,\n        roughness: clearcoatRoughness\n      });\n      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));\n    }\n\n    // Both indirect specular and indirect diffuse light accumulate here\n\n    const singleScattering = vec3().toVar('singleScattering');\n    const multiScattering = vec3().toVar('multiScattering');\n    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);\n    this.computeMultiscattering(singleScattering, multiScattering, specularF90);\n    const totalScattering = singleScattering.add(multiScattering);\n    const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());\n    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));\n    reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));\n    reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));\n  }\n\n  /**\n   * Implements the ambient occlusion term.\n   *\n   * @param {ContextNode} input - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  ambientOcclusion({\n    ambientOcclusion,\n    reflectedLight\n  }) {\n    const dotNV = transformedNormalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n\n    const aoNV = dotNV.add(ambientOcclusion);\n    const aoExp = roughness.mul(-16.0).oneMinus().negate().exp2();\n    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();\n    if (this.clearcoat === true) {\n      this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);\n    }\n    if (this.sheen === true) {\n      this.sheenSpecularIndirect.mulAssign(ambientOcclusion);\n    }\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n    reflectedLight.indirectSpecular.mulAssign(aoNode);\n  }\n\n  /**\n   * Used for final lighting accumulations depending on the requested features.\n   *\n   * @param {ContextNode} context - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  finish(context) {\n    const {\n      outgoingLight\n    } = context;\n    if (this.clearcoat === true) {\n      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      const Fcc = F_Schlick({\n        dotVH: dotNVcc,\n        f0: clearcoatF0,\n        f90: clearcoatF90\n      });\n      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));\n      outgoingLight.assign(clearcoatLight);\n    }\n    if (this.sheen === true) {\n      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();\n      const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);\n      outgoingLight.assign(sheenLight);\n    }\n  }\n}\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = /*@__PURE__*/float(1.0);\nconst cubeUV_m0 = /*@__PURE__*/float(-2.0);\nconst cubeUV_r1 = /*@__PURE__*/float(0.8);\nconst cubeUV_m1 = /*@__PURE__*/float(-1.0);\nconst cubeUV_r4 = /*@__PURE__*/float(0.4);\nconst cubeUV_m4 = /*@__PURE__*/float(2.0);\nconst cubeUV_r5 = /*@__PURE__*/float(0.305);\nconst cubeUV_m5 = /*@__PURE__*/float(3.0);\nconst cubeUV_r6 = /*@__PURE__*/float(0.21);\nconst cubeUV_m6 = /*@__PURE__*/float(4.0);\nconst cubeUV_minMipLevel = /*@__PURE__*/float(4.0);\nconst cubeUV_minTileSize = /*@__PURE__*/float(16.0);\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = /*@__PURE__*/Fn(([direction]) => {\n  const absDirection = vec3(abs(direction)).toVar();\n  const face = float(-1.0).toVar();\n  If(absDirection.x.greaterThan(absDirection.z), () => {\n    If(absDirection.x.greaterThan(absDirection.y), () => {\n      face.assign(select(direction.x.greaterThan(0.0), 0.0, 3.0));\n    }).Else(() => {\n      face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));\n    });\n  }).Else(() => {\n    If(absDirection.z.greaterThan(absDirection.y), () => {\n      face.assign(select(direction.z.greaterThan(0.0), 2.0, 5.0));\n    }).Else(() => {\n      face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));\n    });\n  });\n  return face;\n}).setLayout({\n  name: 'getFace',\n  type: 'float',\n  inputs: [{\n    name: 'direction',\n    type: 'vec3'\n  }]\n});\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = /*@__PURE__*/Fn(([direction, face]) => {\n  const uv = vec2().toVar();\n  If(face.equal(0.0), () => {\n    uv.assign(vec2(direction.z, direction.y).div(abs(direction.x))); // pos x\n  }).ElseIf(face.equal(1.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.z.negate()).div(abs(direction.y))); // pos y\n  }).ElseIf(face.equal(2.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.y).div(abs(direction.z))); // pos z\n  }).ElseIf(face.equal(3.0), () => {\n    uv.assign(vec2(direction.z.negate(), direction.y).div(abs(direction.x))); // neg x\n  }).ElseIf(face.equal(4.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.z).div(abs(direction.y))); // neg y\n  }).Else(() => {\n    uv.assign(vec2(direction.x, direction.y).div(abs(direction.z))); // neg z\n  });\n  return mul(0.5, uv.add(1.0));\n}).setLayout({\n  name: 'getUV',\n  type: 'vec2',\n  inputs: [{\n    name: 'direction',\n    type: 'vec3'\n  }, {\n    name: 'face',\n    type: 'float'\n  }]\n});\nconst roughnessToMip = /*@__PURE__*/Fn(([roughness]) => {\n  const mip = float(0.0).toVar();\n  If(roughness.greaterThanEqual(cubeUV_r1), () => {\n    mip.assign(cubeUV_r0.sub(roughness).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));\n  }).ElseIf(roughness.greaterThanEqual(cubeUV_r4), () => {\n    mip.assign(cubeUV_r1.sub(roughness).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));\n  }).ElseIf(roughness.greaterThanEqual(cubeUV_r5), () => {\n    mip.assign(cubeUV_r4.sub(roughness).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));\n  }).ElseIf(roughness.greaterThanEqual(cubeUV_r6), () => {\n    mip.assign(cubeUV_r5.sub(roughness).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));\n  }).Else(() => {\n    mip.assign(float(-2.0).mul(log2(mul(1.16, roughness)))); // 1.16 = 1.79^0.25\n  });\n  return mip;\n}).setLayout({\n  name: 'roughnessToMip',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }]\n});\n\n// RH coordinate system; PMREM face-indexing convention\nconst getDirection = /*@__PURE__*/Fn(([uv_immutable, face]) => {\n  const uv = uv_immutable.toVar();\n  uv.assign(mul(2.0, uv).sub(1.0));\n  const direction = vec3(uv, 1.0).toVar();\n  If(face.equal(0.0), () => {\n    direction.assign(direction.zyx); // ( 1, v, u ) pos x\n  }).ElseIf(face.equal(1.0), () => {\n    direction.assign(direction.xzy);\n    direction.xz.mulAssign(-1.0); // ( -u, 1, -v ) pos y\n  }).ElseIf(face.equal(2.0), () => {\n    direction.x.mulAssign(-1.0); // ( -u, v, 1 ) pos z\n  }).ElseIf(face.equal(3.0), () => {\n    direction.assign(direction.zyx);\n    direction.xz.mulAssign(-1.0); // ( -1, v, -u ) neg x\n  }).ElseIf(face.equal(4.0), () => {\n    direction.assign(direction.xzy);\n    direction.xy.mulAssign(-1.0); // ( -u, -1, v ) neg y\n  }).ElseIf(face.equal(5.0), () => {\n    direction.z.mulAssign(-1.0); // ( u, v, -1 ) neg zS\n  });\n  return direction;\n}).setLayout({\n  name: 'getDirection',\n  type: 'vec3',\n  inputs: [{\n    name: 'uv',\n    type: 'vec2'\n  }, {\n    name: 'face',\n    type: 'float'\n  }]\n});\n\n//\n\nconst textureCubeUV = /*@__PURE__*/Fn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {\n  const roughness = float(roughness_immutable);\n  const sampleDir = vec3(sampleDir_immutable);\n  const mip = clamp(roughnessToMip(roughness), cubeUV_m0, CUBEUV_MAX_MIP);\n  const mipF = fract(mip);\n  const mipInt = floor(mip);\n  const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n  If(mipF.notEqual(0.0), () => {\n    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1.0), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n    color0.assign(mix(color0, color1, mipF));\n  });\n  return color0;\n});\nconst bilinearCubeUV = /*@__PURE__*/Fn(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {\n  const mipInt = float(mipInt_immutable).toVar();\n  const direction = vec3(direction_immutable);\n  const face = float(getFace(direction)).toVar();\n  const filterInt = float(max$1(cubeUV_minMipLevel.sub(mipInt), 0.0)).toVar();\n  mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));\n  const faceSize = float(exp2(mipInt)).toVar();\n  const uv = vec2(getUV(direction, face).mul(faceSize.sub(2.0)).add(1.0)).toVar();\n  If(face.greaterThan(2.0), () => {\n    uv.y.addAssign(faceSize);\n    face.subAssign(3.0);\n  });\n  uv.x.addAssign(face.mul(faceSize));\n  uv.x.addAssign(filterInt.mul(mul(3.0, cubeUV_minTileSize)));\n  uv.y.addAssign(mul(4.0, exp2(CUBEUV_MAX_MIP).sub(faceSize)));\n  uv.x.mulAssign(CUBEUV_TEXEL_WIDTH);\n  uv.y.mulAssign(CUBEUV_TEXEL_HEIGHT);\n  return envMap.sample(uv).grad(vec2(), vec2()); // disable anisotropic filtering\n});\nconst getSample = /*@__PURE__*/Fn(({\n  envMap,\n  mipInt,\n  outputDirection,\n  theta,\n  axis,\n  CUBEUV_TEXEL_WIDTH,\n  CUBEUV_TEXEL_HEIGHT,\n  CUBEUV_MAX_MIP\n}) => {\n  const cosTheta = cos(theta);\n\n  // Rodrigues' axis-angle rotation\n  const sampleDirection = outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));\n  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);\n});\nconst blur = /*@__PURE__*/Fn(({\n  n,\n  latitudinal,\n  poleAxis,\n  outputDirection,\n  weights,\n  samples,\n  dTheta,\n  mipInt,\n  envMap,\n  CUBEUV_TEXEL_WIDTH,\n  CUBEUV_TEXEL_HEIGHT,\n  CUBEUV_MAX_MIP\n}) => {\n  const axis = vec3(select(latitudinal, poleAxis, cross(poleAxis, outputDirection))).toVar();\n  If(all(axis.equals(vec3(0.0))), () => {\n    axis.assign(vec3(outputDirection.z, 0.0, outputDirection.x.negate()));\n  });\n  axis.assign(normalize(axis));\n  const gl_FragColor = vec3().toVar();\n  gl_FragColor.addAssign(weights.element(int(0)).mul(getSample({\n    theta: 0.0,\n    axis,\n    outputDirection,\n    mipInt,\n    envMap,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  })));\n  Loop({\n    start: int(1),\n    end: n\n  }, ({\n    i\n  }) => {\n    If(i.greaterThanEqual(samples), () => {\n      Break();\n    });\n    const theta = float(dTheta.mul(float(i))).toVar();\n    gl_FragColor.addAssign(weights.element(i).mul(getSample({\n      theta: theta.mul(-1.0),\n      axis,\n      outputDirection,\n      mipInt,\n      envMap,\n      CUBEUV_TEXEL_WIDTH,\n      CUBEUV_TEXEL_HEIGHT,\n      CUBEUV_MAX_MIP\n    })));\n    gl_FragColor.addAssign(weights.element(i).mul(getSample({\n      theta,\n      axis,\n      outputDirection,\n      mipInt,\n      envMap,\n      CUBEUV_TEXEL_WIDTH,\n      CUBEUV_TEXEL_HEIGHT,\n      CUBEUV_MAX_MIP\n    })));\n  });\n  return vec4(gl_FragColor, 1);\n});\n\n/** @module PMREMNode **/\n\nlet _generator = null;\nconst _cache = new WeakMap();\n\n/**\n * Generates the cubeUV size based on the given image height.\n *\n * @private\n * @param {Number} imageHeight - The image height.\n * @return {{texelWidth: Number,texelHeight: Number, maxMip: Number}} The result object.\n */\nfunction _generateCubeUVSize(imageHeight) {\n  const maxMip = Math.log2(imageHeight) - 2;\n  const texelHeight = 1.0 / imageHeight;\n  const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n  return {\n    texelWidth,\n    texelHeight,\n    maxMip\n  };\n}\n\n/**\n * Generates a PMREM from the given texture .\n *\n * @private\n * @param {Texture} texture - The texture to create the PMREM for.\n * @return {Texture} The PMREM.\n */\nfunction _getPMREMFromTexture(texture) {\n  let cacheTexture = _cache.get(texture);\n  const pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : -1;\n  if (pmremVersion !== texture.pmremVersion) {\n    const image = texture.image;\n    if (texture.isCubeTexture) {\n      if (isCubeMapReady(image)) {\n        cacheTexture = _generator.fromCubemap(texture, cacheTexture);\n      } else {\n        return null;\n      }\n    } else {\n      if (isEquirectangularMapReady(image)) {\n        cacheTexture = _generator.fromEquirectangular(texture, cacheTexture);\n      } else {\n        return null;\n      }\n    }\n    cacheTexture.pmremVersion = texture.pmremVersion;\n    _cache.set(texture, cacheTexture);\n  }\n  return cacheTexture.texture;\n}\n\n/**\n * This node represents a PMREM which is a special type of preprocessed\n * environment map intended for PBR materials.\n *\n * ```js\n * const material = new MeshStandardNodeMaterial();\n * material.envNode = pmremTexture( envMap );\n * ```\n *\n * @augments TempNode\n */\nclass PMREMNode extends TempNode {\n  static get type() {\n    return 'PMREMNode';\n  }\n\n  /**\n   * Constructs a new function overloading node.\n   *\n   * @param {Texture} value - The input texture.\n   * @param {Node<vec2>} [uvNode=null] - The uv node.\n   * @param {Node<float>} [levelNode=null] - The level node.\n   */\n  constructor(value, uvNode = null, levelNode = null) {\n    super('vec3');\n\n    /**\n     * Reference to the input texture.\n     *\n     * @private\n     * @type {Texture}\n     */\n    this._value = value;\n\n    /**\n     * Reference to the generated PMREM.\n     *\n     * @private\n     * @type {Texture | null}\n     * @default null\n     */\n    this._pmrem = null;\n\n    /**\n     *  The uv node.\n     *\n     * @type {Node<vec2>}\n     */\n    this.uvNode = uvNode;\n\n    /**\n     *  The level node.\n     *\n     * @type {Node<float>}\n     */\n    this.levelNode = levelNode;\n\n    /**\n     * Reference to a PMREM generator.\n     *\n     * @private\n     * @type {PMREMGenerator}\n     * @default null\n     */\n    this._generator = null;\n    const defaultTexture = new Texture();\n    defaultTexture.isRenderTargetTexture = true;\n\n    /**\n     * The texture node holding the generated PMREM.\n     *\n     * @private\n     * @type {TextureNode}\n     */\n    this._texture = texture(defaultTexture);\n\n    /**\n     * A uniform representing the PMREM's width.\n     *\n     * @private\n     * @type {UniformNode<float>}\n     */\n    this._width = uniform(0);\n\n    /**\n     * A uniform representing the PMREM's height.\n     *\n     * @private\n     * @type {UniformNode<float>}\n     */\n    this._height = uniform(0);\n\n    /**\n     * A uniform representing the PMREM's max Mip.\n     *\n     * @private\n     * @type {UniformNode<float>}\n     */\n    this._maxMip = uniform(0);\n\n    /**\n     * The `updateBeforeType` is set to `NodeUpdateType.RENDER`.\n     *\n     * @type {String}\n     * @default 'render'\n     */\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  set value(value) {\n    this._value = value;\n    this._pmrem = null;\n  }\n\n  /**\n   * The node's texture value.\n   *\n   * @type {Texture}\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Uses the given PMREM texture to update internal values.\n   *\n   * @param {Texture} texture - The PMREM texture.\n   */\n  updateFromTexture(texture) {\n    const cubeUVSize = _generateCubeUVSize(texture.image.height);\n    this._texture.value = texture;\n    this._width.value = cubeUVSize.texelWidth;\n    this._height.value = cubeUVSize.texelHeight;\n    this._maxMip.value = cubeUVSize.maxMip;\n  }\n  updateBefore() {\n    let pmrem = this._pmrem;\n    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;\n    const texture = this._value;\n    if (pmremVersion !== texture.pmremVersion) {\n      if (texture.isPMREMTexture === true) {\n        pmrem = texture;\n      } else {\n        pmrem = _getPMREMFromTexture(texture);\n      }\n      if (pmrem !== null) {\n        this._pmrem = pmrem;\n        this.updateFromTexture(pmrem);\n      }\n    }\n  }\n  setup(builder) {\n    if (_generator === null) {\n      _generator = builder.createPMREMGenerator();\n    }\n\n    //\n\n    this.updateBefore(builder);\n\n    //\n\n    let uvNode = this.uvNode;\n    if (uvNode === null && builder.context.getUV) {\n      uvNode = builder.context.getUV(this);\n    }\n\n    //\n\n    const texture = this.value;\n    if (builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true) {\n      uvNode = vec3(uvNode.x.negate(), uvNode.yz);\n    }\n    uvNode = vec3(uvNode.x, uvNode.y.negate(), uvNode.z);\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getTextureLevel) {\n      levelNode = builder.context.getTextureLevel(this);\n    }\n\n    //\n\n    return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);\n  }\n}\n\n/**\n * Returns `true` if the given cube map image has been fully loaded.\n *\n * @private\n * @param {Array<(Image|Object)>} image - The cube map image.\n * @return {Boolean} Whether the given cube map is ready or not.\n */\nfunction isCubeMapReady(image) {\n  if (image === null || image === undefined) return false;\n  let count = 0;\n  const length = 6;\n  for (let i = 0; i < length; i++) {\n    if (image[i] !== undefined) count++;\n  }\n  return count === length;\n}\n\n/**\n * Returns `true` if the given equirectangular image has been fully loaded.\n *\n * @private\n * @param {(Image|Object)} image - The equirectangular image.\n * @return {Boolean} Whether the given cube map is ready or not.\n */\nfunction isEquirectangularMapReady(image) {\n  if (image === null || image === undefined) return false;\n  return image.height > 0;\n}\n\n/**\n * TSL function for creating a PMREM node.\n *\n * @function\n * @param {Texture} value - The input texture.\n * @param {Node<vec2>} [uvNode=null] - The uv node.\n * @param {Node<float>} [levelNode=null] - The level node.\n * @returns {PMREMNode}\n */\nconst pmremTexture = /*@__PURE__*/nodeProxy(PMREMNode);\nconst _envNodeCache = new WeakMap();\n\n/**\n * Represents a physical model for Image-based lighting (IBL). The environment\n * is defined via environment maps in the equirectangular, cube map or cubeUV (PMREM) format.\n * `EnvironmentNode` is intended for PBR materials like {@link MeshStandardNodeMaterial}.\n *\n * @augments LightingNode\n */\nclass EnvironmentNode extends LightingNode {\n  static get type() {\n    return 'EnvironmentNode';\n  }\n\n  /**\n   * Constructs a new environment node.\n   *\n   * @param {Node} [envNode=null] - A node representing the environment.\n   */\n  constructor(envNode = null) {\n    super();\n\n    /**\n     * A node representing the environment.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.envNode = envNode;\n  }\n  setup(builder) {\n    const {\n      material\n    } = builder;\n    let envNode = this.envNode;\n    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {\n      const value = envNode.isTextureNode ? envNode.value : material[envNode.property];\n      let cacheEnvNode = _envNodeCache.get(value);\n      if (cacheEnvNode === undefined) {\n        cacheEnvNode = pmremTexture(value);\n        _envNodeCache.set(value, cacheEnvNode);\n      }\n      envNode = cacheEnvNode;\n    }\n\n    //\n\n    const envMap = material.envMap;\n    const intensity = envMap ? reference('envMapIntensity', 'float', builder.material) : reference('environmentIntensity', 'float', builder.scene); // @TODO: Add materialEnvIntensity in MaterialNode\n\n    const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;\n    const radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;\n    const radiance = envNode.context(createRadianceContext(roughness, radianceNormalView)).mul(intensity);\n    const irradiance = envNode.context(createIrradianceContext(transformedNormalWorld)).mul(Math.PI).mul(intensity);\n    const isolateRadiance = cache(radiance);\n    const isolateIrradiance = cache(irradiance);\n\n    //\n\n    builder.context.radiance.addAssign(isolateRadiance);\n    builder.context.iblIrradiance.addAssign(isolateIrradiance);\n\n    //\n\n    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n    if (clearcoatRadiance) {\n      const clearcoatRadianceContext = envNode.context(createRadianceContext(clearcoatRoughness, transformedClearcoatNormalView)).mul(intensity);\n      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);\n      clearcoatRadiance.addAssign(isolateClearcoatRadiance);\n    }\n  }\n}\nconst createRadianceContext = (roughnessNode, normalViewNode) => {\n  let reflectVec = null;\n  return {\n    getUV: () => {\n      if (reflectVec === null) {\n        reflectVec = positionViewDirection.negate().reflect(normalViewNode);\n\n        // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n        reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();\n        reflectVec = reflectVec.transformDirection(cameraViewMatrix);\n      }\n      return reflectVec;\n    },\n    getTextureLevel: () => {\n      return roughnessNode;\n    }\n  };\n};\nconst createIrradianceContext = normalWorldNode => {\n  return {\n    getUV: () => {\n      return normalWorldNode;\n    },\n    getTextureLevel: () => {\n      return float(1.0);\n    }\n  };\n};\nconst _defaultValues$6 = /*@__PURE__*/new MeshStandardMaterial();\n\n/**\n * Node material version of `MeshStandardMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshStandardNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshStandardNodeMaterial';\n  }\n\n  /**\n   * Constructs a new mesh standard node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMeshStandardNodeMaterial = true;\n\n    /**\n     * Set to `true` because standard materials react on lights.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.lights = true;\n\n    /**\n     * The emissive color of standard materials is by default inferred from the `emissive`,\n     * `emissiveIntensity` and `emissiveMap` properties. This node property allows to\n     * overwrite the default and define the emissive color with a node instead.\n     *\n     * If you don't want to overwrite the emissive color but modify the existing\n     * value instead, use {@link module:MaterialNode.materialEmissive}.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.emissiveNode = null;\n\n    /**\n     * The metalness of standard materials is by default inferred from the `metalness`,\n     * and `metalnessMap` properties. This node property allows to\n     * overwrite the default and define the metalness with a node instead.\n     *\n     * If you don't want to overwrite the metalness but modify the existing\n     * value instead, use {@link module:MaterialNode.materialMetalness}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.metalnessNode = null;\n\n    /**\n     * The roughness of standard materials is by default inferred from the `roughness`,\n     * and `roughnessMap` properties. This node property allows to\n     * overwrite the default and define the roughness with a node instead.\n     *\n     * If you don't want to overwrite the roughness but modify the existing\n     * value instead, use {@link module:MaterialNode.materialRoughness}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.roughnessNode = null;\n    this.setDefaultValues(_defaultValues$6);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Overwritten since this type of material uses {@link EnvironmentNode}\n   * to implement the PBR (PMREM based) environment mapping. Besides, the\n   * method honors `Scene.environment`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {EnvironmentNode<vec3>?} The environment node.\n   */\n  setupEnvironment(builder) {\n    let envNode = super.setupEnvironment(builder);\n    if (envNode === null && builder.environmentNode) {\n      envNode = builder.environmentNode;\n    }\n    return envNode ? new EnvironmentNode(envNode) : null;\n  }\n\n  /**\n   * Setups the lighting model.\n   *\n   * @return {PhysicalLightingModel} The lighting model.\n   */\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhysicalLightingModel();\n  }\n\n  /**\n   * Setups the specular related node variables.\n   */\n  setupSpecular() {\n    const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalness);\n    specularColor.assign(specularColorNode);\n    specularF90.assign(1.0);\n  }\n\n  /**\n   * Setups the standard specific node variables.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setupVariants() {\n    // METALNESS\n\n    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;\n    metalness.assign(metalnessNode);\n\n    // ROUGHNESS\n\n    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;\n    roughnessNode = getRoughness({\n      roughness: roughnessNode\n    });\n    roughness.assign(roughnessNode);\n\n    // SPECULAR COLOR\n\n    this.setupSpecular();\n\n    // DIFFUSE COLOR\n\n    diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));\n  }\n  copy(source) {\n    this.emissiveNode = source.emissiveNode;\n    this.metalnessNode = source.metalnessNode;\n    this.roughnessNode = source.roughnessNode;\n    return super.copy(source);\n  }\n}\nconst _defaultValues$5 = /*@__PURE__*/new MeshPhysicalMaterial();\n\n/**\n * Node material version of `MeshPhysicalMaterial`.\n *\n * @augments MeshStandardNodeMaterial\n */\nclass MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {\n  static get type() {\n    return 'MeshPhysicalNodeMaterial';\n  }\n\n  /**\n   * Constructs a new mesh physical node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMeshPhysicalNodeMaterial = true;\n\n    /**\n     * The clearcoat of physical materials is by default inferred from the `clearcoat`\n     * and `clearcoatMap` properties. This node property allows to overwrite the default\n     * and define the clearcoat with a node instead.\n     *\n     * If you don't want to overwrite the clearcoat but modify the existing\n     * value instead, use {@link module:MaterialNode.materialClearcoat}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.clearcoatNode = null;\n\n    /**\n     * The clearcoat roughness of physical materials is by default inferred from the `clearcoatRoughness`\n     * and `clearcoatRoughnessMap` properties. This node property allows to overwrite the default\n     * and define the clearcoat roughness with a node instead.\n     *\n     * If you don't want to overwrite the clearcoat roughness but modify the existing\n     * value instead, use {@link module:MaterialNode.materialClearcoatRoughness}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.clearcoatRoughnessNode = null;\n\n    /**\n     * The clearcoat normal of physical materials is by default inferred from the `clearcoatNormalMap`\n     * property. This node property allows to overwrite the default\n     * and define the clearcoat normal with a node instead.\n     *\n     * If you don't want to overwrite the clearcoat normal but modify the existing\n     * value instead, use {@link module:MaterialNode.materialClearcoatNormal}.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.clearcoatNormalNode = null;\n\n    /**\n     * The sheen of physical materials is by default inferred from the `sheen`, `sheenColor`\n     * and `sheenColorMap` properties. This node property allows to overwrite the default\n     * and define the sheen with a node instead.\n     *\n     * If you don't want to overwrite the sheen but modify the existing\n     * value instead, use {@link module:MaterialNode.materialSheen}.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.sheenNode = null;\n\n    /**\n     * The sheen roughness of physical materials is by default inferred from the `sheenRoughness` and\n     * `sheenRoughnessMap` properties. This node property allows to overwrite the default\n     * and define the sheen roughness with a node instead.\n     *\n     * If you don't want to overwrite the sheen roughness but modify the existing\n     * value instead, use {@link module:MaterialNode.materialSheenRoughness}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.sheenRoughnessNode = null;\n\n    /**\n     * The iridescence of physical materials is by default inferred from the `iridescence`\n     * property. This node property allows to overwrite the default\n     * and define the iridescence with a node instead.\n     *\n     * If you don't want to overwrite the iridescence but modify the existing\n     * value instead, use {@link module:MaterialNode.materialIridescence}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.iridescenceNode = null;\n\n    /**\n     * The iridescence IOR of physical materials is by default inferred from the `iridescenceIOR`\n     * property. This node property allows to overwrite the default\n     * and define the iridescence IOR with a node instead.\n     *\n     * If you don't want to overwrite the iridescence IOR but modify the existing\n     * value instead, use {@link module:MaterialNode.materialIridescenceIOR}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.iridescenceIORNode = null;\n\n    /**\n     * The iridescence thickness of physical materials is by default inferred from the `iridescenceThicknessRange`\n     * and `iridescenceThicknessMap` properties. This node property allows to overwrite the default\n     * and define the iridescence thickness with a node instead.\n     *\n     * If you don't want to overwrite the iridescence thickness but modify the existing\n     * value instead, use {@link module:MaterialNode.materialIridescenceThickness}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.iridescenceThicknessNode = null;\n\n    /**\n     * The specular intensity of physical materials is by default inferred from the `specularIntensity`\n     * and `specularIntensityMap` properties. This node property allows to overwrite the default\n     * and define the specular intensity with a node instead.\n     *\n     * If you don't want to overwrite the specular intensity but modify the existing\n     * value instead, use {@link module:MaterialNode.materialSpecularIntensity}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.specularIntensityNode = null;\n\n    /**\n     * The specular color of physical materials is by default inferred from the `specularColor`\n     * and `specularColorMap` properties. This node property allows to overwrite the default\n     * and define the specular color with a node instead.\n     *\n     * If you don't want to overwrite the specular color but modify the existing\n     * value instead, use {@link module:MaterialNode.materialSpecularColor}.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.specularColorNode = null;\n\n    /**\n     * The ior of physical materials is by default inferred from the `ior`\n     * property. This node property allows to overwrite the default\n     * and define the ior with a node instead.\n     *\n     * If you don't want to overwrite the ior but modify the existing\n     * value instead, use {@link module:MaterialNode.materialIOR}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.iorNode = null;\n\n    /**\n     * The transmission of physical materials is by default inferred from the `transmission` and\n     * `transmissionMap` properties. This node property allows to overwrite the default\n     * and define the transmission with a node instead.\n     *\n     * If you don't want to overwrite the transmission but modify the existing\n     * value instead, use {@link module:MaterialNode.materialTransmission}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.transmissionNode = null;\n\n    /**\n     * The thickness of physical materials is by default inferred from the `thickness` and\n     * `thicknessMap` properties. This node property allows to overwrite the default\n     * and define the thickness with a node instead.\n     *\n     * If you don't want to overwrite the thickness but modify the existing\n     * value instead, use {@link module:MaterialNode.materialThickness}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.thicknessNode = null;\n\n    /**\n     * The attenuation distance of physical materials is by default inferred from the\n     * `attenuationDistance` property. This node property allows to overwrite the default\n     * and define the attenuation distance with a node instead.\n     *\n     * If you don't want to overwrite the attenuation distance but modify the existing\n     * value instead, use {@link module:MaterialNode.materialAttenuationDistance}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.attenuationDistanceNode = null;\n\n    /**\n     * The attenuation color of physical materials is by default inferred from the\n     * `attenuationColor` property. This node property allows to overwrite the default\n     * and define the attenuation color with a node instead.\n     *\n     * If you don't want to overwrite the attenuation color but modify the existing\n     * value instead, use {@link module:MaterialNode.materialAttenuationColor}.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.attenuationColorNode = null;\n\n    /**\n     * The dispersion of physical materials is by default inferred from the\n     * `dispersion` property. This node property allows to overwrite the default\n     * and define the dispersion with a node instead.\n     *\n     * If you don't want to overwrite the dispersion but modify the existing\n     * value instead, use {@link module:MaterialNode.materialDispersion}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.dispersionNode = null;\n\n    /**\n     * The anisotropy of physical materials is by default inferred from the\n     * `anisotropy` property. This node property allows to overwrite the default\n     * and define the anisotropy with a node instead.\n     *\n     * If you don't want to overwrite the anisotropy but modify the existing\n     * value instead, use {@link module:MaterialNode.materialAnisotropy}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.anisotropyNode = null;\n    this.setDefaultValues(_defaultValues$5);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Whether the lighting model should use clearcoat or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get useClearcoat() {\n    return this.clearcoat > 0 || this.clearcoatNode !== null;\n  }\n\n  /**\n   * Whether the lighting model should use iridescence or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get useIridescence() {\n    return this.iridescence > 0 || this.iridescenceNode !== null;\n  }\n\n  /**\n   * Whether the lighting model should use sheen or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get useSheen() {\n    return this.sheen > 0 || this.sheenNode !== null;\n  }\n\n  /**\n   * Whether the lighting model should use anisotropy or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get useAnisotropy() {\n    return this.anisotropy > 0 || this.anisotropyNode !== null;\n  }\n\n  /**\n   * Whether the lighting model should use transmission or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get useTransmission() {\n    return this.transmission > 0 || this.transmissionNode !== null;\n  }\n\n  /**\n   * Whether the lighting model should use dispersion or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get useDispersion() {\n    return this.dispersion > 0 || this.dispersionNode !== null;\n  }\n\n  /**\n   * Setups the specular related node variables.\n   */\n  setupSpecular() {\n    const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;\n    ior.assign(iorNode);\n    specularColor.assign(mix(min$1(pow2(ior.sub(1.0).div(ior.add(1.0))).mul(materialSpecularColor), vec3(1.0)).mul(materialSpecularIntensity), diffuseColor.rgb, metalness));\n    specularF90.assign(mix(materialSpecularIntensity, 1.0, metalness));\n  }\n\n  /**\n   * Setups the lighting model.\n   *\n   * @return {PhysicalLightingModel} The lighting model.\n   */\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhysicalLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);\n  }\n\n  /**\n   * Setups the physical specific node variables.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setupVariants(builder) {\n    super.setupVariants(builder);\n\n    // CLEARCOAT\n\n    if (this.useClearcoat) {\n      const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;\n      const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;\n      clearcoat.assign(clearcoatNode);\n      clearcoatRoughness.assign(getRoughness({\n        roughness: clearcoatRoughnessNode\n      }));\n    }\n\n    // SHEEN\n\n    if (this.useSheen) {\n      const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;\n      const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;\n      sheen.assign(sheenNode);\n      sheenRoughness.assign(sheenRoughnessNode);\n    }\n\n    // IRIDESCENCE\n\n    if (this.useIridescence) {\n      const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;\n      const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;\n      const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;\n      iridescence.assign(iridescenceNode);\n      iridescenceIOR.assign(iridescenceIORNode);\n      iridescenceThickness.assign(iridescenceThicknessNode);\n    }\n\n    // ANISOTROPY\n\n    if (this.useAnisotropy) {\n      const anisotropyV = (this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy).toVar();\n      anisotropy.assign(anisotropyV.length());\n      If(anisotropy.equal(0.0), () => {\n        anisotropyV.assign(vec2(1.0, 0.0));\n      }).Else(() => {\n        anisotropyV.divAssign(vec2(anisotropy));\n        anisotropy.assign(anisotropy.saturate());\n      });\n\n      // Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.\n      alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1.0));\n      anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y)));\n      anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)));\n    }\n\n    // TRANSMISSION\n\n    if (this.useTransmission) {\n      const transmissionNode = this.transmissionNode ? float(this.transmissionNode) : materialTransmission;\n      const thicknessNode = this.thicknessNode ? float(this.thicknessNode) : materialThickness;\n      const attenuationDistanceNode = this.attenuationDistanceNode ? float(this.attenuationDistanceNode) : materialAttenuationDistance;\n      const attenuationColorNode = this.attenuationColorNode ? vec3(this.attenuationColorNode) : materialAttenuationColor;\n      transmission.assign(transmissionNode);\n      thickness.assign(thicknessNode);\n      attenuationDistance.assign(attenuationDistanceNode);\n      attenuationColor.assign(attenuationColorNode);\n      if (this.useDispersion) {\n        const dispersionNode = this.dispersionNode ? float(this.dispersionNode) : materialDispersion;\n        dispersion.assign(dispersionNode);\n      }\n    }\n  }\n\n  /**\n   * Setups the clearcoat normal node.\n   *\n   * @return {Node<vec3>} The clearcoat noraml.\n   */\n  setupClearcoatNormal() {\n    return this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;\n  }\n  setup(builder) {\n    builder.context.setupClearcoatNormal = () => this.setupClearcoatNormal(builder);\n    super.setup(builder);\n  }\n  copy(source) {\n    this.clearcoatNode = source.clearcoatNode;\n    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n    this.clearcoatNormalNode = source.clearcoatNormalNode;\n    this.sheenNode = source.sheenNode;\n    this.sheenRoughnessNode = source.sheenRoughnessNode;\n    this.iridescenceNode = source.iridescenceNode;\n    this.iridescenceIORNode = source.iridescenceIORNode;\n    this.iridescenceThicknessNode = source.iridescenceThicknessNode;\n    this.specularIntensityNode = source.specularIntensityNode;\n    this.specularColorNode = source.specularColorNode;\n    this.transmissionNode = source.transmissionNode;\n    this.thicknessNode = source.thicknessNode;\n    this.attenuationDistanceNode = source.attenuationDistanceNode;\n    this.attenuationColorNode = source.attenuationColorNode;\n    this.dispersionNode = source.dispersionNode;\n    this.anisotropyNode = source.anisotropyNode;\n    return super.copy(source);\n  }\n}\n\n/** @module MeshSSSNodeMaterial **/\n\n/**\n * Represents the lighting model for {@link MeshSSSNodeMaterial}.\n *\n * @augments PhysicalLightingModel\n */\nclass SSSLightingModel extends PhysicalLightingModel {\n  /**\n   * Constructs a new physical lighting model.\n   *\n   * @param {Boolean} [clearcoat=false] - Whether clearcoat is supported or not.\n   * @param {Boolean} [sheen=false] - Whether sheen is supported or not.\n   * @param {Boolean} [iridescence=false] - Whether iridescence is supported or not.\n   * @param {Boolean} [anisotropy=false] - Whether anisotropy is supported or not.\n   * @param {Boolean} [transmission=false] - Whether transmission is supported or not.\n   * @param {Boolean} [dispersion=false] - Whether dispersion is supported or not.\n   * @param {Boolean} [sss=false] - Whether SSS is supported or not.\n   */\n  constructor(clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false, sss = false) {\n    super(clearcoat, sheen, iridescence, anisotropy, transmission, dispersion);\n\n    /**\n     * Whether the lighting model should use SSS or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.useSSS = sss;\n  }\n\n  /**\n   * Extends the default implementation with a SSS term.\n   *\n   * Reference: [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look]{@link https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/}\n   *\n   * @param {Object} input - The input data.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }, stack, builder) {\n    if (this.useSSS === true) {\n      const material = builder.material;\n      const {\n        thicknessColorNode,\n        thicknessDistortionNode,\n        thicknessAmbientNode,\n        thicknessAttenuationNode,\n        thicknessPowerNode,\n        thicknessScaleNode\n      } = material;\n      const scatteringHalf = lightDirection.add(transformedNormalView.mul(thicknessDistortionNode)).normalize();\n      const scatteringDot = float(positionViewDirection.dot(scatteringHalf.negate()).saturate().pow(thicknessPowerNode).mul(thicknessScaleNode));\n      const scatteringIllu = vec3(scatteringDot.add(thicknessAmbientNode).mul(thicknessColorNode));\n      reflectedLight.directDiffuse.addAssign(scatteringIllu.mul(thicknessAttenuationNode.mul(lightColor)));\n    }\n    super.direct({\n      lightDirection,\n      lightColor,\n      reflectedLight\n    }, stack, builder);\n  }\n}\n\n/**\n * This node material is an experimental extension of {@link MeshPhysicalNodeMaterial}\n * that implements a Subsurface scattering (SSS) term.\n *\n * @augments MeshPhysicalNodeMaterial\n */\nclass MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {\n  static get type() {\n    return 'MeshSSSNodeMaterial';\n  }\n\n  /**\n   * Constructs a new mesh SSS node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super(parameters);\n\n    /**\n     * Represents the thickness color.\n     *\n     * @type {Node<vec3>?}\n     * @default null\n     */\n    this.thicknessColorNode = null;\n\n    /**\n     * Represents the distortion factor.\n     *\n     * @type {Node<float>?}\n     */\n    this.thicknessDistortionNode = float(0.1);\n\n    /**\n     * Represents the thickness ambient factor.\n     *\n     * @type {Node<float>?}\n     */\n    this.thicknessAmbientNode = float(0.0);\n\n    /**\n     * Represents the thickness attenuation.\n     *\n     * @type {Node<float>?}\n     */\n    this.thicknessAttenuationNode = float(.1);\n\n    /**\n     * Represents the thickness power.\n     *\n     * @type {Node<float>?}\n     */\n    this.thicknessPowerNode = float(2.0);\n\n    /**\n     * Represents the thickness scale.\n     *\n     * @type {Node<float>?}\n     */\n    this.thicknessScaleNode = float(10.0);\n  }\n\n  /**\n   * Whether the lighting model should use SSS or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get useSSS() {\n    return this.thicknessColorNode !== null;\n  }\n\n  /**\n   * Setups the lighting model.\n   *\n   * @return {SSSLightingModel} The lighting model.\n   */\n  setupLightingModel(/*builder*/\n  ) {\n    return new SSSLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion, this.useSSS);\n  }\n  copy(source) {\n    this.thicknessColorNode = source.thicknessColorNode;\n    this.thicknessDistortionNode = source.thicknessDistortionNode;\n    this.thicknessAmbientNode = source.thicknessAmbientNode;\n    this.thicknessAttenuationNode = source.thicknessAttenuationNode;\n    this.thicknessPowerNode = source.thicknessPowerNode;\n    this.thicknessScaleNode = source.thicknessScaleNode;\n    return super.copy(source);\n  }\n}\nconst getGradientIrradiance = /*@__PURE__*/Fn(({\n  normal,\n  lightDirection,\n  builder\n}) => {\n  // dotNL will be from -1.0 to 1.0\n  const dotNL = normal.dot(lightDirection);\n  const coord = vec2(dotNL.mul(0.5).add(0.5), 0.0);\n  if (builder.material.gradientMap) {\n    const gradientMap = materialReference('gradientMap', 'texture').context({\n      getUV: () => coord\n    });\n    return vec3(gradientMap.r);\n  } else {\n    const fw = coord.fwidth().mul(0.5);\n    return mix(vec3(0.7), vec3(1.0), smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));\n  }\n});\n\n/**\n * Represents the lighting model for a toon material. Used in {@link MeshToonNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass ToonLightingModel extends LightingModel {\n  /**\n   * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is\n   * reduced to a small number of discrete shades to create a comic-like, flat look.\n   *\n   * @param {Object} input - The input data.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }, stack, builder) {\n    const irradiance = getGradientIrradiance({\n      normal: normalGeometry,\n      lightDirection,\n      builder\n    }).mul(lightColor);\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n  }\n\n  /**\n   * Implements the indirect lighting.\n   *\n   * @param {ContextNode} input - The current node context.\n   * @param {StackNode} stack - The current stack.\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  indirect({\n    ambientOcclusion,\n    irradiance,\n    reflectedLight\n  }) {\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n  }\n}\nconst _defaultValues$4 = /*@__PURE__*/new MeshToonMaterial();\n\n/**\n * Node material version of `MeshToonMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshToonNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshToonNodeMaterial';\n  }\n\n  /**\n   * Constructs a new mesh toon node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMeshToonNodeMaterial = true;\n\n    /**\n     * Set to `true` because toon materials react on lights.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.lights = true;\n    this.setDefaultValues(_defaultValues$4);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Setups the lighting model.\n   *\n   * @return {ToonLightingModel} The lighting model.\n   */\n  setupLightingModel(/*builder*/\n  ) {\n    return new ToonLightingModel();\n  }\n}\n\n/** @module MatcapUVNode **/\n\n/**\n * Can be used to compute texture coordinates for projecting a\n * matcap onto a mesh. Used by {@link MeshMatcapNodeMaterial}.\n *\n * @augments TempNode\n */\nclass MatcapUVNode extends TempNode {\n  static get type() {\n    return 'MatcapUVNode';\n  }\n\n  /**\n   * Constructs a new matcap uv node.\n   */\n  constructor() {\n    super('vec2');\n  }\n  setup() {\n    const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();\n    const y = positionViewDirection.cross(x);\n    return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5); // 0.495 to remove artifacts caused by undersized matcap disks\n  }\n}\n\n/**\n * TSL function for creating a matcap uv node.\n *\n * @function\n * @returns {MatcapUVNode}\n */\nconst matcapUV = /*@__PURE__*/nodeImmutable(MatcapUVNode);\nconst _defaultValues$3 = /*@__PURE__*/new MeshMatcapMaterial();\n\n/**\n * Node material version of `MeshMatcapMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshMatcapNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshMatcapNodeMaterial';\n  }\n\n  /**\n   * Constructs a new mesh normal node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMeshMatcapNodeMaterial = true;\n    this.setDefaultValues(_defaultValues$3);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Setups the matcap specific node variables.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setupVariants(builder) {\n    const uv = matcapUV;\n    let matcapColor;\n    if (builder.material.matcap) {\n      matcapColor = materialReference('matcap', 'texture').context({\n        getUV: () => uv\n      });\n    } else {\n      matcapColor = vec3(mix(0.2, 0.8, uv.y)); // default if matcap is missing\n    }\n    diffuseColor.rgb.mulAssign(matcapColor.rgb);\n  }\n}\nconst _defaultValues$2 = /*@__PURE__*/new PointsMaterial();\n\n/**\n * Node material version of `PointsMaterial`.\n *\n * Since WebGPU can render point primitives only with a size of one pixel,\n * this material type does not evaluate the `size` and `sizeAttenuation`\n * property of `PointsMaterial`. Use {@link InstancedPointsNodeMaterial}\n * instead if you need points with a size larger than one pixel.\n *\n * @augments NodeMaterial\n */\nclass PointsNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'PointsNodeMaterial';\n  }\n\n  /**\n   * Constructs a new points node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isPointsNodeMaterial = true;\n    this.setDefaultValues(_defaultValues$2);\n    this.setValues(parameters);\n  }\n}\n\n/** @module RotateNode **/\n\n/**\n * Applies a rotation to the given position node.\n *\n * @augments TempNode\n */\nclass RotateNode extends TempNode {\n  static get type() {\n    return 'RotateNode';\n  }\n\n  /**\n   * Constructs a new rotate node.\n   *\n   * @param {Node} positionNode - The position node.\n   * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending\n   * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n   */\n  constructor(positionNode, rotationNode) {\n    super();\n\n    /**\n     * The position node.\n     *\n     * @type {Node}\n     */\n    this.positionNode = positionNode;\n\n    /**\n     *  Represents the rotation that is applied to the position node.\n     *  Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n     *\n     * @type {Node}\n     */\n    this.rotationNode = rotationNode;\n  }\n\n  /**\n   * The type of the {@link RotateNode#positionNode} defines the node's type.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node's type.\n   */\n  getNodeType(builder) {\n    return this.positionNode.getNodeType(builder);\n  }\n  setup(builder) {\n    const {\n      rotationNode,\n      positionNode\n    } = this;\n    const nodeType = this.getNodeType(builder);\n    if (nodeType === 'vec2') {\n      const cosAngle = rotationNode.cos();\n      const sinAngle = rotationNode.sin();\n      const rotationMatrix = mat2(cosAngle, sinAngle, sinAngle.negate(), cosAngle);\n      return rotationMatrix.mul(positionNode);\n    } else {\n      const rotation = rotationNode;\n      const rotationXMatrix = mat4(vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, cos(rotation.x), sin(rotation.x).negate(), 0.0), vec4(0.0, sin(rotation.x), cos(rotation.x), 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n      const rotationYMatrix = mat4(vec4(cos(rotation.y), 0.0, sin(rotation.y), 0.0), vec4(0.0, 1.0, 0.0, 0.0), vec4(sin(rotation.y).negate(), 0.0, cos(rotation.y), 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n      const rotationZMatrix = mat4(vec4(cos(rotation.z), sin(rotation.z).negate(), 0.0, 0.0), vec4(sin(rotation.z), cos(rotation.z), 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n      return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1.0)).xyz;\n    }\n  }\n}\n\n/**\n * TSL function for creating a rotate node.\n *\n * @function\n * @param {Node} positionNode - The position node.\n * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending\n * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n * @returns {RotateNode}\n */\nconst rotate = /*@__PURE__*/nodeProxy(RotateNode);\nconst _defaultValues$1 = /*@__PURE__*/new SpriteMaterial();\n\n/**\n * Node material version of `SpriteMaterial`.\n *\n * @augments NodeMaterial\n */\nclass SpriteNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'SpriteNodeMaterial';\n  }\n\n  /**\n   * Constructs a new sprite node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isSpriteNodeMaterial = true;\n    this._useSizeAttenuation = true;\n\n    /**\n     * This property makes it possible to define the position of the sprite with a\n     * node. That can be useful when the material is used with instanced rendering\n     * and node data are defined with an instanced attribute node:\n     * ```js\n     * const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );\n     * material.positionNode = instancedBufferAttribute( positionAttribute );\n     * ```\n     * Another possibility is to compute the instanced data with a compute shader:\n     * ```js\n     * const positionBuffer = instancedArray( particleCount, 'vec3' );\n     * particleMaterial.positionNode = positionBuffer.toAttribute();\n     * ```\n     *\n     * @type {Node<vec2>?}\n     * @default null\n     */\n    this.positionNode = null;\n\n    /**\n     * The rotation of sprite materials is by default inferred from the `rotation`,\n     * property. This node property allows to overwrite the default and define\n     * the rotation with a node instead.\n     *\n     * If you don't want to overwrite the rotation but modify the existing\n     * value instead, use {@link module:MaterialNode.materialRotation}.\n     *\n     * @type {Node<float>?}\n     * @default null\n     */\n    this.rotationNode = null;\n\n    /**\n     * This node property provides an additional way to scale sprites next to\n     * `Object3D.scale`. The scale transformation based in `Object3D.scale`\n     * is multiplied with the scale value of this node in the vertex shader.\n     *\n     * @type {Node<vec2>?}\n     * @default null\n     */\n    this.scaleNode = null;\n    this.setDefaultValues(_defaultValues$1);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Setups the position node in view space. This method implements\n   * the sprite specific vertex shader.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node<vec3>} The position in view space.\n   */\n  setupPositionView(builder) {\n    const {\n      object,\n      camera\n    } = builder;\n    const sizeAttenuation = this.sizeAttenuation;\n    const {\n      positionNode,\n      rotationNode,\n      scaleNode\n    } = this;\n    const mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));\n    let scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());\n    if (scaleNode !== null) {\n      scale = scale.mul(scaleNode);\n    }\n    if (sizeAttenuation === false) {\n      if (camera.isPerspectiveCamera) {\n        scale = scale.mul(mvPosition.z.negate());\n      } else {\n        const orthoScale = float(2.0).div(cameraProjectionMatrix.element(1).element(1));\n        scale = scale.mul(orthoScale.mul(2));\n      }\n    }\n    let alignedPosition = positionGeometry.xy;\n    if (object.center && object.center.isVector2 === true) {\n      const center = reference$1('center', 'vec2', object);\n      alignedPosition = alignedPosition.sub(center.sub(0.5));\n    }\n    alignedPosition = alignedPosition.mul(scale);\n    const rotation = float(rotationNode || materialRotation);\n    const rotatedPosition = rotate(alignedPosition, rotation);\n    return vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);\n  }\n  copy(source) {\n    this.positionNode = source.positionNode;\n    this.rotationNode = source.rotationNode;\n    this.scaleNode = source.scaleNode;\n    return super.copy(source);\n  }\n\n  /**\n   * Whether to use size attenuation or not.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  get sizeAttenuation() {\n    return this._useSizeAttenuation;\n  }\n  set sizeAttenuation(value) {\n    if (this._useSizeAttenuation !== value) {\n      this._useSizeAttenuation = value;\n      this.needsUpdate = true;\n    }\n  }\n}\n\n/**\n * Represents lighting model for a shadow material. Used in {@link ShadowNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass ShadowMaskModel extends LightingModel {\n  /**\n   * Constructs a new shadow mask model.\n   */\n  constructor() {\n    super();\n\n    /**\n     * The shadow mask node.\n     *\n     * @type {Node}\n     */\n    this.shadowNode = float(1).toVar('shadowMask');\n  }\n\n  /**\n   * Only used to save the shadow mask.\n   *\n   * @param {Object} input - The input data.\n   */\n  direct({\n    shadowMask\n  }) {\n    this.shadowNode.mulAssign(shadowMask);\n  }\n\n  /**\n   * Uses the shadow mask to produce the final color.\n   *\n   * @param {ContextNode} context - The current node context.\n   */\n  finish(context) {\n    diffuseColor.a.mulAssign(this.shadowNode.oneMinus());\n    context.outgoingLight.rgb.assign(diffuseColor.rgb); // TODO: Optimize LightsNode to avoid this assignment\n  }\n}\nconst _defaultValues = /*@__PURE__*/new ShadowMaterial();\n\n/**\n * Node material version of `ShadowMaterial`.\n *\n * @augments NodeMaterial\n */\nclass ShadowNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'ShadowNodeMaterial';\n  }\n\n  /**\n   * Constructs a new shadow node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isShadowNodeMaterial = true;\n\n    /**\n     * Set to `true` because so it's possible to implement\n     * the shadow mask effect.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.lights = true;\n    this.setDefaultValues(_defaultValues);\n    this.setValues(parameters);\n  }\n\n  /**\n   * Setups the lighting model.\n   *\n   * @return {ShadowMaskModel} The lighting model.\n   */\n  setupLightingModel(/*builder*/\n  ) {\n    return new ShadowMaskModel();\n  }\n}\n\n/** @module Texture3DNode **/\n\nconst normal = Fn(({\n  texture,\n  uv\n}) => {\n  const epsilon = 0.0001;\n  const ret = vec3().toVar();\n  If(uv.x.lessThan(epsilon), () => {\n    ret.assign(vec3(1, 0, 0));\n  }).ElseIf(uv.y.lessThan(epsilon), () => {\n    ret.assign(vec3(0, 1, 0));\n  }).ElseIf(uv.z.lessThan(epsilon), () => {\n    ret.assign(vec3(0, 0, 1));\n  }).ElseIf(uv.x.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(-1, 0, 0));\n  }).ElseIf(uv.y.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(0, -1, 0));\n  }).ElseIf(uv.z.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(0, 0, -1));\n  }).Else(() => {\n    const step = 0.01;\n    const x = texture.sample(uv.add(vec3(-step, 0.0, 0.0))).r.sub(texture.sample(uv.add(vec3(step, 0.0, 0.0))).r);\n    const y = texture.sample(uv.add(vec3(0.0, -step, 0.0))).r.sub(texture.sample(uv.add(vec3(0.0, step, 0.0))).r);\n    const z = texture.sample(uv.add(vec3(0.0, 0.0, -step))).r.sub(texture.sample(uv.add(vec3(0.0, 0.0, step))).r);\n    ret.assign(vec3(x, y, z));\n  });\n  return ret.normalize();\n});\n\n/**\n * This type of uniform node represents a 3D texture.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass Texture3DNode extends TextureNode {\n  static get type() {\n    return 'Texture3DNode';\n  }\n\n  /**\n   * Constructs a new 3D texture node.\n   *\n   * @param {Data3DTexture} value - The 3D texture.\n   * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n   * @param {Node<int>?} [levelNode=null] - The level node.\n   */\n  constructor(value, uvNode = null, levelNode = null) {\n    super(value, uvNode, levelNode);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isTexture3DNode = true;\n  }\n\n  /**\n   * Overwrites the default implementation to return a fixed value `'texture3D'`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(/*builder*/\n  ) {\n    return 'texture3D';\n  }\n\n  /**\n   * Returns a default uv node which is in context of 3D textures a three-dimensional\n   * uv node.\n   *\n   * @return {Node<vec3>} The default uv node.\n   */\n  getDefaultUV() {\n    return vec3(0.5, 0.5, 0.5);\n  }\n\n  /**\n   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored\n   * for 3D textures. The uv transformation matrix is not applied to 3D textures.\n   *\n   * @param {Boolean} value - The update toggle.\n   */\n  setUpdateMatrix(/*updateMatrix*/) {} // Ignore .updateMatrix for 3d TextureNode\n\n  /**\n   * Overwrites the default implementation to return the unmodified uv node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {Node} uvNode - The uv node to setup.\n   * @return {Node} The unmodified uv node.\n   */\n  setupUV(builder, uvNode) {\n    const texture = this.value;\n    if (builder.isFlipY() && (texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true)) {\n      if (this.sampler) {\n        uvNode = uvNode.flipY();\n      } else {\n        uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));\n      }\n    }\n    return uvNode;\n  }\n\n  /**\n   * Generates the uv code snippet.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {Node} uvNode - The uv node to generate code for.\n   * @return {String} The generated code snippet.\n   */\n  generateUV(builder, uvNode) {\n    return uvNode.build(builder, 'vec3');\n  }\n\n  /**\n   * TODO.\n   *\n   * @param {Node<vec3>} uvNode - The uv node .\n   * @return {Node<vec3>} TODO.\n   */\n  normal(uvNode) {\n    return normal({\n      texture: this,\n      uv: uvNode\n    });\n  }\n}\n\n/**\n * TSL function for creating a 3D texture node.\n *\n * @function\n * @param {Data3DTexture} value - The 3D texture.\n * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @returns {Texture3DNode}\n */\nconst texture3D = /*@__PURE__*/nodeProxy(Texture3DNode);\n\n/** @module VolumeNodeMaterial **/\n\n/**\n * Node material intended for volume rendering. The volumetic data are\n * defined with an instance of {@link Data3DTexture}.\n *\n * @augments NodeMaterial\n */\nclass VolumeNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'VolumeNodeMaterial';\n  }\n\n  /**\n   * Constructs a new volume node material.\n   *\n   * @param {Object?} parameters - The configuration parameter.\n   */\n  constructor(parameters) {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isVolumeNodeMaterial = true;\n\n    /**\n     * The base color of the volume.\n     *\n     * @type {Color}\n     * @default 100\n     */\n    this.base = new Color(0xffffff);\n\n    /**\n     * A 3D data texture holding the volumetric data.\n     *\n     * @type {Data3DTexture?}\n     * @default null\n     */\n    this.map = null;\n\n    /**\n     * This number of samples for each ray that hits the mesh's surface\n     * and travels through the volume.\n     *\n     * @type {Number}\n     * @default 100\n     */\n    this.steps = 100;\n\n    /**\n     * Callback for {@link VolumeNodeMaterial#testNode}.\n     *\n     * @callback testNodeCallback\n     * @param {Data3DTexture<float>} map - The 3D texture.\n     * @param {Node<float>} mapValue - The sampled value inside the volume.\n     * @param {Node<vec3>} probe - The probe which is the entry point of the ray on the mesh's surface.\n     * @param {Node<vec4>} finalColor - The final color.\n     */\n\n    /**\n     * The volume rendering of this material works by shooting rays\n     * from the camera position through each fragment of the mesh's\n     * surface and sample the inner volume in a raymarching fashion\n     * mutiple times.\n     *\n     * This node can be used to assign a callback function of type `Fn`\n     * that will be exexuted per sample. The callback receives the\n     * texture, the sampled texture value as well as position on the surface\n     * where the rays enters the volume. The last parameter is a color\n     * that allows the callback to determine the final color.\n     *\n     * @type {testNodeCallback?}\n     * @default null\n     */\n    this.testNode = null;\n    this.setValues(parameters);\n  }\n\n  /**\n   * Setups the vertex and fragment stage of this node material.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    const map = texture3D(this.map, null, 0);\n    const hitBox = Fn(({\n      orig,\n      dir\n    }) => {\n      const box_min = vec3(-0.5);\n      const box_max = vec3(0.5);\n      const inv_dir = dir.reciprocal();\n      const tmin_tmp = box_min.sub(orig).mul(inv_dir);\n      const tmax_tmp = box_max.sub(orig).mul(inv_dir);\n      const tmin = min$1(tmin_tmp, tmax_tmp);\n      const tmax = max$1(tmin_tmp, tmax_tmp);\n      const t0 = max$1(tmin.x, max$1(tmin.y, tmin.z));\n      const t1 = min$1(tmax.x, min$1(tmax.y, tmax.z));\n      return vec2(t0, t1);\n    });\n    this.fragmentNode = Fn(() => {\n      const vOrigin = varying(vec3(modelWorldMatrixInverse.mul(vec4(cameraPosition, 1.0))));\n      const vDirection = varying(positionGeometry.sub(vOrigin));\n      const rayDir = vDirection.normalize();\n      const bounds = vec2(hitBox({\n        orig: vOrigin,\n        dir: rayDir\n      })).toVar();\n      bounds.x.greaterThan(bounds.y).discard();\n      bounds.assign(vec2(max$1(bounds.x, 0.0), bounds.y));\n      const p = vec3(vOrigin.add(bounds.x.mul(rayDir))).toVar();\n      const inc = vec3(rayDir.abs().reciprocal()).toVar();\n      const delta = float(min$1(inc.x, min$1(inc.y, inc.z))).toVar('delta'); // used 'delta' name in loop\n\n      delta.divAssign(materialReference('steps', 'float'));\n      const ac = vec4(materialReference('base', 'color'), 0.0).toVar();\n      Loop({\n        type: 'float',\n        start: bounds.x,\n        end: bounds.y,\n        update: '+= delta'\n      }, () => {\n        const d = property('float', 'd').assign(map.sample(p.add(0.5)).r);\n        if (this.testNode !== null) {\n          this.testNode({\n            map: map,\n            mapValue: d,\n            probe: p,\n            finalColor: ac\n          }).append();\n        } else {\n          // default to show surface of mesh\n          ac.a.assign(1);\n          Break();\n        }\n        p.addAssign(rayDir.mul(delta));\n      });\n      ac.a.equal(0).discard();\n      return vec4(ac);\n    })();\n    super.setup(builder);\n  }\n}\n\n/**\n * This module manages the internal animation loop of the renderer.\n *\n * @private\n */\nclass Animation {\n  /**\n   * Constructs a new animation loop management component.\n   *\n   * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n   * @param {Info} info - Renderer component for managing metrics and monitoring data.\n   */\n  constructor(nodes, info) {\n    /**\n     * Renderer component for managing nodes related logic.\n     *\n     * @type {Nodes}\n     */\n    this.nodes = nodes;\n\n    /**\n     * Renderer component for managing metrics and monitoring data.\n     *\n     * @type {Info}\n     */\n    this.info = info;\n\n    /**\n     * A reference to the context from `requestAnimationFrame()` can\n     * be called (usually `window`).\n     *\n     * @type {Window|XRSession}\n     */\n    this._context = self;\n\n    /**\n     * The user-defined animation loop.\n     *\n     * @type {Function?}\n     * @default null\n     */\n    this._animationLoop = null;\n\n    /**\n     * The requestId whic is returned from the `requestAnimationFrame()` call.\n     * Can be used to cancel the stop the animation loop.\n     *\n     * @type {Number?}\n     * @default null\n     */\n    this._requestId = null;\n  }\n\n  /**\n   * Starts the internal animation loop.\n   */\n  start() {\n    const update = (time, frame) => {\n      this._requestId = this._context.requestAnimationFrame(update);\n      if (this.info.autoReset === true) this.info.reset();\n      this.nodes.nodeFrame.update();\n      this.info.frame = this.nodes.nodeFrame.frameId;\n      if (this._animationLoop !== null) this._animationLoop(time, frame);\n    };\n    update();\n  }\n\n  /**\n   * Stops the internal animation loop.\n   */\n  stop() {\n    this._context.cancelAnimationFrame(this._requestId);\n    this._requestId = null;\n  }\n\n  /**\n   * Defines the user-level animation loop.\n   *\n   * @param {Function} callback - The animation loop.\n   */\n  setAnimationLoop(callback) {\n    this._animationLoop = callback;\n  }\n\n  /**\n   * Defines the context in which `requestAnimationFrame()` is executed.\n   *\n   * @param {Window|XRSession} context - The context to set.\n   */\n  setContext(context) {\n    this._context = context;\n  }\n\n  /**\n   * Frees all internal resources and stops the animation loop.\n   */\n  dispose() {\n    this.stop();\n  }\n}\n\n/**\n * Data structure for the renderer. It allows defining values\n * with chained, hierarchical keys. Keys are meant to be\n * objects since the module internally works with Weak Maps\n * for perforamnce reasons.\n *\n * @private\n */\nclass ChainMap {\n  /**\n   * Constructs a new chained map.\n   */\n  constructor() {\n    /**\n     * The root Weak Map.\n     *\n     * @type {WeakMap}\n     */\n    this.weakMap = new WeakMap();\n  }\n\n  /**\n   * Returns the value for the given array of keys.\n   *\n   * @param {Array<Object>} keys - List of keys.\n   * @return {Any} The value. Returns `undefined` if no value was found.\n   */\n  get(keys) {\n    let map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      map = map.get(keys[i]);\n      if (map === undefined) return undefined;\n    }\n    return map.get(keys[keys.length - 1]);\n  }\n\n  /**\n   * Sets the value for the given keys.\n   *\n   * @param {Array<Object>} keys - List of keys.\n   * @param {Any} value - The value to set.\n   * @return {ChainMap} A reference to this chain map.\n   */\n  set(keys, value) {\n    let map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (map.has(key) === false) map.set(key, new WeakMap());\n      map = map.get(key);\n    }\n    map.set(keys[keys.length - 1], value);\n    return this;\n  }\n\n  /**\n   * Deletes a value for the given keys.\n   *\n   * @param {Array<Object>} keys - The keys.\n   * @return {Boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.\n   */\n  delete(keys) {\n    let map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      map = map.get(keys[i]);\n      if (map === undefined) return false;\n    }\n    return map.delete(keys[keys.length - 1]);\n  }\n}\nlet _id$9 = 0;\nfunction getKeys(obj) {\n  const keys = Object.keys(obj);\n  let proto = Object.getPrototypeOf(obj);\n  while (proto) {\n    const descriptors = Object.getOwnPropertyDescriptors(proto);\n    for (const key in descriptors) {\n      if (descriptors[key] !== undefined) {\n        const descriptor = descriptors[key];\n        if (descriptor && typeof descriptor.get === 'function') {\n          keys.push(key);\n        }\n      }\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return keys;\n}\n\n/**\n * A render object is the renderer's representation of single entity that gets drawn\n * with a draw command. There is no unique mapping of render objects to 3D objects in the\n * scene since render objects also depend from the used material, the current render context\n * and the current scene's lighting.\n *\n * In general, the basic process of the renderer is:\n *\n * - Analyze the 3D objects in the scene and generate render lists containing render items.\n * - Process the render lists by calling one or more render commands for each render item.\n * - For each render command, request a render object and perform the draw.\n *\n * The module provides an interface to get data required for the draw command like the actual\n * draw parameters or vertex buffers. It also holds a series of caching related methods since\n * creating render objects should only be done when necessary.\n *\n * @private\n */\nclass RenderObject {\n  /**\n   * Constructs a new render object.\n   *\n   * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n   * @param {Geometries} geometries - Renderer component for managing geometries.\n   * @param {Renderer} renderer - The renderer.\n   * @param {Object3D} object - The 3D object.\n   * @param {Material} material - The 3D object's material.\n   * @param {Scene} scene - The scene the 3D object belongs to.\n   * @param {Camera} camera - The camera the object should be rendered with.\n   * @param {LightsNode} lightsNode - The lights node.\n   * @param {RenderContext} renderContext - The render context.\n   * @param {ClippingContext} clippingContext - The clipping context.\n   */\n  constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext) {\n    this.id = _id$9++;\n\n    /**\n     * Renderer component for managing nodes related logic.\n     *\n     * @type {Nodes}\n     * @private\n     */\n    this._nodes = nodes;\n\n    /**\n     * Renderer component for managing geometries.\n     *\n     * @type {Geometries}\n     * @private\n     */\n    this._geometries = geometries;\n\n    /**\n     * The renderer.\n     *\n     * @type {Renderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The 3D object.\n     *\n     * @type {Object3D}\n     */\n    this.object = object;\n\n    /**\n     * The 3D object's material.\n     *\n     * @type {Material}\n     */\n    this.material = material;\n\n    /**\n     * The scene the 3D object belongs to.\n     *\n     * @type {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The camera the 3D object should be rendered with.\n     *\n     * @type {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * The lights node.\n     *\n     * @type {LightsNode}\n     */\n    this.lightsNode = lightsNode;\n\n    /**\n     * The render context.\n     *\n     * @type {RenderContext}\n     */\n    this.context = renderContext;\n\n    /**\n     * The 3D object's geometry.\n     *\n     * @type {BufferGeometry}\n     */\n    this.geometry = object.geometry;\n\n    /**\n     * The render object's version.\n     *\n     * @type {Number}\n     */\n    this.version = material.version;\n\n    /**\n     * The draw range of the geometry.\n     *\n     * @type {Object?}\n     * @default null\n     */\n    this.drawRange = null;\n\n    /**\n     * An array holding the buffer attributes\n     * of the render object. This entails attribute\n     * definitions on geometry and node level.\n     *\n     * @type {Array<BufferAttribute>?}\n     * @default null\n     */\n    this.attributes = null;\n\n    /**\n     * A reference to a render pipeline the render\n     * object is processed with.\n     *\n     * @type {RenderPipeline}\n     * @default null\n     */\n    this.pipeline = null;\n\n    /**\n     * An array holding the vertex buffers which can\n     * be buffer attributes but also interleaved buffers.\n     *\n     * @type {Array<BufferAttribute|InterleavedBuffer>?}\n     * @default null\n     */\n    this.vertexBuffers = null;\n\n    /**\n     * The parameters for the draw command.\n     *\n     * @type {Object?}\n     * @default null\n     */\n    this.drawParams = null;\n\n    /**\n     * If this render object is used inside a render bundle,\n     * this property points to the respective bundle group.\n     *\n     * @type {BundleGroup?}\n     * @default null\n     */\n    this.bundle = null;\n\n    /**\n     * The clipping context.\n     *\n     * @type {ClippingContext}\n     */\n    this.clippingContext = clippingContext;\n\n    /**\n     * The clipping context's cache key.\n     *\n     * @type {String}\n     */\n    this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';\n\n    /**\n     * The initial node cache key.\n     *\n     * @type {Number}\n     */\n    this.initialNodesCacheKey = this.getDynamicCacheKey();\n\n    /**\n     * The initial cache key.\n     *\n     * @type {Number}\n     */\n    this.initialCacheKey = this.getCacheKey();\n\n    /**\n     * The node builder state.\n     *\n     * @type {NodeBuilderState?}\n     * @private\n     * @default null\n     */\n    this._nodeBuilderState = null;\n\n    /**\n     * An array of bindings.\n     *\n     * @type {Array<BindGroup>?}\n     * @private\n     * @default null\n     */\n    this._bindings = null;\n\n    /**\n     * Reference to the node material observer.\n     *\n     * @type {NodeMaterialObserver?}\n     * @private\n     * @default null\n     */\n    this._monitor = null;\n\n    /**\n     * An event listener which is defined by `RenderObjects`. It performs\n     * clean up tasks when `dispose()` on this render object.\n     *\n     * @method\n     */\n    this.onDispose = null;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isRenderObject = true;\n\n    /**\n     * An event listener which is executed when `dispose()` is called on\n     * the render object's material.\n     *\n     * @method\n     */\n    this.onMaterialDispose = () => {\n      this.dispose();\n    };\n    this.material.addEventListener('dispose', this.onMaterialDispose);\n  }\n\n  /**\n   * Updates the clipping context.\n   *\n   * @param {ClippingContext} context - The clipping context to set.\n   */\n  updateClipping(context) {\n    this.clippingContext = context;\n  }\n\n  /**\n   * Whether the clipping requires an update or not.\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  get clippingNeedsUpdate() {\n    if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey) return false;\n    this.clippingContextCacheKey = this.clippingContext.cacheKey;\n    return true;\n  }\n\n  /**\n   * The number of clipping planes defined in context of hardware clipping.\n   *\n   * @type {Number}\n   * @readonly\n   */\n  get hardwareClippingPlanes() {\n    return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;\n  }\n\n  /**\n   * Returns the node builder state of this render object.\n   *\n   * @return {NodeBuilderState} The node buider state.\n   */\n  getNodeBuilderState() {\n    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));\n  }\n\n  /**\n   * Returns the node material observer of this render object.\n   *\n   * @return {NodeMaterialObserver} The node material observer.\n   */\n  getMonitor() {\n    return this._monitor || (this._monitor = this.getNodeBuilderState().monitor);\n  }\n\n  /**\n   * Returns an array of bind groups of this render object.\n   *\n   * @return {Array<BindGroup>} The bindings.\n   */\n  getBindings() {\n    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());\n  }\n\n  /**\n   * Returns the index of the render object's geometry.\n   *\n   * @return {BufferAttribute?} The index. Returns `null` for non-indexed geometries.\n   */\n  getIndex() {\n    return this._geometries.getIndex(this);\n  }\n\n  /**\n   * Returns the indirect buffer attribute.\n   *\n   * @return {BufferAttribute?} The indirect attribute. `null` if no indirect drawing is used.\n   */\n  getIndirect() {\n    return this._geometries.getIndirect(this);\n  }\n\n  /**\n   * Returns an array that acts as a key for identifying the render object in a chain map.\n   *\n   * @return {Array<Object>} An array with object references.\n   */\n  getChainArray() {\n    return [this.object, this.material, this.context, this.lightsNode];\n  }\n\n  /**\n   * This method is used when the geometry of a 3D object has been exchanged and the\n   * respective render object now requires an update.\n   *\n   * @param {BufferGeometry} geometry - The geometry to set.\n   */\n  setGeometry(geometry) {\n    this.geometry = geometry;\n    this.attributes = null;\n  }\n\n  /**\n   * Returns the buffer attributes of the render object. The returned array holds\n   * attribute definitions on geometry and node level.\n   *\n   * @return {Array<BufferAttribute>} An array with buffer attributes.\n   */\n  getAttributes() {\n    if (this.attributes !== null) return this.attributes;\n    const nodeAttributes = this.getNodeBuilderState().nodeAttributes;\n    const geometry = this.geometry;\n    const attributes = [];\n    const vertexBuffers = new Set();\n    for (const nodeAttribute of nodeAttributes) {\n      const attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute(nodeAttribute.name);\n      if (attribute === undefined) continue;\n      attributes.push(attribute);\n      const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n      vertexBuffers.add(bufferAttribute);\n    }\n    this.attributes = attributes;\n    this.vertexBuffers = Array.from(vertexBuffers.values());\n    return attributes;\n  }\n\n  /**\n   * Returns the vertex buffers of the render object.\n   *\n   * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.\n   */\n  getVertexBuffers() {\n    if (this.vertexBuffers === null) this.getAttributes();\n    return this.vertexBuffers;\n  }\n\n  /**\n   * Returns the draw parameters for the render object.\n   *\n   * @return {{vertexCount: Number, firstVertex: Number, instanceCount: Number, firstInstance: Number}} The draw parameters.\n   */\n  getDrawParameters() {\n    const {\n      object,\n      material,\n      geometry,\n      group,\n      drawRange\n    } = this;\n    const drawParams = this.drawParams || (this.drawParams = {\n      vertexCount: 0,\n      firstVertex: 0,\n      instanceCount: 0,\n      firstInstance: 0\n    });\n    const index = this.getIndex();\n    const hasIndex = index !== null;\n    const instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : object.count > 1 ? object.count : 1;\n    if (instanceCount === 0) return null;\n    drawParams.instanceCount = instanceCount;\n    if (object.isBatchedMesh === true) return drawParams;\n    let rangeFactor = 1;\n    if (material.wireframe === true && !object.isPoints && !object.isLineSegments && !object.isLine && !object.isLineLoop) {\n      rangeFactor = 2;\n    }\n    let firstVertex = drawRange.start * rangeFactor;\n    let lastVertex = (drawRange.start + drawRange.count) * rangeFactor;\n    if (group !== null) {\n      firstVertex = Math.max(firstVertex, group.start * rangeFactor);\n      lastVertex = Math.min(lastVertex, (group.start + group.count) * rangeFactor);\n    }\n    const position = geometry.attributes.position;\n    let itemCount = Infinity;\n    if (hasIndex) {\n      itemCount = index.count;\n    } else if (position !== undefined && position !== null) {\n      itemCount = position.count;\n    }\n    firstVertex = Math.max(firstVertex, 0);\n    lastVertex = Math.min(lastVertex, itemCount);\n    const count = lastVertex - firstVertex;\n    if (count < 0 || count === Infinity) return null;\n    drawParams.vertexCount = count;\n    drawParams.firstVertex = firstVertex;\n    return drawParams;\n  }\n\n  /**\n   * Returns the render object's geometry cache key.\n   *\n   * The geometry cache key is part of the material cache key.\n   *\n   * @return {String} The geometry cache key.\n   */\n  getGeometryCacheKey() {\n    const {\n      geometry\n    } = this;\n    let cacheKey = '';\n    for (const name of Object.keys(geometry.attributes).sort()) {\n      const attribute = geometry.attributes[name];\n      cacheKey += name + ',';\n      if (attribute.data) cacheKey += attribute.data.stride + ',';\n      if (attribute.offset) cacheKey += attribute.offset + ',';\n      if (attribute.itemSize) cacheKey += attribute.itemSize + ',';\n      if (attribute.normalized) cacheKey += 'n,';\n    }\n    if (geometry.index) {\n      cacheKey += 'index,';\n    }\n    return cacheKey;\n  }\n\n  /**\n   * Returns the render object's material cache key.\n   *\n   * The material cache key is part of the render object cache key.\n   *\n   * @return {String} The material cache key.\n   */\n  getMaterialCacheKey() {\n    const {\n      object,\n      material\n    } = this;\n    let cacheKey = material.customProgramCacheKey();\n    for (const property of getKeys(material)) {\n      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property)) continue;\n      const value = material[property];\n      let valueKey;\n      if (value !== null) {\n        // some material values require a formatting\n\n        const type = typeof value;\n        if (type === 'number') {\n          valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc\n        } else if (type === 'object') {\n          valueKey = '{';\n          if (value.isTexture) {\n            valueKey += value.mapping;\n          }\n          valueKey += '}';\n        } else {\n          valueKey = String(value);\n        }\n      } else {\n        valueKey = String(value);\n      }\n      cacheKey += /*property + ':' +*/valueKey + ',';\n    }\n    cacheKey += this.clippingContextCacheKey + ',';\n    if (object.geometry) {\n      cacheKey += this.getGeometryCacheKey();\n    }\n    if (object.skeleton) {\n      cacheKey += object.skeleton.bones.length + ',';\n    }\n    if (object.morphTargetInfluences) {\n      cacheKey += object.morphTargetInfluences.length + ',';\n    }\n    if (object.isBatchedMesh) {\n      cacheKey += object._matricesTexture.uuid + ',';\n      if (object._colorsTexture !== null) {\n        cacheKey += object._colorsTexture.uuid + ',';\n      }\n    }\n    if (object.count > 1) {\n      // TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850\n\n      cacheKey += object.uuid + ',';\n    }\n    cacheKey += object.receiveShadow + ',';\n    return hashString(cacheKey);\n  }\n\n  /**\n   * Whether the geometry requires an update or not.\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  get needsGeometryUpdate() {\n    return this.geometry.id !== this.object.geometry.id;\n  }\n\n  /**\n   * Whether the render object requires an update or not.\n   *\n   * Note: There are two distinct places where render objects are checked for an update.\n   *\n   * 1. In `RenderObjects.get()` which is executed when the render object is request. This\n   * method checks the `needsUpdate` flag and recreates the render object if necessary.\n   * 2. In `Renderer._renderObjectDirect()` right after getting the render object via\n   * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect\n   * a need for a refresh due to material, geometry or object related value changes.\n   *\n   * TODO: Investigate if it's possible to merge boths steps so there is only a single place\n   * that performs the 'needsUpdate' check.\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  get needsUpdate() {\n    return /*this.object.static !== true &&*/this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate;\n  }\n\n  /**\n   * Returns the dynamic cache key which represents a key that is computed per draw command.\n   *\n   * @return {String} The cache key.\n   */\n  getDynamicCacheKey() {\n    // Environment Nodes Cache Key\n\n    let cacheKey = this._nodes.getCacheKey(this.scene, this.lightsNode);\n    if (this.object.receiveShadow) {\n      cacheKey += 1;\n    }\n    return cacheKey;\n  }\n\n  /**\n   * Returns the render object's cache key.\n   *\n   * @return {String} The cache key.\n   */\n  getCacheKey() {\n    return this.getMaterialCacheKey() + this.getDynamicCacheKey();\n  }\n\n  /**\n   * Frees internal resources.\n   */\n  dispose() {\n    this.material.removeEventListener('dispose', this.onMaterialDispose);\n    this.onDispose();\n  }\n}\nconst _chainArray = [];\n\n/**\n * This module manages the render objects of the renderer.\n *\n * @private\n */\nclass RenderObjects {\n  /**\n   * Constructs a new render object management component.\n   *\n   * @param {Renderer} renderer - The renderer.\n   * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n   * @param {Geometries} geometries - Renderer component for managing geometries.\n   * @param {Pipelines} pipelines - Renderer component for managing pipelines.\n   * @param {Bindings} bindings - Renderer component for managing bindings.\n   * @param {Info} info - Renderer component for managing metrics and monitoring data.\n   */\n  constructor(renderer, nodes, geometries, pipelines, bindings, info) {\n    /**\n     * The renderer.\n     *\n     * @type {Renderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * Renderer component for managing nodes related logic.\n     *\n     * @type {Nodes}\n     */\n    this.nodes = nodes;\n\n    /**\n     * Renderer component for managing geometries.\n     *\n     * @type {Geometries}\n     */\n    this.geometries = geometries;\n\n    /**\n     * Renderer component for managing pipelines.\n     *\n     * @type {Pipelines}\n     */\n    this.pipelines = pipelines;\n\n    /**\n     * Renderer component for managing bindings.\n     *\n     * @type {Bindings}\n     */\n    this.bindings = bindings;\n\n    /**\n     * Renderer component for managing metrics and monitoring data.\n     *\n     * @type {Info}\n     */\n    this.info = info;\n\n    /**\n     * A dictionary that manages render contexts in chain maps\n     * for each pass ID.\n     *\n     * @type {Object<String,ChainMap>}\n     */\n    this.chainMaps = {};\n  }\n\n  /**\n   * Returns a render object for the given object and state data.\n   *\n   * @param {Object3D} object - The 3D object.\n   * @param {Material} material - The 3D object's material.\n   * @param {Scene} scene - The scene the 3D object belongs to.\n   * @param {Camera} camera - The camera the 3D object should be rendered with.\n   * @param {LightsNode} lightsNode - The lights node.\n   * @param {RenderContext} renderContext - The render context.\n   * @param {ClippingContext} clippingContext - The clipping context.\n   * @param {String?} passId - An optional ID for identifying the pass.\n   * @return {RenderObject} The render object.\n   */\n  get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {\n    const chainMap = this.getChainMap(passId);\n\n    // reuse chainArray\n    _chainArray[0] = object;\n    _chainArray[1] = material;\n    _chainArray[2] = renderContext;\n    _chainArray[3] = lightsNode;\n    let renderObject = chainMap.get(_chainArray);\n    if (renderObject === undefined) {\n      renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);\n      chainMap.set(_chainArray, renderObject);\n    } else {\n      renderObject.updateClipping(clippingContext);\n      if (renderObject.needsGeometryUpdate) {\n        renderObject.setGeometry(object.geometry);\n      }\n      if (renderObject.version !== material.version || renderObject.needsUpdate) {\n        if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {\n          renderObject.dispose();\n          renderObject = this.get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);\n        } else {\n          renderObject.version = material.version;\n        }\n      }\n    }\n    return renderObject;\n  }\n\n  /**\n   * Returns a chain map for the given pass ID.\n   *\n   * @param {String} [passId='default'] - The pass ID.\n   * @return {ChainMap} The chain map.\n   */\n  getChainMap(passId = 'default') {\n    return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());\n  }\n\n  /**\n   * Frees internal resources.\n   */\n  dispose() {\n    this.chainMaps = {};\n  }\n\n  /**\n   * Factory method for creating render objects with the given list of parameters.\n   *\n   * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n   * @param {Geometries} geometries - Renderer component for managing geometries.\n   * @param {Renderer} renderer - The renderer.\n   * @param {Object3D} object - The 3D object.\n   * @param {Material} material - The object's material.\n   * @param {Scene} scene - The scene the 3D object belongs to.\n   * @param {Camera} camera - The camera the object should be rendered with.\n   * @param {LightsNode} lightsNode - The lights node.\n   * @param {RenderContext} renderContext - The render context.\n   * @param {ClippingContext} clippingContext - The clipping context.\n   * @param {String?} passId - An optional ID for identifying the pass.\n   * @return {RenderObject} The render object.\n   */\n  createRenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {\n    const chainMap = this.getChainMap(passId);\n    const renderObject = new RenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext);\n    renderObject.onDispose = () => {\n      this.pipelines.delete(renderObject);\n      this.bindings.delete(renderObject);\n      this.nodes.delete(renderObject);\n      chainMap.delete(renderObject.getChainArray());\n    };\n    return renderObject;\n  }\n}\n\n/**\n * Data structure for the renderer. It is intended to manage\n * data of objects in dictionaries.\n *\n * @private\n */\nclass DataMap {\n  /**\n   * Constructs a new data map.\n   */\n  constructor() {\n    /**\n     * `DataMap` internally uses a weak map\n     * to manage its data.\n     *\n     * @type {WeakMap}\n     */\n    this.data = new WeakMap();\n  }\n\n  /**\n   * Returns the dictionary for the given object.\n   *\n   * @param {Object} object - The object.\n   * @return {Object} The dictionary.\n   */\n  get(object) {\n    let map = this.data.get(object);\n    if (map === undefined) {\n      map = {};\n      this.data.set(object, map);\n    }\n    return map;\n  }\n\n  /**\n   * Deletes the dictionary for the given object.\n   *\n   * @param {Object} object - The object.\n   * @return {Object?} The deleted dictionary.\n   */\n  delete(object) {\n    let map = null;\n    if (this.data.has(object)) {\n      map = this.data.get(object);\n      this.data.delete(object);\n    }\n    return map;\n  }\n\n  /**\n   * Returns `true` if the given object has a dictionary defined.\n   *\n   * @param {Object} object - The object to test.\n   * @return {Boolean} Whether a dictionary is defined or not.\n   */\n  has(object) {\n    return this.data.has(object);\n  }\n\n  /**\n   * Frees internal resources.\n   */\n  dispose() {\n    this.data = new WeakMap();\n  }\n}\nconst AttributeType = {\n  VERTEX: 1,\n  INDEX: 2,\n  STORAGE: 3,\n  INDIRECT: 4\n};\n\n// size of a chunk in bytes (STD140 layout)\n\nconst GPU_CHUNK_BYTES = 16;\n\n// @TODO: Move to src/constants.js\n\nconst BlendColorFactor = 211;\nconst OneMinusBlendColorFactor = 212;\n\n/**\n * This renderer module manages geometry attributes.\n *\n * @private\n * @augments DataMap\n */\nclass Attributes extends DataMap {\n  /**\n   * Constructs a new attribute management component.\n   *\n   * @param {Backend} backend - The renderer's backend.\n   */\n  constructor(backend) {\n    super();\n\n    /**\n     * The renderer's backend.\n     *\n     * @type {Backend}\n     */\n    this.backend = backend;\n  }\n\n  /**\n   * Deletes the data for the given attribute.\n   *\n   * @param {BufferAttribute} attribute - The attribute.\n   * @return {Object} The deleted attribute data.\n   */\n  delete(attribute) {\n    const attributeData = super.delete(attribute);\n    if (attributeData !== undefined) {\n      this.backend.destroyAttribute(attribute);\n    }\n    return attributeData;\n  }\n\n  /**\n   * Updates the given attribute. This method creates attribute buffers\n   * for new attributes and updates data for existing ones.\n   *\n   * @param {BufferAttribute} attribute - The attribute to update.\n   * @param {Number} type - The attribute type.\n   */\n  update(attribute, type) {\n    const data = this.get(attribute);\n    if (data.version === undefined) {\n      if (type === AttributeType.VERTEX) {\n        this.backend.createAttribute(attribute);\n      } else if (type === AttributeType.INDEX) {\n        this.backend.createIndexAttribute(attribute);\n      } else if (type === AttributeType.STORAGE) {\n        this.backend.createStorageAttribute(attribute);\n      } else if (type === AttributeType.INDIRECT) {\n        this.backend.createIndirectStorageAttribute(attribute);\n      }\n      data.version = this._getBufferAttribute(attribute).version;\n    } else {\n      const bufferAttribute = this._getBufferAttribute(attribute);\n      if (data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage) {\n        this.backend.updateAttribute(attribute);\n        data.version = bufferAttribute.version;\n      }\n    }\n  }\n\n  /**\n   * Utility method for handling interleaved buffer attributes correctly.\n   * To process them, their `InterleavedBuffer` is returned.\n   *\n   * @param {BufferAttribute} attribute - The attribute.\n   * @return {BufferAttribute|InterleavedBuffer}\n   */\n  _getBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return attribute;\n  }\n}\n\n/**\n * Returns `true` if the given array has values that require an Uint32 array type.\n *\n * @private\n * @function\n * @param {Array<Number>} array - The array to test.\n * @return {Booolean} Whether the given array has values that require an Uint32 array type or not.\n */\nfunction arrayNeedsUint32(array) {\n  // assumes larger values usually on last\n\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n  }\n  return false;\n}\n\n/**\n * Returns the wireframe version for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {Number} The versio.\n */\nfunction getWireframeVersion(geometry) {\n  return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;\n}\n\n/**\n * Returns a wireframe index attribute for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {BufferAttribute} The wireframe index attribute.\n */\nfunction getWireframeIndex(geometry) {\n  const indices = [];\n  const geometryIndex = geometry.index;\n  const geometryPosition = geometry.attributes.position;\n  if (geometryIndex !== null) {\n    const array = geometryIndex.array;\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const a = array[i + 0];\n      const b = array[i + 1];\n      const c = array[i + 2];\n      indices.push(a, b, b, c, c, a);\n    }\n  } else {\n    const array = geometryPosition.array;\n    for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n      const a = i + 0;\n      const b = i + 1;\n      const c = i + 2;\n      indices.push(a, b, b, c, c, a);\n    }\n  }\n  const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n  attribute.version = getWireframeVersion(geometry);\n  return attribute;\n}\n\n/**\n * This renderer module manages geometries.\n *\n * @private\n * @augments DataMap\n */\nclass Geometries extends DataMap {\n  /**\n   * Constructs a new geometry management component.\n   *\n   * @param {Attributes} attributes - Renderer component for managing attributes.\n   * @param {Info} info - Renderer component for managing metrics and monitoring data.\n   */\n  constructor(attributes, info) {\n    super();\n\n    /**\n     * Renderer component for managing attributes.\n     *\n     * @type {Attributes}\n     */\n    this.attributes = attributes;\n\n    /**\n     * Renderer component for managing metrics and monitoring data.\n     *\n     * @type {Info}\n     */\n    this.info = info;\n\n    /**\n     * Weak Map for managing attributes for wireframe rendering.\n     *\n     * @type {WeakMap<BufferGeometry,BufferAttribute>}\n     */\n    this.wireframes = new WeakMap();\n\n    /**\n     * This Weak Map is used to make sure buffer attributes are\n     * updated only once per render call.\n     *\n     * @type {WeakMap<BufferAttribute,Number>}\n     */\n    this.attributeCall = new WeakMap();\n  }\n\n  /**\n   * Returns `true` if the given render object has an initialized geometry.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Boolean} Whether if the given render object has an initialized geometry or not.\n   */\n  has(renderObject) {\n    const geometry = renderObject.geometry;\n    return super.has(geometry) && this.get(geometry).initialized === true;\n  }\n\n  /**\n   * Prepares the geometry of the given render object for rendering.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   */\n  updateForRender(renderObject) {\n    if (this.has(renderObject) === false) this.initGeometry(renderObject);\n    this.updateAttributes(renderObject);\n  }\n\n  /**\n   * Initializes the geometry of the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   */\n  initGeometry(renderObject) {\n    const geometry = renderObject.geometry;\n    const geometryData = this.get(geometry);\n    geometryData.initialized = true;\n    this.info.memory.geometries++;\n    const onDispose = () => {\n      this.info.memory.geometries--;\n      const index = geometry.index;\n      const geometryAttributes = renderObject.getAttributes();\n      if (index !== null) {\n        this.attributes.delete(index);\n      }\n      for (const geometryAttribute of geometryAttributes) {\n        this.attributes.delete(geometryAttribute);\n      }\n      const wireframeAttribute = this.wireframes.get(geometry);\n      if (wireframeAttribute !== undefined) {\n        this.attributes.delete(wireframeAttribute);\n      }\n      geometry.removeEventListener('dispose', onDispose);\n    };\n    geometry.addEventListener('dispose', onDispose);\n  }\n\n  /**\n   * Updates the geometry attributes of the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   */\n  updateAttributes(renderObject) {\n    // attributes\n\n    const attributes = renderObject.getAttributes();\n    for (const attribute of attributes) {\n      if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {\n        this.updateAttribute(attribute, AttributeType.STORAGE);\n      } else {\n        this.updateAttribute(attribute, AttributeType.VERTEX);\n      }\n    }\n\n    // indexes\n\n    const index = this.getIndex(renderObject);\n    if (index !== null) {\n      this.updateAttribute(index, AttributeType.INDEX);\n    }\n\n    // indirect\n\n    const indirect = renderObject.geometry.indirect;\n    if (indirect !== null) {\n      this.updateAttribute(indirect, AttributeType.INDIRECT);\n    }\n  }\n\n  /**\n   * Updates the given attribute.\n   *\n   * @param {BufferAttribute} attribute - The attribute to update.\n   * @param {Number} type - The attribute type.\n   */\n  updateAttribute(attribute, type) {\n    const callId = this.info.render.calls;\n    if (!attribute.isInterleavedBufferAttribute) {\n      if (this.attributeCall.get(attribute) !== callId) {\n        this.attributes.update(attribute, type);\n        this.attributeCall.set(attribute, callId);\n      }\n    } else {\n      if (this.attributeCall.get(attribute) === undefined) {\n        this.attributes.update(attribute, type);\n        this.attributeCall.set(attribute, callId);\n      } else if (this.attributeCall.get(attribute.data) !== callId) {\n        this.attributes.update(attribute, type);\n        this.attributeCall.set(attribute.data, callId);\n        this.attributeCall.set(attribute, callId);\n      }\n    }\n  }\n\n  /**\n   * Returns the indirect buffer attribute of the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {BufferAttribute?} The indirect attribute. `null` if no indirect drawing is used.\n   */\n  getIndirect(renderObject) {\n    return renderObject.geometry.indirect;\n  }\n\n  /**\n   * Returns the index of the given render object's geometry. This is implemented\n   * in a method to return a wireframe index if necessary.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {BufferAttribute?} The index. Returns `null` for non-indexed geometries.\n   */\n  getIndex(renderObject) {\n    const {\n      geometry,\n      material\n    } = renderObject;\n    let index = geometry.index;\n    if (material.wireframe === true) {\n      const wireframes = this.wireframes;\n      let wireframeAttribute = wireframes.get(geometry);\n      if (wireframeAttribute === undefined) {\n        wireframeAttribute = getWireframeIndex(geometry);\n        wireframes.set(geometry, wireframeAttribute);\n      } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {\n        this.attributes.delete(wireframeAttribute);\n        wireframeAttribute = getWireframeIndex(geometry);\n        wireframes.set(geometry, wireframeAttribute);\n      }\n      index = wireframeAttribute;\n    }\n    return index;\n  }\n}\n\n/**\n * This renderer module provides a series of statistical information\n * about the GPU memory and the rendering process. Useful for debugging\n * and monitoring.\n */\nclass Info {\n  /**\n   * Constructs a new info component.\n   */\n  constructor() {\n    /**\n     * Whether frame related metrics should automatically\n     * be resetted or not. This property should be set to `false`\n     * by apps which manage their own animation loop. They must\n     * then call `renderer.info.reset()` once per frame manually.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.autoReset = true;\n\n    /**\n     * The current frame ID. This ID is managed\n     * by `NodeFrame`.\n     *\n     * @type {Number}\n     * @readonly\n     * @default 0\n     */\n    this.frame = 0;\n\n    /**\n     * The number of render calls since the\n     * app has been started.\n     *\n     * @type {Number}\n     * @readonly\n     * @default 0\n     */\n    this.calls = 0;\n\n    /**\n     * Render related metrics.\n     *\n     * @type {Object}\n     * @readonly\n     * @property {Number} calls - The number of render calls since the app has been started.\n     * @property {Number} frameCalls - The number of render calls of the current frame.\n     * @property {Number} drawCalls - The number of draw calls of the current frame.\n     * @property {Number} triangles - The number of rendered triangle primitives of the current frame.\n     * @property {Number} points - The number of rendered point primitives of the current frame.\n     * @property {Number} lines - The number of rendered line primitives of the current frame.\n     * @property {Number} previousFrameCalls - The number of render calls of the previous frame.\n     * @property {Number} timestamp - The timestamp of the frame when using `renderer.renderAsync()`.\n     * @property {Number} timestampCalls - The number of render calls using `renderer.renderAsync()`.\n     */\n    this.render = {\n      calls: 0,\n      frameCalls: 0,\n      drawCalls: 0,\n      triangles: 0,\n      points: 0,\n      lines: 0,\n      timestamp: 0,\n      previousFrameCalls: 0,\n      timestampCalls: 0\n    };\n\n    /**\n     * Compute related metrics.\n     *\n     * @type {Object}\n     * @readonly\n     * @property {Number} calls - The number of compute calls since the app has been started.\n     * @property {Number} frameCalls - The number of compute calls of the current frame.\n     * @property {Number} previousFrameCalls - The number of compute calls of the previous frame.\n     * @property {Number} timestamp - The timestamp of the frame when using `renderer.computeAsync()`.\n     * @property {Number} timestampCalls - The number of render calls using `renderer.computeAsync()`.\n     */\n    this.compute = {\n      calls: 0,\n      frameCalls: 0,\n      timestamp: 0,\n      previousFrameCalls: 0,\n      timestampCalls: 0\n    };\n\n    /**\n     * Memory related metrics.\n     *\n     * @type {Object}\n     * @readonly\n     * @property {Number} geometries - The number of active geometries.\n     * @property {Number} frameCalls - The number of active textures.\n     */\n    this.memory = {\n      geometries: 0,\n      textures: 0\n    };\n  }\n\n  /**\n   * This method should be executed per draw call and updates the corresponding metrics.\n   *\n   * @param {Object3D} object - The 3D object that is going to be rendered.\n   * @param {Number} count - The vertex or index count.\n   * @param {Number} instanceCount - The instance count.\n   */\n  update(object, count, instanceCount) {\n    this.render.drawCalls++;\n    if (object.isMesh || object.isSprite) {\n      this.render.triangles += instanceCount * (count / 3);\n    } else if (object.isPoints) {\n      this.render.points += instanceCount * count;\n    } else if (object.isLineSegments) {\n      this.render.lines += instanceCount * (count / 2);\n    } else if (object.isLine) {\n      this.render.lines += instanceCount * (count - 1);\n    } else {\n      console.error('THREE.WebGPUInfo: Unknown object type.');\n    }\n  }\n\n  /**\n   * Used by async render methods to updated timestamp metrics.\n   *\n   * @param {('render'|'compute')} type - The type of render call.\n   * @param {Number} time - The duration of the compute/render call in milliseconds.\n   */\n  updateTimestamp(type, time) {\n    if (this[type].timestampCalls === 0) {\n      this[type].timestamp = 0;\n    }\n    this[type].timestamp += time;\n    this[type].timestampCalls++;\n    if (this[type].timestampCalls >= this[type].previousFrameCalls) {\n      this[type].timestampCalls = 0;\n    }\n  }\n\n  /**\n   * Resets frame related metrics.\n   */\n  reset() {\n    const previousRenderFrameCalls = this.render.frameCalls;\n    this.render.previousFrameCalls = previousRenderFrameCalls;\n    const previousComputeFrameCalls = this.compute.frameCalls;\n    this.compute.previousFrameCalls = previousComputeFrameCalls;\n    this.render.drawCalls = 0;\n    this.render.frameCalls = 0;\n    this.compute.frameCalls = 0;\n    this.render.triangles = 0;\n    this.render.points = 0;\n    this.render.lines = 0;\n  }\n\n  /**\n   * Performs a complete reset of the object.\n   */\n  dispose() {\n    this.reset();\n    this.calls = 0;\n    this.render.calls = 0;\n    this.compute.calls = 0;\n    this.render.timestamp = 0;\n    this.compute.timestamp = 0;\n    this.memory.geometries = 0;\n    this.memory.textures = 0;\n  }\n}\n\n/**\n * Abstract class for representing pipelines.\n *\n * @private\n * @abstract\n */\nclass Pipeline {\n  /**\n   * Constructs a new pipeline.\n   *\n   * @param {String} cacheKey - The pipeline's cache key.\n   */\n  constructor(cacheKey) {\n    /**\n     * The pipeline's cache key.\n     *\n     * @type {String}\n     */\n    this.cacheKey = cacheKey;\n\n    /**\n     * How often the pipeline is currently in use.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.usedTimes = 0;\n  }\n}\n\n/**\n * Class for representing render pipelines.\n *\n * @private\n * @augments Pipeline\n */\nclass RenderPipeline extends Pipeline {\n  /**\n   * Constructs a new render pipeline.\n   *\n   * @param {String} cacheKey - The pipeline's cache key.\n   * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.\n   * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.\n   */\n  constructor(cacheKey, vertexProgram, fragmentProgram) {\n    super(cacheKey);\n\n    /**\n     * The pipeline's vertex shader.\n     *\n     * @type {ProgrammableStage}\n     */\n    this.vertexProgram = vertexProgram;\n\n    /**\n     * The pipeline's fragment shader.\n     *\n     * @type {ProgrammableStage}\n     */\n    this.fragmentProgram = fragmentProgram;\n  }\n}\n\n/**\n * Class for representing compute pipelines.\n *\n * @private\n * @augments Pipeline\n */\nclass ComputePipeline extends Pipeline {\n  /**\n   * Constructs a new render pipeline.\n   *\n   * @param {String} cacheKey - The pipeline's cache key.\n   * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.\n   */\n  constructor(cacheKey, computeProgram) {\n    super(cacheKey);\n\n    /**\n     * The pipeline's compute shader.\n     *\n     * @type {ProgrammableStage}\n     */\n    this.computeProgram = computeProgram;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isComputePipeline = true;\n  }\n}\nlet _id$8 = 0;\n\n/**\n * Class for representing programmable stages which are vertex,\n * fragment or compute shaders. Unlike fixed-function states (like blending),\n * they represent the programmable part of a pipeline.\n *\n * @private\n */\nclass ProgrammableStage {\n  /**\n   * Constructs a new programmable stage.\n   *\n   * @param {String} code - The shader code.\n   * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.\n   * @param {String} name - The name of the shader.\n   * @param {Array<Object>?} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n   * @param {Array<Object>?} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n   */\n  constructor(code, stage, name, transforms = null, attributes = null) {\n    /**\n     * The id of the programmable stage.\n     *\n     * @type {Number}\n     */\n    this.id = _id$8++;\n\n    /**\n     * The shader code.\n     *\n     * @type {String}\n     */\n    this.code = code;\n\n    /**\n     * The type of stage.\n     *\n     * @type {String}\n     */\n    this.stage = stage;\n\n    /**\n     * The name of the stage.\n     * This is used for debugging purposes.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n     *\n     * @type {Array<Object>?}\n     */\n    this.transforms = transforms;\n\n    /**\n     * The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n     *\n     * @type {Array<Object>?}\n     */\n    this.attributes = attributes;\n\n    /**\n     * How often the programmable stage is currently in use.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.usedTimes = 0;\n  }\n}\n\n/**\n * This renderer module manages the pipelines of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Pipelines extends DataMap {\n  /**\n   * Constructs a new pipeline management component.\n   *\n   * @param {Backend} backend - The renderer's backend.\n   * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n   */\n  constructor(backend, nodes) {\n    super();\n\n    /**\n     * The renderer's backend.\n     *\n     * @type {Backend}\n     */\n    this.backend = backend;\n\n    /**\n     * Renderer component for managing nodes related logic.\n     *\n     * @type {Nodes}\n     */\n    this.nodes = nodes;\n\n    /**\n     * A references to the bindings management component.\n     * This reference will be set inside the `Bindings`\n     * constructor.\n     *\n     * @type {Bindings?}\n     * @default null\n     */\n    this.bindings = null;\n\n    /**\n     * Internal cache for maintaining pipelines.\n     * The key of the map is a cache key, the value the pipeline.\n     *\n     * @type {Map<String,Pipeline>}\n     */\n    this.caches = new Map();\n\n    /**\n     * This dictionary maintains for each shader stage type (vertex,\n     * fragment and compute) the progammable stage objects which\n     * represent the actual shader code.\n     *\n     * @type {Object<String,Map>}\n     */\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n\n  /**\n   * Returns a compute pipeline for the given compute node.\n   *\n   * @param {Node} computeNode - The compute node.\n   * @param {Array<BindGroup>} bindings - The bindings.\n   * @return {ComputePipeline} The compute pipeline.\n   */\n  getForCompute(computeNode, bindings) {\n    const {\n      backend\n    } = this;\n    const data = this.get(computeNode);\n    if (this._needsComputeUpdate(computeNode)) {\n      const previousPipeline = data.pipeline;\n      if (previousPipeline) {\n        previousPipeline.usedTimes--;\n        previousPipeline.computeProgram.usedTimes--;\n      }\n\n      // get shader\n\n      const nodeBuilderState = this.nodes.getForCompute(computeNode);\n\n      // programmable stage\n\n      let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);\n      if (stageCompute === undefined) {\n        if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);\n        stageCompute = new ProgrammableStage(nodeBuilderState.computeShader, 'compute', computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);\n        this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);\n        backend.createProgram(stageCompute);\n      }\n\n      // determine compute pipeline\n\n      const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);\n      let pipeline = this.caches.get(cacheKey);\n      if (pipeline === undefined) {\n        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);\n        pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);\n      }\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageCompute.usedTimes++;\n\n      //\n\n      data.version = computeNode.version;\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n\n  /**\n   * Returns a render pipeline for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @param {Array<Promise>?} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n   * @return {RenderPipeline} The render pipeline.\n   */\n  getForRender(renderObject, promises = null) {\n    const {\n      backend\n    } = this;\n    const data = this.get(renderObject);\n    if (this._needsRenderUpdate(renderObject)) {\n      const previousPipeline = data.pipeline;\n      if (previousPipeline) {\n        previousPipeline.usedTimes--;\n        previousPipeline.vertexProgram.usedTimes--;\n        previousPipeline.fragmentProgram.usedTimes--;\n      }\n\n      // get shader\n\n      const nodeBuilderState = renderObject.getNodeBuilderState();\n      const name = renderObject.material ? renderObject.material.name : '';\n\n      // programmable stages\n\n      let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);\n      if (stageVertex === undefined) {\n        if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);\n        stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex', name);\n        this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);\n        backend.createProgram(stageVertex);\n      }\n      let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);\n      if (stageFragment === undefined) {\n        if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);\n        stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment', name);\n        this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);\n        backend.createProgram(stageFragment);\n      }\n\n      // determine render pipeline\n\n      const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n      let pipeline = this.caches.get(cacheKey);\n      if (pipeline === undefined) {\n        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);\n        pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises);\n      } else {\n        renderObject.pipeline = pipeline;\n      }\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageVertex.usedTimes++;\n      stageFragment.usedTimes++;\n\n      //\n\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n\n  /**\n   * Deletes the pipeline for the given render object.\n   *\n   * @param {RenderObject} object - The render object.\n   * @return {Object?} The deleted dictionary.\n   */\n  delete(object) {\n    const pipeline = this.get(object).pipeline;\n    if (pipeline) {\n      // pipeline\n\n      pipeline.usedTimes--;\n      if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);\n\n      // programs\n\n      if (pipeline.isComputePipeline) {\n        pipeline.computeProgram.usedTimes--;\n        if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);\n      } else {\n        pipeline.fragmentProgram.usedTimes--;\n        pipeline.vertexProgram.usedTimes--;\n        if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);\n        if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);\n      }\n    }\n    return super.delete(object);\n  }\n\n  /**\n   * Frees internal resources.\n   */\n  dispose() {\n    super.dispose();\n    this.caches = new Map();\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n\n  /**\n   * Updates the pipeline for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   */\n  updateForRender(renderObject) {\n    this.getForRender(renderObject);\n  }\n\n  /**\n   * Returns a compute pipeline for the given parameters.\n   *\n   * @private\n   * @param {Node} computeNode - The compute node.\n   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n   * @param {String} cacheKey - The cache key.\n   * @param {Array<BindGroup>} bindings - The bindings.\n   * @return {ComputePipeline} The compute pipeline.\n   */\n  _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {\n    // check for existing pipeline\n\n    cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new ComputePipeline(cacheKey, stageCompute);\n      this.caches.set(cacheKey, pipeline);\n      this.backend.createComputePipeline(pipeline, bindings);\n    }\n    return pipeline;\n  }\n\n  /**\n   * Returns a render pipeline for the given parameters.\n   *\n   * @private\n   * @param {RenderObject} renderObject - The render object.\n   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n   * @param {String} cacheKey - The cache key.\n   * @param {Array} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n   * @return {ComputePipeline} The compute pipeline.\n   */\n  _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {\n    // check for existing pipeline\n\n    cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);\n      this.caches.set(cacheKey, pipeline);\n      renderObject.pipeline = pipeline;\n\n      // The `promises` array is `null` by default and only set to an empty array when\n      // `Renderer.compileAsync()` is used. The next call actually fills the array with\n      // pending promises that resolve when the render pipelines are ready for rendering.\n\n      this.backend.createRenderPipeline(renderObject, promises);\n    }\n    return pipeline;\n  }\n\n  /**\n   * Computes a cache key representing a compute pipeline.\n   *\n   * @private\n   * @param {Node} computeNode - The compute node.\n   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n   * @return {String} The cache key.\n   */\n  _getComputeCacheKey(computeNode, stageCompute) {\n    return computeNode.id + ',' + stageCompute.id;\n  }\n\n  /**\n   * Computes a cache key representing a render pipeline.\n   *\n   * @private\n   * @param {RenderObject} renderObject - The render object.\n   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n   * @return {String} The cache key.\n   */\n  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {\n    return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);\n  }\n\n  /**\n   * Releases the given pipeline.\n   *\n   * @private\n   * @param {Pipeline} pipeline - The pipeline to release.\n   */\n  _releasePipeline(pipeline) {\n    this.caches.delete(pipeline.cacheKey);\n  }\n\n  /**\n   * Releases the shader program.\n   *\n   * @private\n   * @param {Object} program - The shdaer program to release.\n   */\n  _releaseProgram(program) {\n    const code = program.code;\n    const stage = program.stage;\n    this.programs[stage].delete(code);\n  }\n\n  /**\n   * Returns `true` if the compute pipeline for the given compute node requires an update.\n   *\n   * @private\n   * @param {Node} computeNode - The compute node.\n   * @return {Boolean} Whether the compute pipeline for the given compute node requires an update or not.\n   */\n  _needsComputeUpdate(computeNode) {\n    const data = this.get(computeNode);\n    return data.pipeline === undefined || data.version !== computeNode.version;\n  }\n\n  /**\n   * Returns `true` if the render pipeline for the given render object requires an update.\n   *\n   * @private\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Boolean} Whether the render object for the given render object requires an update or not.\n   */\n  _needsRenderUpdate(renderObject) {\n    const data = this.get(renderObject);\n    return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);\n  }\n}\n\n/**\n * This renderer module manages the bindings of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Bindings extends DataMap {\n  /**\n   * Constructs a new bindings management component.\n   *\n   * @param {Backend} backend - The renderer's backend.\n   * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n   * @param {Textures} textures - Renderer component for managing textures.\n   * @param {Attributes} attributes - Renderer component for managing attributes.\n   * @param {Pipelines} pipelines - Renderer component for managing pipelines.\n   * @param {Info} info - Renderer component for managing metrics and monitoring data.\n   */\n  constructor(backend, nodes, textures, attributes, pipelines, info) {\n    super();\n\n    /**\n     * The renderer's backend.\n     *\n     * @type {Backend}\n     */\n    this.backend = backend;\n\n    /**\n     * Renderer component for managing textures.\n     *\n     * @type {Textures}\n     */\n    this.textures = textures;\n\n    /**\n     * Renderer component for managing pipelines.\n     *\n     * @type {Pipelines}\n     */\n    this.pipelines = pipelines;\n\n    /**\n     * Renderer component for managing attributes.\n     *\n     * @type {Attributes}\n     */\n    this.attributes = attributes;\n\n    /**\n     * Renderer component for managing nodes related logic.\n     *\n     * @type {Nodes}\n     */\n    this.nodes = nodes;\n\n    /**\n     * Renderer component for managing metrics and monitoring data.\n     *\n     * @type {Info}\n     */\n    this.info = info;\n    this.pipelines.bindings = this; // assign bindings to pipelines\n  }\n\n  /**\n   * Returns the bind groups for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Array<BindGroup>} The bind groups.\n   */\n  getForRender(renderObject) {\n    const bindings = renderObject.getBindings();\n    for (const bindGroup of bindings) {\n      const groupData = this.get(bindGroup);\n      if (groupData.bindGroup === undefined) {\n        // each object defines an array of bindings (ubos, textures, samplers etc.)\n\n        this._init(bindGroup);\n        this.backend.createBindings(bindGroup, bindings, 0);\n        groupData.bindGroup = bindGroup;\n      }\n    }\n    return bindings;\n  }\n\n  /**\n   * Returns the bind groups for the given compute node.\n   *\n   * @param {Node} computeNode - The compute node.\n   * @return {Array<BindGroup>} The bind groups.\n   */\n  getForCompute(computeNode) {\n    const bindings = this.nodes.getForCompute(computeNode).bindings;\n    for (const bindGroup of bindings) {\n      const groupData = this.get(bindGroup);\n      if (groupData.bindGroup === undefined) {\n        this._init(bindGroup);\n        this.backend.createBindings(bindGroup, bindings, 0);\n        groupData.bindGroup = bindGroup;\n      }\n    }\n    return bindings;\n  }\n\n  /**\n   * Updates the bindings for the given compute node.\n   *\n   * @param {Node} computeNode - The compute node.\n   */\n  updateForCompute(computeNode) {\n    this._updateBindings(this.getForCompute(computeNode));\n  }\n\n  /**\n   * Updates the bindings for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   */\n  updateForRender(renderObject) {\n    this._updateBindings(this.getForRender(renderObject));\n  }\n\n  /**\n   * Updates the given array of bindings.\n   *\n   * @param {Array<BindGroup>} bindings - The bind groups.\n   */\n  _updateBindings(bindings) {\n    for (const bindGroup of bindings) {\n      this._update(bindGroup, bindings);\n    }\n  }\n\n  /**\n   * Initializes the given bind group.\n   *\n   * @param {BindGroup} bindGroup - The bind group to initialize.\n   */\n  _init(bindGroup) {\n    for (const binding of bindGroup.bindings) {\n      if (binding.isSampledTexture) {\n        this.textures.updateTexture(binding.texture);\n      } else if (binding.isStorageBuffer) {\n        const attribute = binding.attribute;\n        const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n        this.attributes.update(attribute, attributeType);\n      }\n    }\n  }\n\n  /**\n   * Updates the given bind group.\n   *\n   * @param {BindGroup} bindGroup - The bind group to update.\n   * @param {Array<BindGroup>} bindings - The bind groups.\n   */\n  _update(bindGroup, bindings) {\n    const {\n      backend\n    } = this;\n    let needsBindingsUpdate = false;\n    let cacheBindings = true;\n    let cacheIndex = 0;\n    let version = 0;\n\n    // iterate over all bindings and check if buffer updates or a new binding group is required\n\n    for (const binding of bindGroup.bindings) {\n      if (binding.isNodeUniformsGroup) {\n        const updated = this.nodes.updateGroup(binding);\n\n        // every uniforms group is a uniform buffer. So if no update is required,\n        // we move one with the next binding. Otherwise the next if block will update the group.\n\n        if (updated === false) continue;\n      }\n      if (binding.isUniformBuffer) {\n        const updated = binding.update();\n        if (updated) {\n          backend.updateBinding(binding);\n        }\n      } else if (binding.isSampler) {\n        binding.update();\n      } else if (binding.isSampledTexture) {\n        const texturesTextureData = this.textures.get(binding.texture);\n        if (binding.needsBindingsUpdate(texturesTextureData.generation)) needsBindingsUpdate = true;\n        const updated = binding.update();\n        const texture = binding.texture;\n        if (updated) {\n          this.textures.updateTexture(texture);\n        }\n        const textureData = backend.get(texture);\n        if (textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture) {\n          cacheBindings = false;\n        } else {\n          cacheIndex = cacheIndex * 10 + texture.id;\n          version += texture.version;\n        }\n        if (backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined) {\n          // TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend\n          console.error('Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate);\n          this.textures.updateTexture(texture);\n          needsBindingsUpdate = true;\n        }\n        if (texture.isStorageTexture === true) {\n          const textureData = this.get(texture);\n          if (binding.store === true) {\n            textureData.needsMipmap = true;\n          } else if (this.textures.needsMipmaps(texture) && textureData.needsMipmap === true) {\n            this.backend.generateMipmaps(texture);\n            textureData.needsMipmap = false;\n          }\n        }\n      }\n    }\n    if (needsBindingsUpdate === true) {\n      this.backend.updateBindings(bindGroup, bindings, cacheBindings ? cacheIndex : 0, version);\n    }\n  }\n}\n\n/**\n * Default sorting function for opaque render items.\n *\n * @private\n * @function\n * @param {Object} a - The first render item.\n * @param {Object} b - The second render item.\n * @return {Number} A numeric value which defines the sort order.\n */\nfunction painterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.material.id !== b.material.id) {\n    return a.material.id - b.material.id;\n  } else if (a.z !== b.z) {\n    return a.z - b.z;\n  } else {\n    return a.id - b.id;\n  }\n}\n\n/**\n * Default sorting function for transparent render items.\n *\n * @private\n * @function\n * @param {Object} a - The first render item.\n * @param {Object} b - The second render item.\n * @return {Number} A numeric value which defines the sort order.\n */\nfunction reversePainterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.z !== b.z) {\n    return b.z - a.z;\n  } else {\n    return a.id - b.id;\n  }\n}\n\n/**\n * Returns `true` if the given transparent material requires a double pass.\n *\n * @private\n * @function\n * @param {Material} material - The transparent material.\n * @return {Boolean} Whether the given material requires a double pass or not.\n */\nfunction needsDoublePass(material) {\n  const hasTransmission = material.transmission > 0 || material.transmissionNode;\n  return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;\n}\n\n/**\n * When the renderer analyzes the scene at the beginning of a render call,\n * it stores 3D object for further processing in render lists. Depending on the\n * properties of a 3D objects (like their transformation or material state), the\n * objects are maintained in ordered lists for the actual rendering.\n *\n * Render lists are unique per scene and camera combination.\n *\n * @private\n * @augments Pipeline\n */\nclass RenderList {\n  /**\n   * Constructs a render list.\n   *\n   * @param {Lighting} lighting - The lighting management component.\n   * @param {Scene} scene - The scene.\n   * @param {Camera} camera - The camera the scene is rendered with.\n   */\n  constructor(lighting, scene, camera) {\n    /**\n     * 3D objects are transformed into render items and stored in this array.\n     *\n     * @type {Array<Object>}\n     */\n    this.renderItems = [];\n\n    /**\n     * The current render items index.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.renderItemsIndex = 0;\n\n    /**\n     * A list with opaque render items.\n     *\n     * @type {Array<Object>}\n     */\n    this.opaque = [];\n\n    /**\n     * A list with transparent render items which require\n     * double pass rendering (e.g. transmissive objects).\n     *\n     * @type {Array<Object>}\n     */\n    this.transparentDoublePass = [];\n\n    /**\n     * A list with transparent render items.\n     *\n     * @type {Array<Object>}\n     */\n    this.transparent = [];\n\n    /**\n     * A list with transparent render bundle data.\n     *\n     * @type {Array<Object>}\n     */\n    this.bundles = [];\n\n    /**\n     * The render list's lights node. This node is later\n     * relevant for the actual analytical light nodes which\n     * compute the scene's lighting in the shader.\n     *\n     * @type {LightsNode}\n     */\n    this.lightsNode = lighting.getNode(scene, camera);\n\n    /**\n     * The scene's lights stored in an array. This array\n     * is used to setup the lights node.\n     *\n     * @type {Array<Light>}\n     */\n    this.lightsArray = [];\n\n    /**\n     * The scene.\n     *\n     * @type {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The camera the scene is rendered with.\n     *\n     * @type {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * How many objects perform occlusion query tests.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.occlusionQueryCount = 0;\n  }\n\n  /**\n   * This method is called right at the beginning of a render call\n   * before the scene is analyzed. It prepares the internal data\n   * structures for the upcoming render lists generation.\n   *\n   * @return {RenderList} A reference to this render list.\n   */\n  begin() {\n    this.renderItemsIndex = 0;\n    this.opaque.length = 0;\n    this.transparentDoublePass.length = 0;\n    this.transparent.length = 0;\n    this.bundles.length = 0;\n    this.lightsArray.length = 0;\n    this.occlusionQueryCount = 0;\n    return this;\n  }\n\n  /**\n   * Returns a render item for the giving render item state. The state is defined\n   * by a series of object-related parameters.\n   *\n   * The method avoids object creation by holding render items and reusing them in\n   * subsequent render calls (just with different property values).\n   *\n   * @param {Object3D} object - The 3D object.\n   * @param {BufferGeometry} geometry - The 3D object's geometry.\n   * @param {Material} material - The 3D object's material.\n   * @param {Number} groupOrder - The current group order.\n   * @param {Number} z - Th 3D object's depth value (z value in clip space).\n   * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n   * @param {ClippingContext} clippingContext - The current clipping context.\n   * @return {Object} The render item.\n   */\n  getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext) {\n    let renderItem = this.renderItems[this.renderItemsIndex];\n    if (renderItem === undefined) {\n      renderItem = {\n        id: object.id,\n        object: object,\n        geometry: geometry,\n        material: material,\n        groupOrder: groupOrder,\n        renderOrder: object.renderOrder,\n        z: z,\n        group: group,\n        clippingContext: clippingContext\n      };\n      this.renderItems[this.renderItemsIndex] = renderItem;\n    } else {\n      renderItem.id = object.id;\n      renderItem.object = object;\n      renderItem.geometry = geometry;\n      renderItem.material = material;\n      renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = object.renderOrder;\n      renderItem.z = z;\n      renderItem.group = group;\n      renderItem.clippingContext = clippingContext;\n    }\n    this.renderItemsIndex++;\n    return renderItem;\n  }\n\n  /**\n   * Pushes the given object as a render item to the internal render lists.\n   * The selected lists depend on the object properties.\n   *\n   * @param {Object3D} object - The 3D object.\n   * @param {BufferGeometry} geometry - The 3D object's geometry.\n   * @param {Material} material - The 3D object's material.\n   * @param {Number} groupOrder - The current group order.\n   * @param {Number} z - Th 3D object's depth value (z value in clip space).\n   * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n   * @param {ClippingContext} clippingContext - The current clipping context.\n   */\n  push(object, geometry, material, groupOrder, z, group, clippingContext) {\n    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);\n    if (object.occlusionTest === true) this.occlusionQueryCount++;\n    if (material.transparent === true || material.transmission > 0) {\n      if (needsDoublePass(material)) this.transparentDoublePass.push(renderItem);\n      this.transparent.push(renderItem);\n    } else {\n      this.opaque.push(renderItem);\n    }\n  }\n\n  /**\n   * Inserts the given object as a render item at the start of the internal render lists.\n   * The selected lists depend on the object properties.\n   *\n   * @param {Object3D} object - The 3D object.\n   * @param {BufferGeometry} geometry - The 3D object's geometry.\n   * @param {Material} material - The 3D object's material.\n   * @param {Number} groupOrder - The current group order.\n   * @param {Number} z - Th 3D object's depth value (z value in clip space).\n   * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n   * @param {ClippingContext} clippingContext - The current clipping context.\n   */\n  unshift(object, geometry, material, groupOrder, z, group, clippingContext) {\n    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);\n    if (material.transparent === true || material.transmission > 0) {\n      if (needsDoublePass(material)) this.transparentDoublePass.unshift(renderItem);\n      this.transparent.unshift(renderItem);\n    } else {\n      this.opaque.unshift(renderItem);\n    }\n  }\n\n  /**\n   * Pushes render bundle group data into the render list.\n   *\n   * @param {Object} group - Bundle group data.\n   */\n  pushBundle(group) {\n    this.bundles.push(group);\n  }\n\n  /**\n   * Pushes a light into the render list.\n   *\n   * @param {Light} light - The light.\n   */\n  pushLight(light) {\n    this.lightsArray.push(light);\n  }\n\n  /**\n   * Sorts the internal render lists.\n   *\n   * @param {Function} customOpaqueSort - A custom sort function for opaque objects.\n   * @param {Function} customTransparentSort -  A custom sort function for transparent objects.\n   */\n  sort(customOpaqueSort, customTransparentSort) {\n    if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);\n    if (this.transparentDoublePass.length > 1) this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);\n    if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);\n  }\n\n  /**\n   * This method performs finalizing tasks right after the render lists\n   * have been generated.\n   */\n  finish() {\n    // update lights\n\n    this.lightsNode.setLights(this.lightsArray);\n\n    // Clear references from inactive renderItems in the list\n\n    for (let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {\n      const renderItem = this.renderItems[i];\n      if (renderItem.id === null) break;\n      renderItem.id = null;\n      renderItem.object = null;\n      renderItem.geometry = null;\n      renderItem.material = null;\n      renderItem.groupOrder = null;\n      renderItem.renderOrder = null;\n      renderItem.z = null;\n      renderItem.group = null;\n      renderItem.clippingContext = null;\n    }\n  }\n}\n\n/**\n * This renderer module manages the render lists which are unique\n * per scene and camera combination.\n *\n * @private\n */\nclass RenderLists {\n  /**\n   * Constructs a render lists management component.\n   *\n   * @param {Lighting} lighting - The lighting management component.\n   */\n  constructor(lighting) {\n    /**\n     * The lighting management component.\n     *\n     * @type {Lighting}\n     */\n    this.lighting = lighting;\n\n    /**\n     * The internal chain map which holds the render lists.\n     *\n     * @type {ChainMap}\n     */\n    this.lists = new ChainMap();\n  }\n\n  /**\n   * Returns a render list for the given scene and camera.\n   *\n   * @param {Scene} scene - The scene.\n   * @param {Camera} camera - The camera.\n   * @return {RenderList} The render list.\n   */\n  get(scene, camera) {\n    const lists = this.lists;\n    const keys = [scene, camera];\n    let list = lists.get(keys);\n    if (list === undefined) {\n      list = new RenderList(this.lighting, scene, camera);\n      lists.set(keys, list);\n    }\n    return list;\n  }\n\n  /**\n   * Frees all internal resources.\n   */\n  dispose() {\n    this.lists = new ChainMap();\n  }\n}\nlet _id$7 = 0;\n\n/**\n * Any render or compute command is executed in a specific context that defines\n * the state of the renderer and its backend. Typical examples for such context\n * data are the current clear values or data from the active framebuffer. This\n * module is used to represent these contexts as objects.\n *\n * @private\n */\nclass RenderContext {\n  /**\n   * Constructs a new render context.\n   */\n  constructor() {\n    /**\n     * The context's ID.\n     *\n     * @type {Number}\n     */\n    this.id = _id$7++;\n\n    /**\n     * Whether the current active framebuffer has a color attachment.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.color = true;\n\n    /**\n     * Whether the color attachment should be cleared or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.clearColor = true;\n\n    /**\n     * The clear color value.\n     *\n     * @type {Object}\n     * @default true\n     */\n    this.clearColorValue = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 1\n    };\n\n    /**\n     * Whether the current active framebuffer has a depth attachment.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.depth = true;\n\n    /**\n     * Whether the depth attachment should be cleared or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.clearDepth = true;\n\n    /**\n     * The clear depth value.\n     *\n     * @type {Number}\n     * @default 1\n     */\n    this.clearDepthValue = 1;\n\n    /**\n     * Whether the current active framebuffer has a stencil attachment.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.stencil = false;\n\n    /**\n     * Whether the stencil attachment should be cleared or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.clearStencil = true;\n\n    /**\n     * The clear stencil value.\n     *\n     * @type {Number}\n     * @default 1\n     */\n    this.clearStencilValue = 1;\n\n    /**\n     * By default the viewport encloses the entire framebuffer If a smaller\n     * viewport is manually defined, this property is to `true` by the renderer.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.viewport = false;\n\n    /**\n     * The viewport value. This value is in physical pixels meaning it incorporates\n     * the renderer's pixel ratio. The viewport property of render targets or\n     * the renderer is in logical pixels.\n     *\n     * @type {Vector4}\n     */\n    this.viewportValue = new Vector4();\n\n    /**\n     * When the scissor test is active and scissor rectangle smaller than the\n     * framebuffers dimensions, this property is to `true` by the renderer.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.scissor = false;\n\n    /**\n     * The scissor rectangle.\n     *\n     * @type {Vector4}\n     */\n    this.scissorValue = new Vector4();\n\n    /**\n     * The textures of the active render target.\n     * `null` when no render target is set.\n     *\n     * @type {Array<Texture>?}\n     * @default null\n     */\n    this.textures = null;\n\n    /**\n     * The depth texture of the active render target.\n     * `null` when no render target is set.\n     *\n     * @type {DepthTexture?}\n     * @default null\n     */\n    this.depthTexture = null;\n\n    /**\n     * The active cube face.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.activeCubeFace = 0;\n\n    /**\n     * The number of MSAA samples. This value is always `1` when\n     * MSAA isn't used.\n     *\n     * @type {Number}\n     * @default 1\n     */\n    this.sampleCount = 1;\n\n    /**\n     * The framebuffers width in physical pixels.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.width = 0;\n\n    /**\n     * The framebuffers height in physical pixels.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.height = 0;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isRenderContext = true;\n  }\n\n  /**\n   * Returns the cache key of this render context.\n   *\n   * @return {Number} The cache key.\n   */\n  getCacheKey() {\n    return getCacheKey(this);\n  }\n}\n\n/**\n * Computes a cache key for the given render context.\n *\n * @param {RenderContext} renderContext - The render context.\n * @return {Number} The cache key.\n */\nfunction getCacheKey(renderContext) {\n  const {\n    textures,\n    activeCubeFace\n  } = renderContext;\n  const values = [activeCubeFace];\n  for (const texture of textures) {\n    values.push(texture.id);\n  }\n  return hashArray(values);\n}\n\n/**\n * This module manages the render contexts of the renderer.\n *\n * @private\n */\nclass RenderContexts {\n  /**\n   * Constructs a new render context management component.\n   */\n  constructor() {\n    /**\n     * A dictionary that manages render contexts in chain maps\n     * for each attachment state.\n     *\n     * @type {Object<String,ChainMap>}\n     */\n    this.chainMaps = {};\n  }\n\n  /**\n   * Returns a render context for the given scene, camera and render target.\n   *\n   * @param {Scene?} [scene=null] - The scene. The parameter can become `null` e.g. when the renderer clears a render target.\n   * @param {Camera?} [camera=null] - The camera that is used to render the scene. The parameter can become `null` e.g. when the renderer clears a render target.\n   * @param {RenderTarget?} [renderTarget=null] - The active render target.\n   * @return {RenderContext} The render context.\n   */\n  get(scene = null, camera = null, renderTarget = null) {\n    const chainKey = [];\n    if (scene !== null) chainKey.push(scene);\n    if (camera !== null) chainKey.push(camera);\n    if (chainKey.length === 0) {\n      chainKey.push({\n        id: 'default'\n      });\n    }\n    let attachmentState;\n    if (renderTarget === null) {\n      attachmentState = 'default';\n    } else {\n      const format = renderTarget.texture.format;\n      const count = renderTarget.textures.length;\n      attachmentState = `${count}:${format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;\n    }\n    const chainMap = this.getChainMap(attachmentState);\n    let renderState = chainMap.get(chainKey);\n    if (renderState === undefined) {\n      renderState = new RenderContext();\n      chainMap.set(chainKey, renderState);\n    }\n    if (renderTarget !== null) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n    return renderState;\n  }\n\n  /**\n   * Returns a chain map for the given attachment state.\n   *\n   * @param {String} attachmentState - The attachment state.\n   * @return {ChainMap} The chain map.\n   */\n  getChainMap(attachmentState) {\n    return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());\n  }\n\n  /**\n   * Frees internal resources.\n   */\n  dispose() {\n    this.chainMaps = {};\n  }\n}\nconst _size$3 = /*@__PURE__*/new Vector3();\n\n/**\n * This module manages the textures of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Textures extends DataMap {\n  /**\n   * Constructs a new texture management component.\n   *\n   * @param {Renderer} renderer - The renderer.\n   * @param {Backend} backend - The renderer's backend.\n   * @param {Info} info - Renderer component for managing metrics and monitoring data.\n   */\n  constructor(renderer, backend, info) {\n    super();\n\n    /**\n     * The renderer.\n     *\n     * @type {Renderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The backend.\n     *\n     * @type {Backend}\n     */\n    this.backend = backend;\n\n    /**\n     * Renderer component for managing metrics and monitoring data.\n     *\n     * @type {Info}\n     */\n    this.info = info;\n  }\n\n  /**\n   * Updates the given render target. Based on the given render target configuration,\n   * it updates the texture states representing the attachments of the framebuffer.\n   *\n   * @param {RenderTarget} renderTarget - The render target to update.\n   * @param {Number} [activeMipmapLevel=0] - The active mipmap level.\n   */\n  updateRenderTarget(renderTarget, activeMipmapLevel = 0) {\n    const renderTargetData = this.get(renderTarget);\n    const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n    const depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});\n    const textures = renderTarget.textures;\n    const size = this.getSize(textures[0]);\n    const mipWidth = size.width >> activeMipmapLevel;\n    const mipHeight = size.height >> activeMipmapLevel;\n    let depthTexture = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];\n    const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;\n    let textureNeedsUpdate = false;\n    if (depthTexture === undefined && useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;\n      depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType\n      depthTexture.image.width = mipWidth;\n      depthTexture.image.height = mipHeight;\n      depthTextureMips[activeMipmapLevel] = depthTexture;\n    }\n    if (renderTargetData.width !== size.width || size.height !== renderTargetData.height) {\n      textureNeedsUpdate = true;\n      if (depthTexture) {\n        depthTexture.needsUpdate = true;\n        depthTexture.image.width = mipWidth;\n        depthTexture.image.height = mipHeight;\n      }\n    }\n    renderTargetData.width = size.width;\n    renderTargetData.height = size.height;\n    renderTargetData.textures = textures;\n    renderTargetData.depthTexture = depthTexture || null;\n    renderTargetData.depth = renderTarget.depthBuffer;\n    renderTargetData.stencil = renderTarget.stencilBuffer;\n    renderTargetData.renderTarget = renderTarget;\n    if (renderTargetData.sampleCount !== sampleCount) {\n      textureNeedsUpdate = true;\n      if (depthTexture) {\n        depthTexture.needsUpdate = true;\n      }\n      renderTargetData.sampleCount = sampleCount;\n    }\n\n    //\n\n    const options = {\n      sampleCount\n    };\n    for (let i = 0; i < textures.length; i++) {\n      const texture = textures[i];\n      if (textureNeedsUpdate) texture.needsUpdate = true;\n      this.updateTexture(texture, options);\n    }\n    if (depthTexture) {\n      this.updateTexture(depthTexture, options);\n    }\n\n    // dispose handler\n\n    if (renderTargetData.initialized !== true) {\n      renderTargetData.initialized = true;\n\n      // dispose\n\n      const onDispose = () => {\n        renderTarget.removeEventListener('dispose', onDispose);\n        for (let i = 0; i < textures.length; i++) {\n          this._destroyTexture(textures[i]);\n        }\n        if (depthTexture) {\n          this._destroyTexture(depthTexture);\n        }\n        this.delete(renderTarget);\n      };\n      renderTarget.addEventListener('dispose', onDispose);\n    }\n  }\n\n  /**\n   * Updates the given texture. Depending on the texture state, this method\n   * triggers the upload of texture data to the GPU memory. If the texture data are\n   * not yet ready for the upload, it uses default texture data for as a placeholder.\n   *\n   * @param {Texture} texture - The texture to update.\n   * @param {Object} [options={}] - The options.\n   */\n  updateTexture(texture, options = {}) {\n    const textureData = this.get(texture);\n    if (textureData.initialized === true && textureData.version === texture.version) return;\n    const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;\n    const backend = this.backend;\n    if (isRenderTarget && textureData.initialized === true) {\n      // it's an update\n\n      backend.destroySampler(texture);\n      backend.destroyTexture(texture);\n    }\n\n    //\n\n    if (texture.isFramebufferTexture) {\n      const renderTarget = this.renderer.getRenderTarget();\n      if (renderTarget) {\n        texture.type = renderTarget.texture.type;\n      } else {\n        texture.type = UnsignedByteType;\n      }\n    }\n\n    //\n\n    const {\n      width,\n      height,\n      depth\n    } = this.getSize(texture);\n    options.width = width;\n    options.height = height;\n    options.depth = depth;\n    options.needsMipmaps = this.needsMipmaps(texture);\n    options.levels = options.needsMipmaps ? this.getMipLevels(texture, width, height) : 1;\n\n    //\n\n    if (isRenderTarget || texture.isStorageTexture === true) {\n      backend.createSampler(texture);\n      backend.createTexture(texture, options);\n      textureData.generation = texture.version;\n    } else {\n      const needsCreate = textureData.initialized !== true;\n      if (needsCreate) backend.createSampler(texture);\n      if (texture.version > 0) {\n        const image = texture.image;\n        if (image === undefined) {\n          console.warn('THREE.Renderer: Texture marked for update but image is undefined.');\n        } else if (image.complete === false) {\n          console.warn('THREE.Renderer: Texture marked for update but image is incomplete.');\n        } else {\n          if (texture.images) {\n            const images = [];\n            for (const image of texture.images) {\n              images.push(image);\n            }\n            options.images = images;\n          } else {\n            options.image = image;\n          }\n          if (textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true) {\n            backend.createTexture(texture, options);\n            textureData.isDefaultTexture = false;\n            textureData.generation = texture.version;\n          }\n          if (texture.source.dataReady === true) backend.updateTexture(texture, options);\n          if (options.needsMipmaps && texture.mipmaps.length === 0) backend.generateMipmaps(texture);\n        }\n      } else {\n        // async update\n\n        backend.createDefaultTexture(texture);\n        textureData.isDefaultTexture = true;\n        textureData.generation = texture.version;\n      }\n    }\n\n    // dispose handler\n\n    if (textureData.initialized !== true) {\n      textureData.initialized = true;\n      textureData.generation = texture.version;\n\n      //\n\n      this.info.memory.textures++;\n\n      // dispose\n\n      const onDispose = () => {\n        texture.removeEventListener('dispose', onDispose);\n        this._destroyTexture(texture);\n        this.info.memory.textures--;\n      };\n      texture.addEventListener('dispose', onDispose);\n    }\n\n    //\n\n    textureData.version = texture.version;\n  }\n\n  /**\n   * Computes the size of the given texture and writes the result\n   * into the target vector. This vector is also returned by the\n   * method.\n   *\n   * If no texture data are available for the compute yet, the method\n   * returns default size values.\n   *\n   * @param {Texture} texture - The texture to compute the size for.\n   * @param {Vector3} target - The target vector.\n   * @return {Vector3} The target vector.\n   */\n  getSize(texture, target = _size$3) {\n    let image = texture.images ? texture.images[0] : texture.image;\n    if (image) {\n      if (image.image !== undefined) image = image.image;\n      target.width = image.width || 1;\n      target.height = image.height || 1;\n      target.depth = texture.isCubeTexture ? 6 : image.depth || 1;\n    } else {\n      target.width = target.height = target.depth = 1;\n    }\n    return target;\n  }\n\n  /**\n   * Computes the number of mipmap levels for the given texture.\n   *\n   * @param {Texture} texture - The texture.\n   * @param {Number} width - The texture's width.\n   * @param {Number} height - The texture's height.\n   * @return {Number} The number of mipmap levels.\n   */\n  getMipLevels(texture, width, height) {\n    let mipLevelCount;\n    if (texture.isCompressedTexture) {\n      if (texture.mipmaps) {\n        mipLevelCount = texture.mipmaps.length;\n      } else {\n        mipLevelCount = 1;\n      }\n    } else {\n      mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;\n    }\n    return mipLevelCount;\n  }\n\n  /**\n   * Returns `true` if the given texture requires mipmaps.\n   *\n   * @param {Texture} texture - The texture.\n   * @return {Boolean} Whether mipmaps are required or not.\n   */\n  needsMipmaps(texture) {\n    return this.isEnvironmentTexture(texture) || texture.isCompressedTexture === true || texture.generateMipmaps;\n  }\n\n  /**\n   * Returns `true` if the given texture is an environment map.\n   *\n   * @param {Texture} texture - The texture.\n   * @return {Boolean} Whether the given texture is an environment map or not.\n   */\n  isEnvironmentTexture(texture) {\n    const mapping = texture.mapping;\n    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n  }\n\n  /**\n   * Frees internal resource when the given texture isn't\n   * required anymore.\n   *\n   * @param {Texture} texture - The texture to destroy.\n   */\n  _destroyTexture(texture) {\n    this.backend.destroySampler(texture);\n    this.backend.destroyTexture(texture);\n    this.delete(texture);\n  }\n}\n\n/**\n * A four-component version of {@link Color} which is internally\n * used by the renderer to represents clear color with alpha as\n * one object.\n *\n * @private\n * @augments Color\n */\nclass Color4 extends Color {\n  /**\n   * Constructs a new four-component color.\n   *\n   * @param {Number|String} r - The red value.\n   * @param {Number} g - The green value.\n   * @param {Number} b - The blue value.\n   * @param {Number} [a=1] - The alpha value.\n   */\n  constructor(r, g, b, a = 1) {\n    super(r, g, b);\n    this.a = a;\n  }\n\n  /**\n   * Overwrites the default to honor alpha.\n   *\n   * @param {Number|String} r - The red value.\n   * @param {Number} g - The green value.\n   * @param {Number} b - The blue value.\n   * @param {Number} [a=1] - The alpha value.\n   * @return {Color4} A reference to this object.\n   */\n  set(r, g, b, a = 1) {\n    this.a = a;\n    return super.set(r, g, b);\n  }\n\n  /**\n   * Overwrites the default to honor alpha.\n   *\n   * @param {Color4} color - The color to copy.\n   * @return {Color4} A reference to this object.\n   */\n  copy(color) {\n    if (color.a !== undefined) this.a = color.a;\n    return super.copy(color);\n  }\n\n  /**\n   * Overwrites the default to honor alpha.\n   *\n   * @return {Color4} The cloned color.\n   */\n  clone() {\n    return new this.constructor(this.r, this.g, this.b, this.a);\n  }\n}\n\n/** @module ParameterNode **/\n\n/**\n * Special version of {@link PropertyNode} which is used for parameters.\n *\n * @augments PropertyNode\n */\nclass ParameterNode extends PropertyNode {\n  static get type() {\n    return 'ParameterNode';\n  }\n\n  /**\n   * Constructs a new parameter node.\n   *\n   * @param {String} nodeType - The type of the node.\n   * @param {String?} [name=null] - The name of the parameter in the shader.\n   */\n  constructor(nodeType, name = null) {\n    super(nodeType, name);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isParameterNode = true;\n  }\n  getHash() {\n    return this.uuid;\n  }\n  generate() {\n    return this.name;\n  }\n}\n\n/**\n * TSL function for creating a parameter node.\n *\n * @function\n * @param {String} type - The type of the node.\n * @param {String?} name - The name of the parameter in the shader.\n * @returns {ParameterNode}\n */\nconst parameter = (type, name) => nodeObject(new ParameterNode(type, name));\n\n/** @module StackNode **/\n\n/**\n * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.\n * They are usually needed in cases like `If`, `Else`.\n *\n * @augments Node\n */\nclass StackNode extends Node {\n  static get type() {\n    return 'StackNode';\n  }\n\n  /**\n   * Constructs a new stack node.\n   *\n   * @param {StackNode?} [parent=null] - The parent stack node.\n   */\n  constructor(parent = null) {\n    super();\n\n    /**\n     * List of nodes.\n     *\n     * @type {Array<Node>}\n     */\n    this.nodes = [];\n\n    /**\n     * The output node.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.outputNode = null;\n\n    /**\n     * The parent stack node.\n     *\n     * @type {StackNode}\n     * @default null\n     */\n    this.parent = parent;\n\n    /**\n     * The current conditional node.\n     *\n     * @private\n     * @type {ConditionalNode}\n     * @default null\n     */\n    this._currentCond = null;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isStackNode = true;\n  }\n  getNodeType(builder) {\n    return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';\n  }\n\n  /**\n   * Adds a node to this stack.\n   *\n   * @param {Node} node - The node to add.\n   * @return {StackNode} A reference to this stack node.\n   */\n  add(node) {\n    this.nodes.push(node);\n    return this;\n  }\n\n  /**\n   * Represent an `if` statement in TSL.\n   *\n   * @param {Node} boolNode - Represents the condition.\n   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n   * @return {StackNode} A reference to this stack node.\n   */\n  If(boolNode, method) {\n    const methodNode = new ShaderNode(method);\n    this._currentCond = select(boolNode, methodNode);\n    return this.add(this._currentCond);\n  }\n\n  /**\n   * Represent an `elseif` statement in TSL.\n   *\n   * @param {Node} boolNode - Represents the condition.\n   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n   * @return {StackNode} A reference to this stack node.\n   */\n  ElseIf(boolNode, method) {\n    const methodNode = new ShaderNode(method);\n    const ifNode = select(boolNode, methodNode);\n    this._currentCond.elseNode = ifNode;\n    this._currentCond = ifNode;\n    return this;\n  }\n\n  /**\n   * Represent an `else` statement in TSL.\n   *\n   * @param {Function} method - TSL code which is executed in the `else` case.\n   * @return {StackNode} A reference to this stack node.\n   */\n  Else(method) {\n    this._currentCond.elseNode = new ShaderNode(method);\n    return this;\n  }\n  build(builder, ...params) {\n    const previousStack = getCurrentStack();\n    setCurrentStack(this);\n    for (const node of this.nodes) {\n      node.build(builder, 'void');\n    }\n    setCurrentStack(previousStack);\n    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);\n  }\n\n  //\n\n  else(...params) {\n    // @deprecated, r168\n\n    console.warn('TSL.StackNode: .else() has been renamed to .Else().');\n    return this.Else(...params);\n  }\n  elseif(...params) {\n    // @deprecated, r168\n\n    console.warn('TSL.StackNode: .elseif() has been renamed to .ElseIf().');\n    return this.ElseIf(...params);\n  }\n}\n\n/**\n * TSL function for creating a stack node.\n *\n * @function\n * @param {StackNode?} [parent=null] - The parent stack node.\n * @returns {StackNode}\n */\nconst stack = /*@__PURE__*/nodeProxy(StackNode);\n\n/** @module OutputStructNode **/\n\n/**\n * This node can be used to define multiple outputs in a shader programs.\n *\n * @augments Node\n */\nclass OutputStructNode extends Node {\n  static get type() {\n    return 'OutputStructNode';\n  }\n\n  /**\n   * Constructs a new output struct node. The constructor can be invoked with an\n   * arbitrary number of nodes representing the members.\n   *\n   * @param {...Node} members - A parameter list of nodes.\n   */\n  constructor(...members) {\n    super();\n\n    /**\n     * An array of nodes which defines the output.\n     *\n     * @type {Array<Node>}\n     */\n    this.members = members;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isOutputStructNode = true;\n  }\n  setup(builder) {\n    super.setup(builder);\n    const members = this.members;\n    const types = [];\n    for (let i = 0; i < members.length; i++) {\n      types.push(members[i].getNodeType(builder));\n    }\n    this.nodeType = builder.getStructTypeFromNode(this, types).name;\n  }\n  generate(builder, output) {\n    const propertyName = builder.getOutputStructName();\n    const members = this.members;\n    const structPrefix = propertyName !== '' ? propertyName + '.' : '';\n    for (let i = 0; i < members.length; i++) {\n      const snippet = members[i].build(builder, output);\n      builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`, this);\n    }\n    return propertyName;\n  }\n}\n\n/**\n * TSL function for creating an output struct node.\n *\n * @function\n * @param {...Node} members - A parameter list of nodes.\n * @returns {OutputStructNode}\n */\nconst outputStruct = /*@__PURE__*/nodeProxy(OutputStructNode);\n\n/** @module MRTNode **/\n\n/**\n * Returns the MRT texture index for the given name.\n *\n * @param {Array<Texture>} textures - The textures of a MRT-configured render target.\n * @param {String} name - The name of the MRT texture which index is requested.\n * @return {Number} The texture index.\n */\nfunction getTextureIndex(textures, name) {\n  for (let i = 0; i < textures.length; i++) {\n    if (textures[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * This node can be used setup a MRT context for rendering. A typical MRT setup for\n * post-processing is shown below:\n * ```js\n * const mrtNode = mrt( {\n *   output: output,\n *   normal: normalView\n * } ) );\n * ```\n * The MRT output is defined as a dictionary.\n *\n * @augments OutputStructNode\n */\nclass MRTNode extends OutputStructNode {\n  static get type() {\n    return 'MRTNode';\n  }\n\n  /**\n   * Constructs a new output struct node.\n   *\n   * @param {Object<String, Node>} outputNodes - The MRT outputs.\n   */\n  constructor(outputNodes) {\n    super();\n\n    /**\n     * A dictionary representing the MRT outputs. The key\n     * is the name of the output, the value the node which produces\n     * the output result.\n     *\n     * @type {Object<String, Node>}\n     */\n    this.outputNodes = outputNodes;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMRTNode = true;\n  }\n\n  /**\n   * Returns `true` if the MRT node has an output with the given name.\n   *\n   * @param {String} name - The name of the output.\n   * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.\n   */\n  has(name) {\n    return this.outputNodes[name] !== undefined;\n  }\n\n  /**\n   * Returns the output node for the given name.\n   *\n   * @param {String} name - The name of the output.\n   * @return {Node} The output node.\n   */\n  get(name) {\n    return this.outputNodes[name];\n  }\n\n  /**\n   * Merges the outputs of the given MRT node with the outputs of this node.\n   *\n   * @param {MRTNode} mrtNode - The MRT to merge.\n   * @return {MRTNode} A new MRT node with merged outputs..\n   */\n  merge(mrtNode) {\n    const outputs = {\n      ...this.outputNodes,\n      ...mrtNode.outputNodes\n    };\n    return mrt(outputs);\n  }\n  setup(builder) {\n    const outputNodes = this.outputNodes;\n    const mrt = builder.renderer.getRenderTarget();\n    const members = [];\n    const textures = mrt.textures;\n    for (const name in outputNodes) {\n      const index = getTextureIndex(textures, name);\n      members[index] = vec4(outputNodes[name]);\n    }\n    this.members = members;\n    return super.setup(builder);\n  }\n}\n\n/**\n * TSL function for creating a MRT node.\n *\n * @function\n * @param {Object<String, Node>} outputNodes - The MRT outputs.\n * @returns {MRTNode}\n */\nconst mrt = /*@__PURE__*/nodeProxy(MRTNode);\n\n/** @module Hash **/\n\n/**\n * Generates a hash value in the range `[0, 1]` from the given seed.\n *\n * @method\n * @param {Node<float>} seed - The seed.\n * @return {Node<float>} The hash value.\n */\nconst hash = /*@__PURE__*/Fn(([seed]) => {\n  // Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org\n\n  const state = seed.toUint().mul(747796405).add(2891336453);\n  const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);\n  const result = word.shiftRight(22).bitXor(word);\n  return result.toFloat().mul(1 / 2 ** 32); // Convert to range [0, 1)\n});\n\n/** @module MathUtils **/\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * The corners are mapped to `0` and the center to `1`.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} k - Allows to control the remapping functions shape by rising the parabola to a power `k`.\n * @return {Node<float>} The remapped value.\n */\nconst parabola = (x, k) => pow(mul(4.0, x.mul(sub(1.0, x))), k);\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * Expands the sides and compresses the center, and keeps `0.5` mapped to `0.5`.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} k - `k=1` is the identity curve,`k<1` produces the classic `gain()` shape, and `k>1` produces \"s\" shaped curves.\n * @return {Node<float>} The remapped value.\n */\nconst gain = (x, k) => x.lessThan(0.5) ? parabola(x.mul(2.0), k).div(2.0) : sub(1.0, parabola(mul(sub(1.0, x), 2.0), k).div(2.0));\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * A generalization of the `parabola()`. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} a - First control parameter.\n * @param {Node<float>} b - Second control parameter.\n * @return {Node<float>} The remapped value.\n */\nconst pcurve = (x, a, b) => pow(div(pow(x, a), add(pow(x, a), pow(sub(1.0, x), b))), 1.0 / a);\n\n/**\n * A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to compute the sin for.\n * @param {Node<float>} k - Controls the amount of bounces.\n * @return {Node<float>} The result value.\n */\nconst sinc = (x, k) => sin(PI.mul(k.mul(x).sub(1.0))).div(PI.mul(k.mul(x).sub(1.0)));\n\n// https://github.com/cabbibo/glsl-tri-noise-3d\n\n/** @module TriNoise3D **/\n\nconst tri = /*@__PURE__*/Fn(([x]) => {\n  return x.fract().sub(.5).abs();\n}).setLayout({\n  name: 'tri',\n  type: 'float',\n  inputs: [{\n    name: 'x',\n    type: 'float'\n  }]\n});\nconst tri3 = /*@__PURE__*/Fn(([p]) => {\n  return vec3(tri(p.z.add(tri(p.y.mul(1.)))), tri(p.z.add(tri(p.x.mul(1.)))), tri(p.y.add(tri(p.x.mul(1.)))));\n}).setLayout({\n  name: 'tri3',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\n\n/**\n * Generates a noise value from the given position, speed and time parameters.\n *\n * @method\n * @param {Node<vec3>} position - The position.\n * @param {Node<float>} speed - The speed.\n * @param {Node<float>} time - The time.\n * @return {Node<float>} The generated noise.\n */\nconst triNoise3D = /*@__PURE__*/Fn(([position, speed, time]) => {\n  const p = vec3(position).toVar();\n  const z = float(1.4).toVar();\n  const rz = float(0.0).toVar();\n  const bp = vec3(p).toVar();\n  Loop({\n    start: float(0.0),\n    end: float(3.0),\n    type: 'float',\n    condition: '<='\n  }, () => {\n    const dg = vec3(tri3(bp.mul(2.0))).toVar();\n    p.addAssign(dg.add(time.mul(float(0.1).mul(speed))));\n    bp.mulAssign(1.8);\n    z.mulAssign(1.5);\n    p.mulAssign(1.2);\n    const t = float(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();\n    rz.addAssign(t.div(z));\n    bp.addAssign(0.14);\n  });\n  return rz;\n}).setLayout({\n  name: 'triNoise3D',\n  type: 'float',\n  inputs: [{\n    name: 'position',\n    type: 'vec3'\n  }, {\n    name: 'speed',\n    type: 'float'\n  }, {\n    name: 'time',\n    type: 'float'\n  }]\n});\n\n/** @module FunctionOverloadingNode **/\n\n/**\n * This class allows to define multiple overloaded versions\n * of the same function. Depending on the parameters of the function\n * call, the node picks the best-fit overloaded version.\n *\n * @augments Node\n */\nclass FunctionOverloadingNode extends Node {\n  static get type() {\n    return 'FunctionOverloadingNode';\n  }\n\n  /**\n   * Constructs a new function overloading node.\n   *\n   * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.\n   * @param {...Node} parametersNodes - A list of parameter nodes.\n   */\n  constructor(functionNodes = [], ...parametersNodes) {\n    super();\n\n    /**\n     * Array of `Fn` function definitions.\n     *\n     * @type {Array<Function>}\n     */\n    this.functionNodes = functionNodes;\n\n    /**\n     * A list of parameter nodes.\n     *\n     * @type {Array<Node>}\n     */\n    this.parametersNodes = parametersNodes;\n\n    /**\n     * The selected overloaded function call.\n     *\n     * @private\n     * @type {ShaderCallNodeInternal}\n     */\n    this._candidateFnCall = null;\n\n    /**\n     * This node is marked as global.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.global = true;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from\n   * the function's return type.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType() {\n    return this.functionNodes[0].shaderNode.layout.type;\n  }\n  setup(builder) {\n    const params = this.parametersNodes;\n    let candidateFnCall = this._candidateFnCall;\n    if (candidateFnCall === null) {\n      let candidateFn = null;\n      let candidateScore = -1;\n      for (const functionNode of this.functionNodes) {\n        const shaderNode = functionNode.shaderNode;\n        const layout = shaderNode.layout;\n        if (layout === null) {\n          throw new Error('FunctionOverloadingNode: FunctionNode must be a layout.');\n        }\n        const inputs = layout.inputs;\n        if (params.length === inputs.length) {\n          let score = 0;\n          for (let i = 0; i < params.length; i++) {\n            const param = params[i];\n            const input = inputs[i];\n            if (param.getNodeType(builder) === input.type) {\n              score++;\n            } else {\n              score = 0;\n            }\n          }\n          if (score > candidateScore) {\n            candidateFn = functionNode;\n            candidateScore = score;\n          }\n        }\n      }\n      this._candidateFnCall = candidateFnCall = candidateFn(...params);\n    }\n    return candidateFnCall;\n  }\n}\nconst overloadingBaseFn = /*@__PURE__*/nodeProxy(FunctionOverloadingNode);\n\n/**\n * TSL function for creating a function overloading node.\n *\n * @function\n * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.\n * @returns {FunctionOverloadingNode}\n */\nconst overloadingFn = functionNodes => (...params) => overloadingBaseFn(functionNodes, ...params);\n\n/** @module Timer **/\n\n/**\n * Represents the elapsed time in seconds.\n *\n * @type {UniformNode<float>}\n */\nconst time = /*@__PURE__*/uniform(0).setGroup(renderGroup).onRenderUpdate(frame => frame.time);\n\n/**\n * Represents the delta time in seconds.\n *\n * @type {UniformNode<float>}\n */\nconst deltaTime = /*@__PURE__*/uniform(0).setGroup(renderGroup).onRenderUpdate(frame => frame.deltaTime);\n\n/**\n * Represents the current frame ID.\n *\n * @type {UniformNode<uint>}\n */\nconst frameId = /*@__PURE__*/uniform(0, 'uint').setGroup(renderGroup).onRenderUpdate(frame => frame.frameId);\n\n// Deprecated\n\nconst timerLocal = (timeScale = 1) => {\n  // @deprecated, r170\n\n  console.warn('TSL: timerLocal() is deprecated. Use \"time\" instead.');\n  return time.mul(timeScale);\n};\nconst timerGlobal = (timeScale = 1) => {\n  // @deprecated, r170\n\n  console.warn('TSL: timerGlobal() is deprecated. Use \"time\" instead.');\n  return time.mul(timeScale);\n};\nconst timerDelta = (timeScale = 1) => {\n  // @deprecated, r170\n\n  console.warn('TSL: timerDelta() is deprecated. Use \"deltaTime\" instead.');\n  return deltaTime.mul(timeScale);\n};\n\n/** @module Oscillators **/\n\n/**\n * Generates a sine wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSine = (t = time) => t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);\n\n/**\n * Generates a square wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSquare = (t = time) => t.fract().round();\n\n/**\n * Generates a triangle wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscTriangle = (t = time) => t.add(0.5).fract().mul(2).sub(1).abs();\n\n/**\n * Generates a sawtooth wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSawtooth = (t = time) => t.fract();\n\n/** @module UVUtils **/\n\n/**\n * Rotates the given uv coordinates around a center point\n *\n * @method\n * @param {Node<vec2>} uv - The uv coordinates.\n * @param {Node<float>} rotation - The rotation defined in radians.\n * @param {Node<vec2>} center - The center of rotation\n * @return {Node<vec2>} The rotated uv coordinates.\n */\nconst rotateUV = /*@__PURE__*/Fn(([uv, rotation, center = vec2(0.5)]) => {\n  return rotate(uv.sub(center), rotation).add(center);\n});\n\n/**\n * Applies a spherical warping effect to the given uv coordinates.\n *\n * @method\n * @param {Node<vec2>} uv - The uv coordinates.\n * @param {Node<float>} strength - The strength of the effect.\n * @param {Node<vec2>} center - The center point\n * @return {Node<vec2>} The updated uv coordinates.\n */\nconst spherizeUV = /*@__PURE__*/Fn(([uv, strength, center = vec2(0.5)]) => {\n  const delta = uv.sub(center);\n  const delta2 = delta.dot(delta);\n  const delta4 = delta2.mul(delta2);\n  const deltaOffset = delta4.mul(strength);\n  return uv.add(delta.mul(deltaOffset));\n});\n\n/** @module SpriteUtils **/\n\n/**\n * This can be used to achieve a billboarding behavior for flat meshes. That means they are\n * oriented always towards the camera.\n *\n * ```js\n * material.vertexNode = billboarding();\n * ```\n *\n * @method\n * @param {Object} config - The configuration object.\n * @param {Node<vec3>?} [config.position=null] - Can be used to define the vertex positions in world space.\n * @param {Boolean} [config.horizontal=true] - Whether to follow the camera rotation horizontally or not.\n * @param {Boolean} [config.vertical=false] - Whether to follow the camera rotation vertically or not.\n * @return {Node<vec3>} The updated vertex position in clip space.\n */\nconst billboarding = /*@__PURE__*/Fn(({\n  position = null,\n  horizontal = true,\n  vertical = false\n}) => {\n  let worldMatrix;\n  if (position !== null) {\n    worldMatrix = modelWorldMatrix.toVar();\n    worldMatrix[3][0] = position.x;\n    worldMatrix[3][1] = position.y;\n    worldMatrix[3][2] = position.z;\n  } else {\n    worldMatrix = modelWorldMatrix;\n  }\n  const modelViewMatrix = cameraViewMatrix.mul(worldMatrix);\n  if (defined(horizontal)) {\n    modelViewMatrix[0][0] = modelWorldMatrix[0].length();\n    modelViewMatrix[0][1] = 0;\n    modelViewMatrix[0][2] = 0;\n  }\n  if (defined(vertical)) {\n    modelViewMatrix[1][0] = 0;\n    modelViewMatrix[1][1] = modelWorldMatrix[1].length();\n    modelViewMatrix[1][2] = 0;\n  }\n  modelViewMatrix[2][0] = 0;\n  modelViewMatrix[2][1] = 0;\n  modelViewMatrix[2][2] = 1;\n  return cameraProjectionMatrix.mul(modelViewMatrix).mul(positionLocal);\n});\n\n/** @module ViewportUtils **/\n\n/**\n * A special version of a screen uv function that involves a depth comparison\n * when computing the final uvs. The function mitigates visual errors when\n * using viewport texture nodes for refraction purposes. Without this function\n * objects in front of a refractive surface might appear on the refractive surface\n * which is incorrect.\n *\n * @method\n * @param {Node<vec2>?} uv - Optional uv coordinates. By default `screenUV` is used.\n * @return {Node<vec2>} The update uv coordinates.\n */\nconst viewportSafeUV = /*@__PURE__*/Fn(([uv = null]) => {\n  const depth = linearDepth();\n  const depthDiff = linearDepth(viewportDepthTexture(uv)).sub(depth);\n  const finalUV = depthDiff.lessThan(0).select(screenUV, uv);\n  return finalUV;\n});\n\n/** @module SpriteSheetUVNode **/\n\n/**\n * Can be used to compute texture coordinates for animated sprite sheets.\n *\n * ```js\n * const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );\n *\n * material.colorNode = texture( spriteSheet, uvNode );\n * ```\n *\n * @augments Node\n */\nclass SpriteSheetUVNode extends Node {\n  static get type() {\n    return 'SpriteSheetUVNode';\n  }\n\n  /**\n   * Constructs a new sprite sheet uv node.\n   *\n   * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).\n   * @param {Node<vec2>} [uvNode=uv()] - The uv node.\n   * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.\n   */\n  constructor(countNode, uvNode = uv(), frameNode = float(0)) {\n    super('vec2');\n\n    /**\n     * The node that defines the number of sprites in the x and y direction (e.g 6x6).\n     *\n     * @type {Node<vec2>}\n     */\n    this.countNode = countNode;\n\n    /**\n     * The uv node.\n     *\n     * @type {Node<vec2>}\n     */\n    this.uvNode = uvNode;\n\n    /**\n     * The node that defines the current frame/sprite.\n     *\n     * @type {Node<float>}\n     */\n    this.frameNode = frameNode;\n  }\n  setup() {\n    const {\n      frameNode,\n      uvNode,\n      countNode\n    } = this;\n    const {\n      width,\n      height\n    } = countNode;\n    const frameNum = frameNode.mod(width.mul(height)).floor();\n    const column = frameNum.mod(width);\n    const row = height.sub(frameNum.add(1).div(width).ceil());\n    const scale = countNode.reciprocal();\n    const uvFrameOffset = vec2(column, row);\n    return uvNode.add(uvFrameOffset).mul(scale);\n  }\n}\n\n/**\n * TSL function for creating a sprite sheet uv node.\n *\n * @function\n * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).\n * @param {Node<vec2>} [uvNode=uv()] - The uv node.\n * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.\n * @returns {SpriteSheetUVNode}\n */\nconst spritesheetUV = /*@__PURE__*/nodeProxy(SpriteSheetUVNode);\n\n/** @module TriplanarTexturesNode **/\n\n/**\n * Can be used for triplanar texture mapping.\n *\n * ```js\n * material.colorNode = triplanarTexture( texture( diffuseMap ) );\n * ```\n *\n * @augments Node\n */\nclass TriplanarTexturesNode extends Node {\n  static get type() {\n    return 'TriplanarTexturesNode';\n  }\n\n  /**\n   * Constructs a new triplanar textures node.\n   *\n   * @param {Node} textureXNode - First texture node.\n   * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n   * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n   * @param {Node<float>?} [scaleNode=float(1)] - The scale node.\n   * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.\n   * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.\n   */\n  constructor(textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionLocal, normalNode = normalLocal) {\n    super('vec4');\n\n    /**\n     * First texture node.\n     *\n     * @type {Node}\n     */\n    this.textureXNode = textureXNode;\n\n    /**\n     * Second texture node. When not set, the shader will sample from `textureXNode` instead.\n     *\n     * @type {Node}\n     * @default null\n     */\n    this.textureYNode = textureYNode;\n\n    /**\n     * Third texture node. When not set, the shader will sample from `textureXNode` instead.\n     *\n     * @type {Node}\n     * @default null\n     */\n    this.textureZNode = textureZNode;\n\n    /**\n     * The scale node.\n     *\n     * @type {Node<float>}\n     * @default float(1)\n     */\n    this.scaleNode = scaleNode;\n\n    /**\n     * Vertex positions in local space.\n     *\n     * @type {Node<vec3>}\n     * @default positionLocal\n     */\n    this.positionNode = positionNode;\n\n    /**\n     * Normals in local space.\n     *\n     * @type {Node<vec3>}\n     * @default normalLocal\n     */\n    this.normalNode = normalNode;\n  }\n  setup() {\n    const {\n      textureXNode,\n      textureYNode,\n      textureZNode,\n      scaleNode,\n      positionNode,\n      normalNode\n    } = this;\n\n    // Ref: https://github.com/keijiro/StandardTriplanar\n\n    // Blending factor of triplanar mapping\n    let bf = normalNode.abs().normalize();\n    bf = bf.div(bf.dot(vec3(1.0)));\n\n    // Triplanar mapping\n    const tx = positionNode.yz.mul(scaleNode);\n    const ty = positionNode.zx.mul(scaleNode);\n    const tz = positionNode.xy.mul(scaleNode);\n\n    // Base color\n    const textureX = textureXNode.value;\n    const textureY = textureYNode !== null ? textureYNode.value : textureX;\n    const textureZ = textureZNode !== null ? textureZNode.value : textureX;\n    const cx = texture(textureX, tx).mul(bf.x);\n    const cy = texture(textureY, ty).mul(bf.y);\n    const cz = texture(textureZ, tz).mul(bf.z);\n    return add(cx, cy, cz);\n  }\n}\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node<float>?} [scaleNode=float(1)] - The scale node.\n * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.\n * @returns {TriplanarTexturesNode}\n */\nconst triplanarTextures = /*@__PURE__*/nodeProxy(TriplanarTexturesNode);\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node<float>?} [scaleNode=float(1)] - The scale node.\n * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.\n * @returns {TriplanarTexturesNode}\n */\nconst triplanarTexture = (...params) => triplanarTextures(...params);\n\n/** @module ReflectorNode **/\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3(0, 0, -1);\nconst clipPlane = new Vector4();\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\nconst _size$2 = new Vector2();\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = screenUV.flipX();\n_defaultRT.depthTexture = new DepthTexture(1, 1);\nlet _inReflector = false;\n\n/**\n * This node can be used to implement mirror-like flat reflective surfaces.\n *\n * ```js\n * const groundReflector = reflector();\n * material.colorNode = groundReflector;\n *\n * const plane = new Mesh( geometry, material );\n * plane.add( groundReflector.target );\n * ```\n *\n * @augments module:TextureNode~TextureNode\n */\nclass ReflectorNode extends TextureNode {\n  static get type() {\n    return 'ReflectorNode';\n  }\n\n  /**\n   * Constructs a new reflector node.\n   *\n   * @param {Object} [parameters={}] - An object holding configuration parameters.\n   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n   * @param {Number} [parameters.resolution=1] - The resolution scale.\n   * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n   * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n   * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n   * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n   * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n   */\n  constructor(parameters = {}) {\n    super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);\n\n    /**\n     * A reference to the internal reflector base node which holds the actual implementation.\n     *\n     * @private\n     * @type {ReflectorBaseNode?}\n     * @default null\n     */\n    this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(this, parameters);\n\n    /**\n     * A reference to the internal depth node.\n     *\n     * @private\n     * @type {Node?}\n     * @default null\n     */\n    this._depthNode = null;\n    this.setUpdateMatrix(false);\n  }\n\n  /**\n   * A reference to the internal reflector node.\n   *\n   * @type {ReflectorBaseNode}\n   */\n  get reflector() {\n    return this._reflectorBaseNode;\n  }\n\n  /**\n   * A reference to 3D object the reflector is linked to.\n   *\n   * @type {Object3D}\n   */\n  get target() {\n    return this._reflectorBaseNode.target;\n  }\n\n  /**\n   * Returns a node representing the mirror's depth. That can be used\n   * to implement more advanced reflection effects like distance attenuation.\n   *\n   * @return {Node} The depth node.\n   */\n  getDepthNode() {\n    if (this._depthNode === null) {\n      if (this._reflectorBaseNode.depth !== true) {\n        throw new Error('THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ');\n      }\n      this._depthNode = nodeObject(new ReflectorNode({\n        defaultTexture: _defaultRT.depthTexture,\n        reflector: this._reflectorBaseNode\n      }));\n    }\n    return this._depthNode;\n  }\n  setup(builder) {\n    // ignore if used in post-processing\n    if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);\n    return super.setup(builder);\n  }\n  clone() {\n    const texture = new this.constructor(this.reflectorNode);\n    texture._reflectorBaseNode = this._reflectorBaseNode;\n    return texture;\n  }\n}\n\n/**\n * Holds the actual implementation of the reflector.\n *\n * TODO: Explain why `ReflectorBaseNode`. Originally the entire logic was implemented\n * in `ReflectorNode`, see #29619.\n *\n * @private\n * @augments Node\n */\nclass ReflectorBaseNode extends Node {\n  static get type() {\n    return 'ReflectorBaseNode';\n  }\n\n  /**\n   * Constructs a new reflector base node.\n   *\n   * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.\n   * @param {Object} [parameters={}] - An object holding configuration parameters.\n   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n   * @param {Number} [parameters.resolution=1] - The resolution scale.\n   * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n   * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n   * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n   */\n  constructor(textureNode, parameters = {}) {\n    super();\n    const {\n      target = new Object3D(),\n      resolution = 1,\n      generateMipmaps = false,\n      bounces = true,\n      depth = false\n    } = parameters;\n\n    /**\n     * Represents the rendered reflections as a texture node.\n     *\n     * @type {TextureNode}\n     */\n    this.textureNode = textureNode;\n\n    /**\n     * The 3D object the reflector is linked to.\n     *\n     * @type {Object3D}\n     * @default {new Object3D()}\n     */\n    this.target = target;\n\n    /**\n     * The resolution scale.\n     *\n     * @type {Number}\n     * @default {1}\n     */\n    this.resolution = resolution;\n\n    /**\n     * Whether mipmaps should be generated or not.\n     *\n     * @type {Boolean}\n     * @default {false}\n     */\n    this.generateMipmaps = generateMipmaps;\n\n    /**\n     * Whether reflectors can render other reflector nodes or not.\n     *\n     * @type {Boolean}\n     * @default {true}\n     */\n    this.bounces = bounces;\n\n    /**\n     * Whether depth data should be generated or not.\n     *\n     * @type {Boolean}\n     * @default {false}\n     */\n    this.depth = depth;\n\n    /**\n     * The `updateBeforeType` is set to `NodeUpdateType.RENDER` when {@link ReflectorBaseNode#bounces}\n     * is `true`. Otherwise it's `NodeUpdateType.FRAME`.\n     *\n     * @type {String}\n     * @default 'render'\n     */\n    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n    /**\n     * Weak map for managing virtual cameras.\n     *\n     * @type {WeakMap<Camera, Camera>}\n     */\n    this.virtualCameras = new WeakMap();\n\n    /**\n     * Weak map for managing render targets.\n     *\n     * @type {WeakMap<Camera, RenderTarget>}\n     */\n    this.renderTargets = new WeakMap();\n  }\n\n  /**\n   * Updates the resolution of the internal render target.\n   *\n   * @private\n   * @param {RenderTarget} renderTarget - The render target to resize.\n   * @param {Renderer} renderer - The renderer that is used to determine the new size.\n   */\n  _updateResolution(renderTarget, renderer) {\n    const resolution = this.resolution;\n    renderer.getDrawingBufferSize(_size$2);\n    renderTarget.setSize(Math.round(_size$2.width * resolution), Math.round(_size$2.height * resolution));\n  }\n  setup(builder) {\n    this._updateResolution(_defaultRT, builder.renderer);\n    return super.setup(builder);\n  }\n\n  /**\n   * Returns a virtual camera for the given camera. The virtual camera is used to\n   * render the scene from the reflector's view so correct reflections can be produced.\n   *\n   * @param {Camera} camera - The scene's camera.\n   * @return {Camera} The corresponding virtual camera.\n   */\n  getVirtualCamera(camera) {\n    let virtualCamera = this.virtualCameras.get(camera);\n    if (virtualCamera === undefined) {\n      virtualCamera = camera.clone();\n      this.virtualCameras.set(camera, virtualCamera);\n    }\n    return virtualCamera;\n  }\n\n  /**\n   * Returns a render target for the given camera. The reflections are rendered\n   * into this render target.\n   *\n   * @param {Camera} camera - The scene's camera.\n   * @return {RenderTarget} The render target.\n   */\n  getRenderTarget(camera) {\n    let renderTarget = this.renderTargets.get(camera);\n    if (renderTarget === undefined) {\n      renderTarget = new RenderTarget(0, 0, {\n        type: HalfFloatType\n      });\n      if (this.generateMipmaps === true) {\n        renderTarget.texture.minFilter = LinearMipMapLinearFilter;\n        renderTarget.texture.generateMipmaps = true;\n      }\n      if (this.depth === true) {\n        renderTarget.depthTexture = new DepthTexture();\n      }\n      this.renderTargets.set(camera, renderTarget);\n    }\n    return renderTarget;\n  }\n  updateBefore(frame) {\n    if (this.bounces === false && _inReflector) return false;\n    _inReflector = true;\n    const {\n      scene,\n      camera,\n      renderer,\n      material\n    } = frame;\n    const {\n      target\n    } = this;\n    const virtualCamera = this.getVirtualCamera(camera);\n    const renderTarget = this.getRenderTarget(virtualCamera);\n    renderer.getDrawingBufferSize(_size$2);\n    this._updateResolution(renderTarget, renderer);\n\n    //\n\n    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);\n    _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    _rotationMatrix.extractRotation(target.matrixWorld);\n    _normal.set(0, 0, 1);\n    _normal.applyMatrix4(_rotationMatrix);\n    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);\n\n    // Avoid rendering when reflector is facing away\n\n    if (_view.dot(_normal) > 0) return;\n    _view.reflect(_normal).negate();\n    _view.add(_reflectorWorldPosition);\n    _rotationMatrix.extractRotation(camera.matrixWorld);\n    _lookAtPosition.set(0, 0, -1);\n    _lookAtPosition.applyMatrix4(_rotationMatrix);\n    _lookAtPosition.add(_cameraWorldPosition);\n    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);\n    _target.reflect(_normal).negate();\n    _target.add(_reflectorWorldPosition);\n\n    //\n\n    virtualCamera.coordinateSystem = camera.coordinateSystem;\n    virtualCamera.position.copy(_view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(_rotationMatrix);\n    virtualCamera.up.reflect(_normal);\n    virtualCamera.lookAt(_target);\n    virtualCamera.near = camera.near;\n    virtualCamera.far = camera.far;\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n    // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);\n    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);\n    const projectionMatrix = virtualCamera.projectionMatrix;\n    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    _q.z = -1.0;\n    _q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n    // Calculate the scaled plane vector\n    clipPlane.multiplyScalar(1.0 / clipPlane.dot(_q));\n    const clipBias = 0;\n\n    // Replacing the third row of the projection matrix\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = renderer.coordinateSystem === WebGPUCoordinateSystem ? clipPlane.z - clipBias : clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n\n    //\n\n    this.textureNode.value = renderTarget.texture;\n    if (this.depth === true) {\n      this.textureNode.getDepthNode().value = renderTarget.depthTexture;\n    }\n    material.visible = false;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentMRT = renderer.getMRT();\n    const currentAutoClear = renderer.autoClear;\n    renderer.setMRT(null);\n    renderer.setRenderTarget(renderTarget);\n    renderer.autoClear = true;\n    renderer.render(scene, virtualCamera);\n    renderer.setMRT(currentMRT);\n    renderer.setRenderTarget(currentRenderTarget);\n    renderer.autoClear = currentAutoClear;\n    material.visible = true;\n    _inReflector = false;\n  }\n}\n\n/**\n * TSL function for creating a reflector node.\n *\n * @function\n * @param {Object} [parameters={}] - An object holding configuration parameters.\n * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n * @param {Number} [parameters.resolution=1] - The resolution scale.\n * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n * @returns {ReflectorNode}\n */\nconst reflector = parameters => nodeObject(new ReflectorNode(parameters));\nconst _camera = /*@__PURE__*/new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n/**\n * The purpose of this special geometry is to fill the entire viewport with a single triangle.\n *\n * Reference: {@link https://github.com/mrdoob/three.js/pull/21358}\n *\n * @private\n * @augments BufferGeometry\n */\nclass QuadGeometry extends BufferGeometry {\n  /**\n   * Constructs a new quad geometry.\n   *\n   * @param {Boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.\n   */\n  constructor(flipY = false) {\n    super();\n    const uv = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];\n    this.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uv, 2));\n  }\n}\nconst _geometry = /*@__PURE__*/new QuadGeometry();\n\n/**\n * This module is a helper for passes which need to render a full\n * screen effect which is quite common in context of post processing.\n *\n * The intended usage is to reuse a single quad mesh for rendering\n * subsequent passes by just reassigning the `material` reference.\n *\n * @augments BufferGeometry\n */\nclass QuadMesh extends Mesh {\n  /**\n   * Constructs a new quad mesh.\n   *\n   * @param {Material?} [material=null] - The material to render the quad mesh with.\n   */\n  constructor(material = null) {\n    super(_geometry, material);\n\n    /**\n     * The camera to render the quad mesh with.\n     *\n     * @type {OrthographicCamera}\n     * @readonly\n     */\n    this.camera = _camera;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isQuadMesh = true;\n  }\n\n  /**\n   * Async version of `render()`.\n   *\n   * @async\n   * @param {Renderer} renderer - The renderer.\n   * @return {Promise} A Promise that resolves when the render has been finished.\n   */\n  async renderAsync(renderer) {\n    return renderer.renderAsync(this, _camera);\n  }\n\n  /**\n   * Renders the quad mesh\n   *\n   * @param {Renderer} renderer - The renderer.\n   */\n  render(renderer) {\n    renderer.render(this, _camera);\n  }\n}\n\n/** @module RTTNode **/\n\nconst _size$1 = /*@__PURE__*/new Vector2();\n\n/**\n * `RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).\n * This module is especially relevant in context of post processing where certain nodes require\n * texture input for their effects. With the helper function `convertToTexture()` which is based\n * on this module, the node system can automatically ensure texture input if required.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass RTTNode extends TextureNode {\n  static get type() {\n    return 'RTTNode';\n  }\n\n  /**\n   * Constructs a new RTT node.\n   *\n   * @param {Node} node - The node to render a texture with.\n   * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n   * @param {Number?} [height=null] - The height of the internal render target.\n   * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n   */\n  constructor(node, width = null, height = null, options = {\n    type: HalfFloatType\n  }) {\n    const renderTarget = new RenderTarget(width, height, options);\n    super(renderTarget.texture, uv());\n\n    /**\n     * The node to render a texture with.\n     *\n     * @type {Node}\n     */\n    this.node = node;\n\n    /**\n     * The width of the internal render target.\n     * If not width is applied, the render target is automatically resized.\n     *\n     * @type {Number?}\n     * @default null\n     */\n    this.width = width;\n\n    /**\n     * The height of the internal render target.\n     *\n     * @type {Number?}\n     * @default null\n     */\n    this.height = height;\n\n    /**\n     * The pixel ratio\n     *\n     * @type {Number}\n     * @default 1\n     */\n    this.pixelRatio = 1;\n\n    /**\n     * The render target\n     *\n     * @type {RenderTarget}\n     */\n    this.renderTarget = renderTarget;\n\n    /**\n     * Whether the texture requires an update or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.textureNeedsUpdate = true;\n\n    /**\n     * Whether the texture should automatically be updated or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.autoUpdate = true;\n\n    /**\n     * The node which is used with the quad mesh for RTT.\n     *\n     * @private\n     * @type {Node}\n     * @default null\n     */\n    this._rttNode = null;\n\n    /**\n     * The internal quad mesh for RTT.\n     *\n     * @private\n     * @type {QuadMesh}\n     */\n    this._quadMesh = new QuadMesh(new NodeMaterial());\n\n    /**\n     * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n     * the texture once per render in its {@link RTTNode#updateBefore} method.\n     *\n     * @type {String}\n     * @default 'render'\n     */\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n\n  /**\n   * Whether the internal render target should automatically be resized or not.\n   *\n   * @type {Boolean}\n   * @readonly\n   * @default true\n   */\n  get autoSize() {\n    return this.width === null;\n  }\n  setup(builder) {\n    this._rttNode = this.node.context(builder.getSharedContext());\n    this._quadMesh.material.name = 'RTT';\n    this._quadMesh.material.needsUpdate = true;\n    return super.setup(builder);\n  }\n\n  /**\n   * Sets the size of the internal render target\n   *\n   * @param {Number} width - The width to set.\n   * @param {Number} height - The width to set.\n   */\n  setSize(width, height) {\n    this.width = width;\n    this.height = height;\n    const effectiveWidth = width * this.pixelRatio;\n    const effectiveHeight = height * this.pixelRatio;\n    this.renderTarget.setSize(effectiveWidth, effectiveHeight);\n    this.textureNeedsUpdate = true;\n  }\n\n  /**\n   * Sets the pixel ratio. This will also resize the render target.\n   *\n   * @param {Number} pixelRatio - The pixel ratio to set.\n   */\n  setPixelRatio(pixelRatio) {\n    this.pixelRatio = pixelRatio;\n    this.setSize(this.width, this.height);\n  }\n  updateBefore({\n    renderer\n  }) {\n    if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;\n    this.textureNeedsUpdate = false;\n\n    //\n\n    if (this.autoSize === true) {\n      this.pixelRatio = renderer.getPixelRatio();\n      const size = renderer.getSize(_size$1);\n      this.setSize(size.width, size.height);\n    }\n\n    //\n\n    this._quadMesh.material.fragmentNode = this._rttNode;\n\n    //\n\n    const currentRenderTarget = renderer.getRenderTarget();\n    renderer.setRenderTarget(this.renderTarget);\n    this._quadMesh.render(renderer);\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n  clone() {\n    const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);\n    newNode.sampler = this.sampler;\n    newNode.referenceNode = this;\n    return newNode;\n  }\n}\n\n/**\n * TSL function for creating a RTT node.\n *\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {Number?} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nconst rtt = (node, ...params) => nodeObject(new RTTNode(nodeObject(node), ...params));\n\n/**\n * TSL function for converting nodes to textures nodes.\n *\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {Number?} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nconst convertToTexture = (node, ...params) => {\n  if (node.isTextureNode) return node;\n  if (node.isPassNode) return node.getTextureNode();\n  return rtt(node, ...params);\n};\n\n/** @module PostProcessingUtils **/\n\n/**\n * Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments\n * depth value and the camera's inverse projection matrix.\n *\n * @method\n * @param {Node<vec2>} screenPosition - The fragment's screen position expressed as uv coordinates.\n * @param {Node<float>} depth - The fragment's depth value.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The fragments position in view space.\n */\nconst getViewPosition = /*@__PURE__*/Fn(([screenPosition, depth, projectionMatrixInverse], builder) => {\n  let clipSpacePosition;\n  if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {\n    screenPosition = vec2(screenPosition.x, screenPosition.y.oneMinus()).mul(2.0).sub(1.0);\n    clipSpacePosition = vec4(vec3(screenPosition, depth), 1.0);\n  } else {\n    clipSpacePosition = vec4(vec3(screenPosition.x, screenPosition.y.oneMinus(), depth).mul(2.0).sub(1.0), 1.0);\n  }\n  const viewSpacePosition = vec4(projectionMatrixInverse.mul(clipSpacePosition));\n  return viewSpacePosition.xyz.div(viewSpacePosition.w);\n});\n\n/**\n * Computes a screen position expressed as uv coordinates based on a fragment's position in view space\n * and the camera's projection matrix\n *\n * @method\n * @param {Node<vec3>} viewPosition - The fragments position in view space.\n * @param {Node<mat4>} projectionMatrix - The camera's projection matrix.\n * @return {Node<vec2>} The fragment's screen position expressed as uv coordinates.\n */\nconst getScreenPosition = /*@__PURE__*/Fn(([viewPosition, projectionMatrix]) => {\n  const sampleClipPos = projectionMatrix.mul(vec4(viewPosition, 1.0));\n  const sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(0.5).add(0.5).toVar();\n  return vec2(sampleUv.x, sampleUv.y.oneMinus());\n});\n\n/**\n * Computes a normal vector based on depth data. Can be used as a fallback when no normal render\n * target is available or if flat surface normals are required.\n *\n * @method\n * @param {Node<vec2>} uv - The texture coordinate.\n * @param {DepthTexture} depthTexture - The depth texture.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The computed normal vector.\n */\nconst getNormalFromDepth = /*@__PURE__*/Fn(([uv, depthTexture, projectionMatrixInverse]) => {\n  const size = textureSize(textureLoad(depthTexture));\n  const p = ivec2(uv.mul(size)).toVar();\n  const c0 = textureLoad(depthTexture, p).toVar();\n  const l2 = textureLoad(depthTexture, p.sub(ivec2(2, 0))).toVar();\n  const l1 = textureLoad(depthTexture, p.sub(ivec2(1, 0))).toVar();\n  const r1 = textureLoad(depthTexture, p.add(ivec2(1, 0))).toVar();\n  const r2 = textureLoad(depthTexture, p.add(ivec2(2, 0))).toVar();\n  const b2 = textureLoad(depthTexture, p.add(ivec2(0, 2))).toVar();\n  const b1 = textureLoad(depthTexture, p.add(ivec2(0, 1))).toVar();\n  const t1 = textureLoad(depthTexture, p.sub(ivec2(0, 1))).toVar();\n  const t2 = textureLoad(depthTexture, p.sub(ivec2(0, 2))).toVar();\n  const dl = abs(sub(float(2).mul(l1).sub(l2), c0)).toVar();\n  const dr = abs(sub(float(2).mul(r1).sub(r2), c0)).toVar();\n  const db = abs(sub(float(2).mul(b1).sub(b2), c0)).toVar();\n  const dt = abs(sub(float(2).mul(t1).sub(t2), c0)).toVar();\n  const ce = getViewPosition(uv, c0, projectionMatrixInverse).toVar();\n  const dpdx = dl.lessThan(dr).select(ce.sub(getViewPosition(uv.sub(vec2(float(1).div(size.x), 0)), l1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.add(vec2(float(1).div(size.x), 0)), r1, projectionMatrixInverse)));\n  const dpdy = db.lessThan(dt).select(ce.sub(getViewPosition(uv.add(vec2(0, float(1).div(size.y))), b1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.sub(vec2(0, float(1).div(size.y))), t1, projectionMatrixInverse)));\n  return normalize(cross(dpdx, dpdy));\n});\n\n/**\n * This special type of instanced buffer attribute is intended for compute shaders.\n * In earlier three.js versions it was only possible to update attribute data\n * on the CPU via JavaScript and then upload the data to the GPU. With the\n * new material system and renderer it is now possible to use compute shaders\n * to compute the data for an attribute more efficiently on the GPU.\n *\n * The idea is to create an instance of this class and provide it as an input\n * to {@link module:StorageBufferNode}.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`.\n *\n * @augments InstancedBufferAttribute\n */\nclass StorageInstancedBufferAttribute extends InstancedBufferAttribute {\n  /**\n   * Constructs a new storage instanced buffer attribute.\n   *\n   * @param {Number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.\n   * The subsequent parameters are then obsolete.\n   * @param {Number} itemSize - The item size.\n   * @param {TypedArray.contructor} [typeClass=Float32Array] - A typed array constructor.\n   */\n  constructor(count, itemSize, typeClass = Float32Array) {\n    const array = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);\n    super(array, itemSize);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isStorageInstancedBufferAttribute = true;\n  }\n}\n\n/**\n * This special type of buffer attribute is intended for compute shaders.\n * In earlier three.js versions it was only possible to update attribute data\n * on the CPU via JavaScript and then upload the data to the GPU. With the\n * new material system and renderer it is now possible to use compute shaders\n * to compute the data for an attribute more efficiently on the GPU.\n *\n * The idea is to create an instance of this class and provide it as an input\n * to {@link module:StorageBufferNode}.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`.\n *\n * @augments BufferAttribute\n */\nclass StorageBufferAttribute extends BufferAttribute {\n  /**\n   * Constructs a new storage buffer attribute.\n   *\n   * @param {Number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.\n   * The subsequent parameters are then obsolete.\n   * @param {Number} itemSize - The item size.\n   * @param {TypedArray.contructor} [typeClass=Float32Array] - A typed array constructor.\n   */\n  constructor(count, itemSize, typeClass = Float32Array) {\n    const array = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);\n    super(array, itemSize);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isStorageBufferAttribute = true;\n  }\n}\n\n/** @module StorageArrayElementNode **/\n\n/**\n * This class enables element access on instances of {@link StorageBufferNode}.\n * In most cases, it is indirectly used when accessing elements with the\n * {@link StorageBufferNode#element} method.\n *\n * ```js\n * const position = positionStorage.element( instanceIndex );\n * ```\n *\n * @augments ArrayElementNode\n */\nclass StorageArrayElementNode extends ArrayElementNode {\n  static get type() {\n    return 'StorageArrayElementNode';\n  }\n\n  /**\n   * Constructs storage buffer element node.\n   *\n   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n   * @param {Node} indexNode - The index node that defines the element access.\n   */\n  constructor(storageBufferNode, indexNode) {\n    super(storageBufferNode, indexNode);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isStorageArrayElementNode = true;\n  }\n\n  /**\n   * The storage buffer node.\n   *\n   * @param {Node} value\n   * @type {StorageBufferNode}\n   */\n  set storageBufferNode(value) {\n    this.node = value;\n  }\n  get storageBufferNode() {\n    return this.node;\n  }\n  setup(builder) {\n    if (builder.isAvailable('storageBuffer') === false) {\n      if (this.node.isPBO === true) {\n        builder.setupPBO(this.node);\n      }\n    }\n    return super.setup(builder);\n  }\n  generate(builder, output) {\n    let snippet;\n    const isAssignContext = builder.context.assign;\n\n    //\n\n    if (builder.isAvailable('storageBuffer') === false) {\n      if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute')) {\n        snippet = builder.generatePBO(this);\n      } else {\n        snippet = this.node.build(builder);\n      }\n    } else {\n      snippet = super.generate(builder);\n    }\n    if (isAssignContext !== true) {\n      const type = this.getNodeType(builder);\n      snippet = builder.format(snippet, type, output);\n    }\n    return snippet;\n  }\n}\n\n/**\n * TSL function for creating a storage element node.\n *\n * @function\n * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n * @param {Node} indexNode - The index node that defines the element access.\n * @returns {StorageArrayElementNode}\n */\nconst storageElement = /*@__PURE__*/nodeProxy(StorageArrayElementNode);\n\n/** @module StorageBufferNode **/\n\n/**\n * This node is used in context of compute shaders and allows to define a\n * storage buffer for data. A typical workflow is to create instances of\n * this node with the convenience functions `attributeArray()` or `instancedArray()`,\n * setup up a compute shader that writes into the buffers and then convert\n * the storage buffers to attribute nodes for rendering.\n *\n * ```js\n * const positionBuffer = instancedArray( particleCount, 'vec3' ); // the storage buffer node\n *\n * const computeInit = Fn( () => { // the compute shader\n *\n * \tconst position = positionBuffer.element( instanceIndex );\n *\n * \t// compute position data\n *\n * \tposition.x = 1;\n * \tposition.y = 1;\n * \tposition.z = 1;\n *\n * } )().compute( particleCount );\n *\n * const particleMaterial = new THREE.SpriteNodeMaterial();\n * particleMaterial.positionNode = positionBuffer.toAttribute();\n *\n * renderer.computeAsync( computeInit );\n *\n * ```\n *\n * @augments BufferNode\n */\nclass StorageBufferNode extends BufferNode {\n  static get type() {\n    return 'StorageBufferNode';\n  }\n\n  /**\n   * Constructs a new storage buffer node.\n   *\n   * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n   * @param {String?} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n   * @param {Number} [bufferCount=0] - The buffer count.\n   */\n  constructor(value, bufferType = null, bufferCount = 0) {\n    if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {\n      bufferType = getTypeFromLength(value.itemSize);\n      bufferCount = value.count;\n    }\n    super(value, bufferType, bufferCount);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isStorageBufferNode = true;\n\n    /**\n     * The access type of the texture node.\n     *\n     * @type {String}\n     * @default 'readWrite'\n     */\n    this.access = NodeAccess.READ_WRITE;\n\n    /**\n     * Whether the node is atomic or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.isAtomic = false;\n\n    /**\n     * Whether the node represents a PBO or not.\n     * Only relevant for WebGL.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.isPBO = false;\n\n    /**\n     * A reference to the internal buffer attribute node.\n     *\n     * @type {BufferAttributeNode?}\n     * @default null\n     */\n    this._attribute = null;\n\n    /**\n     * A reference to the internal varying node.\n     *\n     * @type {VaryingNode?}\n     * @default null\n     */\n    this._varying = null;\n\n    /**\n     * `StorageBufferNode` sets this property to `true` by default.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.global = true;\n    if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {\n      // TODO: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer\n\n      if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;else value.isStorageBufferAttribute = true;\n    }\n  }\n\n  /**\n   * This method is overwritten since the buffer data might be shared\n   * and thus the hash should be shared as well.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The hash.\n   */\n  getHash(builder) {\n    if (this.bufferCount === 0) {\n      let bufferData = builder.globalCache.getData(this.value);\n      if (bufferData === undefined) {\n        bufferData = {\n          node: this\n        };\n        builder.globalCache.setData(this.value, bufferData);\n      }\n      return bufferData.node.uuid;\n    }\n    return this.uuid;\n  }\n\n  /**\n   * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(/*builder*/\n  ) {\n    return this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';\n  }\n\n  /**\n   * Enables element access with the given index node.\n   *\n   * @param {IndexNode} indexNode - The index node.\n   * @return {StorageArrayElementNode} A node representing the element access.\n   */\n  element(indexNode) {\n    return storageElement(this, indexNode);\n  }\n\n  /**\n   * Defines whether this node is a PBO or not. Only relevant for WebGL.\n   *\n   * @param {Boolean} value - The value so set.\n   * @return {StorageBufferNode} A reference to this node.\n   */\n  setPBO(value) {\n    this.isPBO = value;\n    return this;\n  }\n\n  /**\n   * Returns the `isPBO` value.\n   *\n   * @return {Boolean} Whether the node represents a PBO or not.\n   */\n  getPBO() {\n    return this.isPBO;\n  }\n\n  /**\n   * Defines the node access.\n   *\n   * @param {String} value - The node access.\n   * @return {StorageBufferNode} A reference to this node.\n   */\n  setAccess(value) {\n    this.access = value;\n    return this;\n  }\n\n  /**\n   * Convenience method for configuring a read-only node access.\n   *\n   * @return {StorageBufferNode} A reference to this node.\n   */\n  toReadOnly() {\n    return this.setAccess(NodeAccess.READ_ONLY);\n  }\n\n  /**\n   * Defines whether the node is atomic or not.\n   *\n   * @param {Boolean} value - The atomic flag.\n   * @return {StorageBufferNode} A reference to this node.\n   */\n  setAtomic(value) {\n    this.isAtomic = value;\n    return this;\n  }\n\n  /**\n   * Convenience method for making this node atomic.\n   *\n   * @return {StorageBufferNode} A reference to this node.\n   */\n  toAtomic() {\n    return this.setAtomic(true);\n  }\n\n  /**\n   * Returns attribute data for this storage buffer node.\n   *\n   * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.\n   */\n  getAttributeData() {\n    if (this._attribute === null) {\n      this._attribute = bufferAttribute(this.value);\n      this._varying = varying(this._attribute);\n    }\n    return {\n      attribute: this._attribute,\n      varying: this._varying\n    };\n  }\n\n  /**\n   * This method is overwritten since the node type from the availability of storage buffers\n   * and the attribute data.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {\n      return super.getNodeType(builder);\n    }\n    const {\n      attribute\n    } = this.getAttributeData();\n    return attribute.getNodeType(builder);\n  }\n\n  /**\n   * Generates the code snippet of the storage buffer node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The generated code snippet.\n   */\n  generate(builder) {\n    if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {\n      return super.generate(builder);\n    }\n    const {\n      attribute,\n      varying\n    } = this.getAttributeData();\n    const output = varying.build(builder);\n    builder.registerTransform(output, attribute);\n    return output;\n  }\n}\n\n/**\n * TSL function for creating a storage buffer node.\n *\n * @function\n * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [count=0] - The buffer count.\n * @returns {StorageBufferNode}\n */\nconst storage = (value, type = null, count = 0) => nodeObject(new StorageBufferNode(value, type, count));\nconst storageObject = (value, type, count) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.');\n  return storage(value, type, count).setPBO(true);\n};\n\n/** @module Arrays **/\n\n/**\n * TSL function for creating a storage buffer node with a configured `StorageBufferAttribute`.\n *\n * @function\n * @param {Number} count - The data count.\n * @param {String} [type='float'] - The data type.\n * @returns {StorageBufferNode}\n */\nconst attributeArray = (count, type = 'float') => {\n  const itemSize = getLengthFromType(type);\n  const typedArray = getTypedArrayFromType(type);\n  const buffer = new StorageBufferAttribute(count, itemSize, typedArray);\n  const node = storage(buffer, type, count);\n  return node;\n};\n\n/**\n * TSL function for creating a storage buffer node with a configured `StorageInstancedBufferAttribute`.\n *\n * @function\n * @param {Number} count - The data count.\n * @param {String} [type='float'] - The data type.\n * @returns {StorageBufferNode}\n */\nconst instancedArray = (count, type = 'float') => {\n  const itemSize = getLengthFromType(type);\n  const typedArray = getTypedArrayFromType(type);\n  const buffer = new StorageInstancedBufferAttribute(count, itemSize, typedArray);\n  const node = storage(buffer, type, count);\n  return node;\n};\n\n/** @module VertexColorNode **/\n\n/**\n * An attribute node for representing vertex colors.\n *\n * @augments module:AttributeNode~AttributeNode\n */\nclass VertexColorNode extends AttributeNode {\n  static get type() {\n    return 'VertexColorNode';\n  }\n\n  /**\n   * Constructs a new vertex color node.\n   *\n   * @param {Number} [index=0] - The attribute index.\n   */\n  constructor(index = 0) {\n    super(null, 'vec4');\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isVertexColorNode = true;\n\n    /**\n     * The attribute index to enable more than one sets of vertex colors.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.index = index;\n  }\n\n  /**\n   * Overwrites the default implementation by honoring the attribute index.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The attribute name.\n   */\n  getAttributeName(/*builder*/\n  ) {\n    const index = this.index;\n    return 'color' + (index > 0 ? index : '');\n  }\n  generate(builder) {\n    const attributeName = this.getAttributeName(builder);\n    const geometryAttribute = builder.hasGeometryAttribute(attributeName);\n    let result;\n    if (geometryAttribute === true) {\n      result = super.generate(builder);\n    } else {\n      // Vertex color fallback should be white\n      result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));\n    }\n    return result;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.index = this.index;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.index = data.index;\n  }\n}\n\n/**\n * TSL function for creating a reference node.\n *\n * @function\n * @param {Number} index - The attribute index.\n * @returns {VertexColorNode}\n */\nconst vertexColor = index => nodeObject(new VertexColorNode(index));\n\n/** @module PointUVNode **/\n\n/**\n * A node for representing the uv coordinates of points.\n *\n * Can only be used with a WebGL backend. In WebGPU, point\n * primitives always have the size of one pixel and can thus\n * can't be used as sprite-like objects that display textures.\n *\n * @augments Node\n */\nclass PointUVNode extends Node {\n  static get type() {\n    return 'PointUVNode';\n  }\n\n  /**\n   * Constructs a new point uv node.\n   */\n  constructor() {\n    super('vec2');\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isPointUVNode = true;\n  }\n  generate(/*builder*/\n  ) {\n    return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n  }\n}\n\n/**\n * TSL object that represents the uv coordinates of points.\n *\n * @type {PointUVNode}\n */\nconst pointUV = /*@__PURE__*/nodeImmutable(PointUVNode);\nconst _e1 = /*@__PURE__*/new Euler();\nconst _m1 = /*@__PURE__*/new Matrix4();\n\n/** @module SceneNode **/\n\n/**\n * This module allows access to a collection of scene properties. The following predefined TSL objects\n * are available for easier use:\n *\n * - `backgroundBlurriness`: A node that represents the scene's background blurriness.\n * - `backgroundIntensity`: A node that represents the scene's background intensity.\n * - `backgroundRotation`: A node that represents the scene's background rotation.\n *\n * @augments Node\n */\nclass SceneNode extends Node {\n  static get type() {\n    return 'SceneNode';\n  }\n\n  /**\n   * Constructs a new scene node.\n   *\n   * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.\n   * @param {Scene?} [scene=null] - A reference to the scene.\n   */\n  constructor(scope = SceneNode.BACKGROUND_BLURRINESS, scene = null) {\n    super();\n\n    /**\n     * The scope defines the type of scene property that is accessed.\n     *\n     * @type {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')}\n     */\n    this.scope = scope;\n\n    /**\n     * A reference to the scene that is going to be accessed.\n     *\n     * @type {Scene?}\n     * @default null\n     */\n    this.scene = scene;\n  }\n\n  /**\n   * Depending on the scope, the method returns a different type of node that represents\n   * the respective scene property.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Node} The output node.\n   */\n  setup(builder) {\n    const scope = this.scope;\n    const scene = this.scene !== null ? this.scene : builder.scene;\n    let output;\n    if (scope === SceneNode.BACKGROUND_BLURRINESS) {\n      output = reference('backgroundBlurriness', 'float', scene);\n    } else if (scope === SceneNode.BACKGROUND_INTENSITY) {\n      output = reference('backgroundIntensity', 'float', scene);\n    } else if (scope === SceneNode.BACKGROUND_ROTATION) {\n      output = uniform('mat4').label('backgroundRotation').setGroup(renderGroup).onRenderUpdate(() => {\n        const background = scene.background;\n        if (background !== null && background.isTexture && background.mapping !== UVMapping) {\n          _e1.copy(scene.backgroundRotation);\n\n          // accommodate left-handed frame\n          _e1.x *= -1;\n          _e1.y *= -1;\n          _e1.z *= -1;\n          _m1.makeRotationFromEuler(_e1);\n        } else {\n          _m1.identity();\n        }\n        return _m1;\n      });\n    } else {\n      console.error('THREE.SceneNode: Unknown scope:', scope);\n    }\n    return output;\n  }\n}\nSceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';\nSceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';\nSceneNode.BACKGROUND_ROTATION = 'backgroundRotation';\n\n/**\n * TSL object that represents the scene's background blurriness.\n *\n * @type {SceneNode}\n */\nconst backgroundBlurriness = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);\n\n/**\n * TSL object that represents the scene's background intensity.\n *\n * @type {SceneNode}\n */\nconst backgroundIntensity = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);\n\n/**\n * TSL object that represents the scene's background rotation.\n *\n * @type {SceneNode}\n */\nconst backgroundRotation = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);\n\n/** @module StorageTextureNode **/\n\n/**\n * This special version of a texture node can be used to\n * write data into a storage texture with a compute shader.\n *\n * ```js\n * const storageTexture = new THREE.StorageTexture( width, height );\n *\n * const computeTexture = Fn( ( { storageTexture } ) => {\n *\n * \tconst posX = instanceIndex.modInt( width );\n * \tconst posY = instanceIndex.div( width );\n * \tconst indexUV = uvec2( posX, posY );\n *\n * \t// generate RGB values\n *\n * \tconst r = 1;\n * \tconst g = 1;\n * \tconst b = 1;\n *\n * \ttextureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();\n *\n * } );\n *\n * const computeNode = computeTexture( { storageTexture } ).compute( width * height );\n * renderer.computeAsync( computeNode );\n * ```\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass StorageTextureNode extends TextureNode {\n  static get type() {\n    return 'StorageTextureNode';\n  }\n\n  /**\n   * Constructs a new storage texture node.\n   *\n   * @param {StorageTexture} value - The storage texture.\n   * @param {Node<vec2|vec3>} uvNode - The uv node.\n   * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.\n   */\n  constructor(value, uvNode, storeNode = null) {\n    super(value, uvNode);\n\n    /**\n     * The value node that should be stored in the texture.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.storeNode = storeNode;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isStorageTextureNode = true;\n\n    /**\n     * The access type of the texture node.\n     *\n     * @type {String}\n     * @default 'writeOnly'\n     */\n    this.access = NodeAccess.WRITE_ONLY;\n  }\n\n  /**\n   * Overwrites the default implementation to return a fixed value `'storageTexture'`.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(/*builder*/\n  ) {\n    return 'storageTexture';\n  }\n  setup(builder) {\n    super.setup(builder);\n    const properties = builder.getNodeProperties(this);\n    properties.storeNode = this.storeNode;\n  }\n\n  /**\n   * Defines the node access.\n   *\n   * @param {String} value - The node access.\n   * @return {StorageTextureNode} A reference to this node.\n   */\n  setAccess(value) {\n    this.access = value;\n    return this;\n  }\n\n  /**\n   * Generates the code snippet of the stroge node. If no `storeNode`\n   * is defined, the texture node is generated as normal texture.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @param {String} output - The current output.\n   * @return {String} The generated code snippet.\n   */\n  generate(builder, output) {\n    let snippet;\n    if (this.storeNode !== null) {\n      snippet = this.generateStore(builder);\n    } else {\n      snippet = super.generate(builder, output);\n    }\n    return snippet;\n  }\n\n  /**\n   * Convenience method for configuring a read/write node access.\n   *\n   * @return {StorageTextureNode} A reference to this node.\n   */\n  toReadWrite() {\n    return this.setAccess(NodeAccess.READ_WRITE);\n  }\n\n  /**\n   * Convenience method for configuring a read-only node access.\n   *\n   * @return {StorageTextureNode} A reference to this node.\n   */\n  toReadOnly() {\n    return this.setAccess(NodeAccess.READ_ONLY);\n  }\n\n  /**\n   * Convenience method for configuring a write-only node access.\n   *\n   * @return {StorageTextureNode} A reference to this node.\n   */\n  toWriteOnly() {\n    return this.setAccess(NodeAccess.WRITE_ONLY);\n  }\n\n  /**\n   * Generates the code snippet of the storage texture node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  generateStore(builder) {\n    const properties = builder.getNodeProperties(this);\n    const {\n      uvNode,\n      storeNode\n    } = properties;\n    const textureProperty = super.generate(builder, 'property');\n    const uvSnippet = uvNode.build(builder, 'uvec2');\n    const storeSnippet = storeNode.build(builder, 'vec4');\n    const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, storeSnippet);\n    builder.addLineFlowCode(snippet, this);\n  }\n}\n\n/**\n * TSL function for creating a storage texture node.\n *\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {Node<vec2|vec3>} uvNode - The uv node.\n * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nconst storageTexture = /*@__PURE__*/nodeProxy(StorageTextureNode);\n\n/**\n * TODO: Explain difference to `storageTexture()`.\n *\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {Node<vec2|vec3>} uvNode - The uv node.\n * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nconst textureStore = (value, uvNode, storeNode) => {\n  const node = storageTexture(value, uvNode, storeNode);\n  if (storeNode !== null) node.append();\n  return node;\n};\n\n/** @module UserDataNode **/\n\n/**\n * A special type of reference node that allows to link values in\n * `userData` fields to node objects.\n * ```js\n * sprite.userData.rotation = 1; // stores individual rotation per sprite\n *\n * const material = new THREE.SpriteNodeMaterial();\n * material.rotationNode = userData( 'rotation', 'float' );\n * ```\n * Since `UserDataNode` is extended from {@link module:ReferenceNode~ReferenceNode}, the node value\n * will automatically be updated when the `rotation` user data field changes.\n *\n * @augments module:ReferenceNode~ReferenceNode\n */\nclass UserDataNode extends ReferenceNode {\n  static get type() {\n    return 'UserDataNode';\n  }\n\n  /**\n   * Constructs a new user data node.\n   *\n   * @param {String} property - The property name that should be referenced by the node.\n   * @param {String} inputType - The node data type of the reference.\n   * @param {Object?} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.\n   */\n  constructor(property, inputType, userData = null) {\n    super(property, inputType, userData);\n\n    /**\n     * A reference to the `userData` object. If not provided, the `userData`\n     * property of the 3D object that uses the node material is evaluated.\n     *\n     * @type {Object?}\n     * @default null\n     */\n    this.userData = userData;\n  }\n\n  /**\n   * Overwritten to make sure {@link module:ReferenceNode~ReferenceNode#reference} points to the correct\n   * `userData` field.\n   *\n   * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.\n   * @return {Object} A reference to the `userData` field.\n   */\n  updateReference(state) {\n    this.reference = this.userData !== null ? this.userData : state.object.userData;\n    return this.reference;\n  }\n}\n\n/**\n * TSL function for creating a user data node.\n *\n * @function\n * @param {String} name - The property name that should be referenced by the node.\n * @param {String} inputType - The node data type of the reference.\n * @param {Object?} userData - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.\n * @returns {UserDataNode}\n */\nconst userData = (name, inputType, userData) => nodeObject(new UserDataNode(name, inputType, userData));\nconst _objectData = new WeakMap();\n\n/** @module VelocityNode **/\n\n/**\n * A node for representing motion or velocity vectors. Foundation\n * for advanced post processing effects like motion blur or TRAA.\n *\n * The node keeps track of the model, view and projection matrices\n * of the previous frame and uses them to compute offsets in NDC space.\n * These offsets represent the final velocity.\n *\n * @augments TempNode\n */\nclass VelocityNode extends TempNode {\n  static get type() {\n    return 'VelocityNode';\n  }\n\n  /**\n   * Constructs a new vertex color node.\n   *\n   * @param {Number} [index=0] - The attribute index.\n   */\n  constructor() {\n    super('vec2');\n\n    /**\n     * The current projection matrix.\n     *\n     * @type {Matrix4?}\n     * @default null\n     */\n    this.projectionMatrix = null;\n\n    /**\n     * Overwritten since velocity nodes are updated per object.\n     *\n     * @type {String}\n     * @default 'object'\n     */\n    this.updateType = NodeUpdateType.OBJECT;\n\n    /**\n     * Overwritten since velocity nodes save data after the update.\n     *\n     * @type {String}\n     * @default 'object'\n     */\n    this.updateAfterType = NodeUpdateType.OBJECT;\n\n    /**\n     * Uniform node representing the previous model matrix in world space.\n     *\n     * @type {UniformNode<mat4>}\n     * @default null\n     */\n    this.previousModelWorldMatrix = uniform(new Matrix4());\n\n    /**\n     * Uniform node representing the previous projection matrix.\n     *\n     * @type {UniformNode<mat4>}\n     * @default null\n     */\n    this.previousProjectionMatrix = uniform(new Matrix4()).setGroup(renderGroup);\n\n    /**\n     * Uniform node representing the previous view matrix.\n     *\n     * @type {UniformNode<mat4>}\n     * @default null\n     */\n    this.previousCameraViewMatrix = uniform(new Matrix4());\n  }\n\n  /**\n   * Sets the given projection matrix.\n   *\n   * @param {Matrix4} projectionMatrix - The projection matrix to set.\n   */\n  setProjectionMatrix(projectionMatrix) {\n    this.projectionMatrix = projectionMatrix;\n  }\n\n  /**\n   * Updates velocity specific uniforms.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update({\n    frameId,\n    camera,\n    object\n  }) {\n    const previousModelMatrix = getPreviousMatrix(object);\n    this.previousModelWorldMatrix.value.copy(previousModelMatrix);\n\n    //\n\n    const cameraData = getData(camera);\n    if (cameraData.frameId !== frameId) {\n      cameraData.frameId = frameId;\n      if (cameraData.previousProjectionMatrix === undefined) {\n        cameraData.previousProjectionMatrix = new Matrix4();\n        cameraData.previousCameraViewMatrix = new Matrix4();\n        cameraData.currentProjectionMatrix = new Matrix4();\n        cameraData.currentCameraViewMatrix = new Matrix4();\n        cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);\n        cameraData.previousCameraViewMatrix.copy(camera.matrixWorldInverse);\n      } else {\n        cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);\n        cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);\n      }\n      cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);\n      cameraData.currentCameraViewMatrix.copy(camera.matrixWorldInverse);\n      this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);\n      this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);\n    }\n  }\n\n  /**\n   * Overwritten to updated velocity specific uniforms.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  updateAfter({\n    object\n  }) {\n    getPreviousMatrix(object).copy(object.matrixWorld);\n  }\n\n  /**\n   * Implements the velocity computation based on the previous and current vertex data.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @return {Node<vec2>} The motion vector.\n   */\n  setup(/*builder*/\n  ) {\n    const projectionMatrix = this.projectionMatrix === null ? cameraProjectionMatrix : uniform(this.projectionMatrix);\n    const previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);\n    const clipPositionCurrent = projectionMatrix.mul(modelViewMatrix).mul(positionLocal);\n    const clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious);\n    const ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);\n    const ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);\n    const velocity = sub(ndcPositionCurrent, ndcPositionPrevious);\n    return velocity;\n  }\n}\nfunction getData(object) {\n  let objectData = _objectData.get(object);\n  if (objectData === undefined) {\n    objectData = {};\n    _objectData.set(object, objectData);\n  }\n  return objectData;\n}\nfunction getPreviousMatrix(object, index = 0) {\n  const objectData = getData(object);\n  let matrix = objectData[index];\n  if (matrix === undefined) {\n    objectData[index] = matrix = new Matrix4();\n  }\n  return matrix;\n}\n\n/**\n * TSL object that represents the velocity of a render pass.\n *\n * @type {VelocityNode}\n */\nconst velocity = /*@__PURE__*/nodeImmutable(VelocityNode);\nconst blendBurn = /*@__PURE__*/Fn(([base, blend]) => {\n  return min$1(1.0, base.oneMinus().div(blend)).oneMinus();\n}).setLayout({\n  name: 'blendBurn',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendDodge = /*@__PURE__*/Fn(([base, blend]) => {\n  return min$1(base.div(blend.oneMinus()), 1.0);\n}).setLayout({\n  name: 'blendDodge',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendScreen = /*@__PURE__*/Fn(([base, blend]) => {\n  return base.oneMinus().mul(blend.oneMinus()).oneMinus();\n}).setLayout({\n  name: 'blendScreen',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendOverlay = /*@__PURE__*/Fn(([base, blend]) => {\n  return mix(base.mul(2.0).mul(blend), base.oneMinus().mul(2.0).mul(blend.oneMinus()).oneMinus(), step(0.5, base));\n}).setLayout({\n  name: 'blendOverlay',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendColor = /*@__PURE__*/Fn(([base, blend]) => {\n  const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));\n  return vec4(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);\n}).setLayout({\n  name: 'blendColor',\n  type: 'vec4',\n  inputs: [{\n    name: 'base',\n    type: 'vec4'\n  }, {\n    name: 'blend',\n    type: 'vec4'\n  }]\n});\n\n// deprecated\n\nconst burn = (...params) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"burn\" has been renamed. Use \"blendBurn\" instead.');\n  return blendBurn(params);\n};\nconst dodge = (...params) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"dodge\" has been renamed. Use \"blendDodge\" instead.');\n  return blendDodge(params);\n};\nconst screen = (...params) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"screen\" has been renamed. Use \"blendScreen\" instead.');\n  return blendScreen(params);\n};\nconst overlay = (...params) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"overlay\" has been renamed. Use \"blendOverlay\" instead.');\n  return blendOverlay(params);\n};\n\n/** @module ColorAdjustment **/\n\n/**\n * Computes a grayscale value for the given RGB color value.\n *\n * @method\n * @param {Node<vec3>} color - The color value to compute the grayscale for.\n * @return {Node<vec3>} The grayscale color.\n */\nconst grayscale = /*@__PURE__*/Fn(([color]) => {\n  return luminance(color.rgb);\n});\n\n/**\n * Super-saturates or desaturates the given RGB color.\n *\n * @method\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Specifies the amount of the conversion. A value under `1` desaturates the color, a value over `1` super-saturates it.\n * @return {Node<vec3>} The saturated color.\n */\nconst saturation = /*@__PURE__*/Fn(([color, adjustment = float(1)]) => {\n  return adjustment.mix(luminance(color.rgb), color.rgb);\n});\n\n/**\n * Selectively enhance the intensity of less saturated RGB colors. Can result\n * in a more natural and visually appealing image with enhanced color depth\n * compared to {@link ColorAdjustment#saturation}.\n *\n * @method\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Controls the intensity of the vibrance effect.\n * @return {Node<vec3>} The updated color.\n */\nconst vibrance = /*@__PURE__*/Fn(([color, adjustment = float(1)]) => {\n  const average = add(color.r, color.g, color.b).div(3.0);\n  const mx = color.r.max(color.g.max(color.b));\n  const amt = mx.sub(average).mul(adjustment).mul(-3.0);\n  return mix(color.rgb, mx, amt);\n});\n\n/**\n * Updates the hue component of the given RGB color while preserving its luminance and saturation.\n *\n * @method\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Defines the degree of hue rotation in radians. A positive value rotates the hue clockwise, while a negative value rotates it counterclockwise.\n * @return {Node<vec3>} The updated color.\n */\nconst hue = /*@__PURE__*/Fn(([color, adjustment = float(1)]) => {\n  const k = vec3(0.57735, 0.57735, 0.57735);\n  const cosAngle = adjustment.cos();\n  return vec3(color.rgb.mul(cosAngle).add(k.cross(color.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color.rgb).mul(cosAngle.oneMinus())))));\n});\n\n/**\n * Computes the luminance for the given RGB color value.\n *\n * @method\n * @param {Node<vec3>} color - The color value to compute the luminance for.\n * @param {Node<vec3>?} luminanceCoefficients - The luminance coefficients. By default predefined values of the current working color space are used.\n * @return {Node<vec3>} The luminance.\n */\nconst luminance = (color, luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3()))) => dot(color, luminanceCoefficients);\n\n/**\n * Color Decision List (CDL) v1.2\n *\n * Compact representation of color grading information, defined by slope, offset, power, and\n * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,\n * or AgX Log), and will return output in the same space. Output may require clamping >=0.\n *\n * @method\n * @param {Node<vec4>} color Input (-Infinity < input < +Infinity)\n * @param {Node<vec3>} slope Slope (0 \u2264 slope < +Infinity)\n * @param {Node<vec3>} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)\n * @param {Node<vec3>} power Power (0 < power < +Infinity)\n * @param {Node<float>} saturation Saturation (0 \u2264 saturation < +Infinity; typically 0 \u2264 saturation < 4)\n * @param {Node<vec3>} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709\n * @return {Node<vec4>} Output, -Infinity < output < +Infinity\n *\n * References:\n * - ASC CDL v1.2\n * - {@link https://blender.stackexchange.com/a/55239/43930}\n * - {@link https://docs.acescentral.com/specifications/acescc/}\n */\nconst cdl = /*@__PURE__*/Fn(([color, slope = vec3(1), offset = vec3(0), power = vec3(1), saturation = float(1),\n// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.\nluminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3(), LinearSRGBColorSpace))]) => {\n  // NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the\n  // saturation term. Per the ACEScc specification and Filament, limits may be omitted to support\n  // values outside [0, 1], requiring a workaround for negative values in the power expression.\n\n  const luma = color.rgb.dot(vec3(luminanceCoefficients));\n  const v = max$1(color.rgb.mul(slope).add(offset), 0.0).toVar();\n  const pv = v.pow(power).toVar();\n  If(v.r.greaterThan(0.0), () => {\n    v.r.assign(pv.r);\n  }); // eslint-disable-line\n  If(v.g.greaterThan(0.0), () => {\n    v.g.assign(pv.g);\n  }); // eslint-disable-line\n  If(v.b.greaterThan(0.0), () => {\n    v.b.assign(pv.b);\n  }); // eslint-disable-line\n\n  v.assign(luma.add(v.sub(luma).mul(saturation)));\n  return vec4(v.rgb, color.a);\n});\n\n/** @module PosterizeNode **/\n\n/**\n * Represents a posterize effect which reduces the number of colors\n * in an image, resulting in a more blocky and stylized appearance.\n *\n * @augments TempNode\n */\nclass PosterizeNode extends TempNode {\n  static get type() {\n    return 'PosterizeNode';\n  }\n\n  /**\n   * Constructs a new posterize node.\n   *\n   * @param {Node} sourceNode - The input color.\n   * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n   */\n  constructor(sourceNode, stepsNode) {\n    super();\n\n    /**\n     * The input color.\n     *\n     * @type {Node}\n     */\n    this.sourceNode = sourceNode;\n\n    /**\n     * Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n     *\n     * @type {Node}\n     */\n    this.stepsNode = stepsNode;\n  }\n  setup() {\n    const {\n      sourceNode,\n      stepsNode\n    } = this;\n    return sourceNode.mul(stepsNode).floor().div(stepsNode);\n  }\n}\n\n/**\n * TSL function for creating a posterize node.\n *\n * @function\n * @param {Node} sourceNode - The input color.\n * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n * @returns {PosterizeNode}\n */\nconst posterize = /*@__PURE__*/nodeProxy(PosterizeNode);\n\n/** @module PassNode **/\n\nconst _size = /*@__PURE__*/new Vector2();\n\n/**\n * Represents the texture of a pass node.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass PassTextureNode extends TextureNode {\n  static get type() {\n    return 'PassTextureNode';\n  }\n\n  /**\n   * Constructs a new pass texture node.\n   *\n   * @param {PassNode} passNode - The pass node.\n   * @param {Texture} texture - The output texture.\n   */\n  constructor(passNode, texture) {\n    super(texture);\n\n    /**\n     * A reference to the pass node.\n     *\n     * @type {PassNode}\n     */\n    this.passNode = passNode;\n    this.setUpdateMatrix(false);\n  }\n  setup(builder) {\n    if (builder.object.isQuadMesh) this.passNode.build(builder);\n    return super.setup(builder);\n  }\n  clone() {\n    return new this.constructor(this.passNode, this.value);\n  }\n}\n\n/**\n * An extension of `PassTextureNode` which allows to manage more than one\n * internal texture. Relevant for the `getPreviousTexture()` related API.\n *\n * @augments module:PassTextureNode~PassTextureNode\n */\nclass PassMultipleTextureNode extends PassTextureNode {\n  static get type() {\n    return 'PassMultipleTextureNode';\n  }\n\n  /**\n   * Constructs a new pass texture node.\n   *\n   * @param {PassNode} passNode - The pass node.\n   * @param {String} textureName - The output texture name.\n   * @param {Boolean} [previousTexture=false] - Whether previous frame data should be used or not.\n   */\n  constructor(passNode, textureName, previousTexture = false) {\n    // null is passed to the super call since this class does not\n    // use an external texture for rendering pass data into. Instead\n    // the texture is managed by the pass node itself\n\n    super(passNode, null);\n\n    /**\n     * The output texture name.\n     *\n     * @type {String}\n     */\n    this.textureName = textureName;\n\n    /**\n     * Whether previous frame data should be used or not.\n     *\n     * @type {Boolean}\n     */\n    this.previousTexture = previousTexture;\n  }\n\n  /**\n   * Updates the texture reference of this node.\n   */\n  updateTexture() {\n    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);\n  }\n  setup(builder) {\n    this.updateTexture();\n    return super.setup(builder);\n  }\n  clone() {\n    return new this.constructor(this.passNode, this.textureName, this.previousTexture);\n  }\n}\n\n/**\n * Represents a render pass (sometimes called beauty pass) in context of post processing.\n * This pass produces a render for the given scene and camera and can provide multiple outputs\n * via MRT for further processing.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n *\n * @augments TempNode\n */\nclass PassNode extends TempNode {\n  static get type() {\n    return 'PassNode';\n  }\n\n  /**\n   * Constructs a new pass node.\n   *\n   * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.\n   * @param {Scene} scene - A reference to the scene.\n   * @param {Camera} camera - A reference to the camera.\n   * @param {Object} options - Options for the internal render target.\n   */\n  constructor(scope, scene, camera, options = {}) {\n    super('vec4');\n\n    /**\n     * The scope of the pass. The scope determines whether the node outputs color or depth.\n     *\n     * @type {('color'|'depth')}\n     */\n    this.scope = scope;\n\n    /**\n     * A reference to the scene.\n     *\n     * @type {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * A reference to the camera.\n     *\n     * @type {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Options for the internal render target.\n     *\n     * @type {Object}\n     */\n    this.options = options;\n\n    /**\n     * The pass's pixel ratio. Will be kept automatically kept in sync with the renderer's pixel ratio.\n     *\n     * @private\n     * @type {Number}\n     * @default 1\n     */\n    this._pixelRatio = 1;\n\n    /**\n     * The pass's pixel width. Will be kept automatically kept in sync with the renderer's width.\n     * @private\n     * @type {Number}\n     * @default 1\n     */\n    this._width = 1;\n\n    /**\n     * The pass's pixel height. Will be kept automatically kept in sync with the renderer's height.\n     * @private\n     * @type {Number}\n     * @default 1\n     */\n    this._height = 1;\n    const depthTexture = new DepthTexture();\n    depthTexture.isRenderTargetTexture = true;\n    //depthTexture.type = FloatType;\n    depthTexture.name = 'depth';\n    const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, {\n      type: HalfFloatType,\n      ...options\n    });\n    renderTarget.texture.name = 'output';\n    renderTarget.depthTexture = depthTexture;\n\n    /**\n     * The pass's render target.\n     *\n     * @type {RenderTarget}\n     */\n    this.renderTarget = renderTarget;\n\n    /**\n     * A dictionary holding the internal result textures.\n     *\n     * @private\n     * @type {Object<String, Texture>}\n     */\n    this._textures = {\n      output: renderTarget.texture,\n      depth: depthTexture\n    };\n\n    /**\n     * A dictionary holding the internal texture nodes.\n     *\n     * @private\n     * @type {Object<String, TextureNode>}\n     */\n    this._textureNodes = {};\n\n    /**\n     * A dictionary holding the internal depth nodes.\n     *\n     * @private\n     * @type {Object}\n     */\n    this._linearDepthNodes = {};\n\n    /**\n     * A dictionary holding the internal viewZ nodes.\n     *\n     * @private\n     * @type {Object}\n     */\n    this._viewZNodes = {};\n\n    /**\n     * A dictionary holding the texture data of the previous frame.\n     * Used for computing velocity/motion vectors.\n     *\n     * @private\n     * @type {Object<String, Texture>}\n     */\n    this._previousTextures = {};\n\n    /**\n     * A dictionary holding the texture nodes of the previous frame.\n     * Used for computing velocity/motion vectors.\n     *\n     * @private\n     * @type {Object<String, TextureNode>}\n     */\n    this._previousTextureNodes = {};\n\n    /**\n     * The `near` property of the camera as a uniform.\n     *\n     * @private\n     * @type {UniformNode}\n     */\n    this._cameraNear = uniform(0);\n\n    /**\n     * The `far` property of the camera as a uniform.\n     *\n     * @private\n     * @type {UniformNode}\n     */\n    this._cameraFar = uniform(0);\n\n    /**\n     * A MRT node configuring the MRT settings.\n     *\n     * @private\n     * @type {MRTNode?}\n     * @default null\n     */\n    this._mrt = null;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isPassNode = true;\n\n    /**\n     * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the\n     * scene once per frame in its {@link PassNode#updateBefore} method.\n     *\n     * @type {String}\n     * @default 'frame'\n     */\n    this.updateBeforeType = NodeUpdateType.FRAME;\n  }\n\n  /**\n   * Sets the given MRT node to setup MRT for this pass.\n   *\n   * @param {MRTNode} mrt - The MRT object.\n   * @return {PassNode} A reference to this pass.\n   */\n  setMRT(mrt) {\n    this._mrt = mrt;\n    return this;\n  }\n\n  /**\n   * Returns the current MRT node.\n   *\n   * @return {MRTNode} The current MRT node.\n   */\n  getMRT() {\n    return this._mrt;\n  }\n\n  /**\n   * The method is overwritten so it always returns `true`.\n   *\n   * @return {Boolean} Whether this node is global or not.\n   */\n  isGlobal() {\n    return true;\n  }\n\n  /**\n   * Returns the texture for the given output name.\n   *\n   * @param {String} name - The output name to get the texture for.\n   * @return {Texture} The texture.\n   */\n  getTexture(name) {\n    let texture = this._textures[name];\n    if (texture === undefined) {\n      const refTexture = this.renderTarget.texture;\n      texture = refTexture.clone();\n      texture.name = name;\n      this._textures[name] = texture;\n      this.renderTarget.textures.push(texture);\n    }\n    return texture;\n  }\n\n  /**\n   * Returns the texture holding the data of the previous frame for the given output name.\n   *\n   * @param {String} name - The output name to get the texture for.\n   * @return {Texture} The texture holding the data of the previous frame.\n   */\n  getPreviousTexture(name) {\n    let texture = this._previousTextures[name];\n    if (texture === undefined) {\n      texture = this.getTexture(name).clone();\n      this._previousTextures[name] = texture;\n    }\n    return texture;\n  }\n\n  /**\n   * Switches current and previous textures for the given output name.\n   *\n   * @param {String} name - The output name.\n   */\n  toggleTexture(name) {\n    const prevTexture = this._previousTextures[name];\n    if (prevTexture !== undefined) {\n      const texture = this._textures[name];\n      const index = this.renderTarget.textures.indexOf(texture);\n      this.renderTarget.textures[index] = prevTexture;\n      this._textures[name] = prevTexture;\n      this._previousTextures[name] = texture;\n      this._textureNodes[name].updateTexture();\n      this._previousTextureNodes[name].updateTexture();\n    }\n  }\n\n  /**\n   * Returns the texture node for the given output name.\n   *\n   * @param {String} [name='output'] - The output name to get the texture node for.\n   * @return {TextureNode} The texture node.\n   */\n  getTextureNode(name = 'output') {\n    let textureNode = this._textureNodes[name];\n    if (textureNode === undefined) {\n      textureNode = nodeObject(new PassMultipleTextureNode(this, name));\n      textureNode.updateTexture();\n      this._textureNodes[name] = textureNode;\n    }\n    return textureNode;\n  }\n\n  /**\n   * Returns the previous texture node for the given output name.\n   *\n   * @param {String} [name='output'] - The output name to get the previous texture node for.\n   * @return {TextureNode} The previous texture node.\n   */\n  getPreviousTextureNode(name = 'output') {\n    let textureNode = this._previousTextureNodes[name];\n    if (textureNode === undefined) {\n      if (this._textureNodes[name] === undefined) this.getTextureNode(name);\n      textureNode = nodeObject(new PassMultipleTextureNode(this, name, true));\n      textureNode.updateTexture();\n      this._previousTextureNodes[name] = textureNode;\n    }\n    return textureNode;\n  }\n\n  /**\n   * Returns a viewZ node of this pass.\n   *\n   * @param {String} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n   * @return {Node} The viewZ node.\n   */\n  getViewZNode(name = 'depth') {\n    let viewZNode = this._viewZNodes[name];\n    if (viewZNode === undefined) {\n      const cameraNear = this._cameraNear;\n      const cameraFar = this._cameraFar;\n      this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(this.getTextureNode(name), cameraNear, cameraFar);\n    }\n    return viewZNode;\n  }\n\n  /**\n   * Returns a linear depth node of this pass.\n   *\n   * @param {String} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n   * @return {Node} The linear depth node.\n   */\n  getLinearDepthNode(name = 'depth') {\n    let linearDepthNode = this._linearDepthNodes[name];\n    if (linearDepthNode === undefined) {\n      const cameraNear = this._cameraNear;\n      const cameraFar = this._cameraFar;\n      const viewZNode = this.getViewZNode(name);\n\n      // TODO: just if ( builder.camera.isPerspectiveCamera )\n\n      this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(viewZNode, cameraNear, cameraFar);\n    }\n    return linearDepthNode;\n  }\n  setup({\n    renderer\n  }) {\n    this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;\n\n    // Disable MSAA for WebGL backend for now\n    if (renderer.backend.isWebGLBackend === true) {\n      this.renderTarget.samples = 0;\n    }\n    return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();\n  }\n  updateBefore(frame) {\n    const {\n      renderer\n    } = frame;\n    const {\n      scene,\n      camera\n    } = this;\n    this._pixelRatio = renderer.getPixelRatio();\n    const size = renderer.getSize(_size);\n    this.setSize(size.width, size.height);\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentMRT = renderer.getMRT();\n    this._cameraNear.value = camera.near;\n    this._cameraFar.value = camera.far;\n    for (const name in this._previousTextures) {\n      this.toggleTexture(name);\n    }\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.setMRT(this._mrt);\n    renderer.render(scene, camera);\n    renderer.setRenderTarget(currentRenderTarget);\n    renderer.setMRT(currentMRT);\n  }\n\n  /**\n   * Sets the size of the pass's render target. Honors the pixel ratio.\n   *\n   * @param {Number} width - The width to set.\n   * @param {Number} height - The height to set.\n   */\n  setSize(width, height) {\n    this._width = width;\n    this._height = height;\n    const effectiveWidth = this._width * this._pixelRatio;\n    const effectiveHeight = this._height * this._pixelRatio;\n    this.renderTarget.setSize(effectiveWidth, effectiveHeight);\n  }\n\n  /**\n   * Sets the pixel ratio the pass's render target and updates the size.\n   *\n   * @param {Number} pixelRatio - The pixel ratio to set.\n   */\n  setPixelRatio(pixelRatio) {\n    this._pixelRatio = pixelRatio;\n    this.setSize(this._width, this._height);\n  }\n\n  /**\n   * Frees internal resources. Should be called when the node is no longer in use.\n   */\n  dispose() {\n    this.renderTarget.dispose();\n  }\n}\nPassNode.COLOR = 'color';\nPassNode.DEPTH = 'depth';\n\n/**\n * TSL function for creating a pass node.\n *\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nconst pass = (scene, camera, options) => nodeObject(new PassNode(PassNode.COLOR, scene, camera, options));\n\n/**\n * TSL function for creating a pass texture node.\n *\n * @function\n * @param {PassNode} pass - The pass node.\n * @param {Texture} texture - The output texture.\n * @returns {PassTextureNode}\n */\nconst passTexture = (pass, texture) => nodeObject(new PassTextureNode(pass, texture));\n\n/**\n * TSL function for creating a depth pass node.\n *\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nconst depthPass = (scene, camera, options) => nodeObject(new PassNode(PassNode.DEPTH, scene, camera, options));\n\n/** @module ToonOutlinePassNode **/\n\n/**\n * Represents a render pass for producing a toon outline effect on compatible objects.\n * Only 3D objects with materials of type `MeshToonMaterial` and `MeshToonNodeMaterial`\n * will receive the outline.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = toonOutlinePass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n * @augments PassNode\n */\nclass ToonOutlinePassNode extends PassNode {\n  static get type() {\n    return 'ToonOutlinePassNode';\n  }\n\n  /**\n   * Constructs a new outline pass node.\n   *\n   * @param {Scene} scene - A reference to the scene.\n   * @param {Camera} camera - A reference to the camera.\n   * @param {Node} colorNode - Defines the outline's color.\n   * @param {Node} thicknessNode - Defines the outline's thickness.\n   * @param {Node} alphaNode - Defines the outline's alpha.\n   */\n  constructor(scene, camera, colorNode, thicknessNode, alphaNode) {\n    super(PassNode.COLOR, scene, camera);\n\n    /**\n     * Defines the outline's color.\n     *\n     * @type {Node}\n     */\n    this.colorNode = colorNode;\n\n    /**\n     * Defines the outline's thickness.\n     *\n     * @type {Node}\n     */\n    this.thicknessNode = thicknessNode;\n\n    /**\n     * Defines the outline's alpha.\n     *\n     * @type {Node}\n     */\n    this.alphaNode = alphaNode;\n\n    /**\n     * An internal material cache.\n     *\n     * @private\n     * @type {WeakMap<Material, NodeMaterial>}\n     */\n    this._materialCache = new WeakMap();\n  }\n  updateBefore(frame) {\n    const {\n      renderer\n    } = frame;\n    const currentRenderObjectFunction = renderer.getRenderObjectFunction();\n    renderer.setRenderObjectFunction((object, scene, camera, geometry, material, group, lightsNode, clippingContext) => {\n      // only render outline for supported materials\n\n      if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {\n        if (material.wireframe === false) {\n          const outlineMaterial = this._getOutlineMaterial(material);\n          renderer.renderObject(object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext);\n        }\n      }\n\n      // default\n\n      renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext);\n    });\n    super.updateBefore(frame);\n    renderer.setRenderObjectFunction(currentRenderObjectFunction);\n  }\n\n  /**\n   * Creates the material used for outline rendering.\n   *\n   * @private\n   * @return {NodeMaterial} The outline material.\n   */\n  _createMaterial() {\n    const material = new NodeMaterial();\n    material.isMeshToonOutlineMaterial = true;\n    material.name = 'Toon_Outline';\n    material.side = BackSide;\n\n    // vertex node\n\n    const outlineNormal = normalLocal.negate();\n    const mvp = cameraProjectionMatrix.mul(modelViewMatrix);\n    const ratio = float(1.0); // TODO: support outline thickness ratio for each vertex\n    const pos = mvp.mul(vec4(positionLocal, 1.0));\n    const pos2 = mvp.mul(vec4(positionLocal.add(outlineNormal), 1.0));\n    const norm = normalize(pos.sub(pos2)); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\n    material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));\n\n    // color node\n\n    material.colorNode = vec4(this.colorNode, this.alphaNode);\n    return material;\n  }\n\n  /**\n   * For the given toon material, this method returns a corresponding\n   * outline material.\n   *\n   * @private\n   * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.\n   * @return {NodeMaterial} The outline material.\n   */\n  _getOutlineMaterial(originalMaterial) {\n    let outlineMaterial = this._materialCache.get(originalMaterial);\n    if (outlineMaterial === undefined) {\n      outlineMaterial = this._createMaterial();\n      this._materialCache.set(originalMaterial, outlineMaterial);\n    }\n    return outlineMaterial;\n  }\n}\n\n/**\n * TSL function for creating a toon outline pass node.\n *\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Color} color - Defines the outline's color.\n * @param {Number} [thickness=0.003] - Defines the outline's thickness.\n * @param {Number} [alpha=1] - Defines the outline's alpha.\n * @returns {ToonOutlinePassNode}\n */\nconst toonOutlinePass = (scene, camera, color = new Color(0, 0, 0), thickness = 0.003, alpha = 1) => nodeObject(new ToonOutlinePassNode(scene, camera, nodeObject(color), nodeObject(thickness), nodeObject(alpha)));\n\n/** @module ToneMappingFunctions **/\n\n/**\n * Linear tone mapping, exposure only.\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst linearToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  return color.mul(exposure).clamp();\n}).setLayout({\n  name: 'linearToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n/**\n * Reinhard tone mapping.\n *\n * Reference: {@link https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst reinhardToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  color = color.mul(exposure);\n  return color.div(color.add(1.0)).clamp();\n}).setLayout({\n  name: 'reinhardToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n/**\n * Cineon tone mapping.\n *\n * Reference: {@link http://filmicworlds.com/blog/filmic-tonemapping-operators/}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst cineonToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  // filmic operator by Jim Hejl and Richard Burgess-Dawson\n  color = color.mul(exposure);\n  color = color.sub(0.004).max(0.0);\n  const a = color.mul(color.mul(6.2).add(0.5));\n  const b = color.mul(color.mul(6.2).add(1.7)).add(0.06);\n  return a.div(b).pow(2.2);\n}).setLayout({\n  name: 'cineonToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst RRTAndODTFit = /*@__PURE__*/Fn(([color]) => {\n  const a = color.mul(color.add(0.0245786)).sub(0.000090537);\n  const b = color.mul(color.add(0.4329510).mul(0.983729)).add(0.238081);\n  return a.div(b);\n});\n\n/**\n * ACESFilmic tone mapping.\n *\n * Reference: {@link https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst acesFilmicToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n  const ACESInputMat = mat3(0.59719, 0.35458, 0.04823, 0.07600, 0.90834, 0.01566, 0.02840, 0.13383, 0.83777);\n\n  // ODT_SAT => XYZ => D60_2_D65 => sRGB\n  const ACESOutputMat = mat3(1.60475, -0.53108, -0.07367, -0.10208, 1.10813, -0.00605, -0.00327, -0.07276, 1.07602);\n  color = color.mul(exposure).div(0.6);\n  color = ACESInputMat.mul(color);\n\n  // Apply RRT and ODT\n  color = RRTAndODTFit(color);\n  color = ACESOutputMat.mul(color);\n\n  // Clamp to [0, 1]\n  return color.clamp();\n}).setLayout({\n  name: 'acesFilmicToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\nconst LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -0.0083, 1.1187));\nconst LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.0880), vec3(0.0433, 0.0113, 0.8956));\nconst agxDefaultContrastApprox = /*@__PURE__*/Fn(([x_immutable]) => {\n  const x = vec3(x_immutable).toVar();\n  const x2 = vec3(x.mul(x)).toVar();\n  const x4 = vec3(x2.mul(x2)).toVar();\n  return float(15.5).mul(x4.mul(x2)).sub(mul(40.14, x4.mul(x))).add(mul(31.96, x4).sub(mul(6.868, x2.mul(x))).add(mul(0.4298, x2).add(mul(0.1191, x).sub(0.00232))));\n});\n\n/**\n * AgX tone mapping.\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst agxToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  const colortone = vec3(color).toVar();\n  const AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));\n  const AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));\n  const AgxMinEv = float(-12.47393);\n  const AgxMaxEv = float(4.026069);\n  colortone.mulAssign(exposure);\n  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));\n  colortone.assign(AgXInsetMatrix.mul(colortone));\n  colortone.assign(max$1(colortone, 1e-10));\n  colortone.assign(log2(colortone));\n  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));\n  colortone.assign(clamp(colortone, 0.0, 1.0));\n  colortone.assign(agxDefaultContrastApprox(colortone));\n  colortone.assign(AgXOutsetMatrix.mul(colortone));\n  colortone.assign(pow(max$1(vec3(0.0), colortone), vec3(2.2)));\n  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));\n  colortone.assign(clamp(colortone, 0.0, 1.0));\n  return colortone;\n}).setLayout({\n  name: 'agxToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n/**\n * Neutral tone mapping.\n *\n * Reference: {@link https://modelviewer.dev/examples/tone-mapping}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst neutralToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  const StartCompression = float(0.8 - 0.04);\n  const Desaturation = float(0.15);\n  color = color.mul(exposure);\n  const x = min$1(color.r, min$1(color.g, color.b));\n  const offset = select(x.lessThan(0.08), x.sub(mul(6.25, x.mul(x))), 0.04);\n  color.subAssign(offset);\n  const peak = max$1(color.r, max$1(color.g, color.b));\n  If(peak.lessThan(StartCompression), () => {\n    return color;\n  });\n  const d = sub(1, StartCompression);\n  const newPeak = sub(1, d.mul(d).div(peak.add(d.sub(StartCompression))));\n  color.mulAssign(newPeak.div(peak));\n  const g = sub(1, div(1, Desaturation.mul(peak.sub(newPeak)).add(1)));\n  return mix(color, vec3(newPeak), g);\n}).setLayout({\n  name: 'neutralToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n/** @module CodeNode **/\n\n/**\n * This class represents native code sections. It is the base\n * class for modules like {@link FunctionNode} which allows to implement\n * functions with native shader languages.\n *\n * @augments Node\n */\nclass CodeNode extends Node {\n  static get type() {\n    return 'CodeNode';\n  }\n\n  /**\n   * Constructs a new code node.\n   *\n   * @param {String} [code=''] - The native code.\n   * @param {Array<Node>} [includes=[]] - An array of includes.\n   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n   */\n  constructor(code = '', includes = [], language = '') {\n    super('code');\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isCodeNode = true;\n\n    /**\n     * The native code.\n     *\n     * @type {String}\n     * @default ''\n     */\n    this.code = code;\n\n    /**\n     * An array of includes\n     *\n     * @type {Array<Node>}\n     * @default []\n     */\n    this.includes = includes;\n\n    /**\n     * The used language.\n     *\n     * @type {('js'|'wgsl'|'glsl')}\n     * @default ''\n     */\n    this.language = language;\n  }\n\n  /**\n   * The method is overwritten so it always returns `true`.\n   *\n   * @return {Boolean} Whether this node is global or not.\n   */\n  isGlobal() {\n    return true;\n  }\n\n  /**\n   * Sets the includes of this code node.\n   *\n   * @param {Array<Node>} includes - The includes to set.\n   * @return {CodeNode} A reference to this node.\n   */\n  setIncludes(includes) {\n    this.includes = includes;\n    return this;\n  }\n\n  /**\n   * Returns the includes of this code node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Array<Node>} The includes.\n   */\n  getIncludes(/*builder*/\n  ) {\n    return this.includes;\n  }\n  generate(builder) {\n    const includes = this.getIncludes(builder);\n    for (const include of includes) {\n      include.build(builder);\n    }\n    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));\n    nodeCode.code = this.code;\n    return nodeCode.code;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.code = this.code;\n    data.language = this.language;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.code = data.code;\n    this.language = data.language;\n  }\n}\n\n/**\n * TSL function for creating a code node.\n *\n * @function\n * @param {String} [code=''] - The native code.\n * @param {Array<Node>} [includes=[]] - An array of includes.\n * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n * @returns {CodeNode}\n */\nconst code = /*@__PURE__*/nodeProxy(CodeNode);\n\n/**\n * TSL function for creating a JS code node.\n *\n * @function\n * @param {String} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst js = (src, includes) => code(src, includes, 'js');\n\n/**\n * TSL function for creating a WGSL code node.\n *\n * @function\n * @param {String} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst wgsl = (src, includes) => code(src, includes, 'wgsl');\n\n/**\n * TSL function for creating a GLSL code node.\n *\n * @function\n * @param {String} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst glsl = (src, includes) => code(src, includes, 'glsl');\n\n/**\n * This class represents a native shader function. It can be used to implement\n * certain aspects of a node material with native shader code. There are two predefined\n * TSL functions for easier usage.\n *\n * - `wgslFn`: Creates a WGSL function node.\n * - `glslFn`: Creates a GLSL function node.\n *\n * A basic example with one include looks like so:\n *\n * ```js\n * const desaturateWGSLFn = wgslFn( `\n *\tfn desaturate( color:vec3<f32> ) -> vec3<f32> {\n *\t\tlet lum = vec3<f32>( 0.299, 0.587, 0.114 );\n *\t\treturn vec3<f32>( dot( lum, color ) );\n *\t}`\n *);\n * const someWGSLFn = wgslFn( `\n *\tfn someFn( color:vec3<f32> ) -> vec3<f32> {\n * \t\treturn desaturate( color );\n * \t}\n * `, [ desaturateWGSLFn ] );\n * material.colorNode = someWGSLFn( { color: texture( map ) } );\n *```\n * @augments CodeNode\n */\nclass FunctionNode extends CodeNode {\n  static get type() {\n    return 'FunctionNode';\n  }\n\n  /**\n   * Constructs a new function node.\n   *\n   * @param {String} [code=''] - The native code.\n   * @param {Array<Node>} [includes=[]] - An array of includes.\n   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n   */\n  constructor(code = '', includes = [], language = '') {\n    super(code, includes, language);\n  }\n  getNodeType(builder) {\n    return this.getNodeFunction(builder).type;\n  }\n\n  /**\n   * Returns the inputs of this function node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Array<NodeFunctionInput>} The inputs.\n   */\n  getInputs(builder) {\n    return this.getNodeFunction(builder).inputs;\n  }\n\n  /**\n   * Returns the node function for this function node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {NodeFunction} The node function.\n   */\n  getNodeFunction(builder) {\n    const nodeData = builder.getDataFromNode(this);\n    let nodeFunction = nodeData.nodeFunction;\n    if (nodeFunction === undefined) {\n      nodeFunction = builder.parser.parseFunction(this.code);\n      nodeData.nodeFunction = nodeFunction;\n    }\n    return nodeFunction;\n  }\n  generate(builder, output) {\n    super.generate(builder);\n    const nodeFunction = this.getNodeFunction(builder);\n    const name = nodeFunction.name;\n    const type = nodeFunction.type;\n    const nodeCode = builder.getCodeFromNode(this, type);\n    if (name !== '') {\n      // use a custom property name\n\n      nodeCode.name = name;\n    }\n    const propertyName = builder.getPropertyName(nodeCode);\n    const code = this.getNodeFunction(builder).getCode(propertyName);\n    nodeCode.code = code + '\\n';\n    if (output === 'property') {\n      return propertyName;\n    } else {\n      return builder.format(`${propertyName}()`, type, output);\n    }\n  }\n}\nconst nativeFn = (code, includes = [], language = '') => {\n  for (let i = 0; i < includes.length; i++) {\n    const include = includes[i];\n\n    // TSL Function: glslFn, wgslFn\n\n    if (typeof include === 'function') {\n      includes[i] = include.functionNode;\n    }\n  }\n  const functionNode = nodeObject(new FunctionNode(code, includes, language));\n  const fn = (...params) => functionNode.call(...params);\n  fn.functionNode = functionNode;\n  return fn;\n};\nconst glslFn = (code, includes) => nativeFn(code, includes, 'glsl');\nconst wgslFn = (code, includes) => nativeFn(code, includes, 'wgsl');\n\n/** @module ScriptableValueNode **/\n\n/**\n * `ScriptableNode` uses this class to manage script inputs and outputs.\n *\n * @augments Node\n */\nclass ScriptableValueNode extends Node {\n  static get type() {\n    return 'ScriptableValueNode';\n  }\n\n  /**\n   * Constructs a new scriptable node.\n   *\n   * @param {Any} [value=null] - The value.\n   */\n  constructor(value = null) {\n    super();\n\n    /**\n     * A reference to the value.\n     *\n     * @private\n     * @default null\n     */\n    this._value = value;\n\n    /**\n     * Depending on the type of `_value`, this property might cache parsed data.\n     *\n     * @private\n     * @default null\n     */\n    this._cache = null;\n\n    /**\n     * If this node represents an input, this property represents the input type.\n     *\n     * @type {String?}\n     * @default null\n     */\n    this.inputType = null;\n\n    /**\n     * If this node represents an output, this property represents the output type.\n     *\n     * @type {String?}\n     * @default null\n     */\n    this.outputType = null;\n\n    /**\n     * An event dispatcher for managing events.\n     *\n     * @type {EventDispatcher}\n     */\n    this.events = new EventDispatcher();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isScriptableValueNode = true;\n  }\n\n  /**\n   * Whether this node represents an output or not.\n   *\n   * @type {Boolean}\n   * @readonly\n   * @default true\n   */\n  get isScriptableOutputNode() {\n    return this.outputType !== null;\n  }\n  set value(val) {\n    if (this._value === val) return;\n    if (this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer) {\n      URL.revokeObjectURL(this._cache);\n      this._cache = null;\n    }\n    this._value = val;\n    this.events.dispatchEvent({\n      type: 'change'\n    });\n    this.refresh();\n  }\n\n  /**\n   * The node's value.\n   *\n   * @type {Any}\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Dispatches the `refresh` event.\n   */\n  refresh() {\n    this.events.dispatchEvent({\n      type: 'refresh'\n    });\n  }\n\n  /**\n   * The `value` property usually represents a node or even binary data in form of array buffers.\n   * In this case, this method tries to return the actual value behind the complex type.\n   *\n   * @return {Any} The value.\n   */\n  getValue() {\n    const value = this.value;\n    if (value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer) {\n      this._cache = URL.createObjectURL(new Blob([value.value]));\n    } else if (value && value.value !== null && value.value !== undefined && ((this.inputType === 'URL' || this.inputType === 'String') && typeof value.value === 'string' || this.inputType === 'Number' && typeof value.value === 'number' || this.inputType === 'Vector2' && value.value.isVector2 || this.inputType === 'Vector3' && value.value.isVector3 || this.inputType === 'Vector4' && value.value.isVector4 || this.inputType === 'Color' && value.value.isColor || this.inputType === 'Matrix3' && value.value.isMatrix3 || this.inputType === 'Matrix4' && value.value.isMatrix4)) {\n      return value.value;\n    }\n    return this._cache || value;\n  }\n\n  /**\n   * Overwritten since the node type is inferred from the value.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    return this.value && this.value.isNode ? this.value.getNodeType(builder) : 'float';\n  }\n  setup() {\n    return this.value && this.value.isNode ? this.value : float();\n  }\n  serialize(data) {\n    super.serialize(data);\n    if (this.value !== null) {\n      if (this.inputType === 'ArrayBuffer') {\n        data.value = arrayBufferToBase64(this.value);\n      } else {\n        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;\n      }\n    } else {\n      data.value = null;\n    }\n    data.inputType = this.inputType;\n    data.outputType = this.outputType;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    let value = null;\n    if (data.value !== null) {\n      if (data.inputType === 'ArrayBuffer') {\n        value = base64ToArrayBuffer(data.value);\n      } else if (data.inputType === 'Texture') {\n        value = data.meta.textures[data.value];\n      } else {\n        value = data.meta.nodes[data.value] || null;\n      }\n    }\n    this.value = value;\n    this.inputType = data.inputType;\n    this.outputType = data.outputType;\n  }\n}\n\n/**\n * TSL function for creating a scriptable value node.\n *\n * @function\n * @param {Any} [value=null] - The value.\n * @returns {ScriptableValueNode}\n */\nconst scriptableValue = /*@__PURE__*/nodeProxy(ScriptableValueNode);\n\n/** @module ScriptableNode **/\n\n/**\n * A Map-like data structure for managing resources of scriptable nodes.\n *\n * @augments Map\n */\nclass Resources extends Map {\n  get(key, callback = null, ...params) {\n    if (this.has(key)) return super.get(key);\n    if (callback !== null) {\n      const value = callback(...params);\n      this.set(key, value);\n      return value;\n    }\n  }\n}\nclass Parameters {\n  constructor(scriptableNode) {\n    this.scriptableNode = scriptableNode;\n  }\n  get parameters() {\n    return this.scriptableNode.parameters;\n  }\n  get layout() {\n    return this.scriptableNode.getLayout();\n  }\n  getInputLayout(id) {\n    return this.scriptableNode.getInputLayout(id);\n  }\n  get(name) {\n    const param = this.parameters[name];\n    const value = param ? param.getValue() : null;\n    return value;\n  }\n}\n\n/**\n * Defines the resouces (e.g. namespaces) of scriptable nodes.\n *\n * @type {Resources}\n */\nconst ScriptableNodeResources = new Resources();\n\n/**\n * This type of node allows to implement nodes with custom scripts. The script\n * section is represented as an instance of `CodeNode` written with JavaScript.\n * The script itself must adhere to a specific structure.\n *\n * - main(): Executed once by default and every time `node.needsUpdate` is set.\n * - layout: The layout object defines the script's interface (inputs and outputs).\n *\n * ```js\n * ScriptableNodeResources.set( 'TSL', TSL );\n *\n * const scriptableNode = scriptable( js( `\n * \tlayout = {\n * \t\toutputType: 'node',\n * \t\telements: [\n * \t\t\t{ name: 'source', inputType: 'node' },\n * \t\t]\n * \t};\n *\n * \tconst { mul, oscSine } = TSL;\n *\n * \tfunction main() {\n * \t\tconst source = parameters.get( 'source' ) || float();\n * \t\treturn mul( source, oscSine() ) );\n * \t}\n *\n * ` ) );\n *\n * scriptableNode.setParameter( 'source', color( 1, 0, 0 ) );\n *\n * const material = new THREE.MeshBasicNodeMaterial();\n * material.colorNode = scriptableNode;\n * ```\n *\n * @augments Node\n */\nclass ScriptableNode extends Node {\n  static get type() {\n    return 'ScriptableNode';\n  }\n\n  /**\n   * Constructs a new scriptable node.\n   *\n   * @param {CodeNode?} [codeNode=null] - The code node.\n   * @param {Object} [parameters={}] - The parameters definition.\n   */\n  constructor(codeNode = null, parameters = {}) {\n    super();\n\n    /**\n     * The code node.\n     *\n     * @type {CodeNode?}\n     * @default null\n     */\n    this.codeNode = codeNode;\n\n    /**\n     * The parameters definition.\n     *\n     * @type {Object}\n     * @default {}\n     */\n    this.parameters = parameters;\n    this._local = new Resources();\n    this._output = scriptableValue();\n    this._outputs = {};\n    this._source = this.source;\n    this._method = null;\n    this._object = null;\n    this._value = null;\n    this._needsOutputUpdate = true;\n    this.onRefresh = this.onRefresh.bind(this);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isScriptableNode = true;\n  }\n\n  /**\n   * The source code of the scriptable node.\n   *\n   * @type {String}\n   */\n  get source() {\n    return this.codeNode ? this.codeNode.code : '';\n  }\n\n  /**\n   * Sets the reference of a local script variable.\n   *\n   * @param {String} name - The variable name.\n   * @param {Object} value - The reference to set.\n   * @return {Resources} The resource map\n   */\n  setLocal(name, value) {\n    return this._local.set(name, value);\n  }\n\n  /**\n   * Gets the value of a local script variable.\n   *\n   * @param {String} name - The variable name.\n   * @return {Object} The value.\n   */\n  getLocal(name) {\n    return this._local.get(name);\n  }\n\n  /**\n   * Event listener for the `refresh` event.\n   */\n  onRefresh() {\n    this._refresh();\n  }\n\n  /**\n   * Returns an input from the layout with the given id/name.\n   *\n   * @param {String} id - The id/name of the input.\n   * @return {Object} The element entry.\n   */\n  getInputLayout(id) {\n    for (const element of this.getLayout()) {\n      if (element.inputType && (element.id === id || element.name === id)) {\n        return element;\n      }\n    }\n  }\n\n  /**\n   * Returns an output from the layout with the given id/name.\n   *\n   * @param {String} id - The id/name of the output.\n   * @return {Object} The element entry.\n   */\n  getOutputLayout(id) {\n    for (const element of this.getLayout()) {\n      if (element.outputType && (element.id === id || element.name === id)) {\n        return element;\n      }\n    }\n  }\n\n  /**\n   * Defines a script output for the given name and value.\n   *\n   * @param {String} name - The name of the output.\n   * @param {Node} value - The node value.\n   * @return {ScriptableNode} A reference to this node.\n   */\n  setOutput(name, value) {\n    const outputs = this._outputs;\n    if (outputs[name] === undefined) {\n      outputs[name] = scriptableValue(value);\n    } else {\n      outputs[name].value = value;\n    }\n    return this;\n  }\n\n  /**\n   * Returns a script output for the given name.\n   *\n   * @param {String} name - The name of the output.\n   * @return {ScriptableValueNode} The node value.\n   */\n  getOutput(name) {\n    return this._outputs[name];\n  }\n\n  /**\n   * Returns a paramater for the given name\n   *\n   * @param {String} name - The name of the parameter.\n   * @return {ScriptableValueNode} The node value.\n   */\n  getParameter(name) {\n    return this.parameters[name];\n  }\n\n  /**\n   * Sets a value for the given parameter name.\n   *\n   * @param {String} name - The parameter name.\n   * @param {Any} value - The parameter value.\n   * @return {ScriptableNode} A reference to this node.\n   */\n  setParameter(name, value) {\n    const parameters = this.parameters;\n    if (value && value.isScriptableNode) {\n      this.deleteParameter(name);\n      parameters[name] = value;\n      parameters[name].getDefaultOutput().events.addEventListener('refresh', this.onRefresh);\n    } else if (value && value.isScriptableValueNode) {\n      this.deleteParameter(name);\n      parameters[name] = value;\n      parameters[name].events.addEventListener('refresh', this.onRefresh);\n    } else if (parameters[name] === undefined) {\n      parameters[name] = scriptableValue(value);\n      parameters[name].events.addEventListener('refresh', this.onRefresh);\n    } else {\n      parameters[name].value = value;\n    }\n    return this;\n  }\n\n  /**\n   * Returns the value of this node which is the value of\n   * the default output.\n   *\n   * @return {Node} The value.\n   */\n  getValue() {\n    return this.getDefaultOutput().getValue();\n  }\n\n  /**\n   * Deletes a parameter from the script.\n   *\n   * @param {String} name - The parameter to remove.\n   * @return {ScriptableNode} A reference to this node.\n   */\n  deleteParameter(name) {\n    let valueNode = this.parameters[name];\n    if (valueNode) {\n      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();\n      valueNode.events.removeEventListener('refresh', this.onRefresh);\n    }\n    return this;\n  }\n\n  /**\n   * Deletes all parameters from the script.\n   *\n   * @return {ScriptableNode} A reference to this node.\n   */\n  clearParameters() {\n    for (const name of Object.keys(this.parameters)) {\n      this.deleteParameter(name);\n    }\n    this.needsUpdate = true;\n    return this;\n  }\n\n  /**\n   * Calls a function from the script.\n   *\n   * @param {String} name - The function name.\n   * @param {...Any} params - A list of parameters.\n   * @return {Any} The result of the function call.\n   */\n  call(name, ...params) {\n    const object = this.getObject();\n    const method = object[name];\n    if (typeof method === 'function') {\n      return method(...params);\n    }\n  }\n\n  /**\n   * Asynchronously calls a function from the script.\n   *\n   * @param {String} name - The function name.\n   * @param {...Any} params - A list of parameters.\n   * @return {Any} The result of the function call.\n   */\n  async callAsync(name, ...params) {\n    const object = this.getObject();\n    const method = object[name];\n    if (typeof method === 'function') {\n      return method.constructor.name === 'AsyncFunction' ? await method(...params) : method(...params);\n    }\n  }\n\n  /**\n   * Overwritten since the node types is inferred from the script's output.\n   *\n   * @param {NodeBuilder} builder - The current node builder\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    return this.getDefaultOutputNode().getNodeType(builder);\n  }\n\n  /**\n   * Refreshes the script node.\n   *\n   * @param {String?} [output=null] - An optional output.\n   */\n  refresh(output = null) {\n    if (output !== null) {\n      this.getOutput(output).refresh();\n    } else {\n      this._refresh();\n    }\n  }\n\n  /**\n   * Returns an object representation of the script.\n   *\n   * @return {Object} The result object.\n   */\n  getObject() {\n    if (this.needsUpdate) this.dispose();\n    if (this._object !== null) return this._object;\n\n    //\n\n    const refresh = () => this.refresh();\n    const setOutput = (id, value) => this.setOutput(id, value);\n    const parameters = new Parameters(this);\n    const THREE = ScriptableNodeResources.get('THREE');\n    const TSL = ScriptableNodeResources.get('TSL');\n    const method = this.getMethod();\n    const params = [parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL];\n    this._object = method(...params);\n    const layout = this._object.layout;\n    if (layout) {\n      if (layout.cache === false) {\n        this._local.clear();\n      }\n\n      // default output\n      this._output.outputType = layout.outputType || null;\n      if (Array.isArray(layout.elements)) {\n        for (const element of layout.elements) {\n          const id = element.id || element.name;\n          if (element.inputType) {\n            if (this.getParameter(id) === undefined) this.setParameter(id, null);\n            this.getParameter(id).inputType = element.inputType;\n          }\n          if (element.outputType) {\n            if (this.getOutput(id) === undefined) this.setOutput(id, null);\n            this.getOutput(id).outputType = element.outputType;\n          }\n        }\n      }\n    }\n    return this._object;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    for (const name in this.parameters) {\n      let valueNode = this.parameters[name];\n      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();\n      valueNode.events.addEventListener('refresh', this.onRefresh);\n    }\n  }\n\n  /**\n   * Returns the layout of the script.\n   *\n   * @return {Object} The script's layout.\n   */\n  getLayout() {\n    return this.getObject().layout;\n  }\n\n  /**\n   * Returns default node output of the script.\n   *\n   * @return {Node} The default node output.\n   */\n  getDefaultOutputNode() {\n    const output = this.getDefaultOutput().value;\n    if (output && output.isNode) {\n      return output;\n    }\n    return float();\n  }\n\n  /**\n   * Returns default output of the script.\n   *\n   * @return {ScriptableValueNode} The default output.\n   */\n  getDefaultOutput() {\n    return this._exec()._output;\n  }\n\n  /**\n   * Returns a function created from the node's script.\n   *\n   * @return {Function} The function representing the node's code.\n   */\n  getMethod() {\n    if (this.needsUpdate) this.dispose();\n    if (this._method !== null) return this._method;\n\n    //\n\n    const parametersProps = ['parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL'];\n    const interfaceProps = ['layout', 'init', 'main', 'dispose'];\n    const properties = interfaceProps.join(', ');\n    const declarations = 'var ' + properties + '; var output = {};\\n';\n    const returns = '\\nreturn { ...output, ' + properties + ' };';\n    const code = declarations + this.codeNode.code + returns;\n\n    //\n\n    this._method = new Function(...parametersProps, code);\n    return this._method;\n  }\n\n  /**\n   * Frees all internal resources.\n   */\n  dispose() {\n    if (this._method === null) return;\n    if (this._object && typeof this._object.dispose === 'function') {\n      this._object.dispose();\n    }\n    this._method = null;\n    this._object = null;\n    this._source = null;\n    this._value = null;\n    this._needsOutputUpdate = true;\n    this._output.value = null;\n    this._outputs = {};\n  }\n  setup() {\n    return this.getDefaultOutputNode();\n  }\n  getCacheKey(force) {\n    const values = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];\n    for (const param in this.parameters) {\n      values.push(this.parameters[param].getCacheKey(force));\n    }\n    return hashArray(values);\n  }\n  set needsUpdate(value) {\n    if (value === true) this.dispose();\n  }\n  get needsUpdate() {\n    return this.source !== this._source;\n  }\n\n  /**\n   * Executes the `main` function of the script.\n   *\n   * @private\n   * @return {ScriptableNode} A reference to this node.\n   */\n  _exec() {\n    if (this.codeNode === null) return this;\n    if (this._needsOutputUpdate === true) {\n      this._value = this.call('main');\n      this._needsOutputUpdate = false;\n    }\n    this._output.value = this._value;\n    return this;\n  }\n\n  /**\n   * Executes the refresh.\n   *\n   * @private\n   */\n  _refresh() {\n    this.needsUpdate = true;\n    this._exec();\n    this._output.refresh();\n  }\n}\n\n/**\n * TSL function for creating a scriptable node.\n *\n * @function\n * @param {CodeNode?} [codeNode=null] - The code node.\n * @param {Object} [parameters={}] - The parameters definition.\n * @returns {ScriptableNode}\n */\nconst scriptable = /*@__PURE__*/nodeProxy(ScriptableNode);\n\n/** @module Fog **/\n\n/**\n * Returns a node that represents the `z` coordinate in view space\n * for the current fragment. It's a different representation of the\n * default depth value.\n *\n * This value can be part of a computation that defines how the fog\n * density increases when moving away from the camera.\n *\n * @param {NodeBuilder} builder - The current node builder.\n * @return {Node} The viewZ node.\n */\nfunction getViewZNode(builder) {\n  let viewZ;\n  const getViewZ = builder.context.getViewZ;\n  if (getViewZ !== undefined) {\n    viewZ = getViewZ(this);\n  }\n  return (viewZ || positionView.z).negate();\n}\n\n/**\n * Constructs a new range factor node.\n *\n * @function\n * @param {Node} near - Defines the near value.\n * @param {Node} far - Defines the far value.\n */\nconst rangeFogFactor = Fn(([near, far], builder) => {\n  const viewZ = getViewZNode(builder);\n  return smoothstep(near, far, viewZ);\n});\n\n/**\n * Represents an exponential squared fog. This type of fog gives\n * a clear view near the camera and a faster than exponentially\n * densening fog farther from the camera.\n *\n * @function\n * @param {Node} density - Defines the fog density.\n */\nconst densityFogFactor = Fn(([density], builder) => {\n  const viewZ = getViewZNode(builder);\n  return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();\n});\n\n/**\n * This class can be used to configure a fog for the scene.\n * Nodes of this type are assigned to `Scene.fogNode`.\n *\n * @function\n * @param {Node} color - Defines the color of the fog.\n * @param {Node} factor - Defines how the fog is factored in the scene.\n */\nconst fog = Fn(([color, factor]) => {\n  return vec4(factor.toFloat().mix(output.rgb, color.toVec3()), output.a);\n});\n\n// Deprecated\n\nfunction rangeFog(color, near, far) {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"rangeFog( color, near, far )\" is deprecated. Use \"fog( color, rangeFogFactor( near, far ) )\" instead.');\n  return fog(color, rangeFogFactor(near, far));\n}\nfunction densityFog(color, density) {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"densityFog( color, density )\" is deprecated. Use \"fog( color, densityFogFactor( density ) )\" instead.');\n  return fog(color, densityFogFactor(density));\n}\n\n/** @module RangeNode **/\n\nlet min = null;\nlet max = null;\n\n/**\n * `RangeNode` generates random instanced attribute data in a defined range.\n * An exemplary use case for this utility node is to generate random per-instance\n * colors:\n * ```js\n * const material = new MeshBasicNodeMaterial();\n * material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );\n * const mesh = new InstancedMesh( geometry, material, count );\n * ```\n * @augments Node\n */\nclass RangeNode extends Node {\n  static get type() {\n    return 'RangeNode';\n  }\n\n  /**\n   * Constructs a new range node.\n   *\n   * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n   * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n   */\n  constructor(minNode = float(), maxNode = float()) {\n    super();\n\n    /**\n     *  A node defining the lower bound of the range.\n     *\n     * @type {Node<any>}\n     * @default float()\n     */\n    this.minNode = minNode;\n\n    /**\n     *  A node defining the upper bound of the range.\n     *\n     * @type {Node<any>}\n     * @default float()\n     */\n    this.maxNode = maxNode;\n  }\n\n  /**\n   * Returns the vector length which is computed based on the range definition.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {Number} The vector length.\n   */\n  getVectorLength(builder) {\n    const minLength = builder.getTypeLength(getValueType(this.minNode.value));\n    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));\n    return minLength > maxLength ? minLength : maxLength;\n  }\n\n  /**\n   * This method is overwritten since the node type is inferred from range definition.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : 'float';\n  }\n  setup(builder) {\n    const object = builder.object;\n    let output = null;\n    if (object.count > 1) {\n      const minValue = this.minNode.value;\n      const maxValue = this.maxNode.value;\n      const minLength = builder.getTypeLength(getValueType(minValue));\n      const maxLength = builder.getTypeLength(getValueType(maxValue));\n      min = min || new Vector4();\n      max = max || new Vector4();\n      min.setScalar(0);\n      max.setScalar(0);\n      if (minLength === 1) min.setScalar(minValue);else if (minValue.isColor) min.set(minValue.r, minValue.g, minValue.b, 1);else min.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);\n      if (maxLength === 1) max.setScalar(maxValue);else if (maxValue.isColor) max.set(maxValue.r, maxValue.g, maxValue.b, 1);else max.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);\n      const stride = 4;\n      const length = stride * object.count;\n      const array = new Float32Array(length);\n      for (let i = 0; i < length; i++) {\n        const index = i % stride;\n        const minElementValue = min.getComponent(index);\n        const maxElementValue = max.getComponent(index);\n        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());\n      }\n      const nodeType = this.getNodeType(builder);\n      if (object.count <= 4096) {\n        output = buffer(array, 'vec4', object.count).element(instanceIndex).convert(nodeType);\n      } else {\n        // TODO: Improve anonymous buffer attribute creation removing this part\n        const bufferAttribute = new InstancedBufferAttribute(array, 4);\n        builder.geometry.setAttribute('__range' + this.id, bufferAttribute);\n        output = instancedBufferAttribute(bufferAttribute).convert(nodeType);\n      }\n    } else {\n      output = float(0);\n    }\n    return output;\n  }\n}\n\n/**\n * TSL function for creating a range node.\n *\n * @function\n * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n * @returns {RangeNode}\n */\nconst range = /*@__PURE__*/nodeProxy(RangeNode);\n\n/** @module ComputeBuiltinNode **/\n\n/**\n * `ComputeBuiltinNode` represents a compute-scope builtin value that expose information\n * about the currently running dispatch and/or the device it is running on.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass ComputeBuiltinNode extends Node {\n  static get type() {\n    return 'ComputeBuiltinNode';\n  }\n\n  /**\n   * Constructs a new compute builtin node.\n   *\n   * @param {String} builtinName - The built-in name.\n   * @param {String} nodeType - The node type.\n   */\n  constructor(builtinName, nodeType) {\n    super(nodeType);\n\n    /**\n     * The built-in name.\n     *\n     * @private\n     * @type {String}\n     */\n    this._builtinName = builtinName;\n  }\n\n  /**\n   * This method is overwritten since hash is derived from the built-in name.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The hash.\n   */\n  getHash(builder) {\n    return this.getBuiltinName(builder);\n  }\n\n  /**\n   * This method is overwritten since the node type is simply derived from `nodeType`..\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(/*builder*/\n  ) {\n    return this.nodeType;\n  }\n\n  /**\n   * Sets the builtin name.\n   *\n   * @param {String} builtinName - The built-in name.\n   * @return {ComputeBuiltinNode} A reference to this node.\n   */\n  setBuiltinName(builtinName) {\n    this._builtinName = builtinName;\n    return this;\n  }\n\n  /**\n   * Returns the builtin name.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The builtin name.\n   */\n  getBuiltinName(/*builder*/\n  ) {\n    return this._builtinName;\n  }\n\n  /**\n   * Whether the current node builder has the builtin or not.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  hasBuiltin(builder) {\n    builder.hasBuiltin(this._builtinName);\n  }\n  generate(builder, output) {\n    const builtinName = this.getBuiltinName(builder);\n    const nodeType = this.getNodeType(builder);\n    if (builder.shaderStage === 'compute') {\n      return builder.format(builtinName, nodeType, output);\n    } else {\n      console.warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);\n      return builder.generateConst(nodeType);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.global = this.global;\n    data._builtinName = this._builtinName;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.global = data.global;\n    this._builtinName = data._builtinName;\n  }\n}\n\n/**\n * TSL function for creating a compute builtin node.\n *\n * @function\n * @param {String} name - The built-in name.\n * @param {String} nodeType - The node type.\n * @returns {ComputeBuiltinNode}\n */\nconst computeBuiltin = (name, nodeType) => nodeObject(new ComputeBuiltinNode(name, nodeType));\n\n/**\n * TSL function for creating a `numWorkgroups` builtin node.\n * Represents the number of workgroups dispatched by the compute shader.\n * ```js\n * // Run 512 invocations/threads with a workgroup size of 128.\n * const computeFn = Fn(() => {\n *\n *     // numWorkgroups.x = 4\n *     storageBuffer.element(0).assign(numWorkgroups.x)\n *\n * })().compute(512, [128]);\n *\n * // Run 512 invocations/threads with the default workgroup size of 64.\n * const computeFn = Fn(() => {\n *\n *     // numWorkgroups.x = 8\n *     storageBuffer.element(0).assign(numWorkgroups.x)\n *\n * })().compute(512);\n * ```\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst numWorkgroups = /*@__PURE__*/computeBuiltin('numWorkgroups', 'uvec3');\n\n/**\n * TSL function for creating a `workgroupId` builtin node.\n * Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.\n * ```js\n * // Execute 12 compute threads with a workgroup size of 3.\n * const computeFn = Fn( () => {\n *\n * \tIf( workgroupId.x.modInt( 2 ).equal( 0 ), () => {\n *\n * \t\tstorageBuffer.element( instanceIndex ).assign( instanceIndex );\n *\n * \t} ).Else( () => {\n *\n * \t\tstorageBuffer.element( instanceIndex ).assign( 0 );\n *\n * \t} );\n *\n * } )().compute( 12, [ 3 ] );\n *\n * // workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];\n * // Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];\n * ```\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst workgroupId = /*@__PURE__*/computeBuiltin('workgroupId', 'uvec3');\n\n/**\n * TSL function for creating a `localId` builtin node. A non-linearized 3-dimensional\n * representation of the current invocation's position within a 3D workgroup grid.\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst localId = /*@__PURE__*/computeBuiltin('localId', 'uvec3');\n\n/**\n * TSL function for creating a `subgroupSize` builtin node. A device dependent variable\n * that exposes the size of the current invocation's subgroup.\n *\n * @function\n * @returns {ComputeBuiltinNode<uint>}\n */\nconst subgroupSize = /*@__PURE__*/computeBuiltin('subgroupSize', 'uint');\n\n/** @module BarrierNode **/\n\n/**\n * Represents a GPU control barrier that synchronizes compute operations within a given scope.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass BarrierNode extends Node {\n  /**\n   * Constructs a new barrier node.\n   *\n   * @param {String} scope - The scope defines the behavior of the node.\n   */\n  constructor(scope) {\n    super();\n    this.scope = scope;\n  }\n  generate(builder) {\n    const {\n      scope\n    } = this;\n    const {\n      renderer\n    } = builder;\n    if (renderer.backend.isWebGLBackend === true) {\n      builder.addFlowCode(`\\t// ${scope}Barrier \\n`);\n    } else {\n      builder.addLineFlowCode(`${scope}Barrier()`, this);\n    }\n  }\n}\n\n/**\n * TSL function for creating a barrier node.\n *\n * @function\n * @param {String} scope - The scope defines the behavior of the node..\n * @returns {BarrierNode}\n */\nconst barrier = nodeProxy(BarrierNode);\n\n/**\n * TSL function for creating a workgroup barrier. All compute shader\n * invocations must wait for each invocation within a workgroup to\n * complete before the barrier can be surpassed.\n *\n * @function\n * @returns {BarrierNode}\n */\nconst workgroupBarrier = () => barrier('workgroup').append();\n\n/**\n * TSL function for creating a storage barrier. All invocations must\n * wait for each access to variables within the 'storage' address space\n * to complete before the barrier can be passed.\n *\n * @function\n * @returns {BarrierNode}\n */\nconst storageBarrier = () => barrier('storage').append();\n\n/**\n * TSL function for creating a texture barrier. All invocations must\n * wait for each access to variables within the 'texture' address space\n * to complete before the barrier can be passed.\n *\n * @function\n * @returns {BarrierNode}\n */\nconst textureBarrier = () => barrier('texture').append();\n\n/** @module WorkgroupInfoNode **/\n\n/**\n * Represents an element of a 'workgroup' scoped buffer.\n *\n * @augments ArrayElementNode\n */\nclass WorkgroupInfoElementNode extends ArrayElementNode {\n  /**\n   * Constructs a new workgroup info element node.\n   *\n   * @param {Node} workgroupInfoNode - The workgroup info node.\n   * @param {Node} indexNode - The index node that defines the element access.\n   */\n  constructor(workgroupInfoNode, indexNode) {\n    super(workgroupInfoNode, indexNode);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isWorkgroupInfoElementNode = true;\n  }\n  generate(builder, output) {\n    let snippet;\n    const isAssignContext = builder.context.assign;\n    snippet = super.generate(builder);\n    if (isAssignContext !== true) {\n      const type = this.getNodeType(builder);\n      snippet = builder.format(snippet, type, output);\n    }\n\n    // TODO: Possibly activate clip distance index on index access rather than from clipping context\n\n    return snippet;\n  }\n}\n\n/**\n * A node allowing the user to create a 'workgroup' scoped buffer within the\n * context of a compute shader. Typically, workgroup scoped buffers are\n * created to hold data that is transfered from a global storage scope into\n * a local workgroup scope. For invocations within a workgroup, data\n * access speeds on 'workgroup' scoped buffers can be significantly faster\n * than similar access operations on globally accessible storage buffers.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass WorkgroupInfoNode extends Node {\n  /**\n   * Constructs a new buffer scoped to type scope.\n   *\n   * @param {String} scope - TODO.\n   * @param {String} bufferType - The data type of a 'workgroup' scoped buffer element.\n   * @param {Number} [bufferCount=0] - The number of elements in the buffer.\n   */\n  constructor(scope, bufferType, bufferCount = 0) {\n    super(bufferType);\n\n    /**\n     * The buffer type.\n     *\n     * @type {String}\n     */\n    this.bufferType = bufferType;\n\n    /**\n     * The buffer count.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.bufferCount = bufferCount;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isWorkgroupInfoNode = true;\n\n    /**\n     * The data type of the array buffer.\n     *\n     * @type {String}\n     */\n    this.elementType = bufferType;\n\n    /**\n     * TODO.\n     *\n     * @type {String}\n     */\n    this.scope = scope;\n  }\n\n  /**\n   * Sets the name/label of this node.\n   *\n   * @param {String} name - The name to set.\n   * @return {WorkgroupInfoNode} A reference to this node.\n   */\n  label(name) {\n    this.name = name;\n    return this;\n  }\n\n  /**\n   * Sets the scope of this node.\n   *\n   * @param {String} scope - The scope to set.\n   * @return {WorkgroupInfoNode} A reference to this node.\n   */\n  setScope(scope) {\n    this.scope = scope;\n    return this;\n  }\n\n  /**\n   * The data type of the array buffer.\n   *\n   * @return {String} The element type.\n   */\n  getElementType() {\n    return this.elementType;\n  }\n\n  /**\n   * Overwrites the default implementation since the input type\n   * is inferred from the scope.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(/*builder*/\n  ) {\n    return `${this.scope}Array`;\n  }\n\n  /**\n   * This method can be used to access elements via an index node.\n   *\n   * @param {IndexNode} indexNode - indexNode.\n   * @return {WorkgroupInfoElementNode} A reference to an element.\n   */\n  element(indexNode) {\n    return nodeObject(new WorkgroupInfoElementNode(this, indexNode));\n  }\n  generate(builder) {\n    return builder.getScopedArray(this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount);\n  }\n}\n\n/**\n * TSL function for creating a workgroup info node.\n * Creates a new 'workgroup' scoped array buffer.\n *\n * @function\n * @param {String} type - The data type of a 'workgroup' scoped buffer element.\n * @param {Number} [count=0] - The number of elements in the buffer.\n * @returns {WorkgroupInfoNode}\n */\nconst workgroupArray = (type, count) => nodeObject(new WorkgroupInfoNode('Workgroup', type, count));\n\n/** @module AtomicFunctionNode **/\n\n/**\n * `AtomicFunctionNode` represents any function that can operate on atomic variable types\n * within a shader. In an atomic function, any modifiation to an atomic variable will\n * occur as an indivisble step with a defined order relative to other modifications.\n * Accordingly, even if multiple atomic functions are modifying an atomic variable at once\n * atomic operations will not interfer with each other.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments TempNode\n */\nclass AtomicFunctionNode extends TempNode {\n  static get type() {\n    return 'AtomicFunctionNode';\n  }\n\n  /**\n   * Constructs a new atomic function node.\n   *\n   * @param {String} method - The signature of the atomic function to construct.\n   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n   * @param {Node} valueNode - The value that mutates the atomic variable.\n   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n   */\n  constructor(method, pointerNode, valueNode, storeNode = null) {\n    super('uint');\n\n    /**\n     * The signature of the atomic function to construct.\n     *\n     * @type {String}\n     */\n    this.method = method;\n\n    /**\n     * An atomic variable or element of an atomic buffer.\n     *\n     * @type {Node}\n     */\n    this.pointerNode = pointerNode;\n\n    /**\n     * A value that modifies the atomic variable.\n     *\n     * @type {Node}\n     */\n    this.valueNode = valueNode;\n\n    /**\n     * A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.storeNode = storeNode;\n  }\n\n  /**\n   * Overwrites the default implementation to return the type of\n   * the pointer node.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The input type.\n   */\n  getInputType(builder) {\n    return this.pointerNode.getNodeType(builder);\n  }\n\n  /**\n   * Overwritten since the node type is inferred from the input type.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   * @return {String} The node type.\n   */\n  getNodeType(builder) {\n    return this.getInputType(builder);\n  }\n  generate(builder) {\n    const method = this.method;\n    const type = this.getNodeType(builder);\n    const inputType = this.getInputType(builder);\n    const a = this.pointerNode;\n    const b = this.valueNode;\n    const params = [];\n    params.push(`&${a.build(builder, inputType)}`);\n    params.push(b.build(builder, inputType));\n    const methodSnippet = `${builder.getMethod(method, type)}( ${params.join(', ')} )`;\n    if (this.storeNode !== null) {\n      const varSnippet = this.storeNode.build(builder, inputType);\n      builder.addLineFlowCode(`${varSnippet} = ${methodSnippet}`, this);\n    } else {\n      builder.addLineFlowCode(methodSnippet, this);\n    }\n  }\n}\nAtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';\nAtomicFunctionNode.ATOMIC_STORE = 'atomicStore';\nAtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';\nAtomicFunctionNode.ATOMIC_SUB = 'atomicSub';\nAtomicFunctionNode.ATOMIC_MAX = 'atomicMax';\nAtomicFunctionNode.ATOMIC_MIN = 'atomicMin';\nAtomicFunctionNode.ATOMIC_AND = 'atomicAnd';\nAtomicFunctionNode.ATOMIC_OR = 'atomicOr';\nAtomicFunctionNode.ATOMIC_XOR = 'atomicXor';\n\n/**\n * TSL function for creating an atomic function node.\n *\n * @function\n * @param {String} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicNode = nodeProxy(AtomicFunctionNode);\n\n/**\n * TSL function for appending an atomic function call into the programmatic flow of a compute shader.\n *\n * @function\n * @param {String} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicFunc = (method, pointerNode, valueNode, storeNode = null) => {\n  const node = atomicNode(method, pointerNode, valueNode, storeNode);\n  node.append();\n  return node;\n};\n\n/**\n * Stores a value in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicStore = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode);\n\n/**\n * Increments the value stored in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicAdd = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode);\n\n/**\n * Decrements the value stored in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicSub = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode);\n\n/**\n * Stores in an atomic variable the maximum between its current value and a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicMax = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode);\n\n/**\n * Stores in an atomic variable the minimum between its current value and a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicMin = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode);\n\n/**\n * Stores in an atomic variable the bitwise AND of its value with a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicAnd = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode);\n\n/**\n * Stores in an atomic variable the bitwise OR of its value with a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicOr = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode);\n\n/**\n * Stores in an atomic variable the bitwise XOR of its value with a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicXor = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode);\n\n/** @module Lights **/\n\nlet uniformsLib;\nfunction getLightData(light) {\n  uniformsLib = uniformsLib || new WeakMap();\n  let uniforms = uniformsLib.get(light);\n  if (uniforms === undefined) uniformsLib.set(light, uniforms = {});\n  return uniforms;\n}\n\n/**\n * TSL function for getting a shadow matrix uniform node for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<mat4>} The shadow matrix uniform node.\n */\nfunction lightShadowMatrix(light) {\n  const data = getLightData(light);\n  return data.shadowMatrix || (data.shadowMatrix = uniform('mat4').setGroup(renderGroup).onRenderUpdate(() => {\n    if (light.castShadow !== true) {\n      light.shadow.updateMatrices(light);\n    }\n    return light.shadow.matrix;\n  }));\n}\n\n/**\n * TSL function for getting projected uv coordinates for the given light.\n * Relevant when using maps with spot lights.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {Node<vec3>} The projected uvs.\n */\nfunction lightProjectionUV(light) {\n  const data = getLightData(light);\n  if (data.projectionUV === undefined) {\n    const spotLightCoord = lightShadowMatrix(light).mul(positionWorld);\n    data.projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);\n  }\n  return data.projectionUV;\n}\n\n/**\n * TSL function for getting the position in world space for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light's position in world space.\n */\nfunction lightPosition(light) {\n  const data = getLightData(light);\n  return data.position || (data.position = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self) => self.value.setFromMatrixPosition(light.matrixWorld)));\n}\n\n/**\n * TSL function for getting the light target position in world space for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light target position in world space.\n */\nfunction lightTargetPosition(light) {\n  const data = getLightData(light);\n  return data.targetPosition || (data.targetPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self) => self.value.setFromMatrixPosition(light.target.matrixWorld)));\n}\n\n/**\n * TSL function for getting the position in view space for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light's position in view space.\n */\nfunction lightViewPosition(light) {\n  const data = getLightData(light);\n  return data.viewPosition || (data.viewPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate(({\n    camera\n  }, self) => {\n    self.value = self.value || new Vector3();\n    self.value.setFromMatrixPosition(light.matrixWorld);\n    self.value.applyMatrix4(camera.matrixWorldInverse);\n  }));\n}\n\n/**\n * TSL function for getting the light target direction for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {Node<vec3>} The light's target direction.\n */\nconst lightTargetDirection = light => cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosition(light)));\n\n/** @module LightsNode **/\n\nconst sortLights = lights => {\n  return lights.sort((a, b) => a.id - b.id);\n};\nconst getLightNodeById = (id, lightNodes) => {\n  for (const lightNode of lightNodes) {\n    if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {\n      return lightNode;\n    }\n  }\n  return null;\n};\nconst _lightsNodeRef = /*@__PURE__*/new WeakMap();\n\n/**\n * This node represents the scene's lighting and manages the lighting model's life cycle\n * for the current build 3D object. It is responsible for computing the total outgoing\n * light in a given lighting context.\n *\n * @augments Node\n */\nclass LightsNode extends Node {\n  static get type() {\n    return 'LightsNode';\n  }\n\n  /**\n   * Constructs a new lights node.\n   */\n  constructor() {\n    super('vec3');\n\n    /**\n     * A node representing the total diffuse light.\n     *\n     * @type {Node<vec3>}\n     */\n    this.totalDiffuseNode = vec3().toVar('totalDiffuse');\n\n    /**\n     * A node representing the total specular light.\n     *\n     * @type {Node<vec3>}\n     */\n    this.totalSpecularNode = vec3().toVar('totalSpecular');\n\n    /**\n     * A node representing the outgoing light.\n     *\n     * @type {Node<vec3>}\n     */\n    this.outgoingLightNode = vec3().toVar('outgoingLight');\n\n    /**\n     * An array representing the lights in the scene.\n     *\n     * @private\n     * @type {Array<Light>}\n     */\n    this._lights = [];\n\n    /**\n     * For each light in the scene, this node will create a\n     * corresponding light node.\n     *\n     * @private\n     * @type {Array<LightingNode>?}\n     * @default null\n     */\n    this._lightNodes = null;\n\n    /**\n     * A hash for identifying the current light nodes setup.\n     *\n     * @private\n     * @type {String?}\n     * @default null\n     */\n    this._lightNodesHash = null;\n\n    /**\n     * `LightsNode` sets this property to `true` by default.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.global = true;\n  }\n\n  /**\n   * Overwrites the default {@link Node#customCacheKey} implementation by including the\n   * light IDs into the cache key.\n   *\n   * @return {Number} The custom cache key.\n   */\n  customCacheKey() {\n    const lightIDs = [];\n    const lights = this._lights;\n    for (let i = 0; i < lights.length; i++) {\n      lightIDs.push(lights[i].id);\n    }\n    return hashArray(lightIDs);\n  }\n\n  /**\n   * Computes a hash value for identifying the current light nodes setup.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @return {String} The computed hash.\n   */\n  getHash(builder) {\n    if (this._lightNodesHash === null) {\n      if (this._lightNodes === null) this.setupLightsNode(builder);\n      const hash = [];\n      for (const lightNode of this._lightNodes) {\n        hash.push(lightNode.getSelf().getHash());\n      }\n      this._lightNodesHash = 'lights-' + hash.join(',');\n    }\n    return this._lightNodesHash;\n  }\n  analyze(builder) {\n    const properties = builder.getDataFromNode(this);\n    for (const node of properties.nodes) {\n      node.build(builder);\n    }\n  }\n\n  /**\n   * Creates lighting nodes for each scene light. This makes it possible to further\n   * process lights in the node system.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   */\n  setupLightsNode(builder) {\n    const lightNodes = [];\n    const previousLightNodes = this._lightNodes;\n    const lights = sortLights(this._lights);\n    const nodeLibrary = builder.renderer.library;\n    for (const light of lights) {\n      if (light.isNode) {\n        lightNodes.push(nodeObject(light));\n      } else {\n        let lightNode = null;\n        if (previousLightNodes !== null) {\n          lightNode = getLightNodeById(light.id, previousLightNodes); // reuse existing light node\n        }\n        if (lightNode === null) {\n          // find the corresponding node type for a given light\n\n          const lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);\n          if (lightNodeClass === null) {\n            console.warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);\n            continue;\n          }\n          let lightNode = null;\n          if (!_lightsNodeRef.has(light)) {\n            lightNode = nodeObject(new lightNodeClass(light));\n            _lightsNodeRef.set(light, lightNode);\n          } else {\n            lightNode = _lightsNodeRef.get(light);\n          }\n          lightNodes.push(lightNode);\n        }\n      }\n    }\n    this._lightNodes = lightNodes;\n  }\n\n  /**\n   * Setups the internal lights by building all respective\n   * light nodes.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.\n   */\n  setupLights(builder, lightNodes) {\n    for (const lightNode of lightNodes) {\n      lightNode.build(builder);\n    }\n  }\n\n  /**\n   * The implementation makes sure that for each light in the scene\n   * there is a corresponding light node. By building the light nodes\n   * and evaluating the lighting model the outgoing light is computed.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @return {Node<vec3>} A node representing the outgoing light.\n   */\n  setup(builder) {\n    if (this._lightNodes === null) this.setupLightsNode(builder);\n    const context = builder.context;\n    const lightingModel = context.lightingModel;\n    let outgoingLightNode = this.outgoingLightNode;\n    if (lightingModel) {\n      const {\n        _lightNodes,\n        totalDiffuseNode,\n        totalSpecularNode\n      } = this;\n      context.outgoingLight = outgoingLightNode;\n      const stack = builder.addStack();\n\n      //\n\n      const properties = builder.getDataFromNode(this);\n      properties.nodes = stack.nodes;\n\n      //\n\n      lightingModel.start(context, stack, builder);\n\n      // lights\n\n      this.setupLights(builder, _lightNodes);\n\n      //\n\n      lightingModel.indirect(context, stack, builder);\n\n      //\n\n      const {\n        backdrop,\n        backdropAlpha\n      } = context;\n      const {\n        directDiffuse,\n        directSpecular,\n        indirectDiffuse,\n        indirectSpecular\n      } = context.reflectedLight;\n      let totalDiffuse = directDiffuse.add(indirectDiffuse);\n      if (backdrop !== null) {\n        if (backdropAlpha !== null) {\n          totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));\n        } else {\n          totalDiffuse = vec3(backdrop);\n        }\n        context.material.transparent = true;\n      }\n      totalDiffuseNode.assign(totalDiffuse);\n      totalSpecularNode.assign(directSpecular.add(indirectSpecular));\n      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));\n\n      //\n\n      lightingModel.finish(context, stack, builder);\n\n      //\n\n      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());\n    }\n    return outgoingLightNode;\n  }\n\n  /**\n   * Configures this node with an array of lights.\n   *\n   * @param {Array<Light>} lights - An array of lights.\n   * @return {LightsNode} A reference to this node.\n   */\n  setLights(lights) {\n    this._lights = lights;\n    this._lightNodes = null;\n    this._lightNodesHash = null;\n    return this;\n  }\n\n  /**\n   * Returns an array of the scene's lights.\n   *\n   * @return {Array<Light>} The scene's lights.\n   */\n  getLights() {\n    return this._lights;\n  }\n\n  /**\n   * Whether the scene has lights or not.\n   *\n   * @type {Boolean}\n   */\n  get hasLights() {\n    return this._lights.length > 0;\n  }\n}\n\n/**\n * TSL function for creating an instance of `LightsNode` and configuring\n * it with the given array of lights.\n *\n * @function\n * @param {Array<Light>} lights - An array of lights.\n * @return {LightsNode} The created lights node.\n */\nconst lights = (lights = []) => nodeObject(new LightsNode()).setLights(lights);\n\n/** @module ShadowBaseNode **/\n\n/**\n * Base class for all shadow nodes.\n *\n * Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.\n * Lighting nodes might share the same shadow node type or use specific ones depending on\n * their requirements.\n *\n * @augments Node\n */\nclass ShadowBaseNode extends Node {\n  static get type() {\n    return 'ShadowBaseNode';\n  }\n\n  /**\n   * Constructs a new shadow base node.\n   *\n   * @param {Light} light - The shadow casting light.\n   */\n  constructor(light) {\n    super();\n\n    /**\n     * The shadow casting light.\n     *\n     * @type {Light}\n     */\n    this.light = light;\n\n    /**\n     * Overwritten since shadows are updated by default per render.\n     *\n     * @type {String}\n     * @default 'render'\n     */\n    this.updateBeforeType = NodeUpdateType.RENDER;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isShadowBaseNode = true;\n  }\n\n  /**\n   * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.\n   *\n   * @param {(NodeBuilder|{Material})} object - A configuration object that must at least hold a material reference.\n   */\n  setupShadowPosition({\n    material\n  }) {\n    // Use assign inside an Fn()\n\n    shadowPositionWorld.assign(material.shadowPositionNode || positionWorld);\n  }\n\n  /**\n   * Can be called when the shadow isn't required anymore. That can happen when\n   * a lighting node stops casting shadows by setting {@link Object3D#castShadow}\n   * to `false`.\n   */\n  dispose() {\n    this.updateBeforeType = NodeUpdateType.NONE;\n  }\n}\n\n/**\n * TSL object that represents the vertex position in world space during the shadow pass.\n *\n * @type {Node<vec3>}\n */\nconst shadowPositionWorld = /*@__PURE__*/vec3().toVar('shadowPositionWorld');\n\n/** @module RendererUtils **/\n\n/**\n * Saves the state of the given renderer and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveRendererState(renderer, state = {}) {\n  state.toneMapping = renderer.toneMapping;\n  state.toneMappingExposure = renderer.toneMappingExposure;\n  state.outputColorSpace = renderer.outputColorSpace;\n  state.renderTarget = renderer.getRenderTarget();\n  state.activeCubeFace = renderer.getActiveCubeFace();\n  state.activeMipmapLevel = renderer.getActiveMipmapLevel();\n  state.renderObjectFunction = renderer.getRenderObjectFunction();\n  state.pixelRatio = renderer.getPixelRatio();\n  state.mrt = renderer.getMRT();\n  state.clearColor = renderer.getClearColor(state.clearColor || new Color());\n  state.clearAlpha = renderer.getClearAlpha();\n  state.autoClear = renderer.autoClear;\n  state.scissorTest = renderer.getScissorTest();\n  return state;\n}\n\n/**\n * Saves the state of the given renderer and stores it into the given state object.\n * Besides, the function also resets the state of the renderer to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetRendererState(renderer, state) {\n  state = saveRendererState(renderer, state);\n  renderer.setMRT(null);\n  renderer.setRenderObjectFunction(null);\n  renderer.setClearColor(0x000000, 1);\n  renderer.autoClear = true;\n  return state;\n}\n\n/**\n * Restores the state of the given renderer from the given state object.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} state - The state to restore.\n */\nfunction restoreRendererState(renderer, state) {\n  renderer.toneMapping = state.toneMapping;\n  renderer.toneMappingExposure = state.toneMappingExposure;\n  renderer.outputColorSpace = state.outputColorSpace;\n  renderer.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);\n  renderer.setRenderObjectFunction(state.renderObjectFunction);\n  renderer.setPixelRatio(state.pixelRatio);\n  renderer.setMRT(state.mrt);\n  renderer.setClearColor(state.clearColor, state.clearAlpha);\n  renderer.autoClear = state.autoClear;\n  renderer.setScissorTest(state.scissorTest);\n}\n\n/**\n * Saves the state of the given scene and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveSceneState(scene, state = {}) {\n  state.background = scene.background;\n  state.backgroundNode = scene.backgroundNode;\n  state.overrideMaterial = scene.overrideMaterial;\n  return state;\n}\n\n/**\n * Saves the state of the given scene and stores it into the given state object.\n * Besides, the function also resets the state of the scene to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetSceneState(scene, state) {\n  state = saveSceneState(scene, state);\n  scene.background = null;\n  scene.backgroundNode = null;\n  scene.overrideMaterial = null;\n  return state;\n}\n\n/**\n * Restores the state of the given scene from the given state object.\n *\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} state - The state to restore.\n */\nfunction restoreSceneState(scene, state) {\n  scene.background = state.background;\n  scene.backgroundNode = state.backgroundNode;\n  scene.overrideMaterial = state.overrideMaterial;\n}\n\n/**\n * Saves the state of the given renderer and scene and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveRendererAndSceneState(renderer, scene, state = {}) {\n  state = saveRendererState(renderer, state);\n  state = saveSceneState(scene, state);\n  return state;\n}\n\n/**\n * Saves the state of the given renderer and scene and stores it into the given state object.\n * Besides, the function also resets the state of the renderer and scene to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetRendererAndSceneState(renderer, scene, state) {\n  state = resetRendererState(renderer, state);\n  state = resetSceneState(scene, state);\n  return state;\n}\n\n/**\n * Restores the state of the given renderer and scene from the given state object.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} state - The state to restore.\n */\nfunction restoreRendererAndSceneState(renderer, scene, state) {\n  restoreRendererState(renderer, state);\n  restoreSceneState(scene, state);\n}\nvar RendererUtils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resetRendererAndSceneState: resetRendererAndSceneState,\n  resetRendererState: resetRendererState,\n  resetSceneState: resetSceneState,\n  restoreRendererAndSceneState: restoreRendererAndSceneState,\n  restoreRendererState: restoreRendererState,\n  restoreSceneState: restoreSceneState,\n  saveRendererAndSceneState: saveRendererAndSceneState,\n  saveRendererState: saveRendererState,\n  saveSceneState: saveSceneState\n});\n\n/** @module ShadowNode **/\n\nconst shadowMaterialLib = /*@__PURE__*/new WeakMap();\nconst linearDistance = /*@__PURE__*/Fn(([position, cameraNear, cameraFar]) => {\n  let dist = positionWorld.sub(position).length();\n  dist = dist.sub(cameraNear).div(cameraFar.sub(cameraNear));\n  dist = dist.saturate(); // clamp to [ 0, 1 ]\n\n  return dist;\n});\nconst linearShadowDistance = light => {\n  const camera = light.shadow.camera;\n  const nearDistance = reference('near', 'float', camera).setGroup(renderGroup);\n  const farDistance = reference('far', 'float', camera).setGroup(renderGroup);\n  const referencePosition = objectPosition(light);\n  return linearDistance(referencePosition, nearDistance, farDistance);\n};\nconst getShadowMaterial = light => {\n  let material = shadowMaterialLib.get(light);\n  if (material === undefined) {\n    const depthNode = light.isPointLight ? linearShadowDistance(light) : null;\n    material = new NodeMaterial();\n    material.colorNode = vec4(0, 0, 0, 1);\n    material.depthNode = depthNode;\n    material.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode\n    material.name = 'ShadowMaterial';\n    material.fog = false;\n    shadowMaterialLib.set(light, material);\n  }\n  return material;\n};\n\n/**\n * A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map\n * with a binary `[0,1]` result.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nconst BasicShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  shadowCoord\n}) => {\n  return texture(depthTexture, shadowCoord.xy).compare(shadowCoord.z);\n});\n\n/**\n * A shadow filtering function performing PCF filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nconst PCFShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  shadowCoord,\n  shadow\n}) => {\n  const depthCompare = (uv, compare) => texture(depthTexture, uv).compare(compare);\n  const mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);\n  const radius = reference('radius', 'float', shadow).setGroup(renderGroup);\n  const texelSize = vec2(1).div(mapSize);\n  const dx0 = texelSize.x.negate().mul(radius);\n  const dy0 = texelSize.y.negate().mul(radius);\n  const dx1 = texelSize.x.mul(radius);\n  const dy1 = texelSize.y.mul(radius);\n  const dx2 = dx0.div(2);\n  const dy2 = dy0.div(2);\n  const dx3 = dx1.div(2);\n  const dy3 = dy1.div(2);\n  return add(depthCompare(shadowCoord.xy.add(vec2(dx0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx0, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, 0)), shadowCoord.z), depthCompare(shadowCoord.xy, shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, dy1)), shadowCoord.z)).mul(1 / 17);\n});\n\n/**\n * A shadow filtering function performing PCF soft filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nconst PCFSoftShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  shadowCoord,\n  shadow\n}) => {\n  const depthCompare = (uv, compare) => texture(depthTexture, uv).compare(compare);\n  const mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);\n  const texelSize = vec2(1).div(mapSize);\n  const dx = texelSize.x;\n  const dy = texelSize.y;\n  const uv = shadowCoord.xy;\n  const f = fract(uv.mul(mapSize).add(0.5));\n  uv.subAssign(f.mul(texelSize));\n  return add(depthCompare(uv, shadowCoord.z), depthCompare(uv.add(vec2(dx, 0)), shadowCoord.z), depthCompare(uv.add(vec2(0, dy)), shadowCoord.z), depthCompare(uv.add(texelSize), shadowCoord.z), mix(depthCompare(uv.add(vec2(dx.negate(), 0)), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), 0)), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(dx.negate(), dy)), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy)), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(0, dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(0, dy.mul(2))), shadowCoord.z), f.y), mix(depthCompare(uv.add(vec2(dx, dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(dx, dy.mul(2))), shadowCoord.z), f.y), mix(mix(depthCompare(uv.add(vec2(dx.negate(), dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(dx.negate(), dy.mul(2))), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy.mul(2))), shadowCoord.z), f.x), f.y)).mul(1 / 9);\n});\n\n/**\n * A shadow filtering function performing VSM filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nconst VSMShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  shadowCoord\n}) => {\n  const occlusion = float(1).toVar();\n  const distribution = texture(depthTexture).sample(shadowCoord.xy).rg;\n  const hardShadow = step(shadowCoord.z, distribution.x);\n  If(hardShadow.notEqual(float(1.0)), () => {\n    const distance = shadowCoord.z.sub(distribution.x);\n    const variance = max$1(0, distribution.y.mul(distribution.y));\n    let softnessProbability = variance.div(variance.add(distance.mul(distance))); // Chebeyshevs inequality\n    softnessProbability = clamp(sub(softnessProbability, 0.3).div(0.95 - 0.3));\n    occlusion.assign(clamp(max$1(hardShadow, softnessProbability)));\n  });\n  return occlusion;\n});\n\n/**\n * Represents the shader code for the first VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - A reference to the render target's depth data.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassVertical = /*@__PURE__*/Fn(({\n  samples,\n  radius,\n  size,\n  shadowPass\n}) => {\n  const mean = float(0).toVar();\n  const squaredMean = float(0).toVar();\n  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));\n  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));\n  Loop({\n    start: int(0),\n    end: int(samples),\n    type: 'int',\n    condition: '<'\n  }, ({\n    i\n  }) => {\n    const uvOffset = uvStart.add(float(i).mul(uvStride));\n    const depth = shadowPass.sample(add(screenCoordinate.xy, vec2(0, uvOffset).mul(radius)).div(size)).x;\n    mean.addAssign(depth);\n    squaredMean.addAssign(depth.mul(depth));\n  });\n  mean.divAssign(samples);\n  squaredMean.divAssign(samples);\n  const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));\n  return vec2(mean, std_dev);\n});\n\n/**\n * Represents the shader code for the second VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - The result of the first VSM render pass.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassHorizontal = /*@__PURE__*/Fn(({\n  samples,\n  radius,\n  size,\n  shadowPass\n}) => {\n  const mean = float(0).toVar();\n  const squaredMean = float(0).toVar();\n  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));\n  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));\n  Loop({\n    start: int(0),\n    end: int(samples),\n    type: 'int',\n    condition: '<'\n  }, ({\n    i\n  }) => {\n    const uvOffset = uvStart.add(float(i).mul(uvStride));\n    const distribution = shadowPass.sample(add(screenCoordinate.xy, vec2(uvOffset, 0).mul(radius)).div(size));\n    mean.addAssign(distribution.x);\n    squaredMean.addAssign(add(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));\n  });\n  mean.divAssign(samples);\n  squaredMean.divAssign(samples);\n  const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));\n  return vec2(mean, std_dev);\n});\nconst _shadowFilterLib = [BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter];\n\n//\n\nlet _rendererState;\nconst _quadMesh$1 = /*@__PURE__*/new QuadMesh();\n\n/**\n * Represents the default shadow implementation for lighting nodes.\n *\n * @augments module:ShadowBaseNode~ShadowBaseNode\n */\nclass ShadowNode extends ShadowBaseNode {\n  static get type() {\n    return 'ShadowNode';\n  }\n\n  /**\n   * Constructs a new shadow node.\n   *\n   * @param {Light} light - The shadow casting light.\n   * @param {LightShadow?} [shadow=null] - An optional light shadow.\n   */\n  constructor(light, shadow = null) {\n    super(light);\n\n    /**\n     * The light shadow which defines the properties light's\n     * shadow.\n     *\n     * @type {LightShadow?}\n     * @default null\n     */\n    this.shadow = shadow || light.shadow;\n\n    /**\n     * A reference to the shadow map which is a render target.\n     *\n     * @type {RenderTarget?}\n     * @default null\n     */\n    this.shadowMap = null;\n\n    /**\n     * Only relevant for VSM shadows. Render target for the\n     * first VSM render pass.\n     *\n     * @type {RenderTarget?}\n     * @default null\n     */\n    this.vsmShadowMapVertical = null;\n\n    /**\n     * Only relevant for VSM shadows. Render target for the\n     * second VSM render pass.\n     *\n     * @type {RenderTarget?}\n     * @default null\n     */\n    this.vsmShadowMapHorizontal = null;\n\n    /**\n     * Only relevant for VSM shadows. Node material which\n     * is used to render the first VSM pass.\n     *\n     * @type {NodeMaterial?}\n     * @default null\n     */\n    this.vsmMaterialVertical = null;\n\n    /**\n     * Only relevant for VSM shadows. Node material which\n     * is used to render the second VSM pass.\n     *\n     * @type {NodeMaterial?}\n     * @default null\n     */\n    this.vsmMaterialHorizontal = null;\n\n    /**\n     * A reference to the output node which defines the\n     * final result of this shadow node.\n     *\n     * @type {Node?}\n     * @private\n     * @default null\n     */\n    this._node = null;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isShadowNode = true;\n  }\n\n  /**\n   * Setups the shadow filtering.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @param {Object} inputs - A configuration object that defines the shadow filtering.\n   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n   * @param {LightShadow} inputs.shadow - The light shadow.\n   * @return {Node<float>} The result node of the shadow filtering.\n   */\n  setupShadowFilter(builder, {\n    filterFn,\n    depthTexture,\n    shadowCoord,\n    shadow\n  }) {\n    const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));\n    const shadowNode = filterFn({\n      depthTexture,\n      shadowCoord,\n      shadow\n    });\n    return frustumTest.select(shadowNode, float(1));\n  }\n\n  /**\n   * Setups the shadow coordinates.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n   * @return {Node<vec3>} The shadow coordinates.\n   */\n  setupShadowCoord(builder, shadowPosition) {\n    const {\n      shadow\n    } = this;\n    const {\n      renderer\n    } = builder;\n    const bias = reference('bias', 'float', shadow).setGroup(renderGroup);\n    let shadowCoord = shadowPosition;\n    let coordZ;\n    if (shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true) {\n      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n      coordZ = shadowCoord.z;\n      if (renderer.coordinateSystem === WebGPUCoordinateSystem) {\n        coordZ = coordZ.mul(2).sub(1); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]\n      }\n    } else {\n      const w = shadowCoord.w;\n      shadowCoord = shadowCoord.xy.div(w); // <-- Only divide X/Y coords since we don't need Z\n\n      // The normally available \"cameraNear\" and \"cameraFar\" nodes cannot be used here because they do not get\n      // updated to use the shadow camera. So, we have to declare our own \"local\" ones here.\n      // TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?\n      const cameraNearLocal = reference('near', 'float', shadow.camera).setGroup(renderGroup);\n      const cameraFarLocal = reference('far', 'float', shadow.camera).setGroup(renderGroup);\n      coordZ = viewZToLogarithmicDepth(w.negate(), cameraNearLocal, cameraFarLocal);\n    }\n    shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(),\n    // follow webgpu standards\n    coordZ.add(bias));\n    return shadowCoord;\n  }\n\n  /**\n   * Returns the shadow filtering function for the given shadow type.\n   *\n   * @param {Number} type - The shadow type.\n   * @return {Function} The filtering function.\n   */\n  getShadowFilterFn(type) {\n    return _shadowFilterLib[type];\n  }\n\n  /**\n   * Setups the shadow output node.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @return {Node<vec3>} The shadow output node.\n   */\n  setupShadow(builder) {\n    const {\n      renderer\n    } = builder;\n    const {\n      light,\n      shadow\n    } = this;\n    const shadowMapType = renderer.shadowMap.type;\n    const depthTexture = new DepthTexture(shadow.mapSize.width, shadow.mapSize.height);\n    depthTexture.compareFunction = LessCompare;\n    const shadowMap = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height);\n    shadowMap.depthTexture = depthTexture;\n    shadow.camera.updateProjectionMatrix();\n\n    // VSM\n\n    if (shadowMapType === VSMShadowMap) {\n      depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()\n\n      this.vsmShadowMapVertical = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, {\n        format: RGFormat,\n        type: HalfFloatType\n      });\n      this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, {\n        format: RGFormat,\n        type: HalfFloatType\n      });\n      const shadowPassVertical = texture(depthTexture);\n      const shadowPassHorizontal = texture(this.vsmShadowMapVertical.texture);\n      const samples = reference('blurSamples', 'float', shadow).setGroup(renderGroup);\n      const radius = reference('radius', 'float', shadow).setGroup(renderGroup);\n      const size = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);\n      let material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());\n      material.fragmentNode = VSMPassVertical({\n        samples,\n        radius,\n        size,\n        shadowPass: shadowPassVertical\n      }).context(builder.getSharedContext());\n      material.name = 'VSMVertical';\n      material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());\n      material.fragmentNode = VSMPassHorizontal({\n        samples,\n        radius,\n        size,\n        shadowPass: shadowPassHorizontal\n      }).context(builder.getSharedContext());\n      material.name = 'VSMHorizontal';\n    }\n\n    //\n\n    const shadowIntensity = reference('intensity', 'float', shadow).setGroup(renderGroup);\n    const normalBias = reference('normalBias', 'float', shadow).setGroup(renderGroup);\n    const shadowPosition = lightShadowMatrix(light).mul(shadowPositionWorld.add(transformedNormalWorld.mul(normalBias)));\n    const shadowCoord = this.setupShadowCoord(builder, shadowPosition);\n\n    //\n\n    const filterFn = shadow.filterNode || this.getShadowFilterFn(renderer.shadowMap.type) || null;\n    if (filterFn === null) {\n      throw new Error('THREE.WebGPURenderer: Shadow map type not supported yet.');\n    }\n    const shadowDepthTexture = shadowMapType === VSMShadowMap ? this.vsmShadowMapHorizontal.texture : depthTexture;\n    const shadowNode = this.setupShadowFilter(builder, {\n      filterFn,\n      shadowTexture: shadowMap.texture,\n      depthTexture: shadowDepthTexture,\n      shadowCoord,\n      shadow\n    });\n    const shadowColor = texture(shadowMap.texture, shadowCoord);\n    const shadowOutput = mix(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();\n    this.shadowMap = shadowMap;\n    this.shadow.map = shadowMap;\n    return shadowOutput;\n  }\n\n  /**\n   * The implementation performs the setup of the output node. An output is only\n   * produces if shadow mapping is globally enabled in the renderer.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @return {ShaderCallNodeInternal} The output node.\n   */\n  setup(builder) {\n    if (builder.renderer.shadowMap.enabled === false) return;\n    return Fn(() => {\n      let node = this._node;\n      this.setupShadowPosition(builder);\n      if (node === null) {\n        this._node = node = this.setupShadow(builder);\n      }\n      if (builder.material.shadowNode) {\n        // @deprecated, r171\n\n        console.warn('THREE.NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.');\n      }\n      if (builder.material.receivedShadowNode) {\n        node = builder.material.receivedShadowNode(node);\n      }\n      return node;\n    })();\n  }\n\n  /**\n   * Renders the shadow. The logic of this function could be included\n   * into {@link ShadowNode#updateShadow} however more specialized shadow\n   * nodes might require a custom shadow map rendering. By having a\n   * dedicated method, it's easier to overwrite the default behavior.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  renderShadow(frame) {\n    const {\n      shadow,\n      shadowMap,\n      light\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    shadow.updateMatrices(light);\n    shadowMap.setSize(shadow.mapSize.width, shadow.mapSize.height);\n    renderer.render(scene, shadow.camera);\n  }\n\n  /**\n   * Updates the shadow.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  updateShadow(frame) {\n    const {\n      shadowMap,\n      light,\n      shadow\n    } = this;\n    const {\n      renderer,\n      scene,\n      camera\n    } = frame;\n    const shadowType = renderer.shadowMap.type;\n    const depthVersion = shadowMap.depthTexture.version;\n    this._depthVersionCached = depthVersion;\n    shadow.camera.layers.mask = camera.layers.mask;\n    const currentRenderObjectFunction = renderer.getRenderObjectFunction();\n    const currentMRT = renderer.getMRT();\n    const useVelocity = currentMRT ? currentMRT.has('velocity') : false;\n    _rendererState = resetRendererAndSceneState(renderer, scene, _rendererState);\n    scene.overrideMaterial = getShadowMaterial(light);\n    renderer.setRenderObjectFunction((object, scene, _camera, geometry, material, group, ...params) => {\n      if (object.castShadow === true || object.receiveShadow && shadowType === VSMShadowMap) {\n        if (useVelocity) {\n          getDataFromObject(object).useVelocity = true;\n        }\n        object.onBeforeShadow(renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group);\n        renderer.renderObject(object, scene, _camera, geometry, material, group, ...params);\n        object.onAfterShadow(renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group);\n      }\n    });\n    renderer.setRenderTarget(shadowMap);\n    this.renderShadow(frame);\n    renderer.setRenderObjectFunction(currentRenderObjectFunction);\n\n    // vsm blur pass\n\n    if (light.isPointLight !== true && shadowType === VSMShadowMap) {\n      this.vsmPass(renderer);\n    }\n    restoreRendererAndSceneState(renderer, scene, _rendererState);\n  }\n\n  /**\n   * For VSM additional render passes are required.\n   *\n   * @param {Renderer} renderer - A reference to the current renderer.\n   */\n  vsmPass(renderer) {\n    const {\n      shadow\n    } = this;\n    this.vsmShadowMapVertical.setSize(shadow.mapSize.width, shadow.mapSize.height);\n    this.vsmShadowMapHorizontal.setSize(shadow.mapSize.width, shadow.mapSize.height);\n    renderer.setRenderTarget(this.vsmShadowMapVertical);\n    _quadMesh$1.material = this.vsmMaterialVertical;\n    _quadMesh$1.render(renderer);\n    renderer.setRenderTarget(this.vsmShadowMapHorizontal);\n    _quadMesh$1.material = this.vsmMaterialHorizontal;\n    _quadMesh$1.render(renderer);\n  }\n\n  /**\n   * Frees the internal resources of this shadow node.\n   */\n  dispose() {\n    this.shadowMap.dispose();\n    this.shadowMap = null;\n    if (this.vsmShadowMapVertical !== null) {\n      this.vsmShadowMapVertical.dispose();\n      this.vsmShadowMapVertical = null;\n      this.vsmMaterialVertical.dispose();\n      this.vsmMaterialVertical = null;\n    }\n    if (this.vsmShadowMapHorizontal !== null) {\n      this.vsmShadowMapHorizontal.dispose();\n      this.vsmShadowMapHorizontal = null;\n      this.vsmMaterialHorizontal.dispose();\n      this.vsmMaterialHorizontal = null;\n    }\n    super.dispose();\n  }\n\n  /**\n   * The implementation performs the update of the shadow map if necessary.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  updateBefore(frame) {\n    const {\n      shadow\n    } = this;\n    const needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n    if (needsUpdate) {\n      this.updateShadow(frame);\n      if (this.shadowMap.depthTexture.version === this._depthVersionCached) {\n        shadow.needsUpdate = false;\n      }\n    }\n  }\n}\n\n/**\n * TSL function for creating an instance of `ShadowNode`.\n *\n * @function\n * @param {Light} light - The shadow casting light.\n * @param {LightShadow} shadow - The light shadow.\n * @return {ShadowNode} The created shadow node.\n */\nconst shadow = (light, shadow) => nodeObject(new ShadowNode(light, shadow));\n\n/**\n * Base class for analytic light nodes.\n *\n * @augments LightingNode\n */\nclass AnalyticLightNode extends LightingNode {\n  static get type() {\n    return 'AnalyticLightNode';\n  }\n\n  /**\n   * Constructs a new analytic light node.\n   *\n   * @param {Light?} [light=null] - The light source.\n   */\n  constructor(light = null) {\n    super();\n\n    /**\n     * The light source.\n     *\n     * @type {Light?}\n     * @default null\n     */\n    this.light = light;\n\n    /**\n     * The light's color value.\n     *\n     * @type {Color}\n     */\n    this.color = new Color();\n\n    /**\n     * The light's color node. Points to `colorNode` of the light source, if set. Otherwise\n     * it creates a uniform node based on {@link AnalyticLightNode#color}.\n     *\n     * @type {Node}\n     */\n    this.colorNode = light && light.colorNode || uniform(this.color).setGroup(renderGroup);\n\n    /**\n     * This property is used to retain a reference to the original value of {@link AnalyticLightNode#colorNode}.\n     * The final color node is represented by a different node when using shadows.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.baseColorNode = null;\n\n    /**\n     * Represents the light's shadow.\n     *\n     * @type {ShadowNode?}\n     \t\t * @default null\n     */\n    this.shadowNode = null;\n\n    /**\n     * Represents the light's shadow color.\n     *\n     * @type {Node?}\n     \t\t * @default null\n     */\n    this.shadowColorNode = null;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isAnalyticLightNode = true;\n\n    /**\n     * Overwritten since analytic light nodes are updated\n     * once per frame.\n     *\n     * @type {String}\n     * @default 'frame'\n     */\n    this.updateType = NodeUpdateType.FRAME;\n  }\n\n  /**\n   * Overwrites the default {@link Node#customCacheKey} implementation by including the\n   * `light.id` and `light.castShadow` into the cache key.\n   *\n   * @return {Number} The custom cache key.\n   */\n  customCacheKey() {\n    return hash$1(this.light.id, this.light.castShadow ? 1 : 0);\n  }\n  getHash() {\n    return this.light.uuid;\n  }\n\n  /**\n   * Setups the shadow node for this light. The method exists so concrete light classes\n   * can setup different types of shadow nodes.\n   *\n   * @return {ShadowNode} The created shadow node.\n   */\n  setupShadowNode() {\n    return shadow(this.light);\n  }\n\n  /**\n   * Setups the shadow for this light. This method is only executed if the light\n   * cast shadows and the current build object receives shadows. It incorporates\n   * shadows into the lighting computation.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setupShadow(builder) {\n    const {\n      renderer\n    } = builder;\n    if (renderer.shadowMap.enabled === false) return;\n    let shadowColorNode = this.shadowColorNode;\n    if (shadowColorNode === null) {\n      const customShadowNode = this.light.shadow.shadowNode;\n      let shadowNode;\n      if (customShadowNode !== undefined) {\n        shadowNode = nodeObject(customShadowNode);\n      } else {\n        shadowNode = this.setupShadowNode(builder);\n      }\n      this.shadowNode = shadowNode;\n      this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);\n      this.baseColorNode = this.colorNode;\n    }\n\n    //\n\n    this.colorNode = shadowColorNode;\n  }\n\n  /**\n   * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.\n   * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or\n   * invocate the respective interface methods.\n   *\n   * @param {NodeBuilder} builder - The current node builder.\n   */\n  setup(builder) {\n    this.colorNode = this.baseColorNode || this.colorNode;\n    if (this.light.castShadow) {\n      if (builder.object.receiveShadow) {\n        this.setupShadow(builder);\n      }\n    } else if (this.shadowNode !== null) {\n      this.shadowNode.dispose();\n      this.shadowNode = null;\n      this.shadowColorNode = null;\n    }\n  }\n\n  /**\n   * The update method is used to update light uniforms per frame.\n   * Potentially overwritten in concrete light nodes to update light\n   * specific uniforms.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update(/*frame*/\n  ) {\n    const {\n      light\n    } = this;\n    this.color.copy(light.color).multiplyScalar(light.intensity);\n  }\n}\n\n/** @module LightUtils **/\n\n/**\n * Represents a `discard` shader operation in TSL.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.lightDistance - The distance of the light's position to the current fragment position.\n * @param {Node<float>} inputs.cutoffDistance - The light's cutoff distance.\n * @param {Node<float>} inputs.decayExponent - The light's decay exponent.\n * @return {Node<float>} The distance falloff.\n */\nconst getDistanceAttenuation = /*@__PURE__*/Fn(inputs => {\n  const {\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  } = inputs;\n\n  // based upon Frostbite 3 Moving to Physically-based Rendering\n  // page 32, equation 26: E[window1]\n  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();\n  return cutoffDistance.greaterThan(0).select(distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()), distanceFalloff);\n}); // validated\n\n/** @module PointShadowNode **/\n\nconst _clearColor$2 = /*@__PURE__*/new Color();\n\n// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n// vector suitable for 2D texture mapping. This code uses the following layout for the\n// 2D texture:\n//\n// xzXZ\n//  y Y\n//\n// Y - Positive y direction\n// y - Negative y direction\n// X - Positive x direction\n// x - Negative x direction\n// Z - Positive z direction\n// z - Negative z direction\n//\n// Source and test bed:\n// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\nconst cubeToUV = /*@__PURE__*/Fn(([pos, texelSizeY]) => {\n  const v = pos.toVar();\n\n  // Number of texels to avoid at the edge of each square\n\n  const absV = abs(v);\n\n  // Intersect unit cube\n\n  const scaleToCube = div(1.0, max$1(absV.x, max$1(absV.y, absV.z)));\n  absV.mulAssign(scaleToCube);\n\n  // Apply scale to avoid seams\n\n  // two texels less per square (one texel will do for NEAREST)\n  v.mulAssign(scaleToCube.mul(texelSizeY.mul(2).oneMinus()));\n\n  // Unwrap\n\n  // space: -1 ... 1 range for each square\n  //\n  // #X##\t\tdim    := ( 4 , 2 )\n  //  # #\t\tcenter := ( 1 , 1 )\n\n  const planar = vec2(v.xy).toVar();\n  const almostATexel = texelSizeY.mul(1.5);\n  const almostOne = almostATexel.oneMinus();\n  If(absV.z.greaterThanEqual(almostOne), () => {\n    If(v.z.greaterThan(0.0), () => {\n      planar.x.assign(sub(4.0, v.x));\n    });\n  }).ElseIf(absV.x.greaterThanEqual(almostOne), () => {\n    const signX = sign(v.x);\n    planar.x.assign(v.z.mul(signX).add(signX.mul(2.0)));\n  }).ElseIf(absV.y.greaterThanEqual(almostOne), () => {\n    const signY = sign(v.y);\n    planar.x.assign(v.x.add(signY.mul(2.0)).add(2.0));\n    planar.y.assign(v.z.mul(signY).sub(2.0));\n  });\n\n  // Transform to UV space\n\n  // scale := 0.5 / dim\n  // translate := ( center + 0.5 ) / dim\n  return vec2(0.125, 0.25).mul(planar).add(vec2(0.375, 0.75)).flipY();\n}).setLayout({\n  name: 'cubeToUV',\n  type: 'vec2',\n  inputs: [{\n    name: 'pos',\n    type: 'vec3'\n  }, {\n    name: 'texelSizeY',\n    type: 'float'\n  }]\n});\nconst BasicPointShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  bd3D,\n  dp,\n  texelSize\n}) => {\n  return texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp);\n});\nconst PointShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  bd3D,\n  dp,\n  texelSize,\n  shadow\n}) => {\n  const radius = reference('radius', 'float', shadow).setGroup(renderGroup);\n  const offset = vec2(-1.0, 1.0).mul(radius).mul(texelSize.y);\n  return texture(depthTexture, cubeToUV(bd3D.add(offset.xyy), texelSize.y)).compare(dp).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxx), texelSize.y)).compare(dp)).mul(1.0 / 9.0);\n});\nconst pointShadowFilter = /*@__PURE__*/Fn(({\n  filterFn,\n  depthTexture,\n  shadowCoord,\n  shadow\n}) => {\n  // for point lights, the uniform @vShadowCoord is re-purposed to hold\n  // the vector from the light to the world-space position of the fragment.\n  const lightToPosition = shadowCoord.xyz.toVar();\n  const lightToPositionLength = lightToPosition.length();\n  const cameraNearLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(() => shadow.camera.near);\n  const cameraFarLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(() => shadow.camera.far);\n  const bias = reference('bias', 'float', shadow).setGroup(renderGroup);\n  const mapSize = uniform(shadow.mapSize).setGroup(renderGroup);\n  const result = float(1.0).toVar();\n  If(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0.0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0.0)), () => {\n    // dp = normalized distance from light to fragment position\n    const dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar(); // need to clamp?\n    dp.addAssign(bias);\n\n    // bd3D = base direction 3D\n    const bd3D = lightToPosition.normalize();\n    const texelSize = vec2(1.0).div(mapSize.mul(vec2(4.0, 2.0)));\n\n    // percentage-closer filtering\n    result.assign(filterFn({\n      depthTexture,\n      bd3D,\n      dp,\n      texelSize,\n      shadow\n    }));\n  });\n  return result;\n});\nconst _viewport = /*@__PURE__*/new Vector4();\nconst _viewportSize = /*@__PURE__*/new Vector2();\nconst _shadowMapSize = /*@__PURE__*/new Vector2();\n\n/**\n * Represents the shadow implementation for point light nodes.\n *\n * @augments module:ShadowNode~ShadowNode\n */\nclass PointShadowNode extends ShadowNode {\n  static get type() {\n    return 'PointShadowNode';\n  }\n\n  /**\n   * Constructs a new point shadow node.\n   *\n   * @param {PointLight} light - The shadow casting point light.\n   * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.\n   */\n  constructor(light, shadow = null) {\n    super(light, shadow);\n  }\n\n  /**\n   * Overwrites the default implementation to return point light shadow specific\n   * filtering functions.\n   *\n   * @param {Number} type - The shadow type.\n   * @return {Function} The filtering function.\n   */\n  getShadowFilterFn(type) {\n    return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;\n  }\n\n  /**\n   * Overwrites the default implementation so the unaltered shadow position is used.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n   * @return {Node<vec3>} The shadow coordinates.\n   */\n  setupShadowCoord(builder, shadowPosition) {\n    return shadowPosition;\n  }\n\n  /**\n   * Overwrites the default implementation to only use point light specific\n   * shadow filter functions.\n   *\n   * @param {NodeBuilder} builder - A reference to the current node builder.\n   * @param {Object} inputs - A configuration object that defines the shadow filtering.\n   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n   * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.\n   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n   * @param {LightShadow} inputs.shadow - The light shadow.\n   * @return {Node<float>} The result node of the shadow filtering.\n   */\n  setupShadowFilter(builder, {\n    filterFn,\n    shadowTexture,\n    depthTexture,\n    shadowCoord,\n    shadow\n  }) {\n    return pointShadowFilter({\n      filterFn,\n      shadowTexture,\n      depthTexture,\n      shadowCoord,\n      shadow\n    });\n  }\n\n  /**\n   * Overwrites the default implementation with point light specific\n   * rendering code.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  renderShadow(frame) {\n    const {\n      shadow,\n      shadowMap,\n      light\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    const shadowFrameExtents = shadow.getFrameExtents();\n    _shadowMapSize.copy(shadow.mapSize);\n    _shadowMapSize.multiply(shadowFrameExtents);\n    shadowMap.setSize(_shadowMapSize.width, _shadowMapSize.height);\n    _viewportSize.copy(shadow.mapSize);\n\n    //\n\n    const previousAutoClear = renderer.autoClear;\n    const previousClearColor = renderer.getClearColor(_clearColor$2);\n    const previousClearAlpha = renderer.getClearAlpha();\n    renderer.autoClear = false;\n    renderer.setClearColor(shadow.clearColor, shadow.clearAlpha);\n    renderer.clear();\n    const viewportCount = shadow.getViewportCount();\n    for (let vp = 0; vp < viewportCount; vp++) {\n      const viewport = shadow.getViewport(vp);\n      const x = _viewportSize.x * viewport.x;\n      const y = _shadowMapSize.y - _viewportSize.y - _viewportSize.y * viewport.y;\n      _viewport.set(x, y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n      shadowMap.viewport.copy(_viewport);\n      shadow.updateMatrices(light, vp);\n      renderer.render(scene, shadow.camera);\n    }\n\n    //\n\n    renderer.autoClear = previousAutoClear;\n    renderer.setClearColor(previousClearColor, previousClearAlpha);\n  }\n}\n\n/**\n * TSL function for creating an instance of `PointShadowNode`.\n *\n * @function\n * @param {PointLight} light - The shadow casting point light.\n * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.\n * @return {PointShadowNode} The created point shadow node.\n */\nconst pointShadow = (light, shadow) => nodeObject(new PointShadowNode(light, shadow));\nconst directPointLight = Fn(({\n  color,\n  lightViewPosition,\n  cutoffDistance,\n  decayExponent\n}, builder) => {\n  const lightingModel = builder.context.lightingModel;\n  const lVector = lightViewPosition.sub(positionView); // @TODO: Add it into LightNode\n\n  const lightDirection = lVector.normalize();\n  const lightDistance = lVector.length();\n  const lightAttenuation = getDistanceAttenuation({\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  });\n  const lightColor = color.mul(lightAttenuation);\n  const reflectedLight = builder.context.reflectedLight;\n  lightingModel.direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }, builder.stack, builder);\n});\n\n/**\n * Module for representing point lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass PointLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'PointLightNode';\n  }\n\n  /**\n   * Constructs a new point light node.\n   *\n   * @param {PointLight?} [light=null] - The point light source.\n   */\n  constructor(light = null) {\n    super(light);\n\n    /**\n     * Uniform node representing the cutoff distance.\n     *\n     * @type {UniformNode<float>}\n     */\n    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);\n\n    /**\n     * Uniform node representing the decay exponent.\n     *\n     * @type {UniformNode<float>}\n     */\n    this.decayExponentNode = uniform(2).setGroup(renderGroup);\n  }\n\n  /**\n   * Overwritten to updated point light specific uniforms.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update(frame) {\n    const {\n      light\n    } = this;\n    super.update(frame);\n    this.cutoffDistanceNode.value = light.distance;\n    this.decayExponentNode.value = light.decay;\n  }\n\n  /**\n   * Overwritten to setup point light specific shadow.\n   *\n   * @return {PointShadowNode}\n   */\n  setupShadowNode() {\n    return pointShadow(this.light);\n  }\n  setup(builder) {\n    super.setup(builder);\n    directPointLight({\n      color: this.colorNode,\n      lightViewPosition: lightViewPosition(this.light),\n      cutoffDistance: this.cutoffDistanceNode,\n      decayExponent: this.decayExponentNode\n    }).append();\n  }\n}\n\n/** @module Procedural **/\n\n/**\n * Creates a 2x2 checkerboard pattern that can be used as procedural texture data.\n *\n * @method\n * @param {Node<vec2>} coord - The uv coordinates.\n * @return {Node<float>} The result data.\n */\nconst checker = /*@__PURE__*/Fn(([coord = uv()]) => {\n  const uv = coord.mul(2.0);\n  const cx = uv.x.floor();\n  const cy = uv.y.floor();\n  const result = cx.add(cy).mod(2.0);\n  return result.sign();\n});\n\n// Three.js Transpiler\n// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\nconst mx_select = /*@__PURE__*/Fn(([b_immutable, t_immutable, f_immutable]) => {\n  const f = float(f_immutable).toVar();\n  const t = float(t_immutable).toVar();\n  const b = bool(b_immutable).toVar();\n  return select(b, t, f);\n}).setLayout({\n  name: 'mx_select',\n  type: 'float',\n  inputs: [{\n    name: 'b',\n    type: 'bool'\n  }, {\n    name: 't',\n    type: 'float'\n  }, {\n    name: 'f',\n    type: 'float'\n  }]\n});\nconst mx_negate_if = /*@__PURE__*/Fn(([val_immutable, b_immutable]) => {\n  const b = bool(b_immutable).toVar();\n  const val = float(val_immutable).toVar();\n  return select(b, val.negate(), val);\n}).setLayout({\n  name: 'mx_negate_if',\n  type: 'float',\n  inputs: [{\n    name: 'val',\n    type: 'float'\n  }, {\n    name: 'b',\n    type: 'bool'\n  }]\n});\nconst mx_floor = /*@__PURE__*/Fn(([x_immutable]) => {\n  const x = float(x_immutable).toVar();\n  return int(floor(x));\n}).setLayout({\n  name: 'mx_floor',\n  type: 'int',\n  inputs: [{\n    name: 'x',\n    type: 'float'\n  }]\n});\nconst mx_floorfrac = /*@__PURE__*/Fn(([x_immutable, i]) => {\n  const x = float(x_immutable).toVar();\n  i.assign(mx_floor(x));\n  return x.sub(float(i));\n});\nconst mx_bilerp_0 = /*@__PURE__*/Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v3 = float(v3_immutable).toVar();\n  const v2 = float(v2_immutable).toVar();\n  const v1 = float(v1_immutable).toVar();\n  const v0 = float(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));\n}).setLayout({\n  name: 'mx_bilerp_0',\n  type: 'float',\n  inputs: [{\n    name: 'v0',\n    type: 'float'\n  }, {\n    name: 'v1',\n    type: 'float'\n  }, {\n    name: 'v2',\n    type: 'float'\n  }, {\n    name: 'v3',\n    type: 'float'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }]\n});\nconst mx_bilerp_1 = /*@__PURE__*/Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v3 = vec3(v3_immutable).toVar();\n  const v2 = vec3(v2_immutable).toVar();\n  const v1 = vec3(v1_immutable).toVar();\n  const v0 = vec3(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));\n}).setLayout({\n  name: 'mx_bilerp_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v0',\n    type: 'vec3'\n  }, {\n    name: 'v1',\n    type: 'vec3'\n  }, {\n    name: 'v2',\n    type: 'vec3'\n  }, {\n    name: 'v3',\n    type: 'vec3'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }]\n});\nconst mx_bilerp = /*@__PURE__*/overloadingFn([mx_bilerp_0, mx_bilerp_1]);\nconst mx_trilerp_0 = /*@__PURE__*/Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {\n  const r = float(r_immutable).toVar();\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v7 = float(v7_immutable).toVar();\n  const v6 = float(v6_immutable).toVar();\n  const v5 = float(v5_immutable).toVar();\n  const v4 = float(v4_immutable).toVar();\n  const v3 = float(v3_immutable).toVar();\n  const v2 = float(v2_immutable).toVar();\n  const v1 = float(v1_immutable).toVar();\n  const v0 = float(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  const t1 = float(sub(1.0, t)).toVar();\n  const r1 = float(sub(1.0, r)).toVar();\n  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));\n}).setLayout({\n  name: 'mx_trilerp_0',\n  type: 'float',\n  inputs: [{\n    name: 'v0',\n    type: 'float'\n  }, {\n    name: 'v1',\n    type: 'float'\n  }, {\n    name: 'v2',\n    type: 'float'\n  }, {\n    name: 'v3',\n    type: 'float'\n  }, {\n    name: 'v4',\n    type: 'float'\n  }, {\n    name: 'v5',\n    type: 'float'\n  }, {\n    name: 'v6',\n    type: 'float'\n  }, {\n    name: 'v7',\n    type: 'float'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }, {\n    name: 'r',\n    type: 'float'\n  }]\n});\nconst mx_trilerp_1 = /*@__PURE__*/Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {\n  const r = float(r_immutable).toVar();\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v7 = vec3(v7_immutable).toVar();\n  const v6 = vec3(v6_immutable).toVar();\n  const v5 = vec3(v5_immutable).toVar();\n  const v4 = vec3(v4_immutable).toVar();\n  const v3 = vec3(v3_immutable).toVar();\n  const v2 = vec3(v2_immutable).toVar();\n  const v1 = vec3(v1_immutable).toVar();\n  const v0 = vec3(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  const t1 = float(sub(1.0, t)).toVar();\n  const r1 = float(sub(1.0, r)).toVar();\n  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));\n}).setLayout({\n  name: 'mx_trilerp_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v0',\n    type: 'vec3'\n  }, {\n    name: 'v1',\n    type: 'vec3'\n  }, {\n    name: 'v2',\n    type: 'vec3'\n  }, {\n    name: 'v3',\n    type: 'vec3'\n  }, {\n    name: 'v4',\n    type: 'vec3'\n  }, {\n    name: 'v5',\n    type: 'vec3'\n  }, {\n    name: 'v6',\n    type: 'vec3'\n  }, {\n    name: 'v7',\n    type: 'vec3'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }, {\n    name: 'r',\n    type: 'float'\n  }]\n});\nconst mx_trilerp = /*@__PURE__*/overloadingFn([mx_trilerp_0, mx_trilerp_1]);\nconst mx_gradient_float_0 = /*@__PURE__*/Fn(([hash_immutable, x_immutable, y_immutable]) => {\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uint(hash_immutable).toVar();\n  const h = uint(hash.bitAnd(uint(7))).toVar();\n  const u = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();\n  const v = float(mul(2.0, mx_select(h.lessThan(uint(4)), y, x))).toVar();\n  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));\n}).setLayout({\n  name: 'mx_gradient_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'hash',\n    type: 'uint'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }]\n});\nconst mx_gradient_float_1 = /*@__PURE__*/Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {\n  const z = float(z_immutable).toVar();\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uint(hash_immutable).toVar();\n  const h = uint(hash.bitAnd(uint(15))).toVar();\n  const u = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();\n  const v = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();\n  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));\n}).setLayout({\n  name: 'mx_gradient_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'hash',\n    type: 'uint'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }, {\n    name: 'z',\n    type: 'float'\n  }]\n});\nconst mx_gradient_float = /*@__PURE__*/overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);\nconst mx_gradient_vec3_0 = /*@__PURE__*/Fn(([hash_immutable, x_immutable, y_immutable]) => {\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uvec3(hash_immutable).toVar();\n  return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));\n}).setLayout({\n  name: 'mx_gradient_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'hash',\n    type: 'uvec3'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }]\n});\nconst mx_gradient_vec3_1 = /*@__PURE__*/Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {\n  const z = float(z_immutable).toVar();\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uvec3(hash_immutable).toVar();\n  return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));\n}).setLayout({\n  name: 'mx_gradient_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'hash',\n    type: 'uvec3'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }, {\n    name: 'z',\n    type: 'float'\n  }]\n});\nconst mx_gradient_vec3 = /*@__PURE__*/overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);\nconst mx_gradient_scale2d_0 = /*@__PURE__*/Fn(([v_immutable]) => {\n  const v = float(v_immutable).toVar();\n  return mul(0.6616, v);\n}).setLayout({\n  name: 'mx_gradient_scale2d_0',\n  type: 'float',\n  inputs: [{\n    name: 'v',\n    type: 'float'\n  }]\n});\nconst mx_gradient_scale3d_0 = /*@__PURE__*/Fn(([v_immutable]) => {\n  const v = float(v_immutable).toVar();\n  return mul(0.9820, v);\n}).setLayout({\n  name: 'mx_gradient_scale3d_0',\n  type: 'float',\n  inputs: [{\n    name: 'v',\n    type: 'float'\n  }]\n});\nconst mx_gradient_scale2d_1 = /*@__PURE__*/Fn(([v_immutable]) => {\n  const v = vec3(v_immutable).toVar();\n  return mul(0.6616, v);\n}).setLayout({\n  name: 'mx_gradient_scale2d_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v',\n    type: 'vec3'\n  }]\n});\nconst mx_gradient_scale2d = /*@__PURE__*/overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);\nconst mx_gradient_scale3d_1 = /*@__PURE__*/Fn(([v_immutable]) => {\n  const v = vec3(v_immutable).toVar();\n  return mul(0.9820, v);\n}).setLayout({\n  name: 'mx_gradient_scale3d_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v',\n    type: 'vec3'\n  }]\n});\nconst mx_gradient_scale3d = /*@__PURE__*/overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);\nconst mx_rotl32 = /*@__PURE__*/Fn(([x_immutable, k_immutable]) => {\n  const k = int(k_immutable).toVar();\n  const x = uint(x_immutable).toVar();\n  return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));\n}).setLayout({\n  name: 'mx_rotl32',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'uint'\n  }, {\n    name: 'k',\n    type: 'int'\n  }]\n});\nconst mx_bjmix = /*@__PURE__*/Fn(([a, b, c]) => {\n  a.subAssign(c);\n  a.bitXorAssign(mx_rotl32(c, int(4)));\n  c.addAssign(b);\n  b.subAssign(a);\n  b.bitXorAssign(mx_rotl32(a, int(6)));\n  a.addAssign(c);\n  c.subAssign(b);\n  c.bitXorAssign(mx_rotl32(b, int(8)));\n  b.addAssign(a);\n  a.subAssign(c);\n  a.bitXorAssign(mx_rotl32(c, int(16)));\n  c.addAssign(b);\n  b.subAssign(a);\n  b.bitXorAssign(mx_rotl32(a, int(19)));\n  a.addAssign(c);\n  c.subAssign(b);\n  c.bitXorAssign(mx_rotl32(b, int(4)));\n  b.addAssign(a);\n});\nconst mx_bjfinal = /*@__PURE__*/Fn(([a_immutable, b_immutable, c_immutable]) => {\n  const c = uint(c_immutable).toVar();\n  const b = uint(b_immutable).toVar();\n  const a = uint(a_immutable).toVar();\n  c.bitXorAssign(b);\n  c.subAssign(mx_rotl32(b, int(14)));\n  a.bitXorAssign(c);\n  a.subAssign(mx_rotl32(c, int(11)));\n  b.bitXorAssign(a);\n  b.subAssign(mx_rotl32(a, int(25)));\n  c.bitXorAssign(b);\n  c.subAssign(mx_rotl32(b, int(16)));\n  a.bitXorAssign(c);\n  a.subAssign(mx_rotl32(c, int(4)));\n  b.bitXorAssign(a);\n  b.subAssign(mx_rotl32(a, int(14)));\n  c.bitXorAssign(b);\n  c.subAssign(mx_rotl32(b, int(24)));\n  return c;\n}).setLayout({\n  name: 'mx_bjfinal',\n  type: 'uint',\n  inputs: [{\n    name: 'a',\n    type: 'uint'\n  }, {\n    name: 'b',\n    type: 'uint'\n  }, {\n    name: 'c',\n    type: 'uint'\n  }]\n});\nconst mx_bits_to_01 = /*@__PURE__*/Fn(([bits_immutable]) => {\n  const bits = uint(bits_immutable).toVar();\n  return float(bits).div(float(uint(int(0xffffffff))));\n}).setLayout({\n  name: 'mx_bits_to_01',\n  type: 'float',\n  inputs: [{\n    name: 'bits',\n    type: 'uint'\n  }]\n});\nconst mx_fade = /*@__PURE__*/Fn(([t_immutable]) => {\n  const t = float(t_immutable).toVar();\n  return t.mul(t).mul(t).mul(t.mul(t.mul(6.0).sub(15.0)).add(10.0));\n}).setLayout({\n  name: 'mx_fade',\n  type: 'float',\n  inputs: [{\n    name: 't',\n    type: 'float'\n  }]\n});\nconst mx_hash_int_0 = /*@__PURE__*/Fn(([x_immutable]) => {\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(1)).toVar();\n  const seed = uint(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13))).toVar();\n  return mx_bjfinal(seed.add(uint(x)), seed, seed);\n}).setLayout({\n  name: 'mx_hash_int_0',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_1 = /*@__PURE__*/Fn(([x_immutable, y_immutable]) => {\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(2)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_1',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_2 = /*@__PURE__*/Fn(([x_immutable, y_immutable, z_immutable]) => {\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(3)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  c.addAssign(uint(z));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_2',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_3 = /*@__PURE__*/Fn(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {\n  const xx = int(xx_immutable).toVar();\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(4)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  c.addAssign(uint(z));\n  mx_bjmix(a, b, c);\n  a.addAssign(uint(xx));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_3',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }, {\n    name: 'xx',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_4 = /*@__PURE__*/Fn(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {\n  const yy = int(yy_immutable).toVar();\n  const xx = int(xx_immutable).toVar();\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(5)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  c.addAssign(uint(z));\n  mx_bjmix(a, b, c);\n  a.addAssign(uint(xx));\n  b.addAssign(uint(yy));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_4',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }, {\n    name: 'xx',\n    type: 'int'\n  }, {\n    name: 'yy',\n    type: 'int'\n  }]\n});\nconst mx_hash_int = /*@__PURE__*/overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);\nconst mx_hash_vec3_0 = /*@__PURE__*/Fn(([x_immutable, y_immutable]) => {\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const h = uint(mx_hash_int(x, y)).toVar();\n  const result = uvec3().toVar();\n  result.x.assign(h.bitAnd(int(0xFF)));\n  result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));\n  result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));\n  return result;\n}).setLayout({\n  name: 'mx_hash_vec3_0',\n  type: 'uvec3',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }]\n});\nconst mx_hash_vec3_1 = /*@__PURE__*/Fn(([x_immutable, y_immutable, z_immutable]) => {\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const h = uint(mx_hash_int(x, y, z)).toVar();\n  const result = uvec3().toVar();\n  result.x.assign(h.bitAnd(int(0xFF)));\n  result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));\n  result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));\n  return result;\n}).setLayout({\n  name: 'mx_hash_vec3_1',\n  type: 'uvec3',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }]\n});\nconst mx_hash_vec3 = /*@__PURE__*/overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);\nconst mx_perlin_noise_float_0 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();\n  return mx_gradient_scale2d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_perlin_noise_float_1 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const fz = float(mx_floorfrac(p.z, Z)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const w = float(mx_fade(fz)).toVar();\n  const result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();\n  return mx_gradient_scale3d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_perlin_noise_float = /*@__PURE__*/overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);\nconst mx_perlin_noise_vec3_0 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();\n  return mx_gradient_scale2d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_perlin_noise_vec3_1 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const fz = float(mx_floorfrac(p.z, Z)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const w = float(mx_fade(fz)).toVar();\n  const result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();\n  return mx_gradient_scale3d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_perlin_noise_vec3 = /*@__PURE__*/overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);\nconst mx_cell_noise_float_0 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = float(p_immutable).toVar();\n  const ix = int(mx_floor(p)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix));\n}).setLayout({\n  name: 'mx_cell_noise_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'float'\n  }]\n});\nconst mx_cell_noise_float_1 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec2(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix, iy));\n}).setLayout({\n  name: 'mx_cell_noise_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_cell_noise_float_2 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec3(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix, iy, iz));\n}).setLayout({\n  name: 'mx_cell_noise_float_2',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_cell_noise_float_3 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec4(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  const iw = int(mx_floor(p.w)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));\n}).setLayout({\n  name: 'mx_cell_noise_float_3',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec4'\n  }]\n});\nconst mx_cell_noise_float$1 = /*@__PURE__*/overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);\nconst mx_cell_noise_vec3_0 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = float(p_immutable).toVar();\n  const ix = int(mx_floor(p)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'float'\n  }]\n});\nconst mx_cell_noise_vec3_1 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec2(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_cell_noise_vec3_2 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec3(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_2',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_cell_noise_vec3_3 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec4(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  const iw = int(mx_floor(p.w)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_3',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec4'\n  }]\n});\nconst mx_cell_noise_vec3 = /*@__PURE__*/overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);\nconst mx_fractal_noise_float$1 = /*@__PURE__*/Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const result = float(0.0).toVar();\n  const amplitude = float(1.0).toVar();\n  Loop(octaves, () => {\n    result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));\n    amplitude.mulAssign(diminish);\n    p.mulAssign(lacunarity);\n  });\n  return result;\n}).setLayout({\n  name: 'mx_fractal_noise_float',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_fractal_noise_vec3$1 = /*@__PURE__*/Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const result = vec3(0.0).toVar();\n  const amplitude = float(1.0).toVar();\n  Loop(octaves, () => {\n    result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));\n    amplitude.mulAssign(diminish);\n    p.mulAssign(lacunarity);\n  });\n  return result;\n}).setLayout({\n  name: 'mx_fractal_noise_vec3',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_fractal_noise_vec2$1 = /*@__PURE__*/Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  return vec2(mx_fractal_noise_float$1(p, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));\n}).setLayout({\n  name: 'mx_fractal_noise_vec2',\n  type: 'vec2',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_fractal_noise_vec4$1 = /*@__PURE__*/Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const c = vec3(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish)).toVar();\n  const f = float(mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();\n  return vec4(c, f);\n}).setLayout({\n  name: 'mx_fractal_noise_vec4',\n  type: 'vec4',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_worley_distance_0 = /*@__PURE__*/Fn(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const yoff = int(yoff_immutable).toVar();\n  const xoff = int(xoff_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();\n  const off = vec2(tmp.x, tmp.y).toVar();\n  off.subAssign(0.5);\n  off.mulAssign(jitter);\n  off.addAssign(0.5);\n  const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();\n  const diff = vec2(cellpos.sub(p)).toVar();\n  If(metric.equal(int(2)), () => {\n    return abs(diff.x).add(abs(diff.y));\n  });\n  If(metric.equal(int(3)), () => {\n    return max$1(abs(diff.x), abs(diff.y));\n  });\n  return dot(diff, diff);\n}).setLayout({\n  name: 'mx_worley_distance_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'xoff',\n    type: 'int'\n  }, {\n    name: 'yoff',\n    type: 'int'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_distance_1 = /*@__PURE__*/Fn(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const zoff = int(zoff_immutable).toVar();\n  const yoff = int(yoff_immutable).toVar();\n  const xoff = int(xoff_immutable).toVar();\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();\n  off.subAssign(0.5);\n  off.mulAssign(jitter);\n  off.addAssign(0.5);\n  const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();\n  const diff = vec3(cellpos.sub(p)).toVar();\n  If(metric.equal(int(2)), () => {\n    return abs(diff.x).add(abs(diff.y)).add(abs(diff.z));\n  });\n  If(metric.equal(int(3)), () => {\n    return max$1(max$1(abs(diff.x), abs(diff.y)), abs(diff.z));\n  });\n  return dot(diff, diff);\n}).setLayout({\n  name: 'mx_worley_distance_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }, {\n    name: 'xoff',\n    type: 'int'\n  }, {\n    name: 'yoff',\n    type: 'int'\n  }, {\n    name: 'zoff',\n    type: 'int'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_distance = /*@__PURE__*/overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);\nconst mx_worley_noise_float_0 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();\n  const sqdist = float(1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();\n      sqdist.assign(min$1(sqdist, dist));\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec2_0 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();\n  const sqdist = vec2(1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();\n      If(dist.lessThan(sqdist.x), () => {\n        sqdist.y.assign(sqdist.x);\n        sqdist.x.assign(dist);\n      }).ElseIf(dist.lessThan(sqdist.y), () => {\n        sqdist.y.assign(dist);\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec2_0',\n  type: 'vec2',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec3_0 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();\n  const sqdist = vec3(1e6, 1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();\n      If(dist.lessThan(sqdist.x), () => {\n        sqdist.z.assign(sqdist.y);\n        sqdist.y.assign(sqdist.x);\n        sqdist.x.assign(dist);\n      }).ElseIf(dist.lessThan(sqdist.y), () => {\n        sqdist.z.assign(sqdist.y);\n        sqdist.y.assign(dist);\n      }).ElseIf(dist.lessThan(sqdist.z), () => {\n        sqdist.z.assign(dist);\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_float_1 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();\n  const sqdist = float(1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      Loop({\n        start: -1,\n        end: int(1),\n        name: 'z',\n        condition: '<='\n      }, ({\n        z\n      }) => {\n        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();\n        sqdist.assign(min$1(sqdist, dist));\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_float$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);\nconst mx_worley_noise_vec2_1 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();\n  const sqdist = vec2(1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      Loop({\n        start: -1,\n        end: int(1),\n        name: 'z',\n        condition: '<='\n      }, ({\n        z\n      }) => {\n        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();\n        If(dist.lessThan(sqdist.x), () => {\n          sqdist.y.assign(sqdist.x);\n          sqdist.x.assign(dist);\n        }).ElseIf(dist.lessThan(sqdist.y), () => {\n          sqdist.y.assign(dist);\n        });\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec2_1',\n  type: 'vec2',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec2$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);\nconst mx_worley_noise_vec3_1 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();\n  const sqdist = vec3(1e6, 1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      Loop({\n        start: -1,\n        end: int(1),\n        name: 'z',\n        condition: '<='\n      }, ({\n        z\n      }) => {\n        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();\n        If(dist.lessThan(sqdist.x), () => {\n          sqdist.z.assign(sqdist.y);\n          sqdist.y.assign(sqdist.x);\n          sqdist.x.assign(dist);\n        }).ElseIf(dist.lessThan(sqdist.y), () => {\n          sqdist.z.assign(sqdist.y);\n          sqdist.y.assign(dist);\n        }).ElseIf(dist.lessThan(sqdist.z), () => {\n          sqdist.z.assign(dist);\n        });\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec3$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\nconst mx_hsvtorgb = /*@__PURE__*/Fn(([hsv]) => {\n  const s = hsv.y;\n  const v = hsv.z;\n  const result = vec3().toVar();\n  If(s.lessThan(0.0001), () => {\n    result.assign(vec3(v, v, v));\n  }).Else(() => {\n    let h = hsv.x;\n    h = h.sub(floor(h)).mul(6.0).toVar(); // TODO: check what .toVar() is needed in node system cache\n    const hi = int(trunc(h));\n    const f = h.sub(float(hi));\n    const p = v.mul(s.oneMinus());\n    const q = v.mul(s.mul(f).oneMinus());\n    const t = v.mul(s.mul(f.oneMinus()).oneMinus());\n    If(hi.equal(int(0)), () => {\n      result.assign(vec3(v, t, p));\n    }).ElseIf(hi.equal(int(1)), () => {\n      result.assign(vec3(q, v, p));\n    }).ElseIf(hi.equal(int(2)), () => {\n      result.assign(vec3(p, v, t));\n    }).ElseIf(hi.equal(int(3)), () => {\n      result.assign(vec3(p, q, v));\n    }).ElseIf(hi.equal(int(4)), () => {\n      result.assign(vec3(t, p, v));\n    }).Else(() => {\n      result.assign(vec3(v, p, q));\n    });\n  });\n  return result;\n}).setLayout({\n  name: 'mx_hsvtorgb',\n  type: 'vec3',\n  inputs: [{\n    name: 'hsv',\n    type: 'vec3'\n  }]\n});\nconst mx_rgbtohsv = /*@__PURE__*/Fn(([c_immutable]) => {\n  const c = vec3(c_immutable).toVar();\n  const r = float(c.x).toVar();\n  const g = float(c.y).toVar();\n  const b = float(c.z).toVar();\n  const mincomp = float(min$1(r, min$1(g, b))).toVar();\n  const maxcomp = float(max$1(r, max$1(g, b))).toVar();\n  const delta = float(maxcomp.sub(mincomp)).toVar();\n  const h = float().toVar(),\n    s = float().toVar(),\n    v = float().toVar();\n  v.assign(maxcomp);\n  If(maxcomp.greaterThan(0.0), () => {\n    s.assign(delta.div(maxcomp));\n  }).Else(() => {\n    s.assign(0.0);\n  });\n  If(s.lessThanEqual(0.0), () => {\n    h.assign(0.0);\n  }).Else(() => {\n    If(r.greaterThanEqual(maxcomp), () => {\n      h.assign(g.sub(b).div(delta));\n    }).ElseIf(g.greaterThanEqual(maxcomp), () => {\n      h.assign(add(2.0, b.sub(r).div(delta)));\n    }).Else(() => {\n      h.assign(add(4.0, r.sub(g).div(delta)));\n    });\n    h.mulAssign(1.0 / 6.0);\n    If(h.lessThan(0.0), () => {\n      h.addAssign(1.0);\n    });\n  });\n  return vec3(h, s, v);\n}).setLayout({\n  name: 'mx_rgbtohsv',\n  type: 'vec3',\n  inputs: [{\n    name: 'c',\n    type: 'vec3'\n  }]\n});\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl\n\nconst mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/Fn(([color_immutable]) => {\n  const color = vec3(color_immutable).toVar();\n  const isAbove = bvec3(greaterThan(color, vec3(0.04045))).toVar();\n  const linSeg = vec3(color.div(12.92)).toVar();\n  const powSeg = vec3(pow(max$1(color.add(vec3(0.055)), vec3(0.0)).div(1.055), vec3(2.4))).toVar();\n  return mix(linSeg, powSeg, isAbove);\n}).setLayout({\n  name: 'mx_srgb_texture_to_lin_rec709',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }]\n});\nconst mx_aastep = (threshold, value) => {\n  threshold = float(threshold);\n  value = float(value);\n  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.70710678118654757);\n  return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);\n};\nconst _ramp = (a, b, uv, p) => mix(a, b, uv[p].clamp());\nconst mx_ramplr = (valuel, valuer, texcoord = uv()) => _ramp(valuel, valuer, texcoord, 'x');\nconst mx_ramptb = (valuet, valueb, texcoord = uv()) => _ramp(valuet, valueb, texcoord, 'y');\nconst _split = (a, b, center, uv, p) => mix(a, b, mx_aastep(center, uv[p]));\nconst mx_splitlr = (valuel, valuer, center, texcoord = uv()) => _split(valuel, valuer, center, texcoord, 'x');\nconst mx_splittb = (valuet, valueb, center, texcoord = uv()) => _split(valuet, valueb, center, texcoord, 'y');\nconst mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv()) => uv_geo.mul(uv_scale).add(uv_offset);\nconst mx_safepower = (in1, in2 = 1) => {\n  in1 = float(in1);\n  return in1.abs().pow(in2).mul(in1.sign());\n};\nconst mx_contrast = (input, amount = 1, pivot = .5) => float(input).sub(pivot).mul(amount).add(pivot);\nconst mx_noise_float = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);\n//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec3 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);\nconst mx_noise_vec4 = (texcoord = uv(), amplitude = 1, pivot = 0) => {\n  texcoord = texcoord.convert('vec2|vec3'); // overloading type\n\n  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));\n  return noise_vec4.mul(amplitude).add(pivot);\n};\nconst mx_worley_noise_float = (texcoord = uv(), jitter = 1) => mx_worley_noise_float$1(texcoord.convert('vec2|vec3'), jitter, int(1));\nconst mx_worley_noise_vec2 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec2$1(texcoord.convert('vec2|vec3'), jitter, int(1));\nconst mx_worley_noise_vec3 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec3$1(texcoord.convert('vec2|vec3'), jitter, int(1));\nconst mx_cell_noise_float = (texcoord = uv()) => mx_cell_noise_float$1(texcoord.convert('vec2|vec3'));\nconst mx_fractal_noise_float = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_float$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\nconst mx_fractal_noise_vec2 = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec2$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\nconst mx_fractal_noise_vec3 = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec3$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\nconst mx_fractal_noise_vec4 = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec4$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\n\n/** @module getParallaxCorrectNormal **/\n\n/**\n * This computes a parallax corrected normal which is used for box-projected cube mapping (BPCEM).\n *\n * Reference: {@link https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html}\n *\n * ```js\n * const uvNode = getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) );\n * material.envNode = pmremTexture( renderTarget.texture, uvNode );\n * ```\n * @function\n * @param {Node<vec3>} normal - The normal to correct.\n * @param {Node<vec3>} cubeSize - The cube size should reflect the size of the environment (BPCEM is usually applied in closed environments like rooms).\n * @param {Node<vec3>} cubePos - The cube position.\n * @return {Node<vec3>} The parallax corrected normal.\n */\nconst getParallaxCorrectNormal = /*@__PURE__*/Fn(([normal, cubeSize, cubePos]) => {\n  const nDir = normalize(normal).toVar('nDir');\n  const rbmax = sub(float(0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar('rbmax');\n  const rbmin = sub(float(-0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar('rbmin');\n  const rbminmax = vec3().toVar('rbminmax');\n  rbminmax.x = nDir.x.greaterThan(float(0)).select(rbmax.x, rbmin.x);\n  rbminmax.y = nDir.y.greaterThan(float(0)).select(rbmax.y, rbmin.y);\n  rbminmax.z = nDir.z.greaterThan(float(0)).select(rbmax.z, rbmin.z);\n  const correction = min$1(min$1(rbminmax.x, rbminmax.y), rbminmax.z).toVar('correction');\n  const boxIntersection = positionWorld.add(nDir.mul(correction)).toVar('boxIntersection');\n  return boxIntersection.sub(cubePos);\n});\nconst getShIrradianceAt = /*@__PURE__*/Fn(([normal, shCoefficients]) => {\n  // normal is assumed to have unit length\n\n  const x = normal.x,\n    y = normal.y,\n    z = normal.z;\n\n  // band 0\n  let result = shCoefficients.element(0).mul(0.886227);\n\n  // band 1\n  result = result.add(shCoefficients.element(1).mul(2.0 * 0.511664).mul(y));\n  result = result.add(shCoefficients.element(2).mul(2.0 * 0.511664).mul(z));\n  result = result.add(shCoefficients.element(3).mul(2.0 * 0.511664).mul(x));\n\n  // band 2\n  result = result.add(shCoefficients.element(4).mul(2.0 * 0.429043).mul(x).mul(y));\n  result = result.add(shCoefficients.element(5).mul(2.0 * 0.429043).mul(y).mul(z));\n  result = result.add(shCoefficients.element(6).mul(z.mul(z).mul(0.743125).sub(0.247708)));\n  result = result.add(shCoefficients.element(7).mul(2.0 * 0.429043).mul(x).mul(z));\n  result = result.add(shCoefficients.element(8).mul(0.429043).mul(mul(x, x).sub(mul(y, y))));\n  return result;\n});\n\n// constants\n\nvar TSL = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BRDF_GGX: BRDF_GGX,\n  BRDF_Lambert: BRDF_Lambert,\n  BasicShadowFilter: BasicShadowFilter,\n  Break: Break,\n  Continue: Continue,\n  DFGApprox: DFGApprox,\n  D_GGX: D_GGX,\n  Discard: Discard,\n  EPSILON: EPSILON,\n  F_Schlick: F_Schlick,\n  Fn: Fn,\n  INFINITY: INFINITY,\n  If: If,\n  Loop: Loop,\n  NodeAccess: NodeAccess,\n  NodeShaderStage: NodeShaderStage,\n  NodeType: NodeType,\n  NodeUpdateType: NodeUpdateType,\n  PCFShadowFilter: PCFShadowFilter,\n  PCFSoftShadowFilter: PCFSoftShadowFilter,\n  PI: PI,\n  PI2: PI2,\n  Return: Return,\n  Schlick_to_F0: Schlick_to_F0,\n  ScriptableNodeResources: ScriptableNodeResources,\n  ShaderNode: ShaderNode,\n  TBNViewMatrix: TBNViewMatrix,\n  VSMShadowFilter: VSMShadowFilter,\n  V_GGX_SmithCorrelated: V_GGX_SmithCorrelated,\n  abs: abs,\n  acesFilmicToneMapping: acesFilmicToneMapping,\n  acos: acos,\n  add: add,\n  addMethodChaining: addMethodChaining,\n  addNodeElement: addNodeElement,\n  agxToneMapping: agxToneMapping,\n  all: all,\n  alphaT: alphaT,\n  and: and,\n  anisotropy: anisotropy,\n  anisotropyB: anisotropyB,\n  anisotropyT: anisotropyT,\n  any: any,\n  append: append,\n  arrayBuffer: arrayBuffer,\n  asin: asin,\n  assign: assign,\n  atan: atan,\n  atan2: atan2,\n  atomicAdd: atomicAdd,\n  atomicAnd: atomicAnd,\n  atomicFunc: atomicFunc,\n  atomicMax: atomicMax,\n  atomicMin: atomicMin,\n  atomicOr: atomicOr,\n  atomicStore: atomicStore,\n  atomicSub: atomicSub,\n  atomicXor: atomicXor,\n  attenuationColor: attenuationColor,\n  attenuationDistance: attenuationDistance,\n  attribute: attribute,\n  attributeArray: attributeArray,\n  backgroundBlurriness: backgroundBlurriness,\n  backgroundIntensity: backgroundIntensity,\n  backgroundRotation: backgroundRotation,\n  batch: batch,\n  billboarding: billboarding,\n  bitAnd: bitAnd,\n  bitNot: bitNot,\n  bitOr: bitOr,\n  bitXor: bitXor,\n  bitangentGeometry: bitangentGeometry,\n  bitangentLocal: bitangentLocal,\n  bitangentView: bitangentView,\n  bitangentWorld: bitangentWorld,\n  bitcast: bitcast,\n  blendBurn: blendBurn,\n  blendColor: blendColor,\n  blendDodge: blendDodge,\n  blendOverlay: blendOverlay,\n  blendScreen: blendScreen,\n  blur: blur,\n  bool: bool,\n  buffer: buffer,\n  bufferAttribute: bufferAttribute,\n  bumpMap: bumpMap,\n  burn: burn,\n  bvec2: bvec2,\n  bvec3: bvec3,\n  bvec4: bvec4,\n  bypass: bypass,\n  cache: cache,\n  call: call,\n  cameraFar: cameraFar,\n  cameraNear: cameraNear,\n  cameraNormalMatrix: cameraNormalMatrix,\n  cameraPosition: cameraPosition,\n  cameraProjectionMatrix: cameraProjectionMatrix,\n  cameraProjectionMatrixInverse: cameraProjectionMatrixInverse,\n  cameraViewMatrix: cameraViewMatrix,\n  cameraWorldMatrix: cameraWorldMatrix,\n  cbrt: cbrt,\n  cdl: cdl,\n  ceil: ceil,\n  checker: checker,\n  cineonToneMapping: cineonToneMapping,\n  clamp: clamp,\n  clearcoat: clearcoat,\n  clearcoatRoughness: clearcoatRoughness,\n  code: code,\n  color: color,\n  colorSpaceToWorking: colorSpaceToWorking,\n  colorToDirection: colorToDirection,\n  compute: compute,\n  cond: cond,\n  context: context,\n  convert: convert,\n  convertColorSpace: convertColorSpace,\n  convertToTexture: convertToTexture,\n  cos: cos,\n  cross: cross,\n  cubeTexture: cubeTexture,\n  dFdx: dFdx,\n  dFdy: dFdy,\n  dashSize: dashSize,\n  defaultBuildStages: defaultBuildStages,\n  defaultShaderStages: defaultShaderStages,\n  defined: defined,\n  degrees: degrees,\n  deltaTime: deltaTime,\n  densityFog: densityFog,\n  densityFogFactor: densityFogFactor,\n  depth: depth,\n  depthPass: depthPass,\n  difference: difference,\n  diffuseColor: diffuseColor,\n  directPointLight: directPointLight,\n  directionToColor: directionToColor,\n  dispersion: dispersion,\n  distance: distance,\n  div: div,\n  dodge: dodge,\n  dot: dot,\n  drawIndex: drawIndex,\n  dynamicBufferAttribute: dynamicBufferAttribute,\n  element: element,\n  emissive: emissive,\n  equal: equal,\n  equals: equals,\n  equirectUV: equirectUV,\n  exp: exp,\n  exp2: exp2,\n  expression: expression,\n  faceDirection: faceDirection,\n  faceForward: faceForward,\n  faceforward: faceforward,\n  float: float,\n  floor: floor,\n  fog: fog,\n  fract: fract,\n  frameGroup: frameGroup,\n  frameId: frameId,\n  frontFacing: frontFacing,\n  fwidth: fwidth,\n  gain: gain,\n  gapSize: gapSize,\n  getConstNodeType: getConstNodeType,\n  getCurrentStack: getCurrentStack,\n  getDirection: getDirection,\n  getDistanceAttenuation: getDistanceAttenuation,\n  getGeometryRoughness: getGeometryRoughness,\n  getNormalFromDepth: getNormalFromDepth,\n  getParallaxCorrectNormal: getParallaxCorrectNormal,\n  getRoughness: getRoughness,\n  getScreenPosition: getScreenPosition,\n  getShIrradianceAt: getShIrradianceAt,\n  getTextureIndex: getTextureIndex,\n  getViewPosition: getViewPosition,\n  glsl: glsl,\n  glslFn: glslFn,\n  grayscale: grayscale,\n  greaterThan: greaterThan,\n  greaterThanEqual: greaterThanEqual,\n  hash: hash,\n  highpModelNormalViewMatrix: highpModelNormalViewMatrix,\n  highpModelViewMatrix: highpModelViewMatrix,\n  hue: hue,\n  instance: instance,\n  instanceIndex: instanceIndex,\n  instancedArray: instancedArray,\n  instancedBufferAttribute: instancedBufferAttribute,\n  instancedDynamicBufferAttribute: instancedDynamicBufferAttribute,\n  instancedMesh: instancedMesh,\n  int: int,\n  inverseSqrt: inverseSqrt,\n  inversesqrt: inversesqrt,\n  invocationLocalIndex: invocationLocalIndex,\n  invocationSubgroupIndex: invocationSubgroupIndex,\n  ior: ior,\n  iridescence: iridescence,\n  iridescenceIOR: iridescenceIOR,\n  iridescenceThickness: iridescenceThickness,\n  ivec2: ivec2,\n  ivec3: ivec3,\n  ivec4: ivec4,\n  js: js,\n  label: label,\n  length: length,\n  lengthSq: lengthSq,\n  lessThan: lessThan,\n  lessThanEqual: lessThanEqual,\n  lightPosition: lightPosition,\n  lightProjectionUV: lightProjectionUV,\n  lightShadowMatrix: lightShadowMatrix,\n  lightTargetDirection: lightTargetDirection,\n  lightTargetPosition: lightTargetPosition,\n  lightViewPosition: lightViewPosition,\n  lightingContext: lightingContext,\n  lights: lights,\n  linearDepth: linearDepth,\n  linearToneMapping: linearToneMapping,\n  localId: localId,\n  log: log,\n  log2: log2,\n  logarithmicDepthToViewZ: logarithmicDepthToViewZ,\n  loop: loop,\n  luminance: luminance,\n  mat2: mat2,\n  mat3: mat3,\n  mat4: mat4,\n  matcapUV: matcapUV,\n  materialAO: materialAO,\n  materialAlphaTest: materialAlphaTest,\n  materialAnisotropy: materialAnisotropy,\n  materialAnisotropyVector: materialAnisotropyVector,\n  materialAttenuationColor: materialAttenuationColor,\n  materialAttenuationDistance: materialAttenuationDistance,\n  materialClearcoat: materialClearcoat,\n  materialClearcoatNormal: materialClearcoatNormal,\n  materialClearcoatRoughness: materialClearcoatRoughness,\n  materialColor: materialColor,\n  materialDispersion: materialDispersion,\n  materialEmissive: materialEmissive,\n  materialIOR: materialIOR,\n  materialIridescence: materialIridescence,\n  materialIridescenceIOR: materialIridescenceIOR,\n  materialIridescenceThickness: materialIridescenceThickness,\n  materialLightMap: materialLightMap,\n  materialLineDashOffset: materialLineDashOffset,\n  materialLineDashSize: materialLineDashSize,\n  materialLineGapSize: materialLineGapSize,\n  materialLineScale: materialLineScale,\n  materialLineWidth: materialLineWidth,\n  materialMetalness: materialMetalness,\n  materialNormal: materialNormal,\n  materialOpacity: materialOpacity,\n  materialPointWidth: materialPointWidth,\n  materialReference: materialReference,\n  materialReflectivity: materialReflectivity,\n  materialRefractionRatio: materialRefractionRatio,\n  materialRotation: materialRotation,\n  materialRoughness: materialRoughness,\n  materialSheen: materialSheen,\n  materialSheenRoughness: materialSheenRoughness,\n  materialShininess: materialShininess,\n  materialSpecular: materialSpecular,\n  materialSpecularColor: materialSpecularColor,\n  materialSpecularIntensity: materialSpecularIntensity,\n  materialSpecularStrength: materialSpecularStrength,\n  materialThickness: materialThickness,\n  materialTransmission: materialTransmission,\n  max: max$1,\n  maxMipLevel: maxMipLevel,\n  mediumpModelViewMatrix: mediumpModelViewMatrix,\n  metalness: metalness,\n  min: min$1,\n  mix: mix,\n  mixElement: mixElement,\n  mod: mod,\n  modInt: modInt,\n  modelDirection: modelDirection,\n  modelNormalMatrix: modelNormalMatrix,\n  modelPosition: modelPosition,\n  modelScale: modelScale,\n  modelViewMatrix: modelViewMatrix,\n  modelViewPosition: modelViewPosition,\n  modelViewProjection: modelViewProjection,\n  modelWorldMatrix: modelWorldMatrix,\n  modelWorldMatrixInverse: modelWorldMatrixInverse,\n  morphReference: morphReference,\n  mrt: mrt,\n  mul: mul,\n  mx_aastep: mx_aastep,\n  mx_cell_noise_float: mx_cell_noise_float,\n  mx_contrast: mx_contrast,\n  mx_fractal_noise_float: mx_fractal_noise_float,\n  mx_fractal_noise_vec2: mx_fractal_noise_vec2,\n  mx_fractal_noise_vec3: mx_fractal_noise_vec3,\n  mx_fractal_noise_vec4: mx_fractal_noise_vec4,\n  mx_hsvtorgb: mx_hsvtorgb,\n  mx_noise_float: mx_noise_float,\n  mx_noise_vec3: mx_noise_vec3,\n  mx_noise_vec4: mx_noise_vec4,\n  mx_ramplr: mx_ramplr,\n  mx_ramptb: mx_ramptb,\n  mx_rgbtohsv: mx_rgbtohsv,\n  mx_safepower: mx_safepower,\n  mx_splitlr: mx_splitlr,\n  mx_splittb: mx_splittb,\n  mx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,\n  mx_transform_uv: mx_transform_uv,\n  mx_worley_noise_float: mx_worley_noise_float,\n  mx_worley_noise_vec2: mx_worley_noise_vec2,\n  mx_worley_noise_vec3: mx_worley_noise_vec3,\n  negate: negate,\n  neutralToneMapping: neutralToneMapping,\n  nodeArray: nodeArray,\n  nodeImmutable: nodeImmutable,\n  nodeObject: nodeObject,\n  nodeObjects: nodeObjects,\n  nodeProxy: nodeProxy,\n  normalFlat: normalFlat,\n  normalGeometry: normalGeometry,\n  normalLocal: normalLocal,\n  normalMap: normalMap,\n  normalView: normalView,\n  normalWorld: normalWorld,\n  normalize: normalize,\n  not: not,\n  notEqual: notEqual,\n  numWorkgroups: numWorkgroups,\n  objectDirection: objectDirection,\n  objectGroup: objectGroup,\n  objectPosition: objectPosition,\n  objectScale: objectScale,\n  objectViewPosition: objectViewPosition,\n  objectWorldMatrix: objectWorldMatrix,\n  oneMinus: oneMinus,\n  or: or,\n  orthographicDepthToViewZ: orthographicDepthToViewZ,\n  oscSawtooth: oscSawtooth,\n  oscSine: oscSine,\n  oscSquare: oscSquare,\n  oscTriangle: oscTriangle,\n  output: output,\n  outputStruct: outputStruct,\n  overlay: overlay,\n  overloadingFn: overloadingFn,\n  parabola: parabola,\n  parallaxDirection: parallaxDirection,\n  parallaxUV: parallaxUV,\n  parameter: parameter,\n  pass: pass,\n  passTexture: passTexture,\n  pcurve: pcurve,\n  perspectiveDepthToViewZ: perspectiveDepthToViewZ,\n  pmremTexture: pmremTexture,\n  pointUV: pointUV,\n  pointWidth: pointWidth,\n  positionGeometry: positionGeometry,\n  positionLocal: positionLocal,\n  positionPrevious: positionPrevious,\n  positionView: positionView,\n  positionViewDirection: positionViewDirection,\n  positionWorld: positionWorld,\n  positionWorldDirection: positionWorldDirection,\n  posterize: posterize,\n  pow: pow,\n  pow2: pow2,\n  pow3: pow3,\n  pow4: pow4,\n  property: property,\n  radians: radians,\n  rand: rand,\n  range: range,\n  rangeFog: rangeFog,\n  rangeFogFactor: rangeFogFactor,\n  reciprocal: reciprocal,\n  reference: reference,\n  referenceBuffer: referenceBuffer,\n  reflect: reflect,\n  reflectVector: reflectVector,\n  reflectView: reflectView,\n  reflector: reflector,\n  refract: refract,\n  refractVector: refractVector,\n  refractView: refractView,\n  reinhardToneMapping: reinhardToneMapping,\n  remainder: remainder,\n  remap: remap,\n  remapClamp: remapClamp,\n  renderGroup: renderGroup,\n  renderOutput: renderOutput,\n  rendererReference: rendererReference,\n  rotate: rotate,\n  rotateUV: rotateUV,\n  roughness: roughness,\n  round: round,\n  rtt: rtt,\n  sRGBTransferEOTF: sRGBTransferEOTF,\n  sRGBTransferOETF: sRGBTransferOETF,\n  sampler: sampler,\n  saturate: saturate,\n  saturation: saturation,\n  screen: screen,\n  screenCoordinate: screenCoordinate,\n  screenSize: screenSize,\n  screenUV: screenUV,\n  scriptable: scriptable,\n  scriptableValue: scriptableValue,\n  select: select,\n  setCurrentStack: setCurrentStack,\n  shaderStages: shaderStages,\n  shadow: shadow,\n  shadowPositionWorld: shadowPositionWorld,\n  sharedUniformGroup: sharedUniformGroup,\n  sheen: sheen,\n  sheenRoughness: sheenRoughness,\n  shiftLeft: shiftLeft,\n  shiftRight: shiftRight,\n  shininess: shininess,\n  sign: sign,\n  sin: sin,\n  sinc: sinc,\n  skinning: skinning,\n  skinningReference: skinningReference,\n  smoothstep: smoothstep,\n  smoothstepElement: smoothstepElement,\n  specularColor: specularColor,\n  specularF90: specularF90,\n  spherizeUV: spherizeUV,\n  split: split,\n  spritesheetUV: spritesheetUV,\n  sqrt: sqrt,\n  stack: stack,\n  step: step,\n  storage: storage,\n  storageBarrier: storageBarrier,\n  storageObject: storageObject,\n  storageTexture: storageTexture,\n  string: string,\n  sub: sub,\n  subgroupIndex: subgroupIndex,\n  subgroupSize: subgroupSize,\n  tan: tan,\n  tangentGeometry: tangentGeometry,\n  tangentLocal: tangentLocal,\n  tangentView: tangentView,\n  tangentWorld: tangentWorld,\n  temp: temp,\n  texture: texture,\n  texture3D: texture3D,\n  textureBarrier: textureBarrier,\n  textureBicubic: textureBicubic,\n  textureCubeUV: textureCubeUV,\n  textureLoad: textureLoad,\n  textureSize: textureSize,\n  textureStore: textureStore,\n  thickness: thickness,\n  time: time,\n  timerDelta: timerDelta,\n  timerGlobal: timerGlobal,\n  timerLocal: timerLocal,\n  toOutputColorSpace: toOutputColorSpace,\n  toWorkingColorSpace: toWorkingColorSpace,\n  toneMapping: toneMapping,\n  toneMappingExposure: toneMappingExposure,\n  toonOutlinePass: toonOutlinePass,\n  transformDirection: transformDirection,\n  transformNormal: transformNormal,\n  transformNormalToView: transformNormalToView,\n  transformedBentNormalView: transformedBentNormalView,\n  transformedBitangentView: transformedBitangentView,\n  transformedBitangentWorld: transformedBitangentWorld,\n  transformedClearcoatNormalView: transformedClearcoatNormalView,\n  transformedNormalView: transformedNormalView,\n  transformedNormalWorld: transformedNormalWorld,\n  transformedTangentView: transformedTangentView,\n  transformedTangentWorld: transformedTangentWorld,\n  transmission: transmission,\n  transpose: transpose,\n  triNoise3D: triNoise3D,\n  triplanarTexture: triplanarTexture,\n  triplanarTextures: triplanarTextures,\n  trunc: trunc,\n  tslFn: tslFn,\n  uint: uint,\n  uniform: uniform,\n  uniformArray: uniformArray,\n  uniformGroup: uniformGroup,\n  uniforms: uniforms,\n  userData: userData,\n  uv: uv,\n  uvec2: uvec2,\n  uvec3: uvec3,\n  uvec4: uvec4,\n  varying: varying,\n  varyingProperty: varyingProperty,\n  vec2: vec2,\n  vec3: vec3,\n  vec4: vec4,\n  vectorComponents: vectorComponents,\n  velocity: velocity,\n  vertexColor: vertexColor,\n  vertexIndex: vertexIndex,\n  vertexStage: vertexStage,\n  vibrance: vibrance,\n  viewZToLogarithmicDepth: viewZToLogarithmicDepth,\n  viewZToOrthographicDepth: viewZToOrthographicDepth,\n  viewZToPerspectiveDepth: viewZToPerspectiveDepth,\n  viewport: viewport,\n  viewportBottomLeft: viewportBottomLeft,\n  viewportCoordinate: viewportCoordinate,\n  viewportDepthTexture: viewportDepthTexture,\n  viewportLinearDepth: viewportLinearDepth,\n  viewportMipTexture: viewportMipTexture,\n  viewportResolution: viewportResolution,\n  viewportSafeUV: viewportSafeUV,\n  viewportSharedTexture: viewportSharedTexture,\n  viewportSize: viewportSize,\n  viewportTexture: viewportTexture,\n  viewportTopLeft: viewportTopLeft,\n  viewportUV: viewportUV,\n  wgsl: wgsl,\n  wgslFn: wgslFn,\n  workgroupArray: workgroupArray,\n  workgroupBarrier: workgroupBarrier,\n  workgroupId: workgroupId,\n  workingToColorSpace: workingToColorSpace,\n  xor: xor\n});\nconst _clearColor$1 = /*@__PURE__*/new Color4();\n\n/**\n * This renderer module manages the background.\n *\n * @private\n * @augments DataMap\n */\nclass Background extends DataMap {\n  /**\n   * Constructs a new background management component.\n   *\n   * @param {Renderer} renderer - The renderer.\n   * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n   */\n  constructor(renderer, nodes) {\n    super();\n\n    /**\n     * The renderer.\n     *\n     * @type {Renderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * Renderer component for managing nodes related logic.\n     *\n     * @type {Nodes}\n     */\n    this.nodes = nodes;\n  }\n\n  /**\n   * Updates the background for the given scene. Depending on how `Scene.background`\n   * or `Scene.backgroundNode` are configured, this method might configure a simple clear\n   * or add a mesh to the render list for rendering the background as a textured plane\n   * or skybox.\n   *\n   * @param {Scene} scene - The scene.\n   * @param {RenderList} renderList - The current render list.\n   * @param {RenderContext} renderContext - The current render context.\n   */\n  update(scene, renderList, renderContext) {\n    const renderer = this.renderer;\n    const background = this.nodes.getBackgroundNode(scene) || scene.background;\n    let forceClear = false;\n    if (background === null) {\n      // no background settings, use clear color configuration from the renderer\n\n      renderer._clearColor.getRGB(_clearColor$1, LinearSRGBColorSpace);\n      _clearColor$1.a = renderer._clearColor.a;\n    } else if (background.isColor === true) {\n      // background is an opaque color\n\n      background.getRGB(_clearColor$1, LinearSRGBColorSpace);\n      _clearColor$1.a = 1;\n      forceClear = true;\n    } else if (background.isNode === true) {\n      const sceneData = this.get(scene);\n      const backgroundNode = background;\n      _clearColor$1.copy(renderer._clearColor);\n      let backgroundMesh = sceneData.backgroundMesh;\n      if (backgroundMesh === undefined) {\n        const backgroundMeshNode = context(vec4(backgroundNode).mul(backgroundIntensity), {\n          // @TODO: Add Texture2D support using node context\n          getUV: () => backgroundRotation.mul(normalWorld),\n          getTextureLevel: () => backgroundBlurriness\n        });\n        let viewProj = modelViewProjection;\n        viewProj = viewProj.setZ(viewProj.w);\n        const nodeMaterial = new NodeMaterial();\n        nodeMaterial.name = 'Background.material';\n        nodeMaterial.side = BackSide;\n        nodeMaterial.depthTest = false;\n        nodeMaterial.depthWrite = false;\n        nodeMaterial.fog = false;\n        nodeMaterial.lights = false;\n        nodeMaterial.vertexNode = viewProj;\n        nodeMaterial.colorNode = backgroundMeshNode;\n        sceneData.backgroundMeshNode = backgroundMeshNode;\n        sceneData.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);\n        backgroundMesh.frustumCulled = false;\n        backgroundMesh.name = 'Background.mesh';\n        backgroundMesh.onBeforeRender = function (renderer, scene, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        };\n      }\n      const backgroundCacheKey = backgroundNode.getCacheKey();\n      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {\n        sceneData.backgroundMeshNode.node = vec4(backgroundNode).mul(backgroundIntensity);\n        sceneData.backgroundMeshNode.needsUpdate = true;\n        backgroundMesh.material.needsUpdate = true;\n        sceneData.backgroundCacheKey = backgroundCacheKey;\n      }\n      renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null);\n    } else {\n      console.error('THREE.Renderer: Unsupported background configuration.', background);\n    }\n\n    //\n\n    if (renderer.autoClear === true || forceClear === true) {\n      const clearColorValue = renderContext.clearColorValue;\n      clearColorValue.r = _clearColor$1.r;\n      clearColorValue.g = _clearColor$1.g;\n      clearColorValue.b = _clearColor$1.b;\n      clearColorValue.a = _clearColor$1.a;\n\n      // premultiply alpha\n\n      if (renderer.backend.isWebGLBackend === true || renderer.alpha === true) {\n        clearColorValue.r *= clearColorValue.a;\n        clearColorValue.g *= clearColorValue.a;\n        clearColorValue.b *= clearColorValue.a;\n      }\n\n      //\n\n      renderContext.depthClearValue = renderer._clearDepth;\n      renderContext.stencilClearValue = renderer._clearStencil;\n      renderContext.clearColor = renderer.autoClearColor === true;\n      renderContext.clearDepth = renderer.autoClearDepth === true;\n      renderContext.clearStencil = renderer.autoClearStencil === true;\n    } else {\n      renderContext.clearColor = false;\n      renderContext.clearDepth = false;\n      renderContext.clearStencil = false;\n    }\n  }\n}\nlet _id$6 = 0;\n\n/**\n * A bind group represents a collection of bindings and thus a collection\n * or resources. Bind groups are assigned to pipelines to provide them\n * with the required resources (like uniform buffers or textures).\n *\n * @private\n */\nclass BindGroup {\n  /**\n   * Constructs a new bind group.\n   *\n   * @param {String} name - The bind group's name.\n   * @param {Array<Binding>} bindings - An array of bindings.\n   * @param {Number} index - The group index.\n   * @param {Array<Binding>} bindingsReference - An array of reference bindings.\n   */\n  constructor(name = '', bindings = [], index = 0, bindingsReference = []) {\n    /**\n     * The bind group's name.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * An array of bindings.\n     *\n     * @type {Array<Binding>}\n     */\n    this.bindings = bindings;\n\n    /**\n     * The group index.\n     *\n     * @type {Number}\n     */\n    this.index = index;\n\n    /**\n     * An array of reference bindings.\n     *\n     * @type {Array<Binding>}\n     */\n    this.bindingsReference = bindingsReference;\n\n    /**\n     * The group's ID.\n     *\n     * @type {Number}\n     */\n    this.id = _id$6++;\n  }\n}\n\n/**\n * This module represents the state of a node builder after it was\n * used to build the nodes for a render object. The state holds the\n * results of the build for further processing in the renderer.\n *\n * Render objects with identical cache keys share the same node builder state.\n *\n * @private\n */\nclass NodeBuilderState {\n  /**\n   * Constructs a new node builder state.\n   *\n   * @param {String?} vertexShader - The native vertex shader code.\n   * @param {String?} fragmentShader - The native fragment shader code.\n   * @param {String?} computeShader - The native compute shader code.\n   * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.\n   * @param {Array<BindGroup>} bindings - An array of bind groups.\n   * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.\n   * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.\n   * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.\n   * @param {NodeMaterialObserver} monitor - A node material observer.\n   * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.\n   */\n  constructor(vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor, transforms = []) {\n    /**\n     * The native vertex shader code.\n     *\n     * @type {String}\n     */\n    this.vertexShader = vertexShader;\n\n    /**\n     * The native fragment shader code.\n     *\n     * @type {String}\n     */\n    this.fragmentShader = fragmentShader;\n\n    /**\n     * The native compute shader code.\n     *\n     * @type {String}\n     */\n    this.computeShader = computeShader;\n\n    /**\n     * An array with transform attribute objects.\n     * Only relevant when using compute shaders with WebGL 2.\n     *\n     * @type {Array<Object>}\n     */\n    this.transforms = transforms;\n\n    /**\n     * An array of node attributes representing\n     * the attributes of the shaders.\n     *\n     * @type {Array<NodeAttribute>}\n     */\n    this.nodeAttributes = nodeAttributes;\n\n    /**\n     * An array of bind groups representing the uniform or storage\n     * buffers, texture or samplers of the shader.\n     *\n     * @type {Array<BindGroup>}\n     */\n    this.bindings = bindings;\n\n    /**\n     * An array of nodes that implement their `update()` method.\n     *\n     * @type {Array<Node>}\n     */\n    this.updateNodes = updateNodes;\n\n    /**\n     * An array of nodes that implement their `updateBefore()` method.\n     *\n     * @type {Array<Node>}\n     */\n    this.updateBeforeNodes = updateBeforeNodes;\n\n    /**\n     * An array of nodes that implement their `updateAfter()` method.\n     *\n     * @type {Array<Node>}\n     */\n    this.updateAfterNodes = updateAfterNodes;\n\n    /**\n     * A node material observer.\n     *\n     * @type {NodeMaterialObserver}\n     */\n    this.monitor = monitor;\n\n    /**\n     * How often this state is used by render objects.\n     *\n     * @type {Number}\n     */\n    this.usedTimes = 0;\n  }\n\n  /**\n   * This method is used to create a array of bind groups based\n   * on the existing bind groups of this state. Shared groups are\n   * not cloned.\n   *\n   * @return {Array<BindGroup>} A array of bind groups.\n   */\n  createBindings() {\n    const bindings = [];\n    for (const instanceGroup of this.bindings) {\n      const shared = instanceGroup.bindings[0].groupNode.shared; // TODO: Is it safe to always check the first binding in the group?\n\n      if (shared !== true) {\n        const bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup);\n        bindings.push(bindingsGroup);\n        for (const instanceBinding of instanceGroup.bindings) {\n          bindingsGroup.bindings.push(instanceBinding.clone());\n        }\n      } else {\n        bindings.push(instanceGroup);\n      }\n    }\n    return bindings;\n  }\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader attributes that are going to be generated\n * by the builder. Arrays of node attributes is maintained in {@link NodeBuilder#attributes}\n * and {@link NodeBuilder#bufferAttributes} for this purpose.\n */\nclass NodeAttribute {\n  /**\n   * Constructs a new node attribute.\n   *\n   * @param {String} name - The name of the attribute.\n   * @param {String} type - The type of the attribute.\n   * @param {Node?} node - An optional reference to the node.\n   */\n  constructor(name, type, node = null) {\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isNodeAttribute = true;\n\n    /**\n     * The name of the attribute.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * The type of the attribute.\n     *\n     * @type {String}\n     */\n    this.type = type;\n\n    /**\n     * An optional reference to the node.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.node = node;\n  }\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader uniforms that are going to be generated\n * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}\n * for this purpose.\n */\nclass NodeUniform {\n  /**\n   * Constructs a new node uniform.\n   *\n   * @param {String} name - The name of the uniform.\n   * @param {String} type - The type of the uniform.\n   * @param {UniformNode} node - An reference to the node.\n   */\n  constructor(name, type, node) {\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isNodeUniform = true;\n\n    /**\n     * The name of the uniform.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * The type of the uniform.\n     *\n     * @type {String}\n     */\n    this.type = type;\n\n    /**\n     * An reference to the node.\n     *\n     * @type {UniformNode}\n     */\n    this.node = node.getSelf();\n  }\n\n  /**\n   * The value of the uniform node.\n   *\n   * @type {Any}\n   */\n  get value() {\n    return this.node.value;\n  }\n  set value(val) {\n    this.node.value = val;\n  }\n\n  /**\n   * The id of the uniform node.\n   *\n   * @type {Number}\n   */\n  get id() {\n    return this.node.id;\n  }\n\n  /**\n   * The uniform node's group.\n   *\n   * @type {UniformGroupNode}\n   */\n  get groupNode() {\n    return this.node.groupNode;\n  }\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader variables that are going to be generated\n * by the builder. A dictionary of node variables is maintained in {@link NodeBuilder#vars} for\n * this purpose.\n */\nclass NodeVar {\n  /**\n   * Constructs a new node variable.\n   *\n   * @param {String} name - The name of the variable.\n   * @param {String} type - The type of the variable.\n   */\n  constructor(name, type) {\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isNodeVar = true;\n\n    /**\n     * The name of the variable.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * The type of the variable.\n     *\n     * @type {String}\n     */\n    this.type = type;\n  }\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader varyings that are going to be generated\n * by the builder. An array of node varyings is maintained in {@link NodeBuilder#varyings} for\n * this purpose.\n *\n * @augments NodeVar\n */\nclass NodeVarying extends NodeVar {\n  /**\n   * Constructs a new node varying.\n   *\n   * @param {String} name - The name of the varying.\n   * @param {String} type - The type of the varying.\n   */\n  constructor(name, type) {\n    super(name, type);\n\n    /**\n     * Whether this varying requires interpolation or not. This property can be used\n     * to check if the varying can be optimized for a variable.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.needsInterpolation = false;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isNodeVarying = true;\n  }\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent user-defined, native shader code portions that are going to be\n * injected by the builder. A dictionary of node codes is maintained in {@link NodeBuilder#codes}\n * for this purpose.\n */\nclass NodeCode {\n  /**\n   * Constructs a new code node.\n   *\n   * @param {String} name - The name of the code.\n   * @param {String} type - The node type.\n   * @param {String} [code=''] - The native shader code.\n   */\n  constructor(name, type, code = '') {\n    /**\n     * The name of the code.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * The node type.\n     *\n     * @type {String}\n     */\n    this.type = type;\n\n    /**\n     * The native shader code.\n     *\n     * @type {String}\n     * @default ''\n     */\n    this.code = code;\n    Object.defineProperty(this, 'isNodeCode', {\n      value: true\n    });\n  }\n}\nlet _id$5 = 0;\n\n/**\n * This utility class is used in {@link NodeBuilder} as an internal\n * cache data structure for node data.\n */\nclass NodeCache {\n  /**\n   * Constructs a new node cache.\n   *\n   * @param {NodeCache?} parent - A reference to a parent cache.\n   */\n  constructor(parent = null) {\n    /**\n     * The id of the cache.\n     *\n     * @type {Number}\n     * @readonly\n     */\n    this.id = _id$5++;\n\n    /**\n     * A weak map for managing node data.\n     *\n     * @type {WeakMap<Node, Object>}\n     */\n    this.nodesData = new WeakMap();\n\n    /**\n     * Reference to a parent node cache.\n     *\n     * @type {NodeCache?}\n     * @default null\n     */\n    this.parent = parent;\n  }\n\n  /**\n   * Returns the data for the given node.\n   *\n   * @param {Node} node - The node.\n   * @return {Object?} The data for the node.\n   */\n  getData(node) {\n    let data = this.nodesData.get(node);\n    if (data === undefined && this.parent !== null) {\n      data = this.parent.getData(node);\n    }\n    return data;\n  }\n\n  /**\n   * Sets the data for a given node.\n   *\n   * @param {Node} node - The node.\n   * @param {Object} data - The data that should be cached.\n   */\n  setData(node, data) {\n    this.nodesData.set(node, data);\n  }\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader struct data that are going to be generated\n * by the builder. A dictionary of struct types is maintained in {@link NodeBuilder#structs}\n * for this purpose.\n */\nclass StructTypeNode extends Node {\n  static get type() {\n    return 'StructTypeNode';\n  }\n\n  /**\n   * Constructs a new struct type node.\n   *\n   * @param {String} name - The name of the struct.\n   * @param {Array<String>} types - An array of types.\n   */\n  constructor(name, types) {\n    super();\n\n    /**\n     * The name of the struct.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * An array of types.\n     *\n     * @type {Array<String>}\n     */\n    this.types = types;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isStructTypeNode = true;\n  }\n\n  /**\n   * Returns the member types.\n   *\n   * @return {Array<String>} The types.\n   */\n  getMemberTypes() {\n    return this.types;\n  }\n}\n\n/**\n * Abstract base class for uniforms.\n *\n * @abstract\n * @private\n */\nclass Uniform {\n  /**\n   * Constructs a new uniform.\n   *\n   * @param {String} name - The uniform's name.\n   * @param {Any} value - The uniform's value.\n   */\n  constructor(name, value) {\n    /**\n     * The uniform's name.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * The uniform's value.\n     *\n     * @type {Any}\n     */\n    this.value = value;\n\n    /**\n     * Used to build the uniform buffer according to the STD140 layout.\n     * Derived uniforms will set this property to a data type specific\n     * value.\n     *\n     * @type {Number}\n     */\n    this.boundary = 0;\n\n    /**\n     * The item size. Derived uniforms will set this property to a data\n     * type specific value.\n     *\n     * @type {Number}\n     */\n    this.itemSize = 0;\n\n    /**\n     * This property is set by {@link UniformsGroup} and marks\n     * the start position in the uniform buffer.\n     *\n     * @type {Number}\n     */\n    this.offset = 0;\n  }\n\n  /**\n   * Sets the uniform's value.\n   *\n   * @param {Any} value - The value to set.\n   */\n  setValue(value) {\n    this.value = value;\n  }\n\n  /**\n   * Returns the uniform's value.\n   *\n   * @return {Any} The value.\n   */\n  getValue() {\n    return this.value;\n  }\n}\n\n/**\n * Represents a Number uniform.\n *\n * @private\n * @augments Uniform\n */\nclass NumberUniform extends Uniform {\n  /**\n   * Constructs a new Number uniform.\n   *\n   * @param {String} name - The uniform's name.\n   * @param {Number} value - The uniform's value.\n   */\n  constructor(name, value = 0) {\n    super(name, value);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isNumberUniform = true;\n    this.boundary = 4;\n    this.itemSize = 1;\n  }\n}\n\n/**\n * Represents a Vector2 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector2Uniform extends Uniform {\n  /**\n   * Constructs a new Number uniform.\n   *\n   * @param {String} name - The uniform's name.\n   * @param {Vector2} value - The uniform's value.\n   */\n  constructor(name, value = new Vector2()) {\n    super(name, value);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isVector2Uniform = true;\n    this.boundary = 8;\n    this.itemSize = 2;\n  }\n}\n\n/**\n * Represents a Vector3 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector3Uniform extends Uniform {\n  /**\n   * Constructs a new Number uniform.\n   *\n   * @param {String} name - The uniform's name.\n   * @param {Vector3} value - The uniform's value.\n   */\n  constructor(name, value = new Vector3()) {\n    super(name, value);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isVector3Uniform = true;\n    this.boundary = 16;\n    this.itemSize = 3;\n  }\n}\n\n/**\n * Represents a Vector4 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector4Uniform extends Uniform {\n  /**\n   * Constructs a new Number uniform.\n   *\n   * @param {String} name - The uniform's name.\n   * @param {Vector4} value - The uniform's value.\n   */\n  constructor(name, value = new Vector4()) {\n    super(name, value);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isVector4Uniform = true;\n    this.boundary = 16;\n    this.itemSize = 4;\n  }\n}\n\n/**\n * Represents a Color uniform.\n *\n * @private\n * @augments Uniform\n */\nclass ColorUniform extends Uniform {\n  /**\n   * Constructs a new Number uniform.\n   *\n   * @param {String} name - The uniform's name.\n   * @param {Color} value - The uniform's value.\n   */\n  constructor(name, value = new Color()) {\n    super(name, value);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isColorUniform = true;\n    this.boundary = 16;\n    this.itemSize = 3;\n  }\n}\n\n/**\n * Represents a Matrix3 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix3Uniform extends Uniform {\n  /**\n   * Constructs a new Number uniform.\n   *\n   * @param {String} name - The uniform's name.\n   * @param {Matrix3} value - The uniform's value.\n   */\n  constructor(name, value = new Matrix3()) {\n    super(name, value);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMatrix3Uniform = true;\n    this.boundary = 48;\n    this.itemSize = 12;\n  }\n}\n\n/**\n * Represents a Matrix4 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix4Uniform extends Uniform {\n  /**\n   * Constructs a new Number uniform.\n   *\n   * @param {String} name - The uniform's name.\n   * @param {Matrix4} value - The uniform's value.\n   */\n  constructor(name, value = new Matrix4()) {\n    super(name, value);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isMatrix4Uniform = true;\n    this.boundary = 64;\n    this.itemSize = 16;\n  }\n}\n\n/**\n * A special form of Number uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments NumberUniform\n */\nclass NumberNodeUniform extends NumberUniform {\n  /**\n   * Constructs a new node-based Number uniform.\n   *\n   * @param {NodeUniform} nodeUniform - The node uniform.\n   */\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n\n    /**\n     * The node uniform.\n     *\n     * @type {NodeUniform}\n     */\n    this.nodeUniform = nodeUniform;\n  }\n\n  /**\n   * Overwritten to return the value of the node uniform.\n   *\n   * @return {Number} The value.\n   */\n  getValue() {\n    return this.nodeUniform.value;\n  }\n\n  /**\n   * Returns the node uniform data type.\n   *\n   * @return {String} The data type.\n   */\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\n\n/**\n * A special form of Vector2 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector2Uniform\n */\nclass Vector2NodeUniform extends Vector2Uniform {\n  /**\n   * Constructs a new node-based Vector2 uniform.\n   *\n   * @param {NodeUniform} nodeUniform - The node uniform.\n   */\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n\n    /**\n     * The node uniform.\n     *\n     * @type {NodeUniform}\n     */\n    this.nodeUniform = nodeUniform;\n  }\n\n  /**\n   * Overwritten to return the value of the node uniform.\n   *\n   * @return {Vector2} The value.\n   */\n  getValue() {\n    return this.nodeUniform.value;\n  }\n\n  /**\n   * Returns the node uniform data type.\n   *\n   * @return {String} The data type.\n   */\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\n\n/**\n * A special form of Vector3 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector3Uniform\n */\nclass Vector3NodeUniform extends Vector3Uniform {\n  /**\n   * Constructs a new node-based Vector3 uniform.\n   *\n   * @param {NodeUniform} nodeUniform - The node uniform.\n   */\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n\n    /**\n     * The node uniform.\n     *\n     * @type {NodeUniform}\n     */\n    this.nodeUniform = nodeUniform;\n  }\n\n  /**\n   * Overwritten to return the value of the node uniform.\n   *\n   * @return {Vector3} The value.\n   */\n  getValue() {\n    return this.nodeUniform.value;\n  }\n\n  /**\n   * Returns the node uniform data type.\n   *\n   * @return {String} The data type.\n   */\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\n\n/**\n * A special form of Vector4 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector4Uniform\n */\nclass Vector4NodeUniform extends Vector4Uniform {\n  /**\n   * Constructs a new node-based Vector4 uniform.\n   *\n   * @param {NodeUniform} nodeUniform - The node uniform.\n   */\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n\n    /**\n     * The node uniform.\n     *\n     * @type {NodeUniform}\n     */\n    this.nodeUniform = nodeUniform;\n  }\n\n  /**\n   * Overwritten to return the value of the node uniform.\n   *\n   * @return {Vector4} The value.\n   */\n  getValue() {\n    return this.nodeUniform.value;\n  }\n\n  /**\n   * Returns the node uniform data type.\n   *\n   * @return {String} The data type.\n   */\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\n\n/**\n * A special form of Color uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments ColorUniform\n */\nclass ColorNodeUniform extends ColorUniform {\n  /**\n   * Constructs a new node-based Color uniform.\n   *\n   * @param {NodeUniform} nodeUniform - The node uniform.\n   */\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n\n    /**\n     * The node uniform.\n     *\n     * @type {NodeUniform}\n     */\n    this.nodeUniform = nodeUniform;\n  }\n\n  /**\n   * Overwritten to return the value of the node uniform.\n   *\n   * @return {Color} The value.\n   */\n  getValue() {\n    return this.nodeUniform.value;\n  }\n\n  /**\n   * Returns the node uniform data type.\n   *\n   * @return {String} The data type.\n   */\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\n\n/**\n * A special form of Matrix3 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix3Uniform\n */\nclass Matrix3NodeUniform extends Matrix3Uniform {\n  /**\n   * Constructs a new node-based Matrix3 uniform.\n   *\n   * @param {NodeUniform} nodeUniform - The node uniform.\n   */\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n\n    /**\n     * The node uniform.\n     *\n     * @type {NodeUniform}\n     */\n    this.nodeUniform = nodeUniform;\n  }\n\n  /**\n   * Overwritten to return the value of the node uniform.\n   *\n   * @return {Matrix3} The value.\n   */\n  getValue() {\n    return this.nodeUniform.value;\n  }\n\n  /**\n   * Returns the node uniform data type.\n   *\n   * @return {String} The data type.\n   */\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\n\n/**\n * A special form of Matrix4 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix4Uniform\n */\nclass Matrix4NodeUniform extends Matrix4Uniform {\n  /**\n   * Constructs a new node-based Matrix4 uniform.\n   *\n   * @param {NodeUniform} nodeUniform - The node uniform.\n   */\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n\n    /**\n     * The node uniform.\n     *\n     * @type {NodeUniform}\n     */\n    this.nodeUniform = nodeUniform;\n  }\n\n  /**\n   * Overwritten to return the value of the node uniform.\n   *\n   * @return {Matrix4} The value.\n   */\n  getValue() {\n    return this.nodeUniform.value;\n  }\n\n  /**\n   * Returns the node uniform data type.\n   *\n   * @return {String} The data type.\n   */\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst _flatCamera = /*@__PURE__*/new OrthographicCamera(-1, 1, 1, -1, 0, 1);\nconst _cubeCamera = /*@__PURE__*/new PerspectiveCamera(90, 1);\nconst _clearColor = /*@__PURE__*/new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [/*@__PURE__*/new Vector3(-PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, 1)];\n\n//\n\n// WebGPU Face indices\nconst _faceLib = [3, 1, 5, 0, 4, 2];\nconst direction = getDirection(uv(), attribute('faceIndex')).normalize();\nconst outputDirection = vec3(direction.x, direction.y, direction.z);\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = [];\n    this._lodMeshes = [];\n    this._blurMaterial = null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n    this._backgroundBox = null;\n  }\n  get _hasInitialized() {\n    return this._renderer.hasInitialized();\n  }\n\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   *\n   * @param {Scene} scene - The scene to be captured.\n   * @param {Number} [sigma=0] - The blur radius in radians.\n   * @param {Number} [near=0.1] - The near plane distance.\n   * @param {Number} [far=100] - The far plane distance.\n   * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n   * @return {RenderTarget} The resulting PMREM.\n   */\n  fromScene(scene, sigma = 0, near = 0.1, far = 100, renderTarget = null) {\n    this._setSize(256);\n    if (this._hasInitialized === false) {\n      console.warn('THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.');\n      const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n      this.fromSceneAsync(scene, sigma, near, far, cubeUVRenderTarget);\n      return cubeUVRenderTarget;\n    }\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    cubeUVRenderTarget.depthBuffer = true;\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  async fromSceneAsync(scene, sigma = 0, near = 0.1, far = 100, renderTarget = null) {\n    if (this._hasInitialized === false) await this._renderer.init();\n    return this.fromScene(scene, sigma, near, far, renderTarget);\n  }\n\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   *\n   * @param {Texture} equirectangular - The equirectangular texture to be converted.\n   * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n   * @return {RenderTarget} The resulting PMREM.\n   */\n  fromEquirectangular(equirectangular, renderTarget = null) {\n    if (this._hasInitialized === false) {\n      console.warn('THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.');\n      this._setSizeFromTexture(equirectangular);\n      const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n      this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);\n      return cubeUVRenderTarget;\n    }\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n  async fromEquirectangularAsync(equirectangular, renderTarget = null) {\n    if (this._hasInitialized === false) await this._renderer.init();\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   *\n   * @param {Texture} cubemap - The cubemap texture to be converted.\n   * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n   * @return {RenderTarget} The resulting PMREM.\n   */\n  fromCubemap(cubemap, renderTarget = null) {\n    if (this._hasInitialized === false) {\n      console.warn('THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.');\n      this._setSizeFromTexture(cubemap);\n      const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n      this.fromCubemapAsync(cubemap, renderTarget);\n      return cubeUVRenderTarget;\n    }\n    return this._fromTexture(cubemap, renderTarget);\n  }\n  async fromCubemapAsync(cubemap, renderTarget = null) {\n    if (this._hasInitialized === false) await this._renderer.init();\n    return this._fromTexture(cubemap, renderTarget);\n  }\n\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  async compileCubemapShader() {\n    if (this._cubemapMaterial === null) {\n      this._cubemapMaterial = _getCubemapMaterial();\n      await this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  async compileEquirectangularShader() {\n    if (this._equirectMaterial === null) {\n      this._equirectMaterial = _getEquirectMaterial();\n      await this._compileMaterial(this._equirectMaterial);\n    }\n  }\n\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n  dispose() {\n    this._dispose();\n    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n    if (this._backgroundBox !== null) {\n      this._backgroundBox.geometry.dispose();\n      this._backgroundBox.material.dispose();\n    }\n  }\n\n  // private interface\n\n  _setSizeFromTexture(texture) {\n    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {\n      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);\n    } else {\n      // Equirectangular\n\n      this._setSize(texture.image.width / 4);\n    }\n  }\n  _setSize(cubeSize) {\n    this._lodMax = Math.floor(Math.log2(cubeSize));\n    this._cubeSize = Math.pow(2, this._lodMax);\n  }\n  _dispose() {\n    if (this._blurMaterial !== null) this._blurMaterial.dispose();\n    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n    for (let i = 0; i < this._lodPlanes.length; i++) {\n      this._lodPlanes[i].dispose();\n    }\n  }\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);\n    outputTarget.scissorTest = false;\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n  _fromTexture(texture, renderTarget) {\n    this._setSizeFromTexture(texture);\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  _allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * 7);\n    const height = 4 * this._cubeSize;\n    const params = {\n      magFilter: LinearFilter,\n      minFilter: LinearFilter,\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace\n      //depthBuffer: false\n    };\n    const cubeUVRenderTarget = _createRenderTarget(width, height, params);\n    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {\n      if (this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n      this._pingPongRenderTarget = _createRenderTarget(width, height, params);\n      const {\n        _lodMax\n      } = this;\n      ({\n        sizeLods: this._sizeLods,\n        lodPlanes: this._lodPlanes,\n        sigmas: this._sigmas,\n        lodMeshes: this._lodMeshes\n      } = _createPlanes(_lodMax));\n      this._blurMaterial = _getBlurShader(_lodMax, width, height);\n    }\n    return cubeUVRenderTarget;\n  }\n  async _compileMaterial(material) {\n    const tmpMesh = new Mesh(this._lodPlanes[0], material);\n    await this._renderer.compile(tmpMesh, _flatCamera);\n  }\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const cubeCamera = _cubeCamera;\n    cubeCamera.near = near;\n    cubeCamera.far = far;\n\n    // px, py, pz, nx, ny, nz\n    const upSign = [1, 1, 1, 1, -1, 1];\n    const forwardSign = [1, -1, 1, -1, 1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    renderer.getClearColor(_clearColor);\n    renderer.autoClear = false;\n    let backgroundBox = this._backgroundBox;\n    if (backgroundBox === null) {\n      const backgroundMaterial = new MeshBasicMaterial({\n        name: 'PMREM.Background',\n        side: BackSide,\n        depthWrite: false,\n        depthTest: false\n      });\n      backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n    }\n    let useSolidColor = false;\n    const background = scene.background;\n    if (background) {\n      if (background.isColor) {\n        backgroundBox.material.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundBox.material.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.clear();\n    if (useSolidColor) {\n      renderer.render(backgroundBox, cubeCamera);\n    }\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n      const size = this._cubeSize;\n      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);\n      renderer.render(scene, cubeCamera);\n    }\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;\n    if (isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        this._cubemapMaterial = _getCubemapMaterial(texture);\n      }\n    } else {\n      if (this._equirectMaterial === null) {\n        this._equirectMaterial = _getEquirectMaterial(texture);\n      }\n    }\n    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n    material.fragmentNode.value = texture;\n    const mesh = this._lodMeshes[0];\n    mesh.material = material;\n    const size = this._cubeSize;\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    const n = this._lodPlanes.length;\n    for (let i = 1; i < n; i++) {\n      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);\n      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n    renderer.autoClear = autoClear;\n  }\n\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   *\n   * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.\n   * @param {Number} lodIn - The input level-of-detail.\n   * @param {Number} lodOut - The output level-of-detail.\n   * @param {Number} sigma - The blur radius in radians.\n   * @param {Vector3} [poleAxis] - The pole axis.\n   */\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    }\n\n    // Number of standard deviations at which to cut off the discrete approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = this._lodMeshes[lodOut];\n    blurMesh.material = blurMaterial;\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = this._sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n      if (i === 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;\n    blurUniforms.envMap.value = targetIn.texture;\n    blurUniforms.samples.value = samples;\n    blurUniforms.weights.array = weights;\n    blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n    if (poleAxis) {\n      blurUniforms.poleAxis.value = poleAxis;\n    }\n    const {\n      _lodMax\n    } = this;\n    blurUniforms.dTheta.value = radiansPerPixel;\n    blurUniforms.mipInt.value = _lodMax - lodIn;\n    const outputSize = this._sizeLods[lodOut];\n    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n    const y = 4 * (this._cubeSize - outputSize);\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n}\nfunction _createPlanes(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  const sigmas = [];\n  const lodMeshes = [];\n  let lod = lodMax;\n  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n  for (let i = 0; i < totalLods; i++) {\n    const sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    let sigma = 1.0 / sizeLod;\n    if (i > lodMax - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];\n    } else if (i === 0) {\n      sigma = 0;\n    }\n    sigmas.push(sigma);\n    const texelSize = 1.0 / (sizeLod - 2);\n    const min = -texelSize;\n    const max = 1 + texelSize;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      const faceIdx = _faceLib[face];\n      position.set(coordinates, positionSize * vertices * faceIdx);\n      uv.set(uv1, uvSize * vertices * faceIdx);\n      const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];\n      faceIndex.set(fill, faceIndexSize * vertices * faceIdx);\n    }\n    const planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n    lodMeshes.push(new Mesh(planes, null));\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n  return {\n    lodPlanes,\n    sizeLods,\n    sigmas,\n    lodMeshes\n  };\n}\nfunction _createRenderTarget(width, height, params) {\n  const cubeUVRenderTarget = new RenderTarget(width, height, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.texture.isPMREMTexture = true;\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\nfunction _getMaterial(type) {\n  const material = new NodeMaterial();\n  material.depthTest = false;\n  material.depthWrite = false;\n  material.blending = NoBlending;\n  material.name = `PMREM_${type}`;\n  return material;\n}\nfunction _getBlurShader(lodMax, width, height) {\n  const weights = uniformArray(new Array(MAX_SAMPLES).fill(0));\n  const poleAxis = uniform(new Vector3(0, 1, 0));\n  const dTheta = uniform(0);\n  const n = float(MAX_SAMPLES);\n  const latitudinal = uniform(0); // false, bool\n  const samples = uniform(1); // int\n  const envMap = texture(null);\n  const mipInt = uniform(0); // int\n  const CUBEUV_TEXEL_WIDTH = float(1 / width);\n  const CUBEUV_TEXEL_HEIGHT = float(1 / height);\n  const CUBEUV_MAX_MIP = float(lodMax);\n  const materialUniforms = {\n    n,\n    latitudinal,\n    weights,\n    poleAxis,\n    outputDirection,\n    dTheta,\n    samples,\n    envMap,\n    mipInt,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  };\n  const material = _getMaterial('blur');\n  material.uniforms = materialUniforms; // TODO: Move to outside of the material\n  material.fragmentNode = blur({\n    ...materialUniforms,\n    latitudinal: latitudinal.equal(1)\n  });\n  return material;\n}\nfunction _getCubemapMaterial(envTexture) {\n  const material = _getMaterial('cubemap');\n  material.fragmentNode = cubeTexture(envTexture, outputDirection);\n  return material;\n}\nfunction _getEquirectMaterial(envTexture) {\n  const material = _getMaterial('equirect');\n  material.fragmentNode = texture(envTexture, equirectUV(outputDirection), 0);\n  return material;\n}\nconst rendererCache = new WeakMap();\nconst typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);\nconst toFloat = value => {\n  if (/e/g.test(value)) {\n    return String(value).replace(/\\+/g, '');\n  } else {\n    value = Number(value);\n    return value + (value % 1 ? '' : '.0');\n  }\n};\n\n/**\n * Base class for builders which generate a shader program based\n * on a 3D object and its node material definition.\n */\nclass NodeBuilder {\n  /**\n   * Constructs a new node builder.\n   *\n   * @param {Object3D} object - The 3D object.\n   * @param {Renderer} renderer - The current renderer.\n   * @param {NodeParser} parser - A reference to a node parser.\n   */\n  constructor(object, renderer, parser) {\n    /**\n     * The 3D object.\n     *\n     * @type {Object3D}\n     */\n    this.object = object;\n\n    /**\n     * The material of the 3D object.\n     *\n     * @type {Material?}\n     */\n    this.material = object && object.material || null;\n\n    /**\n     * The geometry of the 3D object.\n     *\n     * @type {BufferGeometry?}\n     */\n    this.geometry = object && object.geometry || null;\n\n    /**\n     * The current renderer.\n     *\n     * @type {Renderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * A reference to a node parser.\n     *\n     * @type {NodeParser}\n     */\n    this.parser = parser;\n\n    /**\n     * The scene the 3D object belongs to.\n     *\n     * @type {Scene?}\n     * @default null\n     */\n    this.scene = null;\n\n    /**\n     * The camera the 3D object is rendered with.\n     *\n     * @type {Camera?}\n     * @default null\n     */\n    this.camera = null;\n\n    /**\n     * A list of all nodes the builder is processing\n     * for this 3D object.\n     *\n     * @type {Array<Node>}\n     */\n    this.nodes = [];\n\n    /**\n     * A list of all sequential nodes.\n     *\n     * @type {Array<Node>}\n     */\n    this.sequentialNodes = [];\n\n    /**\n     * A list of all nodes which {@link Node#update} method should be executed.\n     *\n     * @type {Array<Node>}\n     */\n    this.updateNodes = [];\n\n    /**\n     * A list of all nodes which {@link Node#updateBefore} method should be executed.\n     *\n     * @type {Array<Node>}\n     */\n    this.updateBeforeNodes = [];\n\n    /**\n     * A list of all nodes which {@link Node#updateAfter} method should be executed.\n     *\n     * @type {Array<Node>}\n     */\n    this.updateAfterNodes = [];\n\n    /**\n     * A dictionary that assigns each node to a unique hash.\n     *\n     * @type {Object<Number,Node>}\n     */\n    this.hashNodes = {};\n\n    /**\n     * A reference to a node material observer.\n     *\n     * @type {NodeMaterialObserver?}\n     * @default null\n     */\n    this.monitor = null;\n\n    /**\n     * A reference to the current lights node.\n     *\n     * @type {LightsNode?}\n     * @default null\n     */\n    this.lightsNode = null;\n\n    /**\n     * A reference to the current environment node.\n     *\n     * @type {Node?}\n     * @default null\n     */\n    this.environmentNode = null;\n\n    /**\n     * A reference to the current fog node.\n     *\n     * @type {FogNode?}\n     * @default null\n     */\n    this.fogNode = null;\n\n    /**\n     * The current clipping context.\n     *\n     * @type {ClippingContext?}\n     */\n    this.clippingContext = null;\n\n    /**\n     * The generated vertex shader.\n     *\n     * @type {String?}\n     */\n    this.vertexShader = null;\n\n    /**\n     * The generated fragment shader.\n     *\n     * @type {String?}\n     */\n    this.fragmentShader = null;\n\n    /**\n     * The generated compute shader.\n     *\n     * @type {String?}\n     */\n    this.computeShader = null;\n\n    /**\n     * Nodes used in the primary flow of code generation.\n     *\n     * @type {Object<String,Array<Node>>}\n     */\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n\n    /**\n     * Nodes code from `.flowNodes`.\n     *\n     * @type {Object<String,String>}\n     */\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: ''\n    };\n\n    /**\n     * This dictionary holds the node uniforms of the builder.\n     * The uniforms are maintained in an array for each shader stage.\n     *\n     * @type {Object}\n     */\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n\n    /**\n     * This dictionary holds the output structs of the builder.\n     * The structs are maintained in an array for each shader stage.\n     *\n     * @type {Object}\n     */\n    this.structs = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n\n    /**\n     * This dictionary holds the bindings for each shader stage.\n     *\n     * @type {Object}\n     */\n    this.bindings = {\n      vertex: {},\n      fragment: {},\n      compute: {}\n    };\n\n    /**\n     * This dictionary maintains the binding indices per bind group.\n     *\n     * @type {Object}\n     */\n    this.bindingsIndexes = {};\n\n    /**\n     * Reference to the array of bind groups.\n     *\n     * @type {Array<BindGroup>?}\n     */\n    this.bindGroups = null;\n\n    /**\n     * This array holds the node attributes of this builder\n     * created via {@link AttributeNode}.\n     *\n     * @type {Array<NodeAttribute>}\n     */\n    this.attributes = [];\n\n    /**\n     * This array holds the node attributes of this builder\n     * created via {@link BufferAttributeNode}.\n     *\n     * @type {Array<NodeAttribute>}\n     */\n    this.bufferAttributes = [];\n\n    /**\n     * This array holds the node varyings of this builder.\n     *\n     * @type {Array<NodeVarying>}\n     */\n    this.varyings = [];\n\n    /**\n     * This dictionary holds the (native) node codes of this builder.\n     * The codes are maintained in an array for each shader stage.\n     *\n     * @type {Object<String,Array<NodeCode>>}\n     */\n    this.codes = {};\n\n    /**\n     * This dictionary holds the node variables of this builder.\n     * The variables are maintained in an array for each shader stage.\n     *\n     * @type {Object<String,Array<NodeVar>>}\n     */\n    this.vars = {};\n\n    /**\n     * Current code flow.\n     * All code generated in this stack will be stored in `.flow`.\n     *\n     * @type {{code: String}}\n     */\n    this.flow = {\n      code: ''\n    };\n\n    /**\n     * A chain of nodes.\n     * Used to check recursive calls in node-graph.\n     *\n     * @type {Array<Node>}\n     */\n    this.chaining = [];\n\n    /**\n     * The current stack.\n     * This reflects the current process in the code block hierarchy,\n     * it is useful to know if the current process is inside a conditional for example.\n     *\n     * @type {StackNode}\n     */\n    this.stack = stack();\n\n    /**\n     * List of stack nodes.\n     * The current stack hierarchy is stored in an array.\n     *\n     * @type {Array<StackNode>}\n     */\n    this.stacks = [];\n\n    /**\n     * A tab value. Used for shader string generation.\n     *\n     * @type {String}\n     * @default '\\t'\n     */\n    this.tab = '\\t';\n\n    /**\n     * Reference to the current function node.\n     *\n     * @type {FunctionNode?}\n     * @default null\n     */\n    this.currentFunctionNode = null;\n\n    /**\n     * The builder's context.\n     *\n     * @type {Object}\n     */\n    this.context = {\n      material: this.material\n    };\n\n    /**\n     * The builder's cache.\n     *\n     * @type {NodeCache}\n     */\n    this.cache = new NodeCache();\n\n    /**\n     * Since the {@link NodeBuilder#cache} might be temporarily\n     * overwritten by other caches, this member retains the reference\n     * to the builder's own cache.\n     *\n     * @type {NodeCache}\n     * @default this.cache\n     */\n    this.globalCache = this.cache;\n    this.flowsData = new WeakMap();\n\n    /**\n     * The current shader stage.\n     *\n     * @type {('vertex'|'fragment'|'compute'|'any')?}\n     */\n    this.shaderStage = null;\n\n    /**\n     * The current build stage.\n     *\n     * @type {('setup'|'analyze'|'generate')?}\n     */\n    this.buildStage = null;\n\n    /**\n     * Whether comparison in shader code are generated with methods or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.useComparisonMethod = false;\n  }\n\n  /**\n   * Returns the bind groups of the current renderer.\n   *\n   * @return {ChainMap} The cache.\n   */\n  getBindGroupsCache() {\n    let bindGroupsCache = rendererCache.get(this.renderer);\n    if (bindGroupsCache === undefined) {\n      bindGroupsCache = new ChainMap();\n      rendererCache.set(this.renderer, bindGroupsCache);\n    }\n    return bindGroupsCache;\n  }\n\n  /**\n   * Factory method for creating an instance of {@link RenderTarget} with the given\n   * dimensions and options.\n   *\n   * @param {Number} width - The width of the render target.\n   * @param {Number} height - The height of the render target.\n   * @param {Object} options - The options of the render target.\n   * @return {RenderTarget} The render target.\n   */\n  createRenderTarget(width, height, options) {\n    return new RenderTarget(width, height, options);\n  }\n\n  /**\n   * Factory method for creating an instance of {@link CubeRenderTarget} with the given\n   * dimensions and options.\n   *\n   * @param {Number} size - The size of the cube render target.\n   * @param {Object} options - The options of the cube render target.\n   * @return {CubeRenderTarget} The cube render target.\n   */\n  createCubeRenderTarget(size, options) {\n    return new CubeRenderTarget(size, options);\n  }\n\n  /**\n   * Factory method for creating an instance of {@link PMREMGenerator}.\n   *\n   * @return {PMREMGenerator} The PMREM generator.\n   */\n  createPMREMGenerator() {\n    // TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n    return new PMREMGenerator(this.renderer);\n  }\n\n  /**\n   * Whether the given node is included in the internal array of nodes or not.\n   *\n   * @param {Node} node - The node to test.\n   * @return {Boolean} Whether the given node is included in the internal array of nodes or not.\n   */\n  includes(node) {\n    return this.nodes.includes(node);\n  }\n\n  /**\n   * Returns a bind group for the given group name and binding.\n   *\n   * @private\n   * @param {String} groupName - The group name.\n   * @param {Array<NodeUniformsGroup>} bindings - List of bindings.\n   * @return {BindGroup} The bind group\n   */\n  _getBindGroup(groupName, bindings) {\n    const bindGroupsCache = this.getBindGroupsCache();\n\n    //\n\n    const bindingsArray = [];\n    let sharedGroup = true;\n    for (const binding of bindings) {\n      bindingsArray.push(binding);\n      sharedGroup = sharedGroup && binding.groupNode.shared !== true;\n    }\n\n    //\n\n    let bindGroup;\n    if (sharedGroup) {\n      bindGroup = bindGroupsCache.get(bindingsArray);\n      if (bindGroup === undefined) {\n        bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);\n        bindGroupsCache.set(bindingsArray, bindGroup);\n      }\n    } else {\n      bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);\n    }\n    return bindGroup;\n  }\n\n  /**\n   * Returns an array of node uniform groups for the given group name and shader stage.\n   *\n   * @param {String} groupName - The group name.\n   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n   * @return {Array<NodeUniformsGroup>} The array of node uniform groups.\n   */\n  getBindGroupArray(groupName, shaderStage) {\n    const bindings = this.bindings[shaderStage];\n    let bindGroup = bindings[groupName];\n    if (bindGroup === undefined) {\n      if (this.bindingsIndexes[groupName] === undefined) {\n        this.bindingsIndexes[groupName] = {\n          binding: 0,\n          group: Object.keys(this.bindingsIndexes).length\n        };\n      }\n      bindings[groupName] = bindGroup = [];\n    }\n    return bindGroup;\n  }\n\n  /**\n   * Returns a list bindings of all shader stages separated by groups.\n   *\n   * @return {Array<BindGroup>} The list of bindings.\n   */\n  getBindings() {\n    let bindingsGroups = this.bindGroups;\n    if (bindingsGroups === null) {\n      const groups = {};\n      const bindings = this.bindings;\n      for (const shaderStage of shaderStages) {\n        for (const groupName in bindings[shaderStage]) {\n          const uniforms = bindings[shaderStage][groupName];\n          const groupUniforms = groups[groupName] || (groups[groupName] = []);\n          groupUniforms.push(...uniforms);\n        }\n      }\n      bindingsGroups = [];\n      for (const groupName in groups) {\n        const group = groups[groupName];\n        const bindingsGroup = this._getBindGroup(groupName, group);\n        bindingsGroups.push(bindingsGroup);\n      }\n      this.bindGroups = bindingsGroups;\n    }\n    return bindingsGroups;\n  }\n\n  /**\n   * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.\n   */\n  sortBindingGroups() {\n    const bindingsGroups = this.getBindings();\n    bindingsGroups.sort((a, b) => a.bindings[0].groupNode.order - b.bindings[0].groupNode.order);\n    for (let i = 0; i < bindingsGroups.length; i++) {\n      const bindingGroup = bindingsGroups[i];\n      this.bindingsIndexes[bindingGroup.name].group = i;\n      bindingGroup.index = i;\n    }\n  }\n\n  /**\n   * The builder maintains each node in a hash-based dictionary.\n   * This method sets the given node (value) with the given hash (key) into this dictionary.\n   *\n   * @param {Node} node - The node to add.\n   * @param {Number} hash - The hash of the node.\n   */\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  /**\n   * Adds a node to this builder.\n   *\n   * @param {Node} node - The node to add.\n   */\n  addNode(node) {\n    if (this.nodes.includes(node) === false) {\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  /**\n   * It is used to add Nodes that will be used as FRAME and RENDER events,\n   * and need to follow a certain sequence in the calls to work correctly.\n   * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.\n   *\n   * @param {Node} node - The node to add.\n   */\n  addSequentialNode(node) {\n    if (this.sequentialNodes.includes(node) === false) {\n      this.sequentialNodes.push(node);\n    }\n  }\n\n  /**\n   * Checks the update types of nodes\n   */\n  buildUpdateNodes() {\n    for (const node of this.nodes) {\n      const updateType = node.getUpdateType();\n      if (updateType !== NodeUpdateType.NONE) {\n        this.updateNodes.push(node.getSelf());\n      }\n    }\n    for (const node of this.sequentialNodes) {\n      const updateBeforeType = node.getUpdateBeforeType();\n      const updateAfterType = node.getUpdateAfterType();\n      if (updateBeforeType !== NodeUpdateType.NONE) {\n        this.updateBeforeNodes.push(node.getSelf());\n      }\n      if (updateAfterType !== NodeUpdateType.NONE) {\n        this.updateAfterNodes.push(node.getSelf());\n      }\n    }\n  }\n\n  /**\n   * A reference the current node which is the\n   * last node in the chain of nodes.\n   *\n   * @type {Node}\n   */\n  get currentNode() {\n    return this.chaining[this.chaining.length - 1];\n  }\n\n  /**\n   * Whether the given texture is filtered or not.\n   *\n   * @param {Texture} texture - The texture to check.\n   * @return {Boolean} Whether the given texture is filtered or not.\n   */\n  isFilteredTexture(texture) {\n    return texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter;\n  }\n\n  /**\n   * Adds the given node to the internal node chain.\n   * This is used to check recursive calls in node-graph.\n   *\n   * @param {Node} node - The node to add.\n   */\n  addChain(node) {\n    /*\n    if ( this.chaining.indexOf( node ) !== - 1 ) {\n    \t\tconsole.warn( 'Recursive node: ', node );\n    \t}\n    */\n\n    this.chaining.push(node);\n  }\n\n  /**\n   * Removes the given node from the internal node chain.\n   *\n   * @param {Node} node - The node to remove.\n   */\n  removeChain(node) {\n    const lastChain = this.chaining.pop();\n    if (lastChain !== node) {\n      throw new Error('NodeBuilder: Invalid node chaining!');\n    }\n  }\n\n  /**\n   * Returns the native shader method name for a given generic name. E.g.\n   * the method name `textureDimensions` matches the WGSL name but must be\n   * resolved to `textureSize` in GLSL.\n   *\n   * @abstract\n   * @param {String} method - The method name to resolve.\n   * @return {String} The resolved method name.\n   */\n  getMethod(method) {\n    return method;\n  }\n\n  /**\n   * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.\n   *\n   * @param {Number} hash - The hash of the node.\n   * @return {Node} The found node.\n   */\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  /**\n   * Adds the Node to a target flow so that it can generate code in the 'generate' process.\n   *\n   * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.\n   * @param {Node} node - The node to add.\n   * @return {Node} The node.\n   */\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  /**\n   * Sets builder's context.\n   *\n   * @param {Object} context - The context to set.\n   */\n  setContext(context) {\n    this.context = context;\n  }\n\n  /**\n   * Returns the builder's current context.\n   *\n   * @return {Object} The builder's current context.\n   */\n  getContext() {\n    return this.context;\n  }\n\n  /**\n   * Gets a context used in shader construction that can be shared across different materials.\n   * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.\n   *\n   * @return {Object} The builder's current context without material.\n   */\n  getSharedContext() {\n    ({\n      ...this.context\n    });\n    return this.context;\n  }\n\n  /**\n   * Sets builder's cache.\n   *\n   * @param {NodeCache} cache - The cache to set.\n   */\n  setCache(cache) {\n    this.cache = cache;\n  }\n\n  /**\n   * Returns the builder's current cache.\n   *\n   * @return {NodeCache} The builder's current cache.\n   */\n  getCache() {\n    return this.cache;\n  }\n\n  /**\n   * Returns a cache for the given node.\n   *\n   * @param {Node} node - The node.\n   * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n   * @return {NodeCache} The cache.\n   */\n  getCacheFromNode(node, parent = true) {\n    const data = this.getDataFromNode(node);\n    if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);\n    return data.cache;\n  }\n\n  /**\n   * Whether the requested feature is available or not.\n   *\n   * @abstract\n   * @param {String} name - The requested feature.\n   * @return {Boolean} Whether the requested feature is supported or not.\n   */\n  isAvailable(/*name*/\n  ) {\n    return false;\n  }\n\n  /**\n   * Returns the vertexIndex input variable as a native shader string.\n   *\n   * @abstract\n   * @return {String} The instanceIndex shader string.\n   */\n  getVertexIndex() {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Returns the instanceIndex input variable as a native shader string.\n   *\n   * @abstract\n   * @return {String} The instanceIndex shader string.\n   */\n  getInstanceIndex() {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Returns the drawIndex input variable as a native shader string.\n   * Only relevant for WebGL and its `WEBGL_multi_draw` extension.\n   *\n   * @abstract\n   * @return {String} The drawIndex shader string.\n   */\n  getDrawIndex() {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Returns the frontFacing input variable as a native shader string.\n   *\n   * @abstract\n   * @return {String} The frontFacing shader string.\n   */\n  getFrontFacing() {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Returns the fragCoord input variable as a native shader string.\n   *\n   * @abstract\n   * @return {String} The fragCoord shader string.\n   */\n  getFragCoord() {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Whether to flip texture data along its vertical axis or not. WebGL needs\n   * this method evaluate to `true`, WebGPU to `false`.\n   *\n   * @abstract\n   * @return {Boolean} Whether to flip texture data along its vertical axis or not.\n   */\n  isFlipY() {\n    return false;\n  }\n\n  /**\n   * Calling this method increases the usage count for the given node by one.\n   *\n   * @param {Node} node - The node to increase the usage count for.\n   * @return {Number} The updated usage count.\n   */\n  increaseUsage(node) {\n    const nodeData = this.getDataFromNode(node);\n    nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;\n    return nodeData.usageCount;\n  }\n\n  /**\n   * Generates a texture sample shader string for the given texture data.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture.\n   * @param {String} textureProperty - The texture property name.\n   * @param {String} uvSnippet - Snippet defining the texture coordinates.\n   * @return {String} The generated shader string.\n   */\n  generateTexture(/* texture, textureProperty, uvSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Generates a texture LOD shader string for the given texture data.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture.\n   * @param {String} textureProperty - The texture property name.\n   * @param {String} uvSnippet - Snippet defining the texture coordinates.\n   * @param {String} levelSnippet - Snippet defining the mip level.\n   * @return {String} The generated shader string.\n   */\n  generateTextureLod(/* texture, textureProperty, uvSnippet, levelSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Generates the shader string for the given type and value.\n   *\n   * @param {String} type - The type.\n   * @param {Any?} [value=null] - The value.\n   * @return {String} The generated value as a shader string.\n   */\n  generateConst(type, value = null) {\n    if (value === null) {\n      if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n    }\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n    const generateConst = value => this.generateConst(componentType, value);\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;\n    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n      return `${this.getType(type)}( ${value.elements.map(generateConst).join(', ')} )`;\n    } else if (typeLength > 4) {\n      return `${this.getType(type)}()`;\n    }\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  /**\n   * It might be necessary to convert certain data types to different ones\n   * so this method can be used to hide the conversion.\n   *\n   * @param {String} type - The type.\n   * @return {String} The updated type.\n   */\n  getType(type) {\n    if (type === 'color') return 'vec3';\n    return type;\n  }\n\n  /**\n   * Whether the given attribute name is defined in the geometry or not.\n   *\n   * @param {String} name - The attribute name.\n   * @return {Boolean} Whether the given attribute name is defined in the geometry.\n   */\n  hasGeometryAttribute(name) {\n    return this.geometry && this.geometry.getAttribute(name) !== undefined;\n  }\n\n  /**\n   * Returns a node attribute for the given name and type.\n   *\n   * @param {String} name - The attribute's name.\n   * @param {String} type - The attribute's type.\n   * @return {NodeAttribute} The node attribute.\n   */\n  getAttribute(name, type) {\n    const attributes = this.attributes;\n\n    // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    }\n\n    // create a new if no exist\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  /**\n   * Returns for the given node and shader stage the property name for the shader.\n   *\n   * @param {Node} node - The node.\n   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n   * @return {String} The property name.\n   */\n  getPropertyName(node /*, shaderStage*/) {\n    return node.name;\n  }\n\n  /**\n   * Whether the given type is a vector type or not.\n   *\n   * @param {String} type - The type to check.\n   * @return {Boolean} Whether the given type is a vector type or not.\n   */\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  /**\n   * Whether the given type is a matrix type or not.\n   *\n   * @param {String} type - The type to check.\n   * @return {Boolean} Whether the given type is a matrix type or not.\n   */\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  /**\n   * Whether the given type is a reference type or not.\n   *\n   * @param {String} type - The type to check.\n   * @return {Boolean} Whether the given type is a reference type or not.\n   */\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';\n  }\n\n  /**\n   * Whether the given texture needs a conversion to working color space.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture to check.\n   * @return {Boolean} Whether a color space conversion is required or not.\n   */\n  needsToWorkingColorSpace(/*texture*/\n  ) {\n    return false;\n  }\n\n  /**\n   * Returns the component type of a given texture.\n   *\n   * @param {Texture} texture - The texture.\n   * @return {String} The component type.\n   */\n  getComponentTypeFromTexture(texture) {\n    const type = texture.type;\n    if (texture.isDataTexture) {\n      if (type === IntType) return 'int';\n      if (type === UnsignedIntType) return 'uint';\n    }\n    return 'float';\n  }\n\n  /**\n   * Returns the element type for a given type.\n   *\n   * @param {String} type - The type.\n   * @return {String} The element type.\n   */\n  getElementType(type) {\n    if (type === 'mat2') return 'vec2';\n    if (type === 'mat3') return 'vec3';\n    if (type === 'mat4') return 'vec4';\n    return this.getComponentType(type);\n  }\n\n  /**\n   * Returns the component type for a given type.\n   *\n   * @param {String} type - The type.\n   * @return {String} The component type.\n   */\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  /**\n   * Returns the vector type for a given type.\n   *\n   * @param {String} type - The type.\n   * @return {String} The vector type.\n   */\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') return 'vec4';\n    return type;\n  }\n\n  /**\n   * Returns the data type for the given the length and component type.\n   *\n   * @param {Number} length - The length.\n   * @param {String} [componentType='float'] - The component type.\n   * @return {String} The type.\n   */\n  getTypeFromLength(length, componentType = 'float') {\n    if (length === 1) return componentType;\n    const baseType = getTypeFromLength(length);\n    const prefix = componentType === 'float' ? '' : componentType[0];\n    return prefix + baseType;\n  }\n\n  /**\n   * Returns the type for a given typed array.\n   *\n   * @param {TypedArray} array - The typed array.\n   * @return {String} The type.\n   */\n  getTypeFromArray(array) {\n    return typeFromArray.get(array.constructor);\n  }\n\n  /**\n   * Returns the type for a given buffer attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute.\n   * @return {String} The type.\n   */\n  getTypeFromAttribute(attribute) {\n    let dataAttribute = attribute;\n    if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n    const array = dataAttribute.array;\n    const itemSize = attribute.itemSize;\n    const normalized = attribute.normalized;\n    let arrayType;\n    if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {\n      arrayType = this.getTypeFromArray(array);\n    }\n    return this.getTypeFromLength(itemSize, arrayType);\n  }\n\n  /**\n   * Returns the length for the given data type.\n   *\n   * @param {String} type - The data type.\n   * @return {Number} The length.\n   */\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    if (/mat2/.test(type) === true) return 4;\n    if (/mat3/.test(type) === true) return 9;\n    if (/mat4/.test(type) === true) return 16;\n    return 0;\n  }\n\n  /**\n   * Returns the vector type for a given matrix type.\n   *\n   * @param {String} type - The matrix type.\n   * @return {String} The vector type.\n   */\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  /**\n   * For a given type this method changes the component type to the\n   * given value. E.g. `vec4` should be changed to the new component type\n   * `uint` which results in `uvec4`.\n   *\n   * @param {String} type - The type.\n   * @param {String} newComponentType - The new component type.\n   * @return {String} The new type.\n   */\n  changeComponentType(type, newComponentType) {\n    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n  }\n\n  /**\n   * Returns the integer type pendant for the given type.\n   *\n   * @param {String} type - The type.\n   * @return {String} The integer type.\n   */\n  getIntegerType(type) {\n    const componentType = this.getComponentType(type);\n    if (componentType === 'int' || componentType === 'uint') return type;\n    return this.changeComponentType(type, 'int');\n  }\n\n  /**\n   * Adds a stack node to the internal stack.\n   *\n   * @return {StackNode} The added stack node.\n   */\n  addStack() {\n    this.stack = stack(this.stack);\n    this.stacks.push(getCurrentStack() || this.stack);\n    setCurrentStack(this.stack);\n    return this.stack;\n  }\n\n  /**\n   * Removes the last stack node from the internal stack.\n   *\n   * @return {StackNode} The removed stack node.\n   */\n  removeStack() {\n    const lastStack = this.stack;\n    this.stack = lastStack.parent;\n    setCurrentStack(this.stacks.pop());\n    return lastStack;\n  }\n\n  /**\n   * The builder maintains (cached) data for each node during the building process. This method\n   * can be used to get these data for a specific shader stage and cache.\n   *\n   * @param {Node} node - The node to get the data for.\n   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n   * @param {NodeCache?} cache - An optional cache.\n   * @return {Object} The node data.\n   */\n  getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {\n    cache = cache === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache;\n    let nodeData = cache.getData(node);\n    if (nodeData === undefined) {\n      nodeData = {};\n      cache.setData(node, nodeData);\n    }\n    if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};\n    return nodeData[shaderStage];\n  }\n\n  /**\n   * Returns the properties for the given node and shader stage.\n   *\n   * @param {Node} node - The node to get the properties for.\n   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.\n   * @return {Object} The node properties.\n   */\n  getNodeProperties(node, shaderStage = 'any') {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    return nodeData.properties || (nodeData.properties = {\n      outputNode: null\n    });\n  }\n\n  /**\n   * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.\n   *\n   * @param {BufferAttributeNode} node - The buffer attribute node.\n   * @param {String} type - The node type.\n   * @return {NodeAttribute} The node attribute.\n   */\n  getBufferAttributeFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node);\n    let bufferAttribute = nodeData.bufferAttribute;\n    if (bufferAttribute === undefined) {\n      const index = this.uniforms.index++;\n      bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);\n      this.bufferAttributes.push(bufferAttribute);\n      nodeData.bufferAttribute = bufferAttribute;\n    }\n    return bufferAttribute;\n  }\n\n  /**\n   * Returns an instance of {@link StructTypeNode} for the given output struct node.\n   *\n   * @param {OutputStructNode} node - The output struct node.\n   * @param {Array<String>} types - The output struct types.\n   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n   * @return {StructTypeNode} The struct type attribute.\n   */\n  getStructTypeFromNode(node, types, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let structType = nodeData.structType;\n    if (structType === undefined) {\n      const index = this.structs.index++;\n      structType = new StructTypeNode('StructType' + index, types);\n      this.structs[shaderStage].push(structType);\n      nodeData.structType = structType;\n    }\n    return structType;\n  }\n\n  /**\n   * Returns an instance of {@link NodeUniform} for the given uniform node.\n   *\n   * @param {UniformNode} node - The uniform node.\n   * @param {String} type - The uniform type.\n   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n   * @param {String?} name - The name of the uniform.\n   * @return {NodeUniform} The node uniform.\n   */\n  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    let nodeUniform = nodeData.uniform;\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform(name || 'nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n    return nodeUniform;\n  }\n\n  /**\n   * Returns an instance of {@link NodeVar} for the given variable node.\n   *\n   * @param {VarNode} node - The variable node.\n   * @param {String?} name - The variable's name.\n   * @param {String} [type=node.getNodeType( this )] - The variable's type.\n   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n   * @return {NodeVar} The node variable.\n   */\n  getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);\n      if (name === null) name = 'nodeVar' + vars.length;\n      nodeVar = new NodeVar(name, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n    return nodeVar;\n  }\n\n  /**\n   * Returns an instance of {@link NodeVarying} for the given varying node.\n   *\n   * @param {(VaryingNode|PropertyNode)} node - The varying node.\n   * @param {String?} name - The varying's name.\n   * @param {String} [type=node.getNodeType( this )] - The varying's type.\n   * @return {NodeVar} The node varying.\n   */\n  getVaryingFromNode(node, name = null, type = node.getNodeType(this)) {\n    const nodeData = this.getDataFromNode(node, 'any');\n    let nodeVarying = nodeData.varying;\n    if (nodeVarying === undefined) {\n      const varyings = this.varyings;\n      const index = varyings.length;\n      if (name === null) name = 'nodeVarying' + index;\n      nodeVarying = new NodeVarying(name, type);\n      varyings.push(nodeVarying);\n      nodeData.varying = nodeVarying;\n    }\n    return nodeVarying;\n  }\n\n  /**\n   * Returns an instance of {@link NodeCode} for the given code node.\n   *\n   * @param {CodeNode} node - The code node.\n   * @param {String} type - The node type.\n   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n   * @return {NodeCode} The node code.\n   */\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return nodeCode;\n  }\n\n  /**\n   * Adds a code flow based on the code-block hierarchy.\n  \t * This is used so that code-blocks like If,Else create their variables locally if the Node\n   * is only used inside one of these conditionals in the current shader stage.\n   *\n   * @param {Node} node - The node to add.\n   * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.\n   */\n  addFlowCodeHierarchy(node, nodeBlock) {\n    const {\n      flowCodes,\n      flowCodeBlock\n    } = this.getDataFromNode(node);\n    let needsFlowCode = true;\n    let nodeBlockHierarchy = nodeBlock;\n    while (nodeBlockHierarchy) {\n      if (flowCodeBlock.get(nodeBlockHierarchy) === true) {\n        needsFlowCode = false;\n        break;\n      }\n      nodeBlockHierarchy = this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;\n    }\n    if (needsFlowCode) {\n      for (const flowCode of flowCodes) {\n        this.addLineFlowCode(flowCode);\n      }\n    }\n  }\n\n  /**\n   * Add a inline-code to the current flow code-block.\n   *\n   * @param {Node} node - The node to add.\n   * @param {String} code - The code to add.\n   * @param {Node} nodeBlock - Current ConditionalNode\n   */\n  addLineFlowCodeBlock(node, code, nodeBlock) {\n    const nodeData = this.getDataFromNode(node);\n    const flowCodes = nodeData.flowCodes || (nodeData.flowCodes = []);\n    const codeBlock = nodeData.flowCodeBlock || (nodeData.flowCodeBlock = new WeakMap());\n    flowCodes.push(code);\n    codeBlock.set(nodeBlock, true);\n  }\n\n  /**\n   * Add a inline-code to the current flow.\n   *\n   * @param {String} code - The code to add.\n   * @param {Node?} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.\n   * @return {NodeBuilder} A reference to this node builder.\n   */\n  addLineFlowCode(code, node = null) {\n    if (code === '') return this;\n    if (node !== null && this.context.nodeBlock) {\n      this.addLineFlowCodeBlock(node, code, this.context.nodeBlock);\n    }\n    code = this.tab + code;\n    if (!/;\\s*$/.test(code)) {\n      code = code + ';\\n';\n    }\n    this.flow.code += code;\n    return this;\n  }\n\n  /**\n   * Adds a code to the current code flow.\n   *\n   * @param {String} code - Shader code.\n   * @return {NodeBuilder} A reference to this node builder.\n   */\n  addFlowCode(code) {\n    this.flow.code += code;\n    return this;\n  }\n\n  /**\n   * Add tab in the code that will be generated so that other snippets respect the current tabulation.\n   * Typically used in codes with If,Else.\n   *\n   * @return {NodeBuilder} A reference to this node builder.\n   */\n  addFlowTab() {\n    this.tab += '\\t';\n    return this;\n  }\n\n  /**\n   * Removes a tab.\n   *\n   * @return {NodeBuilder} A reference to this node builder.\n   */\n  removeFlowTab() {\n    this.tab = this.tab.slice(0, -1);\n    return this;\n  }\n\n  /**\n   * Gets the current flow data based on a Node.\n   *\n   * @param {Node} node - Node that the flow was started.\n   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n   * @return {Object} The flow data.\n   */\n  getFlowData(node /*, shaderStage*/) {\n    return this.flowsData.get(node);\n  }\n\n  /**\n   * Executes the node flow based on a root node to generate the final shader code.\n   *\n   * @param {Node} node - The node to execute.\n   * @return {Object} The code flow.\n   */\n  flowNode(node) {\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    return flowData;\n  }\n\n  /**\n   * Returns the native shader operator name for a given generic name.\n   * It is a similar type of method like {@link NodeBuilder#getMethod}.\n   *\n   * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.\n   * @return {FunctionNode} The build function node.\n   */\n  buildFunctionNode(shaderNode) {\n    const fn = new FunctionNode();\n    const previous = this.currentFunctionNode;\n    this.currentFunctionNode = fn;\n    fn.code = this.buildFunctionCode(shaderNode);\n    this.currentFunctionNode = previous;\n    return fn;\n  }\n\n  /**\n   * Generates a code flow based on a TSL function: Fn().\n   *\n   * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.\n   * @return {Object}\n   */\n  flowShaderNode(shaderNode) {\n    const layout = shaderNode.layout;\n    const inputs = {\n      [Symbol.iterator]() {\n        let index = 0;\n        const values = Object.values(this);\n        return {\n          next: () => ({\n            value: values[index],\n            done: index++ >= values.length\n          })\n        };\n      }\n    };\n    for (const input of layout.inputs) {\n      inputs[input.name] = new ParameterNode(input.type, input.name);\n    }\n\n    //\n\n    shaderNode.layout = null;\n    const callNode = shaderNode.call(inputs);\n    const flowData = this.flowStagesNode(callNode, layout.type);\n    shaderNode.layout = layout;\n    return flowData;\n  }\n\n  /**\n   * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.\n   *\n   * @param {Node} node - The node to execute.\n   * @param {String?} output - Expected output type. For example 'vec3'.\n   * @return {Object}\n   */\n  flowStagesNode(node, output = null) {\n    const previousFlow = this.flow;\n    const previousVars = this.vars;\n    const previousCache = this.cache;\n    const previousBuildStage = this.buildStage;\n    const previousStack = this.stack;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    this.vars = {};\n    this.cache = new NodeCache();\n    this.stack = stack();\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      flow.result = node.build(this, output);\n    }\n    flow.vars = this.getVars(this.shaderStage);\n    this.flow = previousFlow;\n    this.vars = previousVars;\n    this.cache = previousCache;\n    this.stack = previousStack;\n    this.setBuildStage(previousBuildStage);\n    return flow;\n  }\n\n  /**\n   * Returns the native shader operator name for a given generic name.\n   * It is a similar type of method like {@link NodeBuilder#getMethod}.\n   *\n   * @abstract\n   * @param {String} op - The operator name to resolve.\n   * @return {String} The resolved operator name.\n   */\n  getFunctionOperator(/* op */\n  ) {\n    return null;\n  }\n\n  /**\n   * Generates a code flow based on a child Node.\n   *\n   * @param {Node} node - The node to execute.\n   * @param {String?} output - Expected output type. For example 'vec3'.\n   * @return {Object} The code flow.\n   */\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  /**\n   * Executes a flow of code in a different stage.\n   *\n   * Some nodes like `varying()` have the ability to compute code in vertex-stage and\n   * return the value in fragment-stage even if it is being executed in an input fragment.\n   *\n   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n   * @param {Node} node - The node to execute.\n   * @param {String?} output - Expected output type. For example 'vec3'.\n   * @param {String?} propertyName - The property name to assign the result.\n   * @return {Object}\n   */\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n    if (propertyName !== null) {\n      flowData.code += `${this.tab + propertyName} = ${flowData.result};\\n`;\n    }\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  /**\n   * Returns an array holding all node attributes of this node builder.\n   *\n   * @return {Array<NodeAttribute>} The node attributes of this builder.\n   */\n  getAttributesArray() {\n    return this.attributes.concat(this.bufferAttributes);\n  }\n\n  /**\n   * Returns the attribute definitions as a shader string for the given shader stage.\n   *\n   * @abstract\n   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n   * @return {String} The attribute code section.\n   */\n  getAttributes(/*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Returns the varying definitions as a shader string for the given shader stage.\n   *\n   * @abstract\n   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n   * @return {String} The varying code section.\n   */\n  getVaryings(/*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Returns a single variable definition as a shader string for the given variable type and name.\n   *\n   * @param {String} type - The variable's type.\n   * @param {String} name - The variable's name.\n   * @return {String} The shader string.\n   */\n  getVar(type, name) {\n    return `${this.getType(type)} ${name}`;\n  }\n\n  /**\n   * Returns the variable definitions as a shader string for the given shader stage.\n   *\n   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n   * @return {String} The variable code section.\n   */\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippet += `${this.getVar(variable.type, variable.name)}; `;\n      }\n    }\n    return snippet;\n  }\n\n  /**\n   * Returns the uniform definitions as a shader string for the given shader stage.\n   *\n   * @abstract\n   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n   * @return {String} The uniform code section.\n   */\n  getUniforms(/*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Returns the native code definitions as a shader string for the given shader stage.\n   *\n   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n   * @return {String} The native code section.\n   */\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n    if (codes !== undefined) {\n      for (const nodeCode of codes) {\n        code += nodeCode.code + '\\n';\n      }\n    }\n    return code;\n  }\n\n  /**\n   * Returns the hash of this node builder.\n   *\n   * @return {String} The hash.\n   */\n  getHash() {\n    return this.vertexShader + this.fragmentShader + this.computeShader;\n  }\n\n  /**\n   * Sets the current shader stage.\n   *\n   * @param {('vertex'|'fragment'|'compute'|'any')?} shaderStage - The shader stage to set.\n   */\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  /**\n   * Returns the current shader stage.\n   *\n   * @return {('vertex'|'fragment'|'compute'|'any')?} The current shader stage.\n   */\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  /**\n   * Sets the current build stage.\n   *\n   * @param {('setup'|'analyze'|'generate')?} buildStage - The build stage to set.\n   */\n  setBuildStage(buildStage) {\n    this.buildStage = buildStage;\n  }\n\n  /**\n   * Returns the current build stage.\n   *\n   * @return {('setup'|'analyze'|'generate')?} The current build stage.\n   */\n  getBuildStage() {\n    return this.buildStage;\n  }\n\n  /**\n   * Controls the code build of the shader stages.\n   *\n   * @abstract\n   */\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  /**\n   * Central build method which controls the build for the given object.\n   *\n   * @return {NodeBuilder} A reference to this node builder.\n   */\n  build() {\n    const {\n      object,\n      material,\n      renderer\n    } = this;\n    if (material !== null) {\n      let nodeMaterial = renderer.library.fromMaterial(material);\n      if (nodeMaterial === null) {\n        console.error(`NodeMaterial: Material \"${material.type}\" is not compatible.`);\n        nodeMaterial = new NodeMaterial();\n      }\n      nodeMaterial.build(this);\n    } else {\n      this.addFlow('compute', object);\n    }\n\n    // setup() -> stage 1: create possible new nodes and returns an output reference node\n    // analyze()   -> stage 2: analyze nodes to possible optimization and validation\n    // generate()  -> stage 3: generate shader\n\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      }\n      for (const shaderStage of shaderStages) {\n        this.setShaderStage(shaderStage);\n        const flowNodes = this.flowNodes[shaderStage];\n        for (const node of flowNodes) {\n          if (buildStage === 'generate') {\n            this.flowNode(node);\n          } else {\n            node.build(this);\n          }\n        }\n      }\n    }\n    this.setBuildStage(null);\n    this.setShaderStage(null);\n\n    // stage 4: build code for a specific output\n\n    this.buildCode();\n    this.buildUpdateNodes();\n    return this;\n  }\n\n  /**\n   * Returns a uniform representation which is later used for UBO generation and rendering.\n   *\n   * @param {NodeUniform} uniformNode - The uniform node.\n   * @param {String} type - The requested type.\n   * @return {Uniform} The uniform.\n   */\n  getNodeUniform(uniformNode, type) {\n    if (type === 'float' || type === 'int' || type === 'uint') return new NumberNodeUniform(uniformNode);\n    if (type === 'vec2' || type === 'ivec2' || type === 'uvec2') return new Vector2NodeUniform(uniformNode);\n    if (type === 'vec3' || type === 'ivec3' || type === 'uvec3') return new Vector3NodeUniform(uniformNode);\n    if (type === 'vec4' || type === 'ivec4' || type === 'uvec4') return new Vector4NodeUniform(uniformNode);\n    if (type === 'color') return new ColorNodeUniform(uniformNode);\n    if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);\n    if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);\n    throw new Error(`Uniform \"${type}\" not declared.`);\n  }\n\n  /**\n   * Formats the given shader snippet from a given type into another one. E.g.\n   * this method might be used to convert a simple float string `\"1.0\"` into a\n   * `vec3` representation: `\"vec3<f32>( 1.0 )\"`.\n   *\n   * @param {String} snippet - The shader snippet.\n   * @param {String} fromType - The source type.\n   * @param {String} toType - The target type.\n   * @return {String} The updated shader string.\n   */\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n    if (fromTypeLength === 16 && toTypeLength === 9) {\n      return `${this.getType(toType)}(${snippet}[0].xyz, ${snippet}[1].xyz, ${snippet}[2].xyz)`;\n    }\n    if (fromTypeLength === 9 && toTypeLength === 4) {\n      return `${this.getType(toType)}(${snippet}[0].xy, ${snippet}[1].xy)`;\n    }\n    if (fromTypeLength > 4) {\n      // fromType is matrix-like\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (toTypeLength > 4 || toTypeLength === 0) {\n      // toType is matrix-like or unknown\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);\n    }\n    if (toTypeLength === 4 && fromTypeLength > 1) {\n      // toType is vec4-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n    if (fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType(toType)) {\n      // fromType is float-like\n\n      // convert a number value to vector type, e.g:\n      // vec3( 1u ) -> vec3( float( 1u ) )\n\n      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;\n    }\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  /**\n   * Returns a signature with the engine's current revision.\n   *\n   * @return {String} The signature.\n   */\n  getSignature() {\n    return `// Three.js r${REVISION} - Node System\\n`;\n  }\n\n  // deprecated\n\n  createNodeMaterial(type = 'NodeMaterial') {\n    // @deprecated, r168\n\n    throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${type}() instead.`);\n  }\n}\n\n/**\n * Management class for updating nodes. The module tracks metrics like\n * the elapsed time, delta time, the render and frame ID to correctly\n * call the node update methods {@link Node#updateBefore}, {@link Node#update}\n * and {@link Node#updateAfter} depending on the node's configuration.\n */\nclass NodeFrame {\n  /**\n   * Constructs a new node fame.\n   */\n  constructor() {\n    /**\n     * The elapsed time in seconds.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.time = 0;\n\n    /**\n     * The delta time in seconds.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.deltaTime = 0;\n\n    /**\n     * The frame ID.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.frameId = 0;\n\n    /**\n     * The render ID.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.renderId = 0;\n\n    /**\n     * Used to control the {@link Node#update} call.\n     *\n     * @type {WeakMap<Node, Object>}\n     */\n    this.updateMap = new WeakMap();\n\n    /**\n     * Used to control the {@link Node#updateBefore} call.\n     *\n     * @type {WeakMap<Node, Object>}\n     */\n    this.updateBeforeMap = new WeakMap();\n\n    /**\n     * Used to control the {@link Node#updateAfter} call.\n     *\n     * @type {WeakMap<Node, Object>}\n     */\n    this.updateAfterMap = new WeakMap();\n\n    /**\n     * A reference to the current renderer.\n     *\n     * @type {Renderer?}\n     * @default null\n     */\n    this.renderer = null;\n\n    /**\n     * A reference to the current material.\n     *\n     * @type {Material?}\n     * @default null\n     */\n    this.material = null;\n\n    /**\n     * A reference to the current camera.\n     *\n     * @type {Camera?}\n     * @default null\n     */\n    this.camera = null;\n\n    /**\n     * A reference to the current 3D object.\n     *\n     * @type {Object3D?}\n     * @default null\n     */\n    this.object = null;\n\n    /**\n     * A reference to the current scene.\n     *\n     * @type {Scene?}\n     * @default null\n     */\n    this.scene = null;\n  }\n\n  /**\n   * Returns a dictionary for a given node and update map which\n   * is used to correctly call node update methods per frame or render.\n   *\n   * @private\n   * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.\n   * @param {Node} nodeRef - The reference to the current node.\n   * @return {Object<String,WeakMap>} The dictionary.\n   */\n  _getMaps(referenceMap, nodeRef) {\n    let maps = referenceMap.get(nodeRef);\n    if (maps === undefined) {\n      maps = {\n        renderMap: new WeakMap(),\n        frameMap: new WeakMap()\n      };\n      referenceMap.set(nodeRef, maps);\n    }\n    return maps;\n  }\n\n  /**\n   * This method executes the {@link Node#updateBefore} for the given node.\n   * It makes sure {@link Node#updateBeforeType} is honored meaning the update\n   * is only executed once per frame, render or object depending on the update\n   * type.\n   *\n   * @param {Node} node - The node that should be updated.\n   */\n  updateBeforeNode(node) {\n    const updateType = node.getUpdateBeforeType();\n    const reference = node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n      const {\n        frameMap\n      } = this._getMaps(this.updateBeforeMap, reference);\n      if (frameMap.get(reference) !== this.frameId) {\n        if (node.updateBefore(this) !== false) {\n          frameMap.set(reference, this.frameId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const {\n        renderMap\n      } = this._getMaps(this.updateBeforeMap, reference);\n      if (renderMap.get(reference) !== this.renderId) {\n        if (node.updateBefore(this) !== false) {\n          renderMap.set(reference, this.renderId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.OBJECT) {\n      node.updateBefore(this);\n    }\n  }\n\n  /**\n   * This method executes the {@link Node#updateAfter} for the given node.\n   * It makes sure {@link Node#updateAfterType} is honored meaning the update\n   * is only executed once per frame, render or object depending on the update\n   * type.\n   *\n   * @param {Node} node - The node that should be updated.\n   */\n  updateAfterNode(node) {\n    const updateType = node.getUpdateAfterType();\n    const reference = node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n      const {\n        frameMap\n      } = this._getMaps(this.updateAfterMap, reference);\n      if (frameMap.get(reference) !== this.frameId) {\n        if (node.updateAfter(this) !== false) {\n          frameMap.set(reference, this.frameId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const {\n        renderMap\n      } = this._getMaps(this.updateAfterMap, reference);\n      if (renderMap.get(reference) !== this.renderId) {\n        if (node.updateAfter(this) !== false) {\n          renderMap.set(reference, this.renderId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.OBJECT) {\n      node.updateAfter(this);\n    }\n  }\n\n  /**\n   * This method executes the {@link Node#update} for the given node.\n   * It makes sure {@link Node#updateType} is honored meaning the update\n   * is only executed once per frame, render or object depending on the update\n   * type.\n   *\n   * @param {Node} node - The node that should be updated.\n   */\n  updateNode(node) {\n    const updateType = node.getUpdateType();\n    const reference = node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n      const {\n        frameMap\n      } = this._getMaps(this.updateMap, reference);\n      if (frameMap.get(reference) !== this.frameId) {\n        if (node.update(this) !== false) {\n          frameMap.set(reference, this.frameId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const {\n        renderMap\n      } = this._getMaps(this.updateMap, reference);\n      if (renderMap.get(reference) !== this.renderId) {\n        if (node.update(this) !== false) {\n          renderMap.set(reference, this.renderId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.OBJECT) {\n      node.update(this);\n    }\n  }\n\n  /**\n   * Updates the internal state of the node frame. This method is\n   * called by the renderer in its internal animation loop.\n   */\n  update() {\n    this.frameId++;\n    if (this.lastTime === undefined) this.lastTime = performance.now();\n    this.deltaTime = (performance.now() - this.lastTime) / 1000;\n    this.lastTime = performance.now();\n    this.time += this.deltaTime;\n  }\n}\n\n/**\n * Describes the input of a {@link NodeFunction}.\n */\nclass NodeFunctionInput {\n  /**\n   * Constructs a new node function input.\n   *\n   * @param {String} type - The input type.\n   * @param {String} name - The input name.\n   * @param {Number?} [count=null] - If the input is an Array, count will be the length.\n   * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).\n   * @param {Boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).\n   */\n  constructor(type, name, count = null, qualifier = '', isConst = false) {\n    /**\n     *  The input type.\n     *\n     * @type {String}\n     */\n    this.type = type;\n\n    /**\n     * The input name.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * If the input is an Array, count will be the length.\n     *\n     * @type {Number?}\n     * @default null\n     */\n    this.count = count;\n\n    /**\n     *The parameter qualifier (only relevant for GLSL).\n     *\n     * @type {('in'|'out'|'inout')}\n     * @default ''\n     */\n    this.qualifier = qualifier;\n\n    /**\n     * Whether the input uses a const qualifier or not (only relevant for GLSL).\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.isConst = isConst;\n  }\n}\nNodeFunctionInput.isNodeFunctionInput = true;\n\n/**\n * Module for representing directional lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass DirectionalLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'DirectionalLightNode';\n  }\n\n  /**\n   * Constructs a new directional light node.\n   *\n   * @param {DirectionalLight?} [light=null] - The directional light source.\n   */\n  constructor(light = null) {\n    super(light);\n  }\n  setup(builder) {\n    super.setup(builder);\n    const lightingModel = builder.context.lightingModel;\n    const lightColor = this.colorNode;\n    const lightDirection = lightTargetDirection(this.light);\n    const reflectedLight = builder.context.reflectedLight;\n    lightingModel.direct({\n      lightDirection,\n      lightColor,\n      reflectedLight\n    }, builder.stack, builder);\n  }\n}\nconst _matrix41 = /*@__PURE__*/new Matrix4();\nconst _matrix42 = /*@__PURE__*/new Matrix4();\nlet _ltcLib = null;\n\n/**\n * Module for representing rect area lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass RectAreaLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'RectAreaLightNode';\n  }\n\n  /**\n   * Constructs a new rect area light node.\n   *\n   * @param {RectAreaLight?} [light=null] - The rect area light source.\n   */\n  constructor(light = null) {\n    super(light);\n\n    /**\n     * Uniform node representing the half height of the are light.\n     *\n     * @type {UniformNode<vec3>}\n     */\n    this.halfHeight = uniform(new Vector3()).setGroup(renderGroup);\n\n    /**\n     * Uniform node representing the half width of the are light.\n     *\n     * @type {UniformNode<vec3>}\n     */\n    this.halfWidth = uniform(new Vector3()).setGroup(renderGroup);\n\n    /**\n     * The `updateType` is set to `NodeUpdateType.RENDER` since the light\n     * relies on `viewMatrix` which might vary per render call.\n     *\n     * @type {String}\n     * @default 'render'\n     */\n    this.updateType = NodeUpdateType.RENDER;\n  }\n\n  /**\n   * Overwritten to updated rect area light specific uniforms.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update(frame) {\n    super.update(frame);\n    const {\n      light\n    } = this;\n    const viewMatrix = frame.camera.matrixWorldInverse;\n    _matrix42.identity();\n    _matrix41.copy(light.matrixWorld);\n    _matrix41.premultiply(viewMatrix);\n    _matrix42.extractRotation(_matrix41);\n    this.halfWidth.value.set(light.width * 0.5, 0.0, 0.0);\n    this.halfHeight.value.set(0.0, light.height * 0.5, 0.0);\n    this.halfWidth.value.applyMatrix4(_matrix42);\n    this.halfHeight.value.applyMatrix4(_matrix42);\n  }\n  setup(builder) {\n    super.setup(builder);\n    let ltc_1, ltc_2;\n    if (builder.isAvailable('float32Filterable')) {\n      ltc_1 = texture(_ltcLib.LTC_FLOAT_1);\n      ltc_2 = texture(_ltcLib.LTC_FLOAT_2);\n    } else {\n      ltc_1 = texture(_ltcLib.LTC_HALF_1);\n      ltc_2 = texture(_ltcLib.LTC_HALF_2);\n    }\n    const {\n      colorNode,\n      light\n    } = this;\n    const lightingModel = builder.context.lightingModel;\n    const lightPosition = lightViewPosition(light);\n    const reflectedLight = builder.context.reflectedLight;\n    lightingModel.directRectArea({\n      lightColor: colorNode,\n      lightPosition,\n      halfWidth: this.halfWidth,\n      halfHeight: this.halfHeight,\n      reflectedLight,\n      ltc_1,\n      ltc_2\n    }, builder.stack, builder);\n  }\n\n  /**\n   * Used to configure the internal BRDF approximation texture data.\n   *\n   * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.\n   */\n  static setLTC(ltc) {\n    _ltcLib = ltc;\n  }\n}\n\n/**\n * Module for representing spot lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass SpotLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'SpotLightNode';\n  }\n\n  /**\n   * Constructs a new spot light node.\n   *\n   * @param {SpotLight?} [light=null] - The spot light source.\n   */\n  constructor(light = null) {\n    super(light);\n\n    /**\n     * Uniform node representing the cone cosine.\n     *\n     * @type {UniformNode<float>}\n     */\n    this.coneCosNode = uniform(0).setGroup(renderGroup);\n\n    /**\n     * Uniform node representing the penumbra cosine.\n     *\n     * @type {UniformNode<float>}\n     */\n    this.penumbraCosNode = uniform(0).setGroup(renderGroup);\n\n    /**\n     * Uniform node representing the cutoff distance.\n     *\n     * @type {UniformNode<float>}\n     */\n    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);\n\n    /**\n     * Uniform node representing the decay exponent.\n     *\n     * @type {UniformNode<float>}\n     */\n    this.decayExponentNode = uniform(0).setGroup(renderGroup);\n  }\n\n  /**\n   * Overwritten to updated spot light specific uniforms.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update(frame) {\n    super.update(frame);\n    const {\n      light\n    } = this;\n    this.coneCosNode.value = Math.cos(light.angle);\n    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));\n    this.cutoffDistanceNode.value = light.distance;\n    this.decayExponentNode.value = light.decay;\n  }\n\n  /**\n   * Computes the spot attenuation for the given angle.\n   *\n   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.\n   * @return {Node<float>} The spot attenuation.\n   */\n  getSpotAttenuation(angleCosine) {\n    const {\n      coneCosNode,\n      penumbraCosNode\n    } = this;\n    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);\n  }\n  setup(builder) {\n    super.setup(builder);\n    const lightingModel = builder.context.lightingModel;\n    const {\n      colorNode,\n      cutoffDistanceNode,\n      decayExponentNode,\n      light\n    } = this;\n    const lVector = lightViewPosition(light).sub(positionView); // @TODO: Add it into LightNode\n\n    const lightDirection = lVector.normalize();\n    const angleCos = lightDirection.dot(lightTargetDirection(light));\n    const spotAttenuation = this.getSpotAttenuation(angleCos);\n    const lightDistance = lVector.length();\n    const lightAttenuation = getDistanceAttenuation({\n      lightDistance,\n      cutoffDistance: cutoffDistanceNode,\n      decayExponent: decayExponentNode\n    });\n    let lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);\n    if (light.map) {\n      const spotLightCoord = lightProjectionUV(light);\n      const projectedTexture = texture(light.map, spotLightCoord.xy).onRenderUpdate(() => light.map);\n      const inSpotLightMap = spotLightCoord.mul(2.).sub(1.).abs().lessThan(1.).all();\n      lightColor = inSpotLightMap.select(lightColor.mul(projectedTexture), lightColor);\n    }\n    const reflectedLight = builder.context.reflectedLight;\n    lightingModel.direct({\n      lightDirection,\n      lightColor,\n      reflectedLight\n    }, builder.stack, builder);\n  }\n}\n\n/**\n * An IES version of the default spot light node.\n *\n * @augments SpotLightNode\n */\nclass IESSpotLightNode extends SpotLightNode {\n  static get type() {\n    return 'IESSpotLightNode';\n  }\n\n  /**\n   * Overwrites the default implementation to compute an IES conform spot attenuation.\n   *\n   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.\n   * @return {Node<float>} The spot attenuation.\n   */\n  getSpotAttenuation(angleCosine) {\n    const iesMap = this.light.iesMap;\n    let spotAttenuation = null;\n    if (iesMap && iesMap.isTexture === true) {\n      const angle = angleCosine.acos().mul(1.0 / Math.PI);\n      spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;\n    } else {\n      spotAttenuation = super.getSpotAttenuation(angleCosine);\n    }\n    return spotAttenuation;\n  }\n}\n\n/**\n * Module for representing ambient lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass AmbientLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'AmbientLightNode';\n  }\n\n  /**\n   * Constructs a new ambient light node.\n   *\n   * @param {AmbientLight?} [light=null] - The ambient light source.\n   */\n  constructor(light = null) {\n    super(light);\n  }\n  setup({\n    context\n  }) {\n    context.irradiance.addAssign(this.colorNode);\n  }\n}\n\n/**\n * Module for representing hemisphere lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass HemisphereLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'HemisphereLightNode';\n  }\n\n  /**\n   * Constructs a new hemisphere light node.\n   *\n   * @param {HemisphereLight?} [light=null] - The hemisphere light source.\n   */\n  constructor(light = null) {\n    super(light);\n\n    /**\n     * Uniform node representing the light's position.\n     *\n     * @type {UniformNode<vec3>}\n     */\n    this.lightPositionNode = lightPosition(light);\n\n    /**\n     * A node representing the light's direction.\n     *\n     * @type {Node<vec3>}\n     */\n    this.lightDirectionNode = this.lightPositionNode.normalize();\n\n    /**\n     * Uniform node representing the light's ground color.\n     *\n     * @type {UniformNode<vec3>}\n     */\n    this.groundColorNode = uniform(new Color()).setGroup(renderGroup);\n  }\n\n  /**\n   * Overwritten to updated hemisphere light specific uniforms.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update(frame) {\n    const {\n      light\n    } = this;\n    super.update(frame);\n    this.lightPositionNode.object3d = light;\n    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);\n  }\n  setup(builder) {\n    const {\n      colorNode,\n      groundColorNode,\n      lightDirectionNode\n    } = this;\n    const dotNL = normalView.dot(lightDirectionNode);\n    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);\n    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);\n    builder.context.irradiance.addAssign(irradiance);\n  }\n}\n\n/**\n * Module for representing light probes as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass LightProbeNode extends AnalyticLightNode {\n  static get type() {\n    return 'LightProbeNode';\n  }\n\n  /**\n   * Constructs a new light probe node.\n   *\n   * @param {LightProbe?} [light=null] - The light probe.\n   */\n  constructor(light = null) {\n    super(light);\n    const array = [];\n    for (let i = 0; i < 9; i++) array.push(new Vector3());\n\n    /**\n     * Light probe represented as a uniform of spherical harmonics.\n     *\n     * @type {UniformArrayNode}\n     */\n    this.lightProbe = uniformArray(array);\n  }\n\n  /**\n   * Overwritten to updated light probe specific uniforms.\n   *\n   * @param {NodeFrame} frame - A reference to the current node frame.\n   */\n  update(frame) {\n    const {\n      light\n    } = this;\n    super.update(frame);\n\n    //\n\n    for (let i = 0; i < 9; i++) {\n      this.lightProbe.array[i].copy(light.sh.coefficients[i]).multiplyScalar(light.intensity);\n    }\n  }\n  setup(builder) {\n    const irradiance = getShIrradianceAt(normalWorld, this.lightProbe);\n    builder.context.irradiance.addAssign(irradiance);\n  }\n}\n\n/**\n * Base class for node parsers. A derived parser must be implemented\n * for each supported native shader language.\n */\nclass NodeParser {\n  /**\n   * The method parses the given native code an returns a node function.\n   *\n   * @abstract\n   * @param {String} source - The native shader code.\n   * @return {NodeFunction} A node function.\n   */\n  parseFunction(/*source*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\n\n/**\n * Base class for node functions. A derived module must be implemented\n * for each supported native shader language. Similar to other `Node*` modules,\n * this class is only relevant during the building process and not used\n * in user-level code.\n */\nclass NodeFunction {\n  /**\n   * Constructs a new node function.\n   *\n   * @param {String} type - The node type. This type is the return type of the node function.\n   * @param {Array<NodeFunctionInput>} inputs - The function's inputs.\n   * @param {String} [name=''] - The function's name.\n   * @param {String} [precision=''] - The precision qualifier.\n   */\n  constructor(type, inputs, name = '', precision = '') {\n    /**\n     * The node type. This type is the return type of the node function.\n     *\n     * @type {String}\n     */\n    this.type = type;\n\n    /**\n     * The function's inputs.\n     *\n     * @type {Array<NodeFunctionInput>}\n     */\n    this.inputs = inputs;\n\n    /**\n     * The name of the uniform.\n     *\n     * @type {String}\n     * @default ''\n     */\n    this.name = name;\n\n    /**\n     * The precision qualifier.\n     *\n     * @type {String}\n     * @default ''\n     */\n    this.precision = precision;\n  }\n\n  /**\n   * This method returns the native code of the node function.\n   *\n   * @abstract\n   * @param {String} name - The function's name.\n   * @return {String} A shader code.\n   */\n  getCode(/*name = this.name*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\nNodeFunction.isNodeFunction = true;\nconst declarationRegexp$1 = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp$1 = /[a-z_0-9]+/ig;\nconst pragmaMain = '#pragma main';\nconst parse$1 = source => {\n  source = source.trim();\n  const pragmaMainIndex = source.indexOf(pragmaMain);\n  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;\n  const declaration = mainCode.match(declarationRegexp$1);\n  if (declaration !== null && declaration.length === 5) {\n    // tokenizer\n\n    const inputsCode = declaration[4];\n    const propsMatches = [];\n    let nameMatch = null;\n    while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) {\n      propsMatches.push(nameMatch);\n    }\n\n    // parser\n\n    const inputs = [];\n    let i = 0;\n    while (i < propsMatches.length) {\n      const isConst = propsMatches[i][0] === 'const';\n      if (isConst === true) {\n        i++;\n      }\n      let qualifier = propsMatches[i][0];\n      if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n        i++;\n      } else {\n        qualifier = '';\n      }\n      const type = propsMatches[i++][0];\n      let count = Number.parseInt(propsMatches[i][0]);\n      if (Number.isNaN(count) === false) i++;else count = null;\n      const name = propsMatches[i++][0];\n      inputs.push(new NodeFunctionInput(type, name, count, qualifier, isConst));\n    }\n\n    //\n\n    const blockCode = mainCode.substring(declaration[0].length);\n    const name = declaration[3] !== undefined ? declaration[3] : '';\n    const type = declaration[2];\n    const precision = declaration[1] !== undefined ? declaration[1] : '';\n    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : '';\n    return {\n      type,\n      inputs,\n      name,\n      precision,\n      inputsCode,\n      blockCode,\n      headerCode\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a GLSL code.');\n  }\n};\n\n/**\n * This class represents a GLSL node function.\n *\n * @augments NodeFunction\n */\nclass GLSLNodeFunction extends NodeFunction {\n  /**\n   * Constructs a new GLSL node function.\n   *\n   * @param {String} source - The GLSL source.\n   */\n  constructor(source) {\n    const {\n      type,\n      inputs,\n      name,\n      precision,\n      inputsCode,\n      blockCode,\n      headerCode\n    } = parse$1(source);\n    super(type, inputs, name, precision);\n    this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n    this.headerCode = headerCode;\n  }\n\n  /**\n   * This method returns the GLSL code of the node function.\n   *\n   * @param {String} [name=this.name] - The function's name.\n   * @return {String} The shader code.\n   */\n  getCode(name = this.name) {\n    let code;\n    const blockCode = this.blockCode;\n    if (blockCode !== '') {\n      const {\n        type,\n        inputsCode,\n        headerCode,\n        precision\n      } = this;\n      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;\n      if (precision !== '') {\n        declarationCode = `${precision} ${declarationCode}`;\n      }\n      code = headerCode + declarationCode + blockCode;\n    } else {\n      // interface function\n\n      code = '';\n    }\n    return code;\n  }\n}\n\n/**\n * A GLSL node parser.\n *\n * @augments NodeParser\n */\nclass GLSLNodeParser extends NodeParser {\n  /**\n   * The method parses the given GLSL code an returns a node function.\n   *\n   * @param {String} source - The GLSL code.\n   * @return {GLSLNodeFunction} A node function.\n   */\n  parseFunction(source) {\n    return new GLSLNodeFunction(source);\n  }\n}\nconst _outputNodeMap = new WeakMap();\n\n/**\n * This renderer module manages node-related objects and is the\n * primary interface between the renderer and the node system.\n *\n * @private\n * @augments DataMap\n */\nclass Nodes extends DataMap {\n  /**\n   * Constructs a new nodes management component.\n   *\n   * @param {Renderer} renderer - The renderer.\n   * @param {Backend} backend - The renderer's backend.\n   */\n  constructor(renderer, backend) {\n    super();\n\n    /**\n     * The renderer.\n     *\n     * @type {Renderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer's backend.\n     *\n     * @type {Backend}\n     */\n    this.backend = backend;\n\n    /**\n     * The node frame.\n     *\n     * @type {Renderer}\n     */\n    this.nodeFrame = new NodeFrame();\n\n    /**\n     * A cache for managing node builder states.\n     *\n     * @type {Map<Number,NodeBuilderState>}\n     */\n    this.nodeBuilderCache = new Map();\n\n    /**\n     * A cache for managing data cache key data.\n     *\n     * @type {ChainMap}\n     */\n    this.callHashCache = new ChainMap();\n\n    /**\n     * A cache for managing node uniforms group data.\n     *\n     * @type {ChainMap}\n     */\n    this.groupsData = new ChainMap();\n\n    /**\n     * A cache for managing node objects of\n     * scene properties like fog or environments.\n     *\n     * @type {Object<String,WeakMap>}\n     */\n    this.cacheLib = {};\n  }\n\n  /**\n   * Returns `true` if the given node uniforms group must be updated or not.\n   *\n   * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.\n   * @return {Boolean} Whether the node uniforms group requires an update or not.\n   */\n  updateGroup(nodeUniformsGroup) {\n    const groupNode = nodeUniformsGroup.groupNode;\n    const name = groupNode.name;\n\n    // objectGroup is always updated\n\n    if (name === objectGroup.name) return true;\n\n    // renderGroup is updated once per render/compute call\n\n    if (name === renderGroup.name) {\n      const uniformsGroupData = this.get(nodeUniformsGroup);\n      const renderId = this.nodeFrame.renderId;\n      if (uniformsGroupData.renderId !== renderId) {\n        uniformsGroupData.renderId = renderId;\n        return true;\n      }\n      return false;\n    }\n\n    // frameGroup is updated once per frame\n\n    if (name === frameGroup.name) {\n      const uniformsGroupData = this.get(nodeUniformsGroup);\n      const frameId = this.nodeFrame.frameId;\n      if (uniformsGroupData.frameId !== frameId) {\n        uniformsGroupData.frameId = frameId;\n        return true;\n      }\n      return false;\n    }\n\n    // other groups are updated just when groupNode.needsUpdate is true\n\n    const groupChain = [groupNode, nodeUniformsGroup];\n    let groupData = this.groupsData.get(groupChain);\n    if (groupData === undefined) this.groupsData.set(groupChain, groupData = {});\n    if (groupData.version !== groupNode.version) {\n      groupData.version = groupNode.version;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns the cache key for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Number} The cache key.\n   */\n  getForRenderCacheKey(renderObject) {\n    return renderObject.initialCacheKey;\n  }\n\n  /**\n   * Returns a node builder state for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {NodeBuilderState} The node builder state.\n   */\n  getForRender(renderObject) {\n    const renderObjectData = this.get(renderObject);\n    let nodeBuilderState = renderObjectData.nodeBuilderState;\n    if (nodeBuilderState === undefined) {\n      const {\n        nodeBuilderCache\n      } = this;\n      const cacheKey = this.getForRenderCacheKey(renderObject);\n      nodeBuilderState = nodeBuilderCache.get(cacheKey);\n      if (nodeBuilderState === undefined) {\n        const nodeBuilder = this.backend.createNodeBuilder(renderObject.object, this.renderer);\n        nodeBuilder.scene = renderObject.scene;\n        nodeBuilder.material = renderObject.material;\n        nodeBuilder.camera = renderObject.camera;\n        nodeBuilder.context.material = renderObject.material;\n        nodeBuilder.lightsNode = renderObject.lightsNode;\n        nodeBuilder.environmentNode = this.getEnvironmentNode(renderObject.scene);\n        nodeBuilder.fogNode = this.getFogNode(renderObject.scene);\n        nodeBuilder.clippingContext = renderObject.clippingContext;\n        nodeBuilder.build();\n        nodeBuilderState = this._createNodeBuilderState(nodeBuilder);\n        nodeBuilderCache.set(cacheKey, nodeBuilderState);\n      }\n      nodeBuilderState.usedTimes++;\n      renderObjectData.nodeBuilderState = nodeBuilderState;\n    }\n    return nodeBuilderState;\n  }\n\n  /**\n   * Deletes the given object from the internal data map\n   *\n   * @param {Any} object - The object to delete.\n   * @return {Object?} The deleted dictionary.\n   */\n  delete(object) {\n    if (object.isRenderObject) {\n      const nodeBuilderState = this.get(object).nodeBuilderState;\n      nodeBuilderState.usedTimes--;\n      if (nodeBuilderState.usedTimes === 0) {\n        this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));\n      }\n    }\n    return super.delete(object);\n  }\n\n  /**\n   * Returns a node builder state for the given compute node.\n   *\n   * @param {Node} computeNode - The compute node.\n   * @return {NodeBuilderState} The node builder state.\n   */\n  getForCompute(computeNode) {\n    const computeData = this.get(computeNode);\n    let nodeBuilderState = computeData.nodeBuilderState;\n    if (nodeBuilderState === undefined) {\n      const nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);\n      nodeBuilder.build();\n      nodeBuilderState = this._createNodeBuilderState(nodeBuilder);\n      computeData.nodeBuilderState = nodeBuilderState;\n    }\n    return nodeBuilderState;\n  }\n\n  /**\n   * Creates a node builder state for the given node builder.\n   *\n   * @private\n   * @param {NodeBuilder} nodeBuilder - The node builder.\n   * @return {NodeBuilderState} The node builder state.\n   */\n  _createNodeBuilderState(nodeBuilder) {\n    return new NodeBuilderState(nodeBuilder.vertexShader, nodeBuilder.fragmentShader, nodeBuilder.computeShader, nodeBuilder.getAttributesArray(), nodeBuilder.getBindings(), nodeBuilder.updateNodes, nodeBuilder.updateBeforeNodes, nodeBuilder.updateAfterNodes, nodeBuilder.monitor, nodeBuilder.transforms);\n  }\n\n  /**\n   * Returns an environment node for the current configured\n   * scene environment.\n   *\n   * @param {Scene} scene - The scene.\n   * @return {Node} A node representing the current scene environment.\n   */\n  getEnvironmentNode(scene) {\n    this.updateEnvironment(scene);\n    let environmentNode = null;\n    if (scene.environmentNode && scene.environmentNode.isNode) {\n      environmentNode = scene.environmentNode;\n    } else {\n      const sceneData = this.get(scene);\n      if (sceneData.environmentNode) {\n        environmentNode = sceneData.environmentNode;\n      }\n    }\n    return environmentNode;\n  }\n\n  /**\n   * Returns a background node for the current configured\n   * scene background.\n   *\n   * @param {Scene} scene - The scene.\n   * @return {Node} A node representing the current scene background.\n   */\n  getBackgroundNode(scene) {\n    this.updateBackground(scene);\n    let backgroundNode = null;\n    if (scene.backgroundNode && scene.backgroundNode.isNode) {\n      backgroundNode = scene.backgroundNode;\n    } else {\n      const sceneData = this.get(scene);\n      if (sceneData.backgroundNode) {\n        backgroundNode = sceneData.backgroundNode;\n      }\n    }\n    return backgroundNode;\n  }\n\n  /**\n   * Returns a fog node for the current configured scene fog.\n   *\n   * @param {Scene} scene - The scene.\n   * @return {Node} A node representing the current scene fog.\n   */\n  getFogNode(scene) {\n    this.updateFog(scene);\n    return scene.fogNode || this.get(scene).fogNode || null;\n  }\n\n  /**\n   * Returns a cache key for the given scene and lights node.\n   * This key is used by `RenderObject` as a part of the dynamic\n   * cache key (a key that must be checked every time the render\n   * objects is drawn).\n   *\n   * @param {Scene} scene - The scene.\n   * @param {LightsNode} lightsNode - The lights node.\n   * @return {Number} The cache key.\n   */\n  getCacheKey(scene, lightsNode) {\n    const chain = [scene, lightsNode];\n    const callId = this.renderer.info.calls;\n    let cacheKeyData = this.callHashCache.get(chain);\n    if (cacheKeyData === undefined || cacheKeyData.callId !== callId) {\n      const environmentNode = this.getEnvironmentNode(scene);\n      const fogNode = this.getFogNode(scene);\n      const values = [];\n      if (lightsNode) values.push(lightsNode.getCacheKey(true));\n      if (environmentNode) values.push(environmentNode.getCacheKey());\n      if (fogNode) values.push(fogNode.getCacheKey());\n      values.push(this.renderer.shadowMap.enabled ? 1 : 0);\n      cacheKeyData = {\n        callId,\n        cacheKey: hashArray(values)\n      };\n      this.callHashCache.set(chain, cacheKeyData);\n    }\n    return cacheKeyData.cacheKey;\n  }\n\n  /**\n   * A boolean that indicates whether tone mapping should be enabled\n   * or not.\n   *\n   * @type {Boolean}\n   */\n  get isToneMappingState() {\n    return this.renderer.getRenderTarget() ? false : true;\n  }\n\n  /**\n   * If a scene background is configured, this method makes sure to\n   * represent the background with a corresponding node-based implementation.\n   *\n   * @param {Scene} scene - The scene.\n   */\n  updateBackground(scene) {\n    const sceneData = this.get(scene);\n    const background = scene.background;\n    if (background) {\n      const forceUpdate = scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 || scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0;\n      if (sceneData.background !== background || forceUpdate) {\n        const backgroundNode = this.getCacheNode('background', background, () => {\n          if (background.isCubeTexture === true || background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping) {\n            if (scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping) {\n              return pmremTexture(background);\n            } else {\n              let envMap;\n              if (background.isCubeTexture === true) {\n                envMap = cubeTexture(background);\n              } else {\n                envMap = texture(background);\n              }\n              return cubeMapNode(envMap);\n            }\n          } else if (background.isTexture === true) {\n            return texture(background, screenUV.flipY()).setUpdateMatrix(true);\n          } else if (background.isColor !== true) {\n            console.error('WebGPUNodes: Unsupported background configuration.', background);\n          }\n        }, forceUpdate);\n        sceneData.backgroundNode = backgroundNode;\n        sceneData.background = background;\n        sceneData.backgroundBlurriness = scene.backgroundBlurriness;\n      }\n    } else if (sceneData.backgroundNode) {\n      delete sceneData.backgroundNode;\n      delete sceneData.background;\n    }\n  }\n\n  /**\n   * This method is part of the caching of nodes which are used to represents the\n   * scene's background, fog or environment.\n   *\n   * @param {String} type - The type of object to cache.\n   * @param {Object} object - The object.\n   * @param {Function} callback - A callback that produces a node representation for the given object.\n   * @param {Boolean} [forceUpdate=false] - Whether an update should be enforced or not.\n   * @return {Node} The node representation.\n   */\n  getCacheNode(type, object, callback, forceUpdate = false) {\n    const nodeCache = this.cacheLib[type] || (this.cacheLib[type] = new WeakMap());\n    let node = nodeCache.get(object);\n    if (node === undefined || forceUpdate) {\n      node = callback();\n      nodeCache.set(object, node);\n    }\n    return node;\n  }\n\n  /**\n   * If a scene fog is configured, this method makes sure to\n   * represent the fog with a corresponding node-based implementation.\n   *\n   * @param {Scene} scene - The scene.\n   */\n  updateFog(scene) {\n    const sceneData = this.get(scene);\n    const sceneFog = scene.fog;\n    if (sceneFog) {\n      if (sceneData.fog !== sceneFog) {\n        const fogNode = this.getCacheNode('fog', sceneFog, () => {\n          if (sceneFog.isFogExp2) {\n            const color = reference('color', 'color', sceneFog).setGroup(renderGroup);\n            const density = reference('density', 'float', sceneFog).setGroup(renderGroup);\n            return fog(color, densityFogFactor(density));\n          } else if (sceneFog.isFog) {\n            const color = reference('color', 'color', sceneFog).setGroup(renderGroup);\n            const near = reference('near', 'float', sceneFog).setGroup(renderGroup);\n            const far = reference('far', 'float', sceneFog).setGroup(renderGroup);\n            return fog(color, rangeFogFactor(near, far));\n          } else {\n            console.error('THREE.Renderer: Unsupported fog configuration.', sceneFog);\n          }\n        });\n        sceneData.fogNode = fogNode;\n        sceneData.fog = sceneFog;\n      }\n    } else {\n      delete sceneData.fogNode;\n      delete sceneData.fog;\n    }\n  }\n\n  /**\n   * If a scene environment is configured, this method makes sure to\n   * represent the environment with a corresponding node-based implementation.\n   *\n   * @param {Scene} scene - The scene.\n   */\n  updateEnvironment(scene) {\n    const sceneData = this.get(scene);\n    const environment = scene.environment;\n    if (environment) {\n      if (sceneData.environment !== environment) {\n        const environmentNode = this.getCacheNode('environment', environment, () => {\n          if (environment.isCubeTexture === true) {\n            return cubeTexture(environment);\n          } else if (environment.isTexture === true) {\n            return texture(environment);\n          } else {\n            console.error('Nodes: Unsupported environment configuration.', environment);\n          }\n        });\n        sceneData.environmentNode = environmentNode;\n        sceneData.environment = environment;\n      }\n    } else if (sceneData.environmentNode) {\n      delete sceneData.environmentNode;\n      delete sceneData.environment;\n    }\n  }\n  getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {\n    const nodeFrame = this.nodeFrame;\n    nodeFrame.renderer = renderer;\n    nodeFrame.scene = scene;\n    nodeFrame.object = object;\n    nodeFrame.camera = camera;\n    nodeFrame.material = material;\n    return nodeFrame;\n  }\n  getNodeFrameForRender(renderObject) {\n    return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);\n  }\n\n  /**\n   * Returns the current output cache key.\n   *\n   * @return {String} The output cache key.\n   */\n  getOutputCacheKey() {\n    const renderer = this.renderer;\n    return renderer.toneMapping + ',' + renderer.currentColorSpace;\n  }\n\n  /**\n   * Checks if the output configuration (tone mapping and color space) for\n   * the given target has changed.\n   *\n   * @param {Texture} outputTarget - The output target.\n   * @return {Boolean} Whether the output configuration has changed or not.\n   */\n  hasOutputChange(outputTarget) {\n    const cacheKey = _outputNodeMap.get(outputTarget);\n    return cacheKey !== this.getOutputCacheKey();\n  }\n\n  /**\n   * Returns a node that represents the output configuration (tone mapping and\n   * color space) for the current target.\n   *\n   * @param {Texture} outputTarget - The output target.\n   * @return {Node} The output node.\n   */\n  getOutputNode(outputTarget) {\n    const renderer = this.renderer;\n    const cacheKey = this.getOutputCacheKey();\n    const output = texture(outputTarget, screenUV).renderOutput(renderer.toneMapping, renderer.currentColorSpace);\n    _outputNodeMap.set(outputTarget, cacheKey);\n    return output;\n  }\n\n  /**\n   * Triggers the call of `updateBefore()` methods\n   * for all nodes of the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   */\n  updateBefore(renderObject) {\n    const nodeBuilder = renderObject.getNodeBuilderState();\n    for (const node of nodeBuilder.updateBeforeNodes) {\n      // update frame state for each node\n\n      this.getNodeFrameForRender(renderObject).updateBeforeNode(node);\n    }\n  }\n\n  /**\n   * Triggers the call of `updateAfter()` methods\n   * for all nodes of the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   */\n  updateAfter(renderObject) {\n    const nodeBuilder = renderObject.getNodeBuilderState();\n    for (const node of nodeBuilder.updateAfterNodes) {\n      // update frame state for each node\n\n      this.getNodeFrameForRender(renderObject).updateAfterNode(node);\n    }\n  }\n\n  /**\n   * Triggers the call of `update()` methods\n   * for all nodes of the given compute node.\n   *\n   * @param {Node} computeNode - The compute node.\n   */\n  updateForCompute(computeNode) {\n    const nodeFrame = this.getNodeFrame();\n    const nodeBuilder = this.getForCompute(computeNode);\n    for (const node of nodeBuilder.updateNodes) {\n      nodeFrame.updateNode(node);\n    }\n  }\n\n  /**\n   * Triggers the call of `update()` methods\n   * for all nodes of the given compute node.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   */\n  updateForRender(renderObject) {\n    const nodeFrame = this.getNodeFrameForRender(renderObject);\n    const nodeBuilder = renderObject.getNodeBuilderState();\n    for (const node of nodeBuilder.updateNodes) {\n      nodeFrame.updateNode(node);\n    }\n  }\n\n  /**\n   * Returns `true` if the given render object requires a refresh.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Boolean} Whether the given render object requires a refresh or not.\n   */\n  needsRefresh(renderObject) {\n    const nodeFrame = this.getNodeFrameForRender(renderObject);\n    const monitor = renderObject.getMonitor();\n    return monitor.needsRefresh(renderObject, nodeFrame);\n  }\n\n  /**\n   * Frees the intenral resources.\n   */\n  dispose() {\n    super.dispose();\n    this.nodeFrame = new NodeFrame();\n    this.nodeBuilderCache = new Map();\n    this.cacheLib = {};\n  }\n}\nconst _plane = /*@__PURE__*/new Plane();\n\n/**\n * Represents the state that is used to perform clipping via clipping planes.\n * There is a default clipping context for each render context. When the\n * scene holds instances of `ClippingGroup`, there will be a context for each\n * group.\n *\n * @private\n */\nclass ClippingContext {\n  /**\n   * Constructs a new clipping context.\n   *\n   * @param {ClippingContext?} [parentContext=null] - A reference to the parent clipping context.\n   */\n  constructor(parentContext = null) {\n    /**\n     * The clipping context's version.\n     *\n     * @type {Number}\n     * @readonly\n     */\n    this.version = 0;\n\n    /**\n     * Whether the intersection of the clipping planes is used to clip objects, rather than their union.\n     *\n     * @type {Boolean?}\n     * @default null\n     */\n    this.clipIntersection = null;\n\n    /**\n     * The clipping context's cache key.\n     *\n     * @type {String}\n     */\n    this.cacheKey = '';\n\n    /**\n     * Whether the shadow pass is active or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.shadowPass = false;\n\n    /**\n     * The view normal matrix.\n     *\n     * @type {Matrix3}\n     */\n    this.viewNormalMatrix = new Matrix3();\n\n    /**\n     * Internal cache for maintaining clipping contexts.\n     *\n     * @type {WeakMap<ClippingGroup,ClippingContext>}\n     */\n    this.clippingGroupContexts = new WeakMap();\n\n    /**\n     * The intersection planes.\n     *\n     * @type {Array<Vector4>}\n     */\n    this.intersectionPlanes = [];\n\n    /**\n     * The intersection planes.\n     *\n     * @type {Array<Vector4>}\n     */\n    this.unionPlanes = [];\n\n    /**\n     * The version of the clipping context's parent context.\n     *\n     * @type {Number?}\n     * @readonly\n     */\n    this.parentVersion = null;\n    if (parentContext !== null) {\n      this.viewNormalMatrix = parentContext.viewNormalMatrix;\n      this.clippingGroupContexts = parentContext.clippingGroupContexts;\n      this.shadowPass = parentContext.shadowPass;\n      this.viewMatrix = parentContext.viewMatrix;\n    }\n  }\n\n  /**\n   * Projects the given source clipping planes and writes the result into the\n   * destination array.\n   *\n   * @param {Array<Plane>} source - The source clipping planes.\n   * @param {Array<Vector4>} destination - The destination.\n   * @param {Number} offset - The offset.\n   */\n  projectPlanes(source, destination, offset) {\n    const l = source.length;\n    for (let i = 0; i < l; i++) {\n      _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);\n      const v = destination[offset + i];\n      const normal = _plane.normal;\n      v.x = -normal.x;\n      v.y = -normal.y;\n      v.z = -normal.z;\n      v.w = _plane.constant;\n    }\n  }\n\n  /**\n   * Updates the root clipping context of a scene.\n   *\n   * @param {Scene} scene - The scene.\n   * @param {Camera} camera - The camera that is used to render the scene.\n   */\n  updateGlobal(scene, camera) {\n    this.shadowPass = scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial;\n    this.viewMatrix = camera.matrixWorldInverse;\n    this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);\n  }\n\n  /**\n   * Updates the clipping context.\n   *\n   * @param {ClippingContext} parentContext - The parent context.\n   * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.\n   */\n  update(parentContext, clippingGroup) {\n    let update = false;\n    if (parentContext.version !== this.parentVersion) {\n      this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);\n      this.unionPlanes = Array.from(parentContext.unionPlanes);\n      this.parentVersion = parentContext.version;\n    }\n    if (this.clipIntersection !== clippingGroup.clipIntersection) {\n      this.clipIntersection = clippingGroup.clipIntersection;\n      if (this.clipIntersection) {\n        this.unionPlanes.length = parentContext.unionPlanes.length;\n      } else {\n        this.intersectionPlanes.length = parentContext.intersectionPlanes.length;\n      }\n    }\n    const srcClippingPlanes = clippingGroup.clippingPlanes;\n    const l = srcClippingPlanes.length;\n    let dstClippingPlanes;\n    let offset;\n    if (this.clipIntersection) {\n      dstClippingPlanes = this.intersectionPlanes;\n      offset = parentContext.intersectionPlanes.length;\n    } else {\n      dstClippingPlanes = this.unionPlanes;\n      offset = parentContext.unionPlanes.length;\n    }\n    if (dstClippingPlanes.length !== offset + l) {\n      dstClippingPlanes.length = offset + l;\n      for (let i = 0; i < l; i++) {\n        dstClippingPlanes[offset + i] = new Vector4();\n      }\n      update = true;\n    }\n    this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);\n    if (update) {\n      this.version++;\n      this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;\n    }\n  }\n\n  /**\n   * Returns a clipping context for the given clipping group.\n   *\n   * @param {ClippingGroup} clippingGroup - The clipping group.\n   * @return {ClippingContext} The clipping context.\n   */\n  getGroupContext(clippingGroup) {\n    if (this.shadowPass && !clippingGroup.clipShadows) return this;\n    let context = this.clippingGroupContexts.get(clippingGroup);\n    if (context === undefined) {\n      context = new ClippingContext(this);\n      this.clippingGroupContexts.set(clippingGroup, context);\n    }\n    context.update(this, clippingGroup);\n    return context;\n  }\n\n  /**\n   * The count of union clipping planes.\n   *\n   * @type {Number}\n   * @readonly\n   */\n  get unionClippingCount() {\n    return this.unionPlanes.length;\n  }\n}\n\n/**\n * This module is used to represent render bundles inside the renderer\n * for further processing.\n *\n * @private\n */\nclass RenderBundle {\n  /**\n   * Constructs a new bundle group.\n   *\n   * @param {BundleGroup} bundleGroup - The bundle group.\n   * @param {Camera} camera - The camera the bundle group is rendered with.\n   */\n  constructor(bundleGroup, camera) {\n    this.bundleGroup = bundleGroup;\n    this.camera = camera;\n  }\n}\n\n/**\n * This renderer module manages render bundles.\n *\n * @private\n */\nclass RenderBundles {\n  /**\n   * Constructs a new render bundle management component.\n   */\n  constructor() {\n    /**\n     * A chain map for maintaining the render bundles.\n     *\n     * @type {ChainMap}\n     */\n    this.bundles = new ChainMap();\n  }\n\n  /**\n   * Returns a render bundle for the given bundle group and camera.\n   *\n   * @param {BundleGroup} bundleGroup - The bundle group.\n   * @param {Camera} camera - The camera the bundle group is rendered with.\n   * @return {RenderBundle} The render bundle.\n   */\n  get(bundleGroup, camera) {\n    const bundles = this.bundles;\n    const keys = [bundleGroup, camera];\n    let bundle = bundles.get(keys);\n    if (bundle === undefined) {\n      bundle = new RenderBundle(bundleGroup, camera);\n      bundles.set(keys, bundle);\n    }\n    return bundle;\n  }\n\n  /**\n   * Frees all internal resources.\n   */\n  dispose() {\n    this.bundles = new ChainMap();\n  }\n}\n\n/**\n * The purpose of a node library is to assign node implementations\n * to existing library features. In `WebGPURenderer` lights, materials\n * which are not based on `NodeMaterial` as well as tone mapping techniques\n * are implemented with node-based modules.\n *\n * @private\n */\nclass NodeLibrary {\n  /**\n   * Constructs a new node library.\n   */\n  constructor() {\n    /**\n     * A weak map that maps lights to light nodes.\n     *\n     * @type {WeakMap<Light.constructor,AnalyticLightNode.constructor>}\n     */\n    this.lightNodes = new WeakMap();\n\n    /**\n     * A map that maps materials to node materials.\n     *\n     * @type {WeakMap<String,NodeMaterial.constructor>}\n     */\n    this.materialNodes = new Map();\n\n    /**\n     * A map that maps tone mapping techniques (constants)\n     * to tone mapping node functions.\n     *\n     * @type {WeakMap<Number,Function>}\n     */\n    this.toneMappingNodes = new Map();\n  }\n\n  /**\n   * Returns a matching node material instance for the given material object.\n   *\n   * This method also assigns/copies the properties of the given material object\n   * to the node material. This is done to make sure the current material\n   * configuration carries over to the node version.\n   *\n   * @param {Material} material - A material.\n   * @return {NodeMaterial} The corresponding node material.\n   */\n  fromMaterial(material) {\n    if (material.isNodeMaterial) return material;\n    let nodeMaterial = null;\n    const nodeMaterialClass = this.getMaterialNodeClass(material.type);\n    if (nodeMaterialClass !== null) {\n      nodeMaterial = new nodeMaterialClass();\n      for (const key in material) {\n        nodeMaterial[key] = material[key];\n      }\n    }\n    return nodeMaterial;\n  }\n\n  /**\n   * Adds a tone mapping node function for a tone mapping technique (constant).\n   *\n   * @param {Function} toneMappingNode - The tone mapping node function.\n   * @param {Number} toneMapping - The tone mapping.\n   */\n  addToneMapping(toneMappingNode, toneMapping) {\n    this.addType(toneMappingNode, toneMapping, this.toneMappingNodes);\n  }\n\n  /**\n   * Returns a tone mapping node function for a tone mapping technique (constant).\n   *\n   * @param {Number} toneMapping - The tone mapping.\n   * @return {Function?} The tone mapping node function. Returns `null` if no node function is found.\n   */\n  getToneMappingFunction(toneMapping) {\n    return this.toneMappingNodes.get(toneMapping) || null;\n  }\n\n  /**\n   * Returns a node material class definition for a material type.\n   *\n   * @param {Sring} materialType - The material type.\n   * @return {NodeMaterial.constructor?} The node material class definition. Returns `null` if no node material is found.\n   */\n  getMaterialNodeClass(materialType) {\n    return this.materialNodes.get(materialType) || null;\n  }\n\n  /**\n   * Adds a node material class definition for a given material type.\n   *\n   * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.\n   * @param {Sring} materialClassType - The material type.\n   */\n  addMaterial(materialNodeClass, materialClassType) {\n    this.addType(materialNodeClass, materialClassType, this.materialNodes);\n  }\n\n  /**\n   * Returns a light node class definition for a light class definition.\n   *\n   * @param {Light.constructor} light - The light class definition.\n   * @return {AnalyticLightNode.constructor?} The light node class definition. Returns `null` if no light node is found.\n   */\n  getLightNodeClass(light) {\n    return this.lightNodes.get(light) || null;\n  }\n\n  /**\n   * Adds a light node class definition for a given light class definition.\n   *\n   * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.\n   * @param {Light.constructor} lightClass - The light class definition.\n   */\n  addLight(lightNodeClass, lightClass) {\n    this.addClass(lightNodeClass, lightClass, this.lightNodes);\n  }\n\n  /**\n   * Adds a node class definition for the given type to the provided type library.\n   *\n   * @param {Any} nodeClass - The node class definition.\n   * @param {String} type - The object type.\n   * @param {Map} library - The type library.\n   */\n  addType(nodeClass, type, library) {\n    if (library.has(type)) {\n      console.warn(`Redefinition of node ${type}`);\n      return;\n    }\n    if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);\n    if (typeof type === 'function' || typeof type === 'object') throw new Error(`Base class ${type} is not a class.`);\n    library.set(type, nodeClass);\n  }\n\n  /**\n   * Adds a node class definition for the given class definition to the provided type library.\n   *\n   * @param {Any} nodeClass - The node class definition.\n   * @param {Any} baseClass - The class definition.\n   * @param {WeakMap} library - The type library.\n   */\n  addClass(nodeClass, baseClass, library) {\n    if (library.has(baseClass)) {\n      console.warn(`Redefinition of node ${baseClass.name}`);\n      return;\n    }\n    if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);\n    if (typeof baseClass !== 'function') throw new Error(`Base class ${baseClass.name} is not a class.`);\n    library.set(baseClass, nodeClass);\n  }\n}\nconst _defaultLights = /*@__PURE__*/new LightsNode();\n\n/**\n * This renderer module manages the lights nodes which are unique\n * per scene and camera combination.\n *\n * The lights node itself is later configured in the render list\n * with the actual lights from the scene.\n *\n * @private\n * @augments ChainMap\n */\nclass Lighting extends ChainMap {\n  /**\n   * Constructs a lighting management component.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Creates a new lights node for the given array of lights.\n   *\n   * @param {Array<Light>} lights - The render object.\n   * @return {Boolean} Whether if the given render object has an initialized geometry or not.\n   */\n  createNode(lights = []) {\n    return new LightsNode().setLights(lights);\n  }\n\n  /**\n   * Returns a lights node for the given scene and camera.\n   *\n   * @param {Scene} scene - The scene.\n   * @param {Camera} camera - The camera.\n   * @return {LightsNode} The lights node.\n   */\n  getNode(scene, camera) {\n    // ignore post-processing\n\n    if (scene.isQuadMesh) return _defaultLights;\n\n    // tiled lighting\n\n    const keys = [scene, camera];\n    let node = this.get(keys);\n    if (node === undefined) {\n      node = this.createNode();\n      this.set(keys, node);\n    }\n    return node;\n  }\n}\n\n/** @module Renderer **/\n\nconst _scene = /*@__PURE__*/new Scene();\nconst _drawingBufferSize = /*@__PURE__*/new Vector2();\nconst _screen = /*@__PURE__*/new Vector4();\nconst _frustum = /*@__PURE__*/new Frustum();\nconst _projScreenMatrix = /*@__PURE__*/new Matrix4();\nconst _vector4 = /*@__PURE__*/new Vector4();\n\n/**\n * Base class for renderers.\n */\nclass Renderer {\n  /**\n   * Constructs a new renderer.\n   *\n   * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).\n   * @param {Object} parameters - The configuration parameter.\n   * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n   * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n   * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n   * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n   * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n   * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0\n   * to overwrite the default.\n   * @param {Function?} [parameters.getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n   */\n  constructor(backend, parameters = {}) {\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isRenderer = true;\n\n    //\n\n    const {\n      logarithmicDepthBuffer = false,\n      alpha = true,\n      depth = true,\n      stencil = false,\n      antialias = false,\n      samples = 0,\n      getFallback = null\n    } = parameters;\n\n    /**\n     * A reference to the canvas element the renderer is drawing to.\n     * This value of this property will automatically be created by\n     * the renderer.\n     *\n     * @type {HTMLCanvasElement|OffscreenCanvas}\n     */\n    this.domElement = backend.getDomElement();\n\n    /**\n     * A reference to the current backend.\n     *\n     * @type {Backend}\n     */\n    this.backend = backend;\n\n    /**\n     * The number of MSAA samples.\n     *\n     * @type {Number}\n     * @default 0\n     */\n    this.samples = samples || antialias === true ? 4 : 0;\n\n    /**\n     * Whether the renderer should automatically clear the current rendering target\n     * before execute a `render()` call. The target can be the canvas (default framebuffer)\n     * or the current bound render target (custom framebuffer).\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.autoClear = true;\n\n    /**\n     * When `autoClear` is set to `true`, this property defines whether the renderer\n     * should clear the color buffer.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.autoClearColor = true;\n\n    /**\n     * When `autoClear` is set to `true`, this property defines whether the renderer\n     * should clear the depth buffer.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.autoClearDepth = true;\n\n    /**\n     * When `autoClear` is set to `true`, this property defines whether the renderer\n     * should clear the stencil buffer.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.autoClearStencil = true;\n\n    /**\n     * Whether the default framebuffer should be transparent or opaque.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.alpha = alpha;\n\n    /**\n     * Whether logarithmic depth buffer is enabled or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.logarithmicDepthBuffer = logarithmicDepthBuffer;\n\n    /**\n     * Defines the output color space of the renderer.\n     *\n     * @type {String}\n     * @default SRGBColorSpace\n     */\n    this.outputColorSpace = SRGBColorSpace;\n\n    /**\n     * Defines the tone mapping of the renderer.\n     *\n     * @type {Number}\n     * @default NoToneMapping\n     */\n    this.toneMapping = NoToneMapping;\n\n    /**\n     * Defines the tone mapping exposure.\n     *\n     * @type {Number}\n     * @default 1\n     */\n    this.toneMappingExposure = 1.0;\n\n    /**\n     * Whether the renderer should sort its render lists or not.\n     *\n     * Note: Sorting is used to attempt to properly render objects that have some degree of transparency.\n     * By definition, sorting objects may not work in all cases. Depending on the needs of application,\n     * it may be necessary to turn off sorting and use other methods to deal with transparency rendering\n     * e.g. manually determining each object's rendering order.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.sortObjects = true;\n\n    /**\n     * Whether the default framebuffer should have a depth buffer or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.depth = depth;\n\n    /**\n     * Whether the default framebuffer should have a stencil buffer or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.stencil = stencil;\n\n    /**\n     * Holds a series of statistical information about the GPU memory\n     * and the rendering process. Useful for debugging and monitoring.\n     *\n     * @type {Boolean}\n     */\n    this.info = new Info();\n    this.nodes = {\n      modelViewMatrix: null,\n      modelNormalViewMatrix: null\n    };\n\n    /**\n     * The node library defines how certain library objects like materials, lights\n     * or tone mapping functions are mapped to node types. This is required since\n     * although instances of classes like `MeshBasicMaterial` or `PointLight` can\n     * be part of the scene graph, they are internally represented as nodes for\n     * further processing.\n     *\n     * @type {NodeLibrary}\n     */\n    this.library = new NodeLibrary();\n\n    /**\n     * A map-like data structure for managing lights.\n     *\n     * @type {Lighting}\n     */\n    this.lighting = new Lighting();\n\n    // internals\n\n    /**\n     * This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n     *\n     * @private\n     * @type {Function}\n     */\n    this._getFallback = getFallback;\n\n    /**\n     * The renderer's pixel ration.\n     *\n     * @private\n     * @type {Number}\n     * @default 1\n     */\n    this._pixelRatio = 1;\n\n    /**\n     * The width of the renderer's default framebuffer in logical pixel unit.\n     *\n     * @private\n     * @type {Number}\n     */\n    this._width = this.domElement.width;\n\n    /**\n     * The height of the renderer's default framebuffer in logical pixel unit.\n     *\n     * @private\n     * @type {Number}\n     */\n    this._height = this.domElement.height;\n\n    /**\n     * The viewport of the renderer in logical pixel unit.\n     *\n     * @private\n     * @type {Vector4}\n     */\n    this._viewport = new Vector4(0, 0, this._width, this._height);\n\n    /**\n     * The scissor rectangle of the renderer in logical pixel unit.\n     *\n     * @private\n     * @type {Vector4}\n     */\n    this._scissor = new Vector4(0, 0, this._width, this._height);\n\n    /**\n     * Whether the scissor test should be enabled or not.\n     *\n     * @private\n     * @type {Vector4}\n     */\n    this._scissorTest = false;\n\n    /**\n     * A reference to a renderer module for managing shader attributes.\n     *\n     * @private\n     * @type {Attributes?}\n     * @default null\n     */\n    this._attributes = null;\n\n    /**\n     * A reference to a renderer module for managing geometries.\n     *\n     * @private\n     * @type {Geometries?}\n     * @default null\n     */\n    this._geometries = null;\n\n    /**\n     * A reference to a renderer module for managing node related logic.\n     *\n     * @private\n     * @type {Nodes?}\n     * @default null\n     */\n    this._nodes = null;\n\n    /**\n     * A reference to a renderer module for managing the internal animation loop.\n     *\n     * @private\n     * @type {Animation?}\n     * @default null\n     */\n    this._animation = null;\n\n    /**\n     * A reference to a renderer module for managing shader program bindings.\n     *\n     * @private\n     * @type {Bindings?}\n     * @default null\n     */\n    this._bindings = null;\n\n    /**\n     * A reference to a renderer module for managing render objects.\n     *\n     * @private\n     * @type {RenderObjects?}\n     * @default null\n     */\n    this._objects = null;\n\n    /**\n     * A reference to a renderer module for managing render and cmopute pipelines.\n     *\n     * @private\n     * @type {Pipelines?}\n     * @default null\n     */\n    this._pipelines = null;\n\n    /**\n     * A reference to a renderer module for managing render bundles.\n     *\n     * @private\n     * @type {RenderBundles?}\n     * @default null\n     */\n    this._bundles = null;\n\n    /**\n     * A reference to a renderer module for managing render lists.\n     *\n     * @private\n     * @type {RenderLists?}\n     * @default null\n     */\n    this._renderLists = null;\n\n    /**\n     * A reference to a renderer module for managing render contexts.\n     *\n     * @private\n     * @type {RenderContexts?}\n     * @default null\n     */\n    this._renderContexts = null;\n\n    /**\n     * A reference to a renderer module for managing textures.\n     *\n     * @private\n     * @type {Textures?}\n     * @default null\n     */\n    this._textures = null;\n\n    /**\n     * A reference to a renderer module for backgrounds.\n     *\n     * @private\n     * @type {Background?}\n     * @default null\n     */\n    this._background = null;\n\n    /**\n     * This fullscreen quad is used for internal render passes\n     * like the tone mapping and color space output pass.\n     *\n     * @private\n     * @type {QuadMesh}\n     */\n    this._quad = new QuadMesh(new NodeMaterial());\n    this._quad.material.name = 'Renderer_output';\n\n    /**\n     * A reference to the current render context.\n     *\n     * @private\n     * @type {RenderContext?}\n     * @default null\n     */\n    this._currentRenderContext = null;\n\n    /**\n     * A custom sort function for the opaque render list.\n     *\n     * @private\n     * @type {Function?}\n     * @default null\n     */\n    this._opaqueSort = null;\n\n    /**\n     * A custom sort function for the transparent render list.\n     *\n     * @private\n     * @type {Function?}\n     * @default null\n     */\n    this._transparentSort = null;\n\n    /**\n     * The framebuffer target.\n     *\n     * @private\n     * @type {RenderTarget?}\n     * @default null\n     */\n    this._frameBufferTarget = null;\n    const alphaClear = this.alpha === true ? 0 : 1;\n\n    /**\n     * The clear color value.\n     *\n     * @private\n     * @type {Color4}\n     */\n    this._clearColor = new Color4(0, 0, 0, alphaClear);\n\n    /**\n     * The clear depth value.\n     *\n     * @private\n     * @type {Number}\n     * @default 1\n     */\n    this._clearDepth = 1;\n\n    /**\n     * The clear stencil value.\n     *\n     * @private\n     * @type {Number}\n     * @default 0\n     */\n    this._clearStencil = 0;\n\n    /**\n     * The current render target.\n     *\n     * @private\n     * @type {RenderTarget?}\n     * @default null\n     */\n    this._renderTarget = null;\n\n    /**\n     * The active cube face.\n     *\n     * @private\n     * @type {Number}\n     * @default 0\n     */\n    this._activeCubeFace = 0;\n\n    /**\n     * The active mipmap level.\n     *\n     * @private\n     * @type {Number}\n     * @default 0\n     */\n    this._activeMipmapLevel = 0;\n\n    /**\n     * The MRT setting.\n     *\n     * @private\n     * @type {MRTNode?}\n     * @default null\n     */\n    this._mrt = null;\n\n    /**\n     * This function defines how a render object is going\n     * to be rendered.\n     *\n     * @private\n     * @type {Function?}\n     * @default null\n     */\n    this._renderObjectFunction = null;\n\n    /**\n     * Used to keep track of the current render object function.\n     *\n     * @private\n     * @type {Function?}\n     * @default null\n     */\n    this._currentRenderObjectFunction = null;\n\n    /**\n     * Used to keep track of the current render bundle.\n     *\n     * @private\n     * @type {RenderBundle?}\n     * @default null\n     */\n    this._currentRenderBundle = null;\n\n    /**\n     * Next to `_renderObjectFunction()`, this function provides another hook\n     * for influening the render process of a render object. It is meant for internal\n     * use and only relevant for `compileAsync()` right now. Instead of using\n     * the default logic of `_renderObjectDirect()` which actually draws the render object,\n     * a different function might be used which performs no draw but just the node\n     * and pipeline updates.\n     *\n     * @private\n     * @type {Function?}\n     * @default null\n     */\n    this._handleObjectFunction = this._renderObjectDirect;\n\n    /**\n     * Indicates whether the device has been lost or not. In WebGL terms, the device\n     * lost is considered as a context lost. When this is set to `true`, rendering\n     * isn't possible anymore.\n     *\n     * @private\n     * @type {Boolean}\n     * @default false\n     */\n    this._isDeviceLost = false;\n\n    /**\n     * A callback function that defines what should happen when a device/context lost occurs.\n     *\n     * @type {Function}\n     */\n    this.onDeviceLost = this._onDeviceLost;\n\n    /**\n     * Whether the renderer has been initialized or not.\n     *\n     * @private\n     * @type {Boolean}\n     * @default false\n     */\n    this._initialized = false;\n\n    /**\n     * A reference to the promise which initializes the renderer.\n     *\n     * @private\n     * @type {Promise?}\n     * @default null\n     */\n    this._initPromise = null;\n\n    /**\n     * An array of compilation promises which are used in `compileAsync()`.\n     *\n     * @private\n     * @type {Array<Promise>?}\n     * @default null\n     */\n    this._compilationPromises = null;\n\n    /**\n     * Whether the renderer should render transparent render objects or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.transparent = true;\n\n    /**\n     * Whether the renderer should render opaque render objects or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.opaque = true;\n\n    /**\n     * Shadow map configuration\n     * @typedef {Object} ShadowMapConfig\n     * @property {Boolean} enabled - Whether to globally enable shadows or not.\n     * @property {Number} type - The shadow map type.\n     */\n\n    /**\n     * The renderer's shadow configuration.\n     *\n     * @type {module:Renderer~ShadowMapConfig}\n     */\n    this.shadowMap = {\n      enabled: false,\n      type: PCFShadowMap\n    };\n\n    /**\n     * XR configuration.\n     * @typedef {Object} XRConfig\n     * @property {Boolean} enabled - Whether to globally enable XR or not.\n     */\n\n    /**\n     * The renderer's XR configuration.\n     *\n     * @type {module:Renderer~XRConfig}\n     */\n    this.xr = {\n      enabled: false\n    };\n\n    /**\n     * Debug configuration.\n     * @typedef {Object} DebugConfig\n     * @property {Boolean} checkShaderErrors - Whether shader errors should be checked or not.\n     * @property {Function} onShaderError - A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now.\n     * @property {Function} getShaderAsync - Allows the get the raw shader code for the given scene, camerea and 3D object.\n     */\n\n    /**\n     * The renderer's debug configuration.\n     *\n     * @type {module:Renderer~DebugConfig}\n     */\n    this.debug = {\n      checkShaderErrors: true,\n      onShaderError: null,\n      getShaderAsync: async (scene, camera, object) => {\n        await this.compileAsync(scene, camera);\n        const renderList = this._renderLists.get(scene, camera);\n        const renderContext = this._renderContexts.get(scene, camera, this._renderTarget);\n        const material = scene.overrideMaterial || object.material;\n        const renderObject = this._objects.get(object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext);\n        const {\n          fragmentShader,\n          vertexShader\n        } = renderObject.getNodeBuilderState();\n        return {\n          fragmentShader,\n          vertexShader\n        };\n      }\n    };\n  }\n\n  /**\n   * Initializes the renderer so it is ready for usage.\n   *\n   * @async\n   * @return {Promise} A Promise that resolves when the renderer has been initialized.\n   */\n  async init() {\n    if (this._initialized) {\n      throw new Error('Renderer: Backend has already been initialized.');\n    }\n    if (this._initPromise !== null) {\n      return this._initPromise;\n    }\n    this._initPromise = new Promise(async (resolve, reject) => {\n      let backend = this.backend;\n      try {\n        await backend.init(this);\n      } catch (error) {\n        if (this._getFallback !== null) {\n          // try the fallback\n\n          try {\n            this.backend = backend = this._getFallback(error);\n            await backend.init(this);\n          } catch (error) {\n            reject(error);\n            return;\n          }\n        } else {\n          reject(error);\n          return;\n        }\n      }\n      this._nodes = new Nodes(this, backend);\n      this._animation = new Animation(this._nodes, this.info);\n      this._attributes = new Attributes(backend);\n      this._background = new Background(this, this._nodes);\n      this._geometries = new Geometries(this._attributes, this.info);\n      this._textures = new Textures(this, backend, this.info);\n      this._pipelines = new Pipelines(backend, this._nodes);\n      this._bindings = new Bindings(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);\n      this._objects = new RenderObjects(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);\n      this._renderLists = new RenderLists(this.lighting);\n      this._bundles = new RenderBundles();\n      this._renderContexts = new RenderContexts();\n\n      //\n\n      this._animation.start();\n      this._initialized = true;\n      resolve();\n    });\n    return this._initPromise;\n  }\n\n  /**\n   * The coordinate system of the renderer. The value of this property\n   * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or\n   * `THREE.WebGPUCoordinateSystem`.\n   *\n   * @readonly\n   * @type {Number}\n   */\n  get coordinateSystem() {\n    return this.backend.coordinateSystem;\n  }\n\n  /**\n   * Compiles all materials in the given scene. This can be useful to avoid a\n   * phenomenon which is called \"shader compilation stutter\", which occurs when\n   * rendering an object with a new shader for the first time.\n   *\n   * If you want to add a 3D object to an existing scene, use the third optional\n   * parameter for applying the target scene. Note that the (target) scene's lighting\n   * and environment must be configured before calling this method.\n   *\n   * @async\n   * @param {Object3D} scene - The scene or 3D object to precompile.\n   * @param {Camera} camera - The camera that is used to render the scene.\n   * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n   * @return {Promise} A Promise that resolves when the compile has been finished.\n   */\n  async compileAsync(scene, camera, targetScene = null) {\n    if (this._isDeviceLost === true) return;\n    if (this._initialized === false) await this.init();\n\n    // preserve render tree\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n    const previousRenderContext = this._currentRenderContext;\n    const previousRenderObjectFunction = this._currentRenderObjectFunction;\n    const previousCompilationPromises = this._compilationPromises;\n\n    //\n\n    const sceneRef = scene.isScene === true ? scene : _scene;\n    if (targetScene === null) targetScene = scene;\n    const renderTarget = this._renderTarget;\n    const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);\n    const activeMipmapLevel = this._activeMipmapLevel;\n    const compilationPromises = [];\n    this._currentRenderContext = renderContext;\n    this._currentRenderObjectFunction = this.renderObject;\n    this._handleObjectFunction = this._createObjectPipeline;\n    this._compilationPromises = compilationPromises;\n    nodeFrame.renderId++;\n\n    //\n\n    nodeFrame.update();\n\n    //\n\n    renderContext.depth = this.depth;\n    renderContext.stencil = this.stencil;\n    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();\n    renderContext.clippingContext.updateGlobal(sceneRef, camera);\n\n    //\n\n    sceneRef.onBeforeRender(this, scene, camera, renderTarget);\n\n    //\n\n    const renderList = this._renderLists.get(scene, camera);\n    renderList.begin();\n    this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);\n\n    // include lights from target scene\n    if (targetScene !== scene) {\n      targetScene.traverseVisible(function (object) {\n        if (object.isLight && object.layers.test(camera.layers)) {\n          renderList.pushLight(object);\n        }\n      });\n    }\n    renderList.finish();\n\n    //\n\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);\n      const renderTargetData = this._textures.get(renderTarget);\n      renderContext.textures = renderTargetData.textures;\n      renderContext.depthTexture = renderTargetData.depthTexture;\n    } else {\n      renderContext.textures = null;\n      renderContext.depthTexture = null;\n    }\n\n    //\n\n    this._background.update(sceneRef, renderList, renderContext);\n\n    // process render lists\n\n    const opaqueObjects = renderList.opaque;\n    const transparentObjects = renderList.transparent;\n    const transparentDoublePassObjects = renderList.transparentDoublePass;\n    const lightsNode = renderList.lightsNode;\n    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);\n\n    // restore render tree\n\n    nodeFrame.renderId = previousRenderId;\n    this._currentRenderContext = previousRenderContext;\n    this._currentRenderObjectFunction = previousRenderObjectFunction;\n    this._compilationPromises = previousCompilationPromises;\n    this._handleObjectFunction = this._renderObjectDirect;\n\n    // wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete\n\n    await Promise.all(compilationPromises);\n  }\n\n  /**\n   * Renders the scene in an async fashion.\n   *\n   * @async\n   * @param {Object3D} scene - The scene or 3D object to render.\n   * @param {Camera} camera - The camera.\n   * @return {Promise} A Promise that resolves when the render has been finished.\n   */\n  async renderAsync(scene, camera) {\n    if (this._initialized === false) await this.init();\n    const renderContext = this._renderScene(scene, camera);\n    await this.backend.resolveTimestampAsync(renderContext, 'render');\n  }\n\n  /**\n   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n   * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n   *\n   * @async\n   * @return {Promise} A Promise that resolves when synchronization has been finished.\n   */\n  async waitForGPU() {\n    await this.backend.waitForGPU();\n  }\n\n  /**\n   * Sets the given MRT configuration.\n   *\n   * @param {MRTNode} mrt - The MRT node to set.\n   * @return {Renderer} A reference to this renderer.\n   */\n  setMRT(mrt) {\n    this._mrt = mrt;\n    return this;\n  }\n\n  /**\n   * Returns the MRT configuration.\n   *\n   * @return {MRTNode} The MRT configuration.\n   */\n  getMRT() {\n    return this._mrt;\n  }\n\n  /**\n   * Default implementation of the device lost callback.\n   *\n   * @private\n   * @param {Object} info - Information about the context lost.\n   */\n  _onDeviceLost(info) {\n    let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\\n\\nMessage: ${info.message}`;\n    if (info.reason) {\n      errorMessage += `\\nReason: ${info.reason}`;\n    }\n    console.error(errorMessage);\n    this._isDeviceLost = true;\n  }\n\n  /**\n   * Renders the given render bundle.\n   *\n   * @private\n   * @param {Object} bundle - Render bundle data.\n   * @param {Scene} sceneRef - The scene the render bundle belongs to.\n   * @param {LightsNode} lightsNode - The current lights node.\n   */\n  _renderBundle(bundle, sceneRef, lightsNode) {\n    const {\n      bundleGroup,\n      camera,\n      renderList\n    } = bundle;\n    const renderContext = this._currentRenderContext;\n\n    //\n\n    const renderBundle = this._bundles.get(bundleGroup, camera);\n    const renderBundleData = this.backend.get(renderBundle);\n    if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();\n\n    //\n\n    const needsUpdate = bundleGroup.version !== renderBundleData.version;\n    const renderBundleNeedsUpdate = renderBundleData.renderContexts.has(renderContext) === false || needsUpdate;\n    renderBundleData.renderContexts.add(renderContext);\n    if (renderBundleNeedsUpdate) {\n      this.backend.beginBundle(renderContext);\n      if (renderBundleData.renderObjects === undefined || needsUpdate) {\n        renderBundleData.renderObjects = [];\n      }\n      this._currentRenderBundle = renderBundle;\n      const opaqueObjects = renderList.opaque;\n      if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n      this._currentRenderBundle = null;\n\n      //\n\n      this.backend.finishBundle(renderContext, renderBundle);\n      renderBundleData.version = bundleGroup.version;\n    } else {\n      const {\n        renderObjects\n      } = renderBundleData;\n      for (let i = 0, l = renderObjects.length; i < l; i++) {\n        const renderObject = renderObjects[i];\n        if (this._nodes.needsRefresh(renderObject)) {\n          this._nodes.updateBefore(renderObject);\n          this._nodes.updateForRender(renderObject);\n          this._bindings.updateForRender(renderObject);\n          this._nodes.updateAfter(renderObject);\n        }\n      }\n    }\n    this.backend.addBundle(renderContext, renderBundle);\n  }\n\n  /**\n   * Renders the scene or 3D object with the given camera. This method can only be called\n   * if the renderer has been initialized.\n   *\n   * The target of the method is the default framebuffer (meaning the canvas)\n   * or alternatively a render target when specified via `setRenderTarget()`.\n   *\n   * @param {Object3D} scene - The scene or 3D object to render.\n   * @param {Camera} camera - The camera to render the scene with.\n   * @return {Promise?} A Promise that resolve when the scene has been rendered.\n   * Only returned when the renderer has not been initialized.\n   */\n  render(scene, camera) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.');\n      return this.renderAsync(scene, camera);\n    }\n    this._renderScene(scene, camera);\n  }\n\n  /**\n   * Returns an internal render target which is used when computing the output tone mapping\n   * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render\n   * pass and not inline to achieve more correct results.\n   *\n   * @private\n   * @return {RenderTarget?} The render target. The method returns `null` if no output conversion should be applied.\n   */\n  _getFrameBufferTarget() {\n    const {\n      currentToneMapping,\n      currentColorSpace\n    } = this;\n    const useToneMapping = currentToneMapping !== NoToneMapping;\n    const useColorSpace = currentColorSpace !== LinearSRGBColorSpace;\n    if (useToneMapping === false && useColorSpace === false) return null;\n    const {\n      width,\n      height\n    } = this.getDrawingBufferSize(_drawingBufferSize);\n    const {\n      depth,\n      stencil\n    } = this;\n    let frameBufferTarget = this._frameBufferTarget;\n    if (frameBufferTarget === null) {\n      frameBufferTarget = new RenderTarget(width, height, {\n        depthBuffer: depth,\n        stencilBuffer: stencil,\n        type: HalfFloatType,\n        // FloatType\n        format: RGBAFormat,\n        colorSpace: LinearSRGBColorSpace,\n        generateMipmaps: false,\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        samples: this.samples\n      });\n      frameBufferTarget.isPostProcessingRenderTarget = true;\n      this._frameBufferTarget = frameBufferTarget;\n    }\n    frameBufferTarget.depthBuffer = depth;\n    frameBufferTarget.stencilBuffer = stencil;\n    frameBufferTarget.setSize(width, height);\n    frameBufferTarget.viewport.copy(this._viewport);\n    frameBufferTarget.scissor.copy(this._scissor);\n    frameBufferTarget.viewport.multiplyScalar(this._pixelRatio);\n    frameBufferTarget.scissor.multiplyScalar(this._pixelRatio);\n    frameBufferTarget.scissorTest = this._scissorTest;\n    return frameBufferTarget;\n  }\n\n  /**\n   * Renders the scene or 3D object with the given camera.\n   *\n   * @private\n   * @param {Object3D} scene - The scene or 3D object to render.\n   * @param {Camera} camera - The camera to render the scene with.\n   * @param {Boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.\n   * @return {RenderContext} The current render context.\n   */\n  _renderScene(scene, camera, useFrameBufferTarget = true) {\n    if (this._isDeviceLost === true) return;\n    const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;\n\n    // preserve render tree\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n    const previousRenderContext = this._currentRenderContext;\n    const previousRenderObjectFunction = this._currentRenderObjectFunction;\n\n    //\n\n    const sceneRef = scene.isScene === true ? scene : _scene;\n    const outputRenderTarget = this._renderTarget;\n    const activeCubeFace = this._activeCubeFace;\n    const activeMipmapLevel = this._activeMipmapLevel;\n\n    //\n\n    let renderTarget;\n    if (frameBufferTarget !== null) {\n      renderTarget = frameBufferTarget;\n      this.setRenderTarget(renderTarget);\n    } else {\n      renderTarget = outputRenderTarget;\n    }\n\n    //\n\n    const renderContext = this._renderContexts.get(scene, camera, renderTarget);\n    this._currentRenderContext = renderContext;\n    this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;\n\n    //\n\n    this.info.calls++;\n    this.info.render.calls++;\n    this.info.render.frameCalls++;\n    nodeFrame.renderId = this.info.calls;\n\n    //\n\n    const coordinateSystem = this.coordinateSystem;\n    if (camera.coordinateSystem !== coordinateSystem) {\n      camera.coordinateSystem = coordinateSystem;\n      camera.updateProjectionMatrix();\n    }\n\n    //\n\n    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n\n    //\n\n    let viewport = this._viewport;\n    let scissor = this._scissor;\n    let pixelRatio = this._pixelRatio;\n    if (renderTarget !== null) {\n      viewport = renderTarget.viewport;\n      scissor = renderTarget.scissor;\n      pixelRatio = 1;\n    }\n    this.getDrawingBufferSize(_drawingBufferSize);\n    _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);\n    const minDepth = viewport.minDepth === undefined ? 0 : viewport.minDepth;\n    const maxDepth = viewport.maxDepth === undefined ? 1 : viewport.maxDepth;\n    renderContext.viewportValue.copy(viewport).multiplyScalar(pixelRatio).floor();\n    renderContext.viewportValue.width >>= activeMipmapLevel;\n    renderContext.viewportValue.height >>= activeMipmapLevel;\n    renderContext.viewportValue.minDepth = minDepth;\n    renderContext.viewportValue.maxDepth = maxDepth;\n    renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;\n    renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();\n    renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals(_screen) === false;\n    renderContext.scissorValue.width >>= activeMipmapLevel;\n    renderContext.scissorValue.height >>= activeMipmapLevel;\n    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();\n    renderContext.clippingContext.updateGlobal(sceneRef, camera);\n\n    //\n\n    sceneRef.onBeforeRender(this, scene, camera, renderTarget);\n\n    //\n\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);\n    const renderList = this._renderLists.get(scene, camera);\n    renderList.begin();\n    this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);\n    renderList.finish();\n    if (this.sortObjects === true) {\n      renderList.sort(this._opaqueSort, this._transparentSort);\n    }\n\n    //\n\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);\n      const renderTargetData = this._textures.get(renderTarget);\n      renderContext.textures = renderTargetData.textures;\n      renderContext.depthTexture = renderTargetData.depthTexture;\n      renderContext.width = renderTargetData.width;\n      renderContext.height = renderTargetData.height;\n      renderContext.renderTarget = renderTarget;\n      renderContext.depth = renderTarget.depthBuffer;\n      renderContext.stencil = renderTarget.stencilBuffer;\n    } else {\n      renderContext.textures = null;\n      renderContext.depthTexture = null;\n      renderContext.width = this.domElement.width;\n      renderContext.height = this.domElement.height;\n      renderContext.depth = this.depth;\n      renderContext.stencil = this.stencil;\n    }\n    renderContext.width >>= activeMipmapLevel;\n    renderContext.height >>= activeMipmapLevel;\n    renderContext.activeCubeFace = activeCubeFace;\n    renderContext.activeMipmapLevel = activeMipmapLevel;\n    renderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n    //\n\n    this._background.update(sceneRef, renderList, renderContext);\n\n    //\n\n    this.backend.beginRender(renderContext);\n\n    // process render lists\n\n    const {\n      bundles,\n      lightsNode,\n      transparentDoublePass: transparentDoublePassObjects,\n      transparent: transparentObjects,\n      opaque: opaqueObjects\n    } = renderList;\n    if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode);\n    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);\n\n    // finish render pass\n\n    this.backend.finishRender(renderContext);\n\n    // restore render tree\n\n    nodeFrame.renderId = previousRenderId;\n    this._currentRenderContext = previousRenderContext;\n    this._currentRenderObjectFunction = previousRenderObjectFunction;\n\n    //\n\n    if (frameBufferTarget !== null) {\n      this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);\n      const quad = this._quad;\n      if (this._nodes.hasOutputChange(renderTarget.texture)) {\n        quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);\n        quad.material.needsUpdate = true;\n      }\n      this._renderScene(quad, quad.camera, false);\n    }\n\n    //\n\n    sceneRef.onAfterRender(this, scene, camera, renderTarget);\n\n    //\n\n    return renderContext;\n  }\n\n  /**\n   * Returns the maximum available anisotropy for texture filtering.\n   *\n   * @return {Number} The maximum available anisotropy.\n   */\n  getMaxAnisotropy() {\n    return this.backend.getMaxAnisotropy();\n  }\n\n  /**\n   * Returns the active cube face.\n   *\n   * @return {Number} The active cube face.\n   */\n  getActiveCubeFace() {\n    return this._activeCubeFace;\n  }\n\n  /**\n   * Returns the active mipmap level.\n   *\n   * @return {Number} The active mipmap level.\n   */\n  getActiveMipmapLevel() {\n    return this._activeMipmapLevel;\n  }\n\n  /**\n   * Applications are advised to always define the animation loop\n   * with this method and not manually with `requestAnimationFrame()`\n   * for best compatibility.\n   *\n   * @async\n   * @param {Function} callback - The application's animation loop.\n   * @return {Promise} A Promise that resolves when the set has been exeucted.\n   */\n  async setAnimationLoop(callback) {\n    if (this._initialized === false) await this.init();\n    this._animation.setAnimationLoop(callback);\n  }\n\n  /**\n   * Can be used to transfer buffer data from a storage buffer attribute\n   * from the GPU to the CPU in context of compute shaders.\n   *\n   * @async\n   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n   */\n  async getArrayBufferAsync(attribute) {\n    return await this.backend.getArrayBufferAsync(attribute);\n  }\n\n  /**\n   * Returns the rendering context.\n   *\n   * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.\n   */\n  getContext() {\n    return this.backend.getContext();\n  }\n\n  /**\n   * Returns the pixel ratio.\n   *\n   * @return {Number} The pixel ratio.\n   */\n  getPixelRatio() {\n    return this._pixelRatio;\n  }\n\n  /**\n   * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.\n   *\n   * @param {Vector2} target - The method writes the result in this target object.\n   * @return {Vector2} The drawing buffer size.\n   */\n  getDrawingBufferSize(target) {\n    return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();\n  }\n\n  /**\n   * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.\n   *\n   * @param {Vector2} target - The method writes the result in this target object.\n   * @return {Vector2} The drawing buffer size.\n   */\n  getSize(target) {\n    return target.set(this._width, this._height);\n  }\n\n  /**\n   * Sets the given pixel ration and resizes the canvas if necessary.\n   *\n   * @param {Number} [value=1] - The pixel ratio.\n   */\n  setPixelRatio(value = 1) {\n    if (this._pixelRatio === value) return;\n    this._pixelRatio = value;\n    this.setSize(this._width, this._height, false);\n  }\n\n  /**\n   * This method allows to define the drawing buffer size by specifying\n   * width, height and pixel ratio all at once. The size of the drawing\n   * buffer is computed with this formula:\n   * ````\n   * size.x = width * pixelRatio;\n   * size.y = height * pixelRatio;\n   *```\n   *\n   * @param {Number} width - The width in logical pixels.\n   * @param {Number} height - The height in logical pixels.\n   * @param {Number} pixelRatio - The pixel ratio.\n   */\n  setDrawingBufferSize(width, height, pixelRatio) {\n    this._width = width;\n    this._height = height;\n    this._pixelRatio = pixelRatio;\n    this.domElement.width = Math.floor(width * pixelRatio);\n    this.domElement.height = Math.floor(height * pixelRatio);\n    this.setViewport(0, 0, width, height);\n    if (this._initialized) this.backend.updateSize();\n  }\n\n  /**\n   * Sets the size of the renderer.\n   *\n   * @param {Number} width - The width in logical pixels.\n   * @param {Number} height - The height in logical pixels.\n   * @param {Boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.\n   */\n  setSize(width, height, updateStyle = true) {\n    this._width = width;\n    this._height = height;\n    this.domElement.width = Math.floor(width * this._pixelRatio);\n    this.domElement.height = Math.floor(height * this._pixelRatio);\n    if (updateStyle === true) {\n      this.domElement.style.width = width + 'px';\n      this.domElement.style.height = height + 'px';\n    }\n    this.setViewport(0, 0, width, height);\n    if (this._initialized) this.backend.updateSize();\n  }\n\n  /**\n   * Defines a manual sort function for the opaque render list.\n   * Pass `null` to use the default sort.\n   *\n   * @param {Function} method - The sort function.\n   */\n  setOpaqueSort(method) {\n    this._opaqueSort = method;\n  }\n\n  /**\n   * Defines a manual sort function for the transparent render list.\n   * Pass `null` to use the default sort.\n   *\n   * @param {Function} method - The sort function.\n   */\n  setTransparentSort(method) {\n    this._transparentSort = method;\n  }\n\n  /**\n   * Returns the scissor rectangle.\n   *\n   * @param {Vector4} target - The method writes the result in this target object.\n   * @return {Vector4} The scissor rectangle.\n   */\n  getScissor(target) {\n    const scissor = this._scissor;\n    target.x = scissor.x;\n    target.y = scissor.y;\n    target.width = scissor.width;\n    target.height = scissor.height;\n    return target;\n  }\n\n  /**\n   * Defines the scissor rectangle.\n   *\n   * @param {Number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.\n   * Instead of passing four arguments, the method also works with a single four-dimensional vector.\n   * @param {Number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.\n   * @param {Number} width - The width of the scissor box in logical pixel unit.\n   * @param {Number} height - The height of the scissor box in logical pixel unit.\n   */\n  setScissor(x, y, width, height) {\n    const scissor = this._scissor;\n    if (x.isVector4) {\n      scissor.copy(x);\n    } else {\n      scissor.set(x, y, width, height);\n    }\n  }\n\n  /**\n   * Returns the scissor test value.\n   *\n   * @return {Boolean} Whether the scissor test should be enabled or not.\n   */\n  getScissorTest() {\n    return this._scissorTest;\n  }\n\n  /**\n   * Defines the scissor test.\n   *\n   * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n   */\n  setScissorTest(boolean) {\n    this._scissorTest = boolean;\n    this.backend.setScissorTest(boolean);\n  }\n\n  /**\n   * Returns the viewport definition.\n   *\n   * @param {Vector4} target - The method writes the result in this target object.\n   * @return {Vector4} The viewport definition.\n   */\n  getViewport(target) {\n    return target.copy(this._viewport);\n  }\n\n  /**\n   * Defines the viewport.\n   *\n   * @param {Number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.\n   * @param {Number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.\n   * @param {Number} width - The width of the viewport in logical pixel unit.\n   * @param {Number} height - The height of the viewport in logical pixel unit.\n   * @param {Number} minDepth - The minimum depth value of the viewport. WebGPU only.\n   * @param {Number} maxDepth - The maximum depth value of the viewport. WebGPU only.\n   */\n  setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {\n    const viewport = this._viewport;\n    if (x.isVector4) {\n      viewport.copy(x);\n    } else {\n      viewport.set(x, y, width, height);\n    }\n    viewport.minDepth = minDepth;\n    viewport.maxDepth = maxDepth;\n  }\n\n  /**\n   * Returns the clear color.\n   *\n   * @param {Color} target - The method writes the result in this target object.\n   * @return {Color} The clear color.\n   */\n  getClearColor(target) {\n    return target.copy(this._clearColor);\n  }\n\n  /**\n   * Defines the clear color and optionally the clear alpha.\n   *\n   * @param {Color} color - The clear color.\n   * @param {Number} [alpha=1] - The clear alpha.\n   */\n  setClearColor(color, alpha = 1) {\n    this._clearColor.set(color);\n    this._clearColor.a = alpha;\n  }\n\n  /**\n   * Returns the clear alpha.\n   *\n   * @return {Number} The clear alpha.\n   */\n  getClearAlpha() {\n    return this._clearColor.a;\n  }\n\n  /**\n   * Defines the clear alpha.\n   *\n   * @param {Number} alpha - The clear alpha.\n   */\n  setClearAlpha(alpha) {\n    this._clearColor.a = alpha;\n  }\n\n  /**\n   * Returns the clear depth.\n   *\n   * @return {Number} The clear depth.\n   */\n  getClearDepth() {\n    return this._clearDepth;\n  }\n\n  /**\n   * Defines the clear depth.\n   *\n   * @param {Number} depth - The clear depth.\n   */\n  setClearDepth(depth) {\n    this._clearDepth = depth;\n  }\n\n  /**\n   * Returns the clear stencil.\n   *\n   * @return {Number} The clear stencil.\n   */\n  getClearStencil() {\n    return this._clearStencil;\n  }\n\n  /**\n   * Defines the clear stencil.\n   *\n   * @param {Number} stencil - The clear stencil.\n   */\n  setClearStencil(stencil) {\n    this._clearStencil = stencil;\n  }\n\n  /**\n   * This method performs an occlusion query for the given 3D object.\n   * It returns `true` if the given 3D object is fully occluded by other\n   * 3D objects in the scene.\n   *\n   * @param {Object3D} object - The 3D object to test.\n   * @return {Boolean} Whether the 3D object is fully occluded or not.\n   */\n  isOccluded(object) {\n    const renderContext = this._currentRenderContext;\n    return renderContext && this.backend.isOccluded(renderContext, object);\n  }\n\n  /**\n   * Performs a manual clear operation. This method ignores `autoClear` properties.\n   *\n   * @param {Boolean} [color=true] - Whether the color buffer should be cleared or not.\n   * @param {Boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n   * @param {Boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n   * @return {Promise} A Promise that resolves when the clear operation has been executed.\n   * Only returned when the renderer has not been initialized.\n   */\n  clear(color = true, depth = true, stencil = true) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.');\n      return this.clearAsync(color, depth, stencil);\n    }\n    const renderTarget = this._renderTarget || this._getFrameBufferTarget();\n    let renderContext = null;\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget);\n      const renderTargetData = this._textures.get(renderTarget);\n      renderContext = this._renderContexts.get(null, null, renderTarget);\n      renderContext.textures = renderTargetData.textures;\n      renderContext.depthTexture = renderTargetData.depthTexture;\n      renderContext.width = renderTargetData.width;\n      renderContext.height = renderTargetData.height;\n      renderContext.renderTarget = renderTarget;\n      renderContext.depth = renderTarget.depthBuffer;\n      renderContext.stencil = renderTarget.stencilBuffer;\n    }\n    this.backend.clear(color, depth, stencil, renderContext);\n    if (renderTarget !== null && this._renderTarget === null) {\n      // If a color space transform or tone mapping is required,\n      // the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.\n\n      const quad = this._quad;\n      if (this._nodes.hasOutputChange(renderTarget.texture)) {\n        quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);\n        quad.material.needsUpdate = true;\n      }\n      this._renderScene(quad, quad.camera, false);\n    }\n  }\n\n  /**\n   * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.\n   *\n   * @return {Promise} A Promise that resolves when the clear operation has been executed.\n   * Only returned when the renderer has not been initialized.\n   */\n  clearColor() {\n    return this.clear(true, false, false);\n  }\n\n  /**\n   * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.\n   *\n   * @return {Promise} A Promise that resolves when the clear operation has been executed.\n   * Only returned when the renderer has not been initialized.\n   */\n  clearDepth() {\n    return this.clear(false, true, false);\n  }\n\n  /**\n   * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.\n   *\n   * @return {Promise} A Promise that resolves when the clear operation has been executed.\n   * Only returned when the renderer has not been initialized.\n   */\n  clearStencil() {\n    return this.clear(false, false, true);\n  }\n\n  /**\n   * Async version of {@link module:Renderer~Renderer#clear}.\n   *\n   * @async\n   * @param {Boolean} [color=true] - Whether the color buffer should be cleared or not.\n   * @param {Boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n   * @param {Boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n   * @return {Promise} A Promise that resolves when the clear operation has been executed.\n   */\n  async clearAsync(color = true, depth = true, stencil = true) {\n    if (this._initialized === false) await this.init();\n    this.clear(color, depth, stencil);\n  }\n\n  /**\n   * Async version of {@link module:Renderer~Renderer#clearColor}.\n   *\n   * @async\n   * @return {Promise} A Promise that resolves when the clear operation has been executed.\n   */\n  async clearColorAsync() {\n    this.clearAsync(true, false, false);\n  }\n\n  /**\n   * Async version of {@link module:Renderer~Renderer#clearDepth}.\n   *\n   * @async\n   * @return {Promise} A Promise that resolves when the clear operation has been executed.\n   */\n  async clearDepthAsync() {\n    this.clearAsync(false, true, false);\n  }\n\n  /**\n   * Async version of {@link module:Renderer~Renderer#clearStencil}.\n   *\n   * @async\n   * @return {Promise} A Promise that resolves when the clear operation has been executed.\n   */\n  async clearStencilAsync() {\n    this.clearAsync(false, false, true);\n  }\n\n  /**\n   * The current output tone mapping of the renderer. When a render target is set,\n   * the output tone mapping is always `NoToneMapping`.\n   *\n   * @type {Number}\n   */\n  get currentToneMapping() {\n    return this._renderTarget !== null ? NoToneMapping : this.toneMapping;\n  }\n\n  /**\n   * The current output color space of the renderer. When a render target is set,\n   * the output color space is always `LinearSRGBColorSpace`.\n   *\n   * @type {String}\n   */\n  get currentColorSpace() {\n    return this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;\n  }\n\n  /**\n   * Frees all internal resources of the renderer. Call this method if the renderer\n   * is no longer in use by your app.\n   */\n  dispose() {\n    this.info.dispose();\n    this.backend.dispose();\n    this._animation.dispose();\n    this._objects.dispose();\n    this._pipelines.dispose();\n    this._nodes.dispose();\n    this._bindings.dispose();\n    this._renderLists.dispose();\n    this._renderContexts.dispose();\n    this._textures.dispose();\n    this.setRenderTarget(null);\n    this.setAnimationLoop(null);\n  }\n\n  /**\n   * Sets the given render target. Calling this method means the renderer does not\n   * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.\n   * Use `null` as the first argument to reset the state.\n   *\n   * @param {RenderTarget?} renderTarget - The render target to set.\n   * @param {Number} [activeCubeFace=0] - The active cube face.\n   * @param {Number} [activeMipmapLevel=0] - The active mipmap level.\n   */\n  setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n    this._renderTarget = renderTarget;\n    this._activeCubeFace = activeCubeFace;\n    this._activeMipmapLevel = activeMipmapLevel;\n  }\n\n  /**\n   * Returns the current render target.\n   *\n   * @return {RenderTarget?} The render target. Returns `null` if no render target is set.\n   */\n  getRenderTarget() {\n    return this._renderTarget;\n  }\n\n  /**\n   * Callback for {@link module:Renderer~Renderer#setRenderObjectFunction}.\n   *\n   * @callback renderObjectFunction\n   * @param {Object3D} object - The 3D object.\n   * @param {Scene} scene - The scene the 3D object belongs to.\n   * @param {Camera} camera - The camera the object should be rendered with.\n   * @param {BufferGeometry} geometry - The object's geometry.\n   * @param {Material} material - The object's material.\n   * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n   * @param {LightsNode} lightsNode - The current lights node.\n   * @param {ClippingContext} clippingContext - The clipping context.\n   * @param {String?} [passId=null] - An optional ID for identifying the pass.\n   */\n\n  /**\n   * Sets the given render object function. Calling this method overwrites the default implementation\n   * which is {@link module:Renderer~Renderer#renderObject}. Defining a custom function can be useful\n   * if you want to modify the way objects are rendered. For example you can define things like \"every\n   * object that has material of a certain type should perform a pre-pass with a special overwrite material\".\n   * The custom function must always call `renderObject()` in its implementation.\n   *\n   * Use `null` as the first argument to reset the state.\n   *\n   * @param {module:Renderer~renderObjectFunction?} renderObjectFunction - The render object function.\n   */\n  setRenderObjectFunction(renderObjectFunction) {\n    this._renderObjectFunction = renderObjectFunction;\n  }\n\n  /**\n   * Returns the current render object function.\n   *\n   * @return {Function?} The current render object function. Returns `null` if no function is set.\n   */\n  getRenderObjectFunction() {\n    return this._renderObjectFunction;\n  }\n\n  /**\n   * Execute a single or an array of compute nodes. This method can only be called\n   * if the renderer has been initialized.\n   *\n   * @param {Node|Array<Node>} computeNodes - The compute node(s).\n   * @return {Promise?} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.\n   */\n  compute(computeNodes) {\n    if (this.isDeviceLost === true) return;\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.');\n      return this.computeAsync(computeNodes);\n    }\n\n    //\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n\n    //\n\n    this.info.calls++;\n    this.info.compute.calls++;\n    this.info.compute.frameCalls++;\n    nodeFrame.renderId = this.info.calls;\n\n    //\n\n    const backend = this.backend;\n    const pipelines = this._pipelines;\n    const bindings = this._bindings;\n    const nodes = this._nodes;\n    const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];\n    if (computeList[0] === undefined || computeList[0].isComputeNode !== true) {\n      throw new Error('THREE.Renderer: .compute() expects a ComputeNode.');\n    }\n    backend.beginCompute(computeNodes);\n    for (const computeNode of computeList) {\n      // onInit\n\n      if (pipelines.has(computeNode) === false) {\n        const dispose = () => {\n          computeNode.removeEventListener('dispose', dispose);\n          pipelines.delete(computeNode);\n          bindings.delete(computeNode);\n          nodes.delete(computeNode);\n        };\n        computeNode.addEventListener('dispose', dispose);\n\n        //\n\n        const onInitFn = computeNode.onInitFunction;\n        if (onInitFn !== null) {\n          onInitFn.call(computeNode, {\n            renderer: this\n          });\n        }\n      }\n      nodes.updateForCompute(computeNode);\n      bindings.updateForCompute(computeNode);\n      const computeBindings = bindings.getForCompute(computeNode);\n      const computePipeline = pipelines.getForCompute(computeNode, computeBindings);\n      backend.compute(computeNodes, computeNode, computeBindings, computePipeline);\n    }\n    backend.finishCompute(computeNodes);\n\n    //\n\n    nodeFrame.renderId = previousRenderId;\n  }\n\n  /**\n   * Execute a single or an array of compute nodes.\n   *\n   * @async\n   * @param {Node|Array<Node>} computeNodes - The compute node(s).\n   * @return {Promise?} A Promise that resolve when the compute has finished.\n   */\n  async computeAsync(computeNodes) {\n    if (this._initialized === false) await this.init();\n    this.compute(computeNodes);\n    await this.backend.resolveTimestampAsync(computeNodes, 'compute');\n  }\n\n  /**\n   * Checks if the given feature is supported by the selected backend.\n   *\n   * @async\n   * @param {String} name - The feature's name.\n   * @return {Promise<Boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n   */\n  async hasFeatureAsync(name) {\n    if (this._initialized === false) await this.init();\n    return this.backend.hasFeature(name);\n  }\n\n  /**\n   * Checks if the given feature is supported by the selected backend. If the\n   * renderer has not been initialized, this method always returns `false`.\n   *\n   * @param {String} name - The feature's name.\n   * @return {Boolean} Whether the feature is supported or not.\n   */\n  hasFeature(name) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.');\n      return false;\n    }\n    return this.backend.hasFeature(name);\n  }\n\n  /**\n   * Returns `true` when the renderer has been initialized.\n   *\n   * @return {Boolean} Whether the renderer has been initialized or not.\n   */\n  hasInitialized() {\n    return this._initialized;\n  }\n\n  /**\n   * Initializes the given textures. Useful for preloading a texture rather than waiting until first render\n   * (which can cause noticeable lags due to decode and GPU upload overhead).\n   *\n   * @async\n   * @param {Texture} texture - The texture.\n   * @return {Promise} A Promise that resolves when the texture has been initialized.\n   */\n  async initTextureAsync(texture) {\n    if (this._initialized === false) await this.init();\n    this._textures.updateTexture(texture);\n  }\n\n  /**\n   * Initializes the given textures. Useful for preloading a texture rather than waiting until first render\n   * (which can cause noticeable lags due to decode and GPU upload overhead).\n   *\n   * This method can only be used if the renderer has been initialized.\n   *\n   * @param {Texture} texture - The texture.\n   */\n  initTexture(texture) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.');\n    }\n    this._textures.updateTexture(texture);\n  }\n\n  /**\n   * Copies the current bound framebuffer into the given texture.\n   *\n   * @param {FramebufferTexture} framebufferTexture - The texture.\n   * @param {Vector2|Vector4} rectangle - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.\n   */\n  copyFramebufferToTexture(framebufferTexture, rectangle = null) {\n    if (rectangle !== null) {\n      if (rectangle.isVector2) {\n        rectangle = _vector4.set(rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height).floor();\n      } else if (rectangle.isVector4) {\n        rectangle = _vector4.copy(rectangle).floor();\n      } else {\n        console.error('THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.');\n        return;\n      }\n    } else {\n      rectangle = _vector4.set(0, 0, framebufferTexture.image.width, framebufferTexture.image.height);\n    }\n\n    //\n\n    let renderContext = this._currentRenderContext;\n    let renderTarget;\n    if (renderContext !== null) {\n      renderTarget = renderContext.renderTarget;\n    } else {\n      renderTarget = this._renderTarget || this._getFrameBufferTarget();\n      if (renderTarget !== null) {\n        this._textures.updateRenderTarget(renderTarget);\n        renderContext = this._textures.get(renderTarget);\n      }\n    }\n\n    //\n\n    this._textures.updateTexture(framebufferTexture, {\n      renderTarget\n    });\n    this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, rectangle);\n  }\n\n  /**\n   * Copies data of source texture into a destination texture.\n   *\n   * @param {Texture} srcTexture - The source texture.\n   * @param {Texture} dstTexture - The destination texture.\n   * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.\n   * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.\n   * @param {Number} level - The mipmap level to copy.\n   */\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n    this._textures.updateTexture(srcTexture);\n    this._textures.updateTexture(dstTexture);\n    this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);\n  }\n\n  /**\n   * Reads pixel data from the given render target.\n   *\n   * @async\n   * @param {RenderTarget} renderTarget - The render target to read from.\n   * @param {Number} x - The `x` coordinate of the copy region's origin.\n   * @param {Number} y - The `y` coordinate of the copy region's origin.\n   * @param {Number} width - The width of the copy region.\n   * @param {Number} height - The height of the copy region.\n   * @param {Number} [textureIndex=0] - The texture index of a MRT render target.\n   * @param {Number} [faceIndex=0] - The active cube face index.\n   * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.\n   */\n  async readRenderTargetPixelsAsync(renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0) {\n    return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex], x, y, width, height, faceIndex);\n  }\n\n  /**\n   * Analyzes the given 3D object's hierarchy and builds render lists from the\n   * processed hierarchy.\n   *\n   * @param {Object3D} object - The 3D object to process (usually a scene).\n   * @param {Camera} camera - The camera the object is rendered with.\n   * @param {Number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.\n   * @param {RenderList} renderList - The current render list.\n   * @param {ClippingContext} clippingContext - The current clipping context.\n   */\n  _projectObject(object, camera, groupOrder, renderList, clippingContext) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n        if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true) object.update(camera);\n      } else if (object.isLight) {\n        renderList.pushLight(object);\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (this.sortObjects === true) {\n            _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          const {\n            geometry,\n            material\n          } = object;\n          if (material.visible) {\n            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);\n          }\n        }\n      } else if (object.isLineLoop) {\n        console.error('THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.');\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          const {\n            geometry,\n            material\n          } = object;\n          if (this.sortObjects === true) {\n            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n            _vector4.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          if (Array.isArray(material)) {\n            const groups = geometry.groups;\n            for (let i = 0, l = groups.length; i < l; i++) {\n              const group = groups[i];\n              const groupMaterial = material[group.materialIndex];\n              if (groupMaterial && groupMaterial.visible) {\n                renderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext);\n              }\n            }\n          } else if (material.visible) {\n            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);\n          }\n        }\n      }\n    }\n    if (object.isBundleGroup === true && this.backend.beginBundle !== undefined) {\n      const baseRenderList = renderList;\n\n      // replace render list\n      renderList = this._renderLists.get(object, camera);\n      renderList.begin();\n      baseRenderList.pushBundle({\n        bundleGroup: object,\n        camera,\n        renderList\n      });\n      renderList.finish();\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      this._projectObject(children[i], camera, groupOrder, renderList, clippingContext);\n    }\n  }\n\n  /**\n   * Renders the given render bundles.\n   *\n   * @private\n   * @param {Array<Object>} bundles - Array with render bundle data.\n   * @param {Scene} sceneRef - The scene the render bundles belong to.\n   * @param {LightsNode} lightsNode - The current lights node.\n   */\n  _renderBundles(bundles, sceneRef, lightsNode) {\n    for (const bundle of bundles) {\n      this._renderBundle(bundle, sceneRef, lightsNode);\n    }\n  }\n\n  /**\n   * Renders the transparent objects from the given render lists.\n   *\n   * @private\n   * @param {Array<Object>} renderList - The transparent render list.\n   * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).\n   * @param {Camera} camera - The camera the render list should be rendered with.\n   * @param {Scene} scene - The scene the render list belongs to.\n   * @param {LightsNode} lightsNode - The current lights node.\n   */\n  _renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {\n    if (doublePassList.length > 0) {\n      // render back side\n\n      for (const {\n        material\n      } of doublePassList) {\n        material.side = BackSide;\n      }\n      this._renderObjects(doublePassList, camera, scene, lightsNode, 'backSide');\n\n      // render front side\n\n      for (const {\n        material\n      } of doublePassList) {\n        material.side = FrontSide;\n      }\n      this._renderObjects(renderList, camera, scene, lightsNode);\n\n      // restore\n\n      for (const {\n        material\n      } of doublePassList) {\n        material.side = DoubleSide;\n      }\n    } else {\n      this._renderObjects(renderList, camera, scene, lightsNode);\n    }\n  }\n\n  /**\n   * Renders the objects from the given render list.\n   *\n   * @private\n   * @param {Array<Object>} renderList - The render list.\n   * @param {Camera} camera - The camera the render list should be rendered with.\n   * @param {Scene} scene - The scene the render list belongs to.\n   * @param {LightsNode} lightsNode - The current lights node.\n   * @param {String?} [passId=null] - An optional ID for identifying the pass.\n   */\n  _renderObjects(renderList, camera, scene, lightsNode, passId = null) {\n    // process renderable objects\n\n    for (let i = 0, il = renderList.length; i < il; i++) {\n      const renderItem = renderList[i];\n\n      // @TODO: Add support for multiple materials per object. This will require to extract\n      // the material from the renderItem object and pass it with its group data to renderObject().\n\n      const {\n        object,\n        geometry,\n        material,\n        group,\n        clippingContext\n      } = renderItem;\n      if (camera.isArrayCamera) {\n        const cameras = camera.cameras;\n        for (let j = 0, jl = cameras.length; j < jl; j++) {\n          const camera2 = cameras[j];\n          if (object.layers.test(camera2.layers)) {\n            const vp = camera2.viewport;\n            const minDepth = vp.minDepth === undefined ? 0 : vp.minDepth;\n            const maxDepth = vp.maxDepth === undefined ? 1 : vp.maxDepth;\n            const viewportValue = this._currentRenderContext.viewportValue;\n            viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();\n            viewportValue.minDepth = minDepth;\n            viewportValue.maxDepth = maxDepth;\n            this.backend.updateViewport(this._currentRenderContext);\n            this._currentRenderObjectFunction(object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId);\n          }\n        }\n      } else {\n        this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId);\n      }\n    }\n  }\n\n  /**\n   * This method represents the default render object function that manages the render lifecycle\n   * of the object.\n   *\n   * @param {Object3D} object - The 3D object.\n   * @param {Scene} scene - The scene the 3D object belongs to.\n   * @param {Camera} camera - The camera the object should be rendered with.\n   * @param {BufferGeometry} geometry - The object's geometry.\n   * @param {Material} material - The object's material.\n   * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n   * @param {LightsNode} lightsNode - The current lights node.\n   * @param {ClippingContext} clippingContext - The clipping context.\n   * @param {String?} [passId=null] - An optional ID for identifying the pass.\n   */\n  renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null) {\n    let overridePositionNode;\n    let overrideColorNode;\n    let overrideDepthNode;\n\n    //\n\n    object.onBeforeRender(this, scene, camera, geometry, material, group);\n\n    //\n\n    if (scene.overrideMaterial !== null) {\n      const overrideMaterial = scene.overrideMaterial;\n      if (material.positionNode && material.positionNode.isNode) {\n        overridePositionNode = overrideMaterial.positionNode;\n        overrideMaterial.positionNode = material.positionNode;\n      }\n      overrideMaterial.alphaTest = material.alphaTest;\n      overrideMaterial.alphaMap = material.alphaMap;\n      overrideMaterial.transparent = material.transparent || material.transmission > 0;\n      if (overrideMaterial.isShadowNodeMaterial) {\n        overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;\n        if (material.depthNode && material.depthNode.isNode) {\n          overrideDepthNode = overrideMaterial.depthNode;\n          overrideMaterial.depthNode = material.depthNode;\n        }\n        if (material.castShadowNode && material.castShadowNode.isNode) {\n          overrideColorNode = overrideMaterial.colorNode;\n          overrideMaterial.colorNode = material.castShadowNode;\n        }\n      }\n      material = overrideMaterial;\n    }\n\n    //\n\n    if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {\n      material.side = BackSide;\n      this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, 'backSide'); // create backSide pass id\n\n      material.side = FrontSide;\n      this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId); // use default pass id\n\n      material.side = DoubleSide;\n    } else {\n      this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId);\n    }\n\n    //\n\n    if (overridePositionNode !== undefined) {\n      scene.overrideMaterial.positionNode = overridePositionNode;\n    }\n    if (overrideDepthNode !== undefined) {\n      scene.overrideMaterial.depthNode = overrideDepthNode;\n    }\n    if (overrideColorNode !== undefined) {\n      scene.overrideMaterial.colorNode = overrideColorNode;\n    }\n\n    //\n\n    object.onAfterRender(this, scene, camera, geometry, material, group);\n  }\n\n  /**\n   * This method represents the default `_handleObjectFunction` implementation which creates\n   * a render object from the given data and performs the draw command with the selected backend.\n   *\n   * @private\n   * @param {Object3D} object - The 3D object.\n   * @param {Material} material - The object's material.\n   * @param {Scene} scene - The scene the 3D object belongs to.\n   * @param {Camera} camera - The camera the object should be rendered with.\n   * @param {LightsNode} lightsNode - The current lights node.\n   * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n   * @param {ClippingContext} clippingContext - The clipping context.\n   * @param {String?} [passId=null] - An optional ID for identifying the pass.\n   */\n  _renderObjectDirect(object, material, scene, camera, lightsNode, group, clippingContext, passId) {\n    const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);\n    renderObject.drawRange = object.geometry.drawRange;\n    renderObject.group = group;\n\n    //\n\n    const needsRefresh = this._nodes.needsRefresh(renderObject);\n    if (needsRefresh) {\n      this._nodes.updateBefore(renderObject);\n      this._geometries.updateForRender(renderObject);\n      this._nodes.updateForRender(renderObject);\n      this._bindings.updateForRender(renderObject);\n    }\n    this._pipelines.updateForRender(renderObject);\n\n    //\n\n    if (this._currentRenderBundle !== null) {\n      const renderBundleData = this.backend.get(this._currentRenderBundle);\n      renderBundleData.renderObjects.push(renderObject);\n      renderObject.bundle = this._currentRenderBundle.bundleGroup;\n    }\n    this.backend.draw(renderObject, this.info);\n    if (needsRefresh) this._nodes.updateAfter(renderObject);\n  }\n\n  /**\n   * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.\n   * Used in `compileAsync()`.\n   *\n   * @private\n   * @param {Object3D} object - The 3D object.\n   * @param {Material} material - The object's material.\n   * @param {Scene} scene - The scene the 3D object belongs to.\n   * @param {Camera} camera - The camera the object should be rendered with.\n   * @param {LightsNode} lightsNode - The current lights node.\n   * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n   * @param {ClippingContext} clippingContext - The clipping context.\n   * @param {String?} [passId=null] - An optional ID for identifying the pass.\n   */\n  _createObjectPipeline(object, material, scene, camera, lightsNode, group, clippingContext, passId) {\n    const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);\n    renderObject.drawRange = object.geometry.drawRange;\n    renderObject.group = group;\n\n    //\n\n    this._nodes.updateBefore(renderObject);\n    this._geometries.updateForRender(renderObject);\n    this._nodes.updateForRender(renderObject);\n    this._bindings.updateForRender(renderObject);\n    this._pipelines.getForRender(renderObject, this._compilationPromises);\n    this._nodes.updateAfter(renderObject);\n  }\n\n  /**\n   * Alias for `compileAsync()`.\n   *\n   * @method\n   * @param {Object3D} scene - The scene or 3D object to precompile.\n   * @param {Camera} camera - The camera that is used to render the scene.\n   * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n   * @return {Promise} A Promise that resolves when the compile has been finished.\n   */\n  get compile() {\n    return this.compileAsync;\n  }\n}\n\n/**\n * A binding represents the connection between a resource (like a texture, sampler\n * or uniform buffer) and the resource definition in a shader stage.\n *\n * This module is an abstract base class for all concrete bindings types.\n *\n * @abstract\n * @private\n */\nclass Binding {\n  /**\n   * Constructs a new binding.\n   *\n   * @param {String} [name=''] - The binding's name.\n   */\n  constructor(name = '') {\n    /**\n     * The binding's name.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * A bitmask that defines in what shader stages the\n     * binding's resource is accessible.\n     *\n     * @type {String}\n     */\n    this.visibility = 0;\n  }\n\n  /**\n   * Makes sure binding's resource is visible for the given shader stage.\n   *\n   * @param {Number} visibility - The shader stage.\n   */\n  setVisibility(visibility) {\n    this.visibility |= visibility;\n  }\n\n  /**\n   * Clones the binding.\n   *\n   * @return {Binding} The cloned binding.\n   */\n  clone() {\n    return Object.assign(new this.constructor(), this);\n  }\n}\n\n/** @module BufferUtils **/\n\n/**\n * This function is usually called with the length in bytes of an array buffer.\n * It returns an padded value whic ensure chunk size alignment according to STD140 layout.\n *\n * @function\n * @param {Number} floatLength - The buffer length.\n * @return {Number} The padded length.\n */\nfunction getFloatLength(floatLength) {\n  // ensure chunk size alignment (STD140 layout)\n\n  return floatLength + (GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;\n}\n\n/**\n * Represents a buffer binding type.\n *\n * @private\n * @abstract\n * @augments Binding\n */\nclass Buffer extends Binding {\n  /**\n   * Constructs a new buffer.\n   *\n   * @param {String} name - The buffer's name.\n   * @param {TypedArray} [buffer=null] - The buffer.\n   */\n  constructor(name, buffer = null) {\n    super(name);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isBuffer = true;\n\n    /**\n     * The bytes per element.\n     *\n     * @type {Number}\n     */\n    this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;\n\n    /**\n     * A reference to the internal buffer.\n     *\n     * @private\n     * @type {TypedArray}\n     */\n    this._buffer = buffer;\n  }\n\n  /**\n   * The buffer's byte length.\n   *\n   * @type {Number}\n   * @readonly\n   */\n  get byteLength() {\n    return getFloatLength(this._buffer.byteLength);\n  }\n\n  /**\n   * A reference to the internal buffer.\n   *\n   * @type {Float32Array}\n   * @readonly\n   */\n  get buffer() {\n    return this._buffer;\n  }\n\n  /**\n   * Updates the binding.\n   *\n   * @return {Boolean} Whether the buffer has been updated and must be\n   * uploaded to the GPU.\n   */\n  update() {\n    return true;\n  }\n}\n\n/**\n * Represents a uniform buffer binding type.\n *\n * @private\n * @augments Buffer\n */\nclass UniformBuffer extends Buffer {\n  /**\n   * Constructs a new uniform buffer.\n   *\n   * @param {String} name - The buffer's name.\n   * @param {TypedArray} [buffer=null] - The buffer.\n   */\n  constructor(name, buffer = null) {\n    super(name, buffer);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isUniformBuffer = true;\n  }\n}\nlet _id$4 = 0;\n\n/**\n * A special form of uniform buffer binding type.\n * It's buffer value is managed by a node object.\n *\n * @private\n * @augments UniformBuffer\n */\nclass NodeUniformBuffer extends UniformBuffer {\n  /**\n   * Constructs a new node-based uniform buffer.\n   *\n   * @param {BufferNode} nodeUniform - The uniform buffer node.\n   * @param {UniformGroupNode} groupNode - The uniform group node.\n   */\n  constructor(nodeUniform, groupNode) {\n    super('UniformBuffer_' + _id$4++, nodeUniform ? nodeUniform.value : null);\n\n    /**\n     * The uniform buffer node.\n     *\n     * @type {BufferNode}\n     */\n    this.nodeUniform = nodeUniform;\n\n    /**\n     * The uniform group node.\n     *\n     * @type {UniformGroupNode}\n     */\n    this.groupNode = groupNode;\n  }\n\n  /**\n   * The uniform buffer.\n   *\n   * @type {Float32Array}\n   */\n  get buffer() {\n    return this.nodeUniform.value;\n  }\n}\n\n/**\n * This class represents a uniform buffer binding but with\n * an API that allows to maintain individual uniform objects.\n *\n * @private\n * @augments UniformBuffer\n */\nclass UniformsGroup extends UniformBuffer {\n  /**\n   * Constructs a new uniforms group.\n   *\n   * @param {String} name - The group's name.\n   */\n  constructor(name) {\n    super(name);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isUniformsGroup = true;\n\n    /**\n     * An array with the raw uniform values.\n     *\n     * @private\n     * @type {Array<Number>?}\n     * @default null\n     */\n    this._values = null;\n\n    /**\n     * An array of uniform objects.\n     *\n     * The order of uniforms in this array must match the order of uniforms in the shader.\n     *\n     * @type {Array<Uniform>}\n     */\n    this.uniforms = [];\n  }\n\n  /**\n   * Adds a uniform to this group.\n   *\n   * @param {Uniform} uniform - The uniform to add.\n   * @return {UniformsGroup} A reference to this group.\n   */\n  addUniform(uniform) {\n    this.uniforms.push(uniform);\n    return this;\n  }\n\n  /**\n   * Removes a uniform from this group.\n   *\n   * @param {Uniform} uniform - The uniform to remove.\n   * @return {UniformsGroup} A reference to this group.\n   */\n  removeUniform(uniform) {\n    const index = this.uniforms.indexOf(uniform);\n    if (index !== -1) {\n      this.uniforms.splice(index, 1);\n    }\n    return this;\n  }\n\n  /**\n   * An array with the raw uniform values.\n   *\n   * @type {Array<Number>}\n   */\n  get values() {\n    if (this._values === null) {\n      this._values = Array.from(this.buffer);\n    }\n    return this._values;\n  }\n\n  /**\n   * A Float32 array buffer with the uniform values.\n   *\n   * @type {Float32Array}\n   */\n  get buffer() {\n    let buffer = this._buffer;\n    if (buffer === null) {\n      const byteLength = this.byteLength;\n      buffer = new Float32Array(new ArrayBuffer(byteLength));\n      this._buffer = buffer;\n    }\n    return buffer;\n  }\n\n  /**\n   * The byte length of the buffer with correct buffer alignment.\n   *\n   * @type {Number}\n   */\n  get byteLength() {\n    let offset = 0; // global buffer offset in bytes\n\n    for (let i = 0, l = this.uniforms.length; i < l; i++) {\n      const uniform = this.uniforms[i];\n      const {\n        boundary,\n        itemSize\n      } = uniform;\n\n      // offset within a single chunk in bytes\n\n      const chunkOffset = offset % GPU_CHUNK_BYTES;\n      const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n\n      // conformance tests\n\n      if (chunkOffset !== 0 && remainingSizeInChunk - boundary < 0) {\n        // check for chunk overflow\n\n        offset += GPU_CHUNK_BYTES - chunkOffset;\n      } else if (chunkOffset % boundary !== 0) {\n        // check for correct alignment\n\n        offset += chunkOffset % boundary;\n      }\n      uniform.offset = offset / this.bytesPerElement;\n      offset += itemSize * this.bytesPerElement;\n    }\n    return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;\n  }\n\n  /**\n   * Updates this group by updating each uniform object of\n   * the internal uniform list. The uniform objects check if their\n   * values has actually changed so this method only returns\n   * `true` if there is a real value change.\n   *\n   * @return {Boolean} Whether the uniforms have been updated and\n   * must be uploaded to the GPU.\n   */\n  update() {\n    let updated = false;\n    for (const uniform of this.uniforms) {\n      if (this.updateByType(uniform) === true) {\n        updated = true;\n      }\n    }\n    return updated;\n  }\n\n  /**\n   * Updates a given uniform by calling an update method matching\n   * the uniforms type.\n   *\n   * @param {Uniform} uniform - The uniform to update.\n   * @return {Boolean} Whether the uniform has been updated or not.\n   */\n  updateByType(uniform) {\n    if (uniform.isNumberUniform) return this.updateNumber(uniform);\n    if (uniform.isVector2Uniform) return this.updateVector2(uniform);\n    if (uniform.isVector3Uniform) return this.updateVector3(uniform);\n    if (uniform.isVector4Uniform) return this.updateVector4(uniform);\n    if (uniform.isColorUniform) return this.updateColor(uniform);\n    if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);\n    if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);\n    console.error('THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform);\n  }\n\n  /**\n   * Updates a given Number uniform.\n   *\n   * @param {NumberUniform} uniform - The Number uniform.\n   * @return {Boolean} Whether the uniform has been updated or not.\n   */\n  updateNumber(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset] !== v) {\n      const b = this._getBufferForType(type);\n      b[offset] = a[offset] = v;\n      updated = true;\n    }\n    return updated;\n  }\n\n  /**\n   * Updates a given Vector2 uniform.\n   *\n   * @param {Vector2Uniform} uniform - The Vector2 uniform.\n   * @return {Boolean} Whether the uniform has been updated or not.\n   */\n  updateVector2(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y) {\n      const b = this._getBufferForType(type);\n      b[offset + 0] = a[offset + 0] = v.x;\n      b[offset + 1] = a[offset + 1] = v.y;\n      updated = true;\n    }\n    return updated;\n  }\n\n  /**\n   * Updates a given Vector3 uniform.\n   *\n   * @param {Vector3Uniform} uniform - The Vector3 uniform.\n   * @return {Boolean} Whether the uniform has been updated or not.\n   */\n  updateVector3(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z) {\n      const b = this._getBufferForType(type);\n      b[offset + 0] = a[offset + 0] = v.x;\n      b[offset + 1] = a[offset + 1] = v.y;\n      b[offset + 2] = a[offset + 2] = v.z;\n      updated = true;\n    }\n    return updated;\n  }\n\n  /**\n   * Updates a given Vector4 uniform.\n   *\n   * @param {Vector4Uniform} uniform - The Vector4 uniform.\n   * @return {Boolean} Whether the uniform has been updated or not.\n   */\n  updateVector4(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z || a[offset + 4] !== v.w) {\n      const b = this._getBufferForType(type);\n      b[offset + 0] = a[offset + 0] = v.x;\n      b[offset + 1] = a[offset + 1] = v.y;\n      b[offset + 2] = a[offset + 2] = v.z;\n      b[offset + 3] = a[offset + 3] = v.w;\n      updated = true;\n    }\n    return updated;\n  }\n\n  /**\n   * Updates a given Color uniform.\n   *\n   * @param {ColorUniform} uniform - The Color uniform.\n   * @return {Boolean} Whether the uniform has been updated or not.\n   */\n  updateColor(uniform) {\n    let updated = false;\n    const a = this.values;\n    const c = uniform.getValue();\n    const offset = uniform.offset;\n    if (a[offset + 0] !== c.r || a[offset + 1] !== c.g || a[offset + 2] !== c.b) {\n      const b = this.buffer;\n      b[offset + 0] = a[offset + 0] = c.r;\n      b[offset + 1] = a[offset + 1] = c.g;\n      b[offset + 2] = a[offset + 2] = c.b;\n      updated = true;\n    }\n    return updated;\n  }\n\n  /**\n   * Updates a given Matrix3 uniform.\n   *\n   * @param {Matrix3Uniform} uniform - The Matrix3 uniform.\n   * @return {Boolean} Whether the uniform has been updated or not.\n   */\n  updateMatrix3(uniform) {\n    let updated = false;\n    const a = this.values;\n    const e = uniform.getValue().elements;\n    const offset = uniform.offset;\n    if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] || a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] || a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {\n      const b = this.buffer;\n      b[offset + 0] = a[offset + 0] = e[0];\n      b[offset + 1] = a[offset + 1] = e[1];\n      b[offset + 2] = a[offset + 2] = e[2];\n      b[offset + 4] = a[offset + 4] = e[3];\n      b[offset + 5] = a[offset + 5] = e[4];\n      b[offset + 6] = a[offset + 6] = e[5];\n      b[offset + 8] = a[offset + 8] = e[6];\n      b[offset + 9] = a[offset + 9] = e[7];\n      b[offset + 10] = a[offset + 10] = e[8];\n      updated = true;\n    }\n    return updated;\n  }\n\n  /**\n   * Updates a given Matrix4 uniform.\n   *\n   * @param {Matrix4Uniform} uniform - The Matrix4 uniform.\n   * @return {Boolean} Whether the uniform has been updated or not.\n   */\n  updateMatrix4(uniform) {\n    let updated = false;\n    const a = this.values;\n    const e = uniform.getValue().elements;\n    const offset = uniform.offset;\n    if (arraysEqual(a, e, offset) === false) {\n      const b = this.buffer;\n      b.set(e, offset);\n      setArray(a, e, offset);\n      updated = true;\n    }\n    return updated;\n  }\n\n  /**\n   * Returns a typed array that matches the given data type.\n   *\n   * @param {String} type - The data type.\n   * @return {TypedArray} The typed array.\n   */\n  _getBufferForType(type) {\n    if (type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4') return new Int32Array(this.buffer.buffer);\n    if (type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4') return new Uint32Array(this.buffer.buffer);\n    return this.buffer;\n  }\n}\n\n/**\n * Sets the values of the second array to the first array.\n *\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {Number} offset - An index offset for the first array.\n */\nfunction setArray(a, b, offset) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    a[offset + i] = b[i];\n  }\n}\n\n/**\n * Returns `true` if the given arrays are equal.\n *\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {Number} offset - An index offset for the first array.\n * @return {Boolean} Whether the given arrays are equal or not.\n */\nfunction arraysEqual(a, b, offset) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    if (a[offset + i] !== b[i]) return false;\n  }\n  return true;\n}\nlet _id$3 = 0;\n\n/**\n * A special form of uniforms group that represents\n * the individual uniforms as node-based uniforms.\n *\n * @private\n * @augments UniformsGroup\n */\nclass NodeUniformsGroup extends UniformsGroup {\n  /**\n   * Constructs a new node-based uniforms group.\n   *\n   * @param {String} name - The group's name.\n   * @param {UniformGroupNode} groupNode - The uniform group node.\n   */\n  constructor(name, groupNode) {\n    super(name);\n\n    /**\n     * The group's ID.\n     *\n     * @type {Number}\n     */\n    this.id = _id$3++;\n\n    /**\n     * The uniform group node.\n     *\n     * @type {UniformGroupNode}\n     */\n    this.groupNode = groupNode;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isNodeUniformsGroup = true;\n  }\n}\nlet _id$2 = 0;\n\n/**\n * Represents a sampled texture binding type.\n *\n * @private\n * @augments Binding\n */\nclass SampledTexture extends Binding {\n  /**\n   * Constructs a new sampled texture.\n   *\n   * @param {String} name - The sampled texture's name.\n   * @param {Texture?} texture - The texture this binding is referring to.\n   */\n  constructor(name, texture) {\n    super(name);\n\n    /**\n     * This identifier.\n     *\n     * @type {Number}\n     */\n    this.id = _id$2++;\n\n    /**\n     * The texture this binding is referring to.\n     *\n     * @type {Texture?}\n     */\n    this.texture = texture;\n\n    /**\n     * The binding's version.\n     *\n     * @type {Number}\n     */\n    this.version = texture ? texture.version : 0;\n\n    /**\n     * Whether the texture is a storage texture or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.store = false;\n\n    /**\n     * The binding's generation which is an additional version\n     * qualifier.\n     *\n     * @type {Number?}\n     * @default null\n     */\n    this.generation = null;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isSampledTexture = true;\n  }\n\n  /**\n   * Returns `true` whether this binding requires an update for the\n   * given generation.\n   *\n   * @param {Number} generation - The generation.\n   * @return {Boolean} Whether an update is required or not.\n   */\n  needsBindingsUpdate(generation) {\n    const {\n      texture\n    } = this;\n    if (generation !== this.generation) {\n      this.generation = generation;\n      return true;\n    }\n    return texture.isVideoTexture;\n  }\n\n  /**\n   * Updates the binding.\n   *\n   * @param {Number} generation - The generation.\n   * @return {Boolean} Whether the texture has been updated and must be\n   * uploaded to the GPU.\n   */\n  update() {\n    const {\n      texture,\n      version\n    } = this;\n    if (version !== texture.version) {\n      this.version = texture.version;\n      return true;\n    }\n    return false;\n  }\n}\n\n/**\n * A special form of sampled texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments SampledTexture\n */\nclass NodeSampledTexture extends SampledTexture {\n  /**\n   * Constructs a new node-based sampled texture.\n   *\n   * @param {String} name - The textures's name.\n   * @param {TextureNode} textureNode - The texture node.\n   * @param {UniformGroupNode} groupNode - The uniform group node.\n   * @param {String?} [access=null] - The access type.\n   */\n  constructor(name, textureNode, groupNode, access = null) {\n    super(name, textureNode ? textureNode.value : null);\n\n    /**\n     * The texture node.\n     *\n     * @type {TextureNode}\n     */\n    this.textureNode = textureNode;\n\n    /**\n     * The uniform group node.\n     *\n     * @type {UniformGroupNode}\n     */\n    this.groupNode = groupNode;\n\n    /**\n     * The access type.\n     *\n     * @type {String?}\n     * @default null\n     */\n    this.access = access;\n  }\n\n  /**\n   * Overwrites the default to additionally check if the node value has changed.\n   *\n   * @param {Number} generation - The generation.\n   * @return {Boolean} Whether an update is required or not.\n   */\n  needsBindingsUpdate(generation) {\n    return this.textureNode.value !== this.texture || super.needsBindingsUpdate(generation);\n  }\n\n  /**\n   * Updates the binding.\n   *\n   * @param {Number} generation - The generation.\n   * @return {Boolean} Whether the texture has been updated and must be\n   * uploaded to the GPU.\n   */\n  update() {\n    const {\n      textureNode\n    } = this;\n    if (this.texture !== textureNode.value) {\n      this.texture = textureNode.value;\n      return true;\n    }\n    return super.update();\n  }\n}\n\n/**\n * A special form of sampled cube texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments NodeSampledTexture\n */\nclass NodeSampledCubeTexture extends NodeSampledTexture {\n  /**\n   * Constructs a new node-based sampled cube texture.\n   *\n   * @param {String} name - The textures's name.\n   * @param {TextureNode} textureNode - The texture node.\n   * @param {UniformGroupNode} groupNode - The uniform group node.\n   * @param {String?} [access=null] - The access type.\n   */\n  constructor(name, textureNode, groupNode, access = null) {\n    super(name, textureNode, groupNode, access);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isSampledCubeTexture = true;\n  }\n}\n\n/**\n * A special form of sampled 3D texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments NodeSampledTexture\n */\nclass NodeSampledTexture3D extends NodeSampledTexture {\n  /**\n   * Constructs a new node-based sampled 3D texture.\n   *\n   * @param {String} name - The textures's name.\n   * @param {TextureNode} textureNode - The texture node.\n   * @param {UniformGroupNode} groupNode - The uniform group node.\n   * @param {String?} [access=null] - The access type.\n   */\n  constructor(name, textureNode, groupNode, access = null) {\n    super(name, textureNode, groupNode, access);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isSampledTexture3D = true;\n  }\n}\nconst glslMethods = {\n  textureDimensions: 'textureSize',\n  equals: 'equal'\n};\nconst precisionLib = {\n  low: 'lowp',\n  medium: 'mediump',\n  high: 'highp'\n};\nconst supports$1 = {\n  swizzleAssign: true,\n  storageBuffer: false\n};\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n`;\nclass GLSLNodeBuilder extends NodeBuilder {\n  constructor(object, renderer) {\n    super(object, renderer, new GLSLNodeParser());\n    this.uniformGroups = {};\n    this.transforms = [];\n    this.extensions = {};\n    this.builtins = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.useComparisonMethod = true;\n  }\n  needsToWorkingColorSpace(texture) {\n    return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n  }\n  getMethod(method) {\n    return glslMethods[method] || method;\n  }\n  getOutputStructName() {\n    return '';\n  }\n  buildFunctionCode(shaderNode) {\n    const layout = shaderNode.layout;\n    const flowData = this.flowShaderNode(shaderNode);\n    const parameters = [];\n    for (const input of layout.inputs) {\n      parameters.push(this.getType(input.type) + ' ' + input.name);\n    }\n\n    //\n\n    const code = `${this.getType(layout.type)} ${layout.name}( ${parameters.join(', ')} ) {\n\n\t${flowData.vars}\n\n${flowData.code}\n\treturn ${flowData.result};\n\n}`;\n\n    //\n\n    return code;\n  }\n  setupPBO(storageBufferNode) {\n    const attribute = storageBufferNode.value;\n    if (attribute.pbo === undefined) {\n      const originalArray = attribute.array;\n      const numElements = attribute.count * attribute.itemSize;\n      const {\n        itemSize\n      } = attribute;\n      const isInteger = attribute.array.constructor.name.toLowerCase().includes('int');\n      let format = isInteger ? RedIntegerFormat : RedFormat;\n      if (itemSize === 2) {\n        format = isInteger ? RGIntegerFormat : RGFormat;\n      } else if (itemSize === 3) {\n        format = isInteger ? RGBIntegerFormat : RGBFormat;\n      } else if (itemSize === 4) {\n        format = isInteger ? RGBAIntegerFormat : RGBAFormat;\n      }\n      const typeMap = {\n        Float32Array: FloatType,\n        Uint8Array: UnsignedByteType,\n        Uint16Array: UnsignedShortType,\n        Uint32Array: UnsignedIntType,\n        Int8Array: ByteType,\n        Int16Array: ShortType,\n        Int32Array: IntType,\n        Uint8ClampedArray: UnsignedByteType\n      };\n      const width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements / itemSize))));\n      let height = Math.ceil(numElements / itemSize / width);\n      if (width * height * itemSize < numElements) height++; // Ensure enough space\n\n      const newSize = width * height * itemSize;\n      const newArray = new originalArray.constructor(newSize);\n      newArray.set(originalArray, 0);\n      attribute.array = newArray;\n      const pboTexture = new DataTexture(attribute.array, width, height, format, typeMap[attribute.array.constructor.name] || FloatType);\n      pboTexture.needsUpdate = true;\n      pboTexture.isPBOTexture = true;\n      const pbo = new TextureNode(pboTexture, null, null);\n      pbo.setPrecision('high');\n      attribute.pboNode = pbo;\n      attribute.pbo = pbo.value;\n      this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.label);\n    }\n  }\n  getPropertyName(node, shaderStage = this.shaderStage) {\n    if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {\n      return shaderStage.charAt(0) + '_' + node.name;\n    }\n    return super.getPropertyName(node, shaderStage);\n  }\n  generatePBO(storageArrayElementNode) {\n    const {\n      node,\n      indexNode\n    } = storageArrayElementNode;\n    const attribute = node.value;\n    if (this.renderer.backend.has(attribute)) {\n      const attributeData = this.renderer.backend.get(attribute);\n      attributeData.pbo = attribute.pbo;\n    }\n    const nodeUniform = this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.label);\n    const textureName = this.getPropertyName(nodeUniform);\n    this.increaseUsage(indexNode); // force cache generate to be used as index in x,y\n    const indexSnippet = indexNode.build(this, 'uint');\n    const elementNodeData = this.getDataFromNode(storageArrayElementNode);\n    let propertyName = elementNodeData.propertyName;\n    if (propertyName === undefined) {\n      // property element\n\n      const nodeVar = this.getVarFromNode(storageArrayElementNode);\n      propertyName = this.getPropertyName(nodeVar);\n\n      // property size\n\n      const bufferNodeData = this.getDataFromNode(node);\n      let propertySizeName = bufferNodeData.propertySizeName;\n      if (propertySizeName === undefined) {\n        propertySizeName = propertyName + 'Size';\n        this.getVarFromNode(node, propertySizeName, 'uint');\n        this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`, storageArrayElementNode);\n        bufferNodeData.propertySizeName = propertySizeName;\n      }\n\n      //\n\n      const {\n        itemSize\n      } = attribute;\n      const channel = '.' + vectorComponents.join('').slice(0, itemSize);\n      const uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;\n      const snippet = this.generateTextureLoad(null, textureName, uvSnippet, null, '0');\n\n      //\n\n      let prefix = 'vec4';\n      if (attribute.pbo.type === UnsignedIntType) {\n        prefix = 'uvec4';\n      } else if (attribute.pbo.type === IntType) {\n        prefix = 'ivec4';\n      }\n      this.addLineFlowCode(`${propertyName} = ${prefix}(${snippet})${channel}`, storageArrayElementNode);\n      elementNodeData.propertyName = propertyName;\n    }\n    return propertyName;\n  }\n  generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0') {\n    if (depthSnippet) {\n      return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;\n    } else {\n      return `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;\n    }\n  }\n  generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {\n    if (texture.isDepthTexture) {\n      return `texture( ${textureProperty}, ${uvSnippet} ).x`;\n    } else {\n      if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;\n      return `texture( ${textureProperty}, ${uvSnippet} )`;\n    }\n  }\n  generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) {\n    return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;\n  }\n  generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet) {\n    return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;\n  }\n  generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) {\n    return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;\n  }\n  generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);\n    }\n  }\n  getVars(shaderStage) {\n    const snippets = [];\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippets.push(`${this.getVar(variable.type, variable.name)};`);\n      }\n    }\n    return snippets.join('\\n\\t');\n  }\n  getUniforms(shaderStage) {\n    const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const uniformGroups = {};\n    for (const uniform of uniforms) {\n      let snippet = null;\n      let group = false;\n      if (uniform.type === 'texture') {\n        const texture = uniform.node.value;\n        let typePrefix = '';\n        if (texture.isDataTexture === true) {\n          if (texture.type === UnsignedIntType) {\n            typePrefix = 'u';\n          } else if (texture.type === IntType) {\n            typePrefix = 'i';\n          }\n        }\n        if (texture.compareFunction) {\n          snippet = `sampler2DShadow ${uniform.name};`;\n        } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {\n          snippet = `${typePrefix}sampler2DArray ${uniform.name};`;\n        } else {\n          snippet = `${typePrefix}sampler2D ${uniform.name};`;\n        }\n      } else if (uniform.type === 'cubeTexture') {\n        snippet = `samplerCube ${uniform.name};`;\n      } else if (uniform.type === 'texture3D') {\n        snippet = `sampler3D ${uniform.name};`;\n      } else if (uniform.type === 'buffer') {\n        const bufferNode = uniform.node;\n        const bufferType = this.getType(bufferNode.bufferType);\n        const bufferCount = bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n        snippet = `${bufferNode.name} {\\n\\t${bufferType} ${uniform.name}[${bufferCountSnippet}];\\n};\\n`;\n      } else {\n        const vectorType = this.getVectorType(uniform.type);\n        snippet = `${vectorType} ${this.getPropertyName(uniform, shaderStage)};`;\n        group = true;\n      }\n      const precision = uniform.node.precision;\n      if (precision !== null) {\n        snippet = precisionLib[precision] + ' ' + snippet;\n      }\n      if (group) {\n        snippet = '\\t' + snippet;\n        const groupName = uniform.groupNode.name;\n        const groupSnippets = uniformGroups[groupName] || (uniformGroups[groupName] = []);\n        groupSnippets.push(snippet);\n      } else {\n        snippet = 'uniform ' + snippet;\n        bindingSnippets.push(snippet);\n      }\n    }\n    let output = '';\n    for (const name in uniformGroups) {\n      const groupSnippets = uniformGroups[name];\n      output += this._getGLSLUniformStruct(shaderStage + '_' + name, groupSnippets.join('\\n')) + '\\n';\n    }\n    output += bindingSnippets.join('\\n');\n    return output;\n  }\n  getTypeFromAttribute(attribute) {\n    let nodeType = super.getTypeFromAttribute(attribute);\n    if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {\n      let dataAttribute = attribute;\n      if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n      const array = dataAttribute.array;\n      if ((array instanceof Uint32Array || array instanceof Int32Array) === false) {\n        nodeType = nodeType.slice(1);\n      }\n    }\n    return nodeType;\n  }\n  getAttributes(shaderStage) {\n    let snippet = '';\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      const attributes = this.getAttributesArray();\n      let location = 0;\n      for (const attribute of attributes) {\n        snippet += `layout( location = ${location++} ) in ${attribute.type} ${attribute.name};\\n`;\n      }\n    }\n    return snippet;\n  }\n  getStructMembers(struct) {\n    const snippets = [];\n    const members = struct.getMemberTypes();\n    for (let i = 0; i < members.length; i++) {\n      const member = members[i];\n      snippets.push(`layout( location = ${i} ) out ${member} m${i};`);\n    }\n    return snippets.join('\\n');\n  }\n  getStructs(shaderStage) {\n    const snippets = [];\n    const structs = this.structs[shaderStage];\n    if (structs.length === 0) {\n      return 'layout( location = 0 ) out vec4 fragColor;\\n';\n    }\n    for (let index = 0, length = structs.length; index < length; index++) {\n      const struct = structs[index];\n      let snippet = '\\n';\n      snippet += this.getStructMembers(struct);\n      snippet += '\\n';\n      snippets.push(snippet);\n    }\n    return snippets.join('\\n\\n');\n  }\n  getVaryings(shaderStage) {\n    let snippet = '';\n    const varyings = this.varyings;\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      for (const varying of varyings) {\n        if (shaderStage === 'compute') varying.needsInterpolation = true;\n        const type = this.getType(varying.type);\n        const flat = type.includes('int') || type.includes('uv') || type.includes('iv') ? 'flat ' : '';\n        snippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\\n`;\n      }\n    } else if (shaderStage === 'fragment') {\n      for (const varying of varyings) {\n        if (varying.needsInterpolation) {\n          const type = this.getType(varying.type);\n          const flat = type.includes('int') || type.includes('uv') || type.includes('iv') ? 'flat ' : '';\n          snippet += `${flat}in ${type} ${varying.name};\\n`;\n        }\n      }\n    }\n    for (const builtin of this.builtins[shaderStage]) {\n      snippet += `${builtin};\\n`;\n    }\n    return snippet;\n  }\n  getVertexIndex() {\n    return 'uint( gl_VertexID )';\n  }\n  getInstanceIndex() {\n    return 'uint( gl_InstanceID )';\n  }\n  getInvocationLocalIndex() {\n    const workgroupSize = this.object.workgroupSize;\n    const size = workgroupSize.reduce((acc, curr) => acc * curr, 1);\n    return `uint( gl_InstanceID ) % ${size}u`;\n  }\n  getDrawIndex() {\n    const extensions = this.renderer.backend.extensions;\n    if (extensions.has('WEBGL_multi_draw')) {\n      return 'uint( gl_DrawID )';\n    }\n    return null;\n  }\n  getFrontFacing() {\n    return 'gl_FrontFacing';\n  }\n  getFragCoord() {\n    return 'gl_FragCoord.xy';\n  }\n  getFragDepth() {\n    return 'gl_FragDepth';\n  }\n  enableExtension(name, behavior, shaderStage = this.shaderStage) {\n    const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = new Map());\n    if (map.has(name) === false) {\n      map.set(name, {\n        name,\n        behavior\n      });\n    }\n  }\n  getExtensions(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'vertex') {\n      const ext = this.renderer.backend.extensions;\n      const isBatchedMesh = this.object.isBatchedMesh;\n      if (isBatchedMesh && ext.has('WEBGL_multi_draw')) {\n        this.enableExtension('GL_ANGLE_multi_draw', 'require', shaderStage);\n      }\n    }\n    const extensions = this.extensions[shaderStage];\n    if (extensions !== undefined) {\n      for (const {\n        name,\n        behavior\n      } of extensions.values()) {\n        snippets.push(`#extension ${name} : ${behavior}`);\n      }\n    }\n    return snippets.join('\\n');\n  }\n  getClipDistance() {\n    return 'gl_ClipDistance';\n  }\n  isAvailable(name) {\n    let result = supports$1[name];\n    if (result === undefined) {\n      let extensionName;\n      result = false;\n      switch (name) {\n        case 'float32Filterable':\n          extensionName = 'OES_texture_float_linear';\n          break;\n        case 'clipDistance':\n          extensionName = 'WEBGL_clip_cull_distance';\n          break;\n      }\n      if (extensionName !== undefined) {\n        const extensions = this.renderer.backend.extensions;\n        if (extensions.has(extensionName)) {\n          extensions.get(extensionName);\n          result = true;\n        }\n      }\n      supports$1[name] = result;\n    }\n    return result;\n  }\n  isFlipY() {\n    return true;\n  }\n  enableHardwareClipping(planeCount) {\n    this.enableExtension('GL_ANGLE_clip_cull_distance', 'require');\n    this.builtins['vertex'].push(`out float gl_ClipDistance[ ${planeCount} ]`);\n  }\n  registerTransform(varyingName, attributeNode) {\n    this.transforms.push({\n      varyingName,\n      attributeNode\n    });\n  }\n  getTransforms(/* shaderStage  */\n  ) {\n    const transforms = this.transforms;\n    let snippet = '';\n    for (let i = 0; i < transforms.length; i++) {\n      const transform = transforms[i];\n      const attributeName = this.getPropertyName(transform.attributeNode);\n      snippet += `${transform.varyingName} = ${attributeName};\\n\\t`;\n    }\n    return snippet;\n  }\n  _getGLSLUniformStruct(name, vars) {\n    return `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n  }\n  _getGLSLVertexCode(shaderData) {\n    return `#version 300 es\n\n${this.getSignature()}\n\n// extensions \n${shaderData.extensions}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n  }\n  _getGLSLFragmentCode(shaderData) {\n    return `#version 300 es\n\n${this.getSignature()}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  buildCode() {\n    const shadersData = this.material !== null ? {\n      fragment: {},\n      vertex: {}\n    } : {\n      compute: {}\n    };\n    this.sortBindingGroups();\n    for (const shaderStage in shadersData) {\n      let flow = '// code\\n\\n';\n      flow += this.flowCode[shaderStage];\n      const flowNodes = this.flowNodes[shaderStage];\n      const mainNode = flowNodes[flowNodes.length - 1];\n      for (const node of flowNodes) {\n        const flowSlotData = this.getFlowData(node /*, shaderStage*/);\n        const slotName = node.name;\n        if (slotName) {\n          if (flow.length > 0) flow += '\\n';\n          flow += `\\t// flow -> ${slotName}\\n\\t`;\n        }\n        flow += `${flowSlotData.code}\\n\\t`;\n        if (node === mainNode && shaderStage !== 'compute') {\n          flow += '// result\\n\\t';\n          if (shaderStage === 'vertex') {\n            flow += 'gl_Position = ';\n            flow += `${flowSlotData.result};`;\n          } else if (shaderStage === 'fragment') {\n            if (!node.outputNode.isOutputStructNode) {\n              flow += 'fragColor = ';\n              flow += `${flowSlotData.result};`;\n            }\n          }\n        }\n      }\n      const stageData = shadersData[shaderStage];\n      stageData.extensions = this.getExtensions(shaderStage);\n      stageData.uniforms = this.getUniforms(shaderStage);\n      stageData.attributes = this.getAttributes(shaderStage);\n      stageData.varyings = this.getVaryings(shaderStage);\n      stageData.vars = this.getVars(shaderStage);\n      stageData.structs = this.getStructs(shaderStage);\n      stageData.codes = this.getCodes(shaderStage);\n      stageData.transforms = this.getTransforms(shaderStage);\n      stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);\n      this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);\n    } else {\n      this.computeShader = this._getGLSLVertexCode(shadersData.compute);\n    }\n  }\n  getUniformFromNode(node, type, shaderStage, name = null) {\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    let uniformGPU = nodeData.uniformGPU;\n    if (uniformGPU === undefined) {\n      const group = node.groupNode;\n      const groupName = group.name;\n      const bindings = this.getBindGroupArray(groupName, shaderStage);\n      if (type === 'texture') {\n        uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else if (type === 'cubeTexture') {\n        uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else if (type === 'texture3D') {\n        uniformGPU = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else if (type === 'buffer') {\n        node.name = `NodeBuffer_${node.id}`;\n        uniformNode.name = `buffer${node.id}`;\n        const buffer = new NodeUniformBuffer(node, group);\n        buffer.name = node.name;\n        bindings.push(buffer);\n        uniformGPU = buffer;\n      } else {\n        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});\n        let uniformsGroup = uniformsStage[groupName];\n        if (uniformsGroup === undefined) {\n          uniformsGroup = new NodeUniformsGroup(shaderStage + '_' + groupName, group);\n          //uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n          uniformsStage[groupName] = uniformsGroup;\n          bindings.push(uniformsGroup);\n        }\n        uniformGPU = this.getNodeUniform(uniformNode, type);\n        uniformsGroup.addUniform(uniformGPU);\n      }\n      nodeData.uniformGPU = uniformGPU;\n    }\n    return uniformNode;\n  }\n}\nlet _vector2 = null;\nlet _color4 = null;\n\n/**\n * Most of the rendering related logic is implemented in the\n * {@link module:Renderer} module and related management components.\n * Sometimes it is required though to execute commands which are\n * specific to the current 3D backend (which is WebGPU or WebGL 2).\n * This abstract base class defines an interface that encapsulates\n * all backend-related logic. Derived classes for each backend must\n * implement the interface.\n *\n * @abstract\n * @private\n */\nclass Backend {\n  /**\n   * Constructs a new backend.\n   *\n   * @param {Object} parameters - An object holding parameters for the backend.\n   */\n  constructor(parameters = {}) {\n    /**\n     * The parameters of the backend.\n     *\n     * @type {Object}\n     */\n    this.parameters = Object.assign({}, parameters);\n\n    /**\n     * This weak map holds backend-specific data of objects\n     * like textures, attributes or render targets.\n     *\n     * @type {WeakMap}\n     */\n    this.data = new WeakMap();\n\n    /**\n     * A reference to the renderer.\n     *\n     * @type {Renderer?}\n     * @default null\n     */\n    this.renderer = null;\n\n    /**\n     * A reference to the canvas element the renderer is drawing to.\n     *\n     * @type {(HTMLCanvasElement|OffscreenCanvas)?}\n     * @default null\n     */\n    this.domElement = null;\n  }\n\n  /**\n   * Initializes the backend so it is ready for usage. Concrete backends\n   * are supposed to implement their rendering context creation and related\n   * operations in this method.\n   *\n   * @async\n   * @param {Renderer} renderer - The renderer.\n   * @return {Promise} A Promise that resolves when the backend has been initialized.\n   */\n  async init(renderer) {\n    this.renderer = renderer;\n  }\n\n  /**\n   * The coordinate system of the backend.\n   *\n   * @abstract\n   * @type {Number}\n   * @readonly\n   */\n  get coordinateSystem() {}\n\n  // render context\n\n  /**\n   * This method is executed at the beginning of a render call and\n   * can be used by the backend to prepare the state for upcoming\n   * draw calls.\n   *\n   * @abstract\n   * @param {RenderContext} renderContext - The render context.\n   */\n  beginRender(/*renderContext*/) {}\n\n  /**\n   * This method is executed at the end of a render call and\n   * can be used by the backend to finalize work after draw\n   * calls.\n   *\n   * @abstract\n   * @param {RenderContext} renderContext - The render context.\n   */\n  finishRender(/*renderContext*/) {}\n\n  /**\n   * This method is executed at the beginning of a compute call and\n   * can be used by the backend to prepare the state for upcoming\n   * compute tasks.\n   *\n   * @abstract\n   * @param {Node|Array<Node>} computeGroup - The compute node(s).\n   */\n  beginCompute(/*computeGroup*/) {}\n\n  /**\n   * This method is executed at the end of a compute call and\n   * can be used by the backend to finalize work after compute\n   * tasks.\n   *\n   * @abstract\n   * @param {Node|Array<Node>} computeGroup - The compute node(s).\n   */\n  finishCompute(/*computeGroup*/) {}\n\n  // render object\n\n  /**\n   * Executes a draw command for the given render object.\n   *\n   * @abstract\n   * @param {RenderObject} renderObject - The render object to draw.\n   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n   */\n  draw(/*renderObject, info*/) {}\n\n  // compute node\n\n  /**\n   * Executes a compute command for the given compute node.\n   *\n   * @abstract\n   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n   * @param {Node} computeNode - The compute node.\n   * @param {Array<BindGroup>} bindings - The bindings.\n   * @param {ComputePipeline} computePipeline - The compute pipeline.\n   */\n  compute(/*computeGroup, computeNode, computeBindings, computePipeline*/) {}\n\n  // program\n\n  /**\n   * Creates a shader program from the given programmable stage.\n   *\n   * @abstract\n   * @param {ProgrammableStage} program - The programmable stage.\n   */\n  createProgram(/*program*/) {}\n\n  /**\n   * Destroys the shader program of the given programmable stage.\n   *\n   * @abstract\n   * @param {ProgrammableStage} program - The programmable stage.\n   */\n  destroyProgram(/*program*/) {}\n\n  // bindings\n\n  /**\n   * Creates bindings from the given bind group definition.\n   *\n   * @abstract\n   * @param {BindGroup} bindGroup - The bind group.\n   * @param {Array<BindGroup>} bindings - Array of bind groups.\n   * @param {Number} cacheIndex - The cache index.\n   * @param {Number} version - The version.\n   */\n  createBindings(/*bindGroup, bindings, cacheIndex, version*/) {}\n\n  /**\n   * Updates the given bind group definition.\n   *\n   * @abstract\n   * @param {BindGroup} bindGroup - The bind group.\n   * @param {Array<BindGroup>} bindings - Array of bind groups.\n   * @param {Number} cacheIndex - The cache index.\n   * @param {Number} version - The version.\n   */\n  updateBindings(/*bindGroup, bindings, cacheIndex, version*/) {}\n\n  /**\n   * Updates a buffer binding.\n   *\n   * @abstract\n   * @param {Buffer} binding - The buffer binding to update.\n   */\n  updateBinding(/*binding*/) {}\n\n  // pipeline\n\n  /**\n   * Creates a render pipeline for the given render object.\n   *\n   * @abstract\n   * @param {RenderObject} renderObject - The render object.\n   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n   */\n  createRenderPipeline(/*renderObject, promises*/) {}\n\n  /**\n   * Creates a compute pipeline for the given compute node.\n   *\n   * @abstract\n   * @param {ComputePipeline} computePipeline - The compute pipeline.\n   * @param {Array<BindGroup>} bindings - The bindings.\n   */\n  createComputePipeline(/*computePipeline, bindings*/) {}\n\n  // cache key\n\n  /**\n   * Returns `true` if the render pipeline requires an update.\n   *\n   * @abstract\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Boolean} Whether the render pipeline requires an update or not.\n   */\n  needsRenderUpdate(/*renderObject*/) {}\n\n  /**\n   * Returns a cache key that is used to identify render pipelines.\n   *\n   * @abstract\n   * @param {RenderObject} renderObject - The render object.\n   * @return {String} The cache key.\n   */\n  getRenderCacheKey(/*renderObject*/) {}\n\n  // node builder\n\n  /**\n   * Returns a node builder for the given render object.\n   *\n   * @abstract\n   * @param {RenderObject} renderObject - The render object.\n   * @param {Renderer} renderer - The renderer.\n   * @return {NodeBuilder} The node builder.\n   */\n  createNodeBuilder(/*renderObject, renderer*/) {}\n\n  // textures\n\n  /**\n   * Creates a sampler for the given texture.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture to create the sampler for.\n   */\n  createSampler(/*texture*/) {}\n\n  /**\n   * Destroys the sampler for the given texture.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture to destroy the sampler for.\n   */\n  destroySampler(/*texture*/) {}\n\n  /**\n   * Creates a default texture for the given texture that can be used\n   * as a placeholder until the actual texture is ready for usage.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture to create a default texture for.\n   */\n  createDefaultTexture(/*texture*/) {}\n\n  /**\n   * Defines a texture on the GPU for the given texture object.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture.\n   * @param {Object} [options={}] - Optional configuration parameter.\n   */\n  createTexture(/*texture, options={}*/) {}\n\n  /**\n   * Uploads the updated texture data to the GPU.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture.\n   * @param {Object} [options={}] - Optional configuration parameter.\n   */\n  updateTexture(/*texture, options = {}*/) {}\n\n  /**\n   * Generates mipmaps for the given texture\n   *\n   * @abstract\n   * @param {Texture} texture - The texture.\n   */\n  generateMipmaps(/*texture*/) {}\n\n  /**\n   * Destroys the GPU data for the given texture object.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture.\n   */\n  destroyTexture(/*texture*/) {}\n\n  /**\n   * Returns texture data as a typed array.\n   *\n   * @abstract\n   * @param {Texture} texture - The texture to copy.\n   * @param {Number} x - The x coordinate of the copy origin.\n   * @param {Number} y - The y coordinate of the copy origin.\n   * @param {Number} width - The width of the copy.\n   * @param {Number} height - The height of the copy.\n   * @param {Number} faceIndex - The face index.\n   * @return {TypedArray} The texture data as a typed array.\n   */\n  copyTextureToBuffer(/*texture, x, y, width, height, faceIndex*/) {}\n\n  /**\n   * Copies data of the given source texture to the given destination texture.\n   *\n   * @abstract\n   * @param {Texture} srcTexture - The source texture.\n   * @param {Texture} dstTexture - The destination texture.\n   * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n   * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n   * @param {Number} [level=0] - The mip level to copy.\n   */\n  copyTextureToTexture(/*srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0*/) {}\n\n  /**\n  * Copies the current bound framebuffer to the given texture.\n  *\n  * @abstract\n  * @param {Texture} texture - The destination texture.\n  * @param {RenderContext} renderContext - The render context.\n  * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n  */\n  copyFramebufferToTexture(/*texture, renderContext, rectangle*/) {}\n\n  // attributes\n\n  /**\n   * Creates the buffer of a shader attribute.\n   *\n   * @abstract\n   * @param {BufferAttribute} attribute - The buffer attribute.\n   */\n  createAttribute(/*attribute*/) {}\n\n  /**\n   * Creates the buffer of an indexed shader attribute.\n   *\n   * @abstract\n   * @param {BufferAttribute} attribute - The indexed buffer attribute.\n   */\n  createIndexAttribute(/*attribute*/) {}\n\n  /**\n   * Creates the buffer of a storage attribute.\n   *\n   * @abstract\n   * @param {BufferAttribute} attribute - The buffer attribute.\n   */\n  createStorageAttribute(/*attribute*/) {}\n\n  /**\n   * Updates the buffer of a shader attribute.\n   *\n   * @abstract\n   * @param {BufferAttribute} attribute - The buffer attribute to update.\n   */\n  updateAttribute(/*attribute*/) {}\n\n  /**\n   * Destroys the buffer of a shader attribute.\n   *\n   * @abstract\n   * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n   */\n  destroyAttribute(/*attribute*/) {}\n\n  // canvas\n\n  /**\n   * Returns the backend's rendering context.\n   *\n   * @abstract\n   * @return {Object} The rendering context.\n   */\n  getContext() {}\n\n  /**\n   * Backends can use this method if they have to run\n   * logic when the renderer gets resized.\n   *\n   * @abstract\n   */\n  updateSize() {}\n\n  /**\n   * Updates the viewport with the values from the given render context.\n   *\n   * @abstract\n   * @param {RenderContext} renderContext - The render context.\n   */\n  updateViewport(/*renderContext*/) {}\n\n  // utils\n\n  /**\n   * Returns `true` if the given 3D object is fully occluded by other\n   * 3D objects in the scene. Backends must implement this method by using\n   * a Occlusion Query API.\n   *\n   * @abstract\n   * @param {RenderContext} renderContext - The render context.\n   * @param {Object3D} object - The 3D object to test.\n   * @return {Boolean} Whether the 3D object is fully occluded or not.\n   */\n  isOccluded(/*renderContext, object*/) {}\n\n  /**\n   * Resolves the time stamp for the given render context and type.\n   *\n   * @async\n   * @abstract\n   * @param {RenderContext} renderContext - The render context.\n   * @param {String} type - The render context.\n   * @return {Promise} A Promise that resolves when the time stamp has been computed.\n   */\n  async resolveTimestampAsync(/*renderContext, type*/) {}\n\n  /**\n   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n   * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n   *\n   * @async\n   * @abstract\n   * @return {Promise} A Promise that resolves when synchronization has been finished.\n   */\n  async waitForGPU() {}\n\n  /**\n   * Checks if the given feature is supported by the backend.\n   *\n   * @async\n   * @abstract\n   * @param {String} name - The feature's name.\n   * @return {Promise<Boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n   */\n  async hasFeatureAsync(/*name*/) {}\n\n  /**\n   * Checks if the given feature is supported  by the backend.\n   *\n   * @abstract\n   * @param {String} name - The feature's name.\n   * @return {Boolean} Whether the feature is supported or not.\n   */\n  hasFeature(/*name*/) {}\n\n  /**\n   * Returns the maximum anisotropy texture filtering value.\n   *\n   * @abstract\n   * @return {Number} The maximum anisotropy texture filtering value.\n   */\n  getMaxAnisotropy() {}\n\n  /**\n   * Returns the drawing buffer size.\n   *\n   * @return {Vector2} The drawing buffer size.\n   */\n  getDrawingBufferSize() {\n    _vector2 = _vector2 || new Vector2();\n    return this.renderer.getDrawingBufferSize(_vector2);\n  }\n\n  /**\n   * Defines the scissor test.\n   *\n   * @abstract\n   * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n   */\n  setScissorTest(/*boolean*/) {}\n\n  /**\n   * Returns the clear color and alpha into a single\n   * color object.\n   *\n   * @return {Color4} The clear color.\n   */\n  getClearColor() {\n    const renderer = this.renderer;\n    _color4 = _color4 || new Color4();\n    renderer.getClearColor(_color4);\n    _color4.getRGB(_color4, this.renderer.currentColorSpace);\n    return _color4;\n  }\n\n  /**\n   * Returns the DOM element. If no DOM element exists, the backend\n   * creates a new one.\n   *\n   * @return {HTMLCanvasElement} The DOM element.\n   */\n  getDomElement() {\n    let domElement = this.domElement;\n    if (domElement === null) {\n      domElement = this.parameters.canvas !== undefined ? this.parameters.canvas : createCanvasElement();\n\n      // OffscreenCanvas does not have setAttribute, see #22811\n      if ('setAttribute' in domElement) domElement.setAttribute('data-engine', `three.js r${REVISION} webgpu`);\n      this.domElement = domElement;\n    }\n    return domElement;\n  }\n\n  /**\n   * Sets a dictionary for the given object into the\n   * internal data structure.\n   *\n   * @param {Object} object - The object.\n   * @param {Object} value - The dictionary to set.\n   */\n  set(object, value) {\n    this.data.set(object, value);\n  }\n\n  /**\n   * Returns the dictionary for the given object.\n   *\n   * @param {Object} object - The object.\n   * @return {Object} The object's dictionary.\n   */\n  get(object) {\n    let map = this.data.get(object);\n    if (map === undefined) {\n      map = {};\n      this.data.set(object, map);\n    }\n    return map;\n  }\n\n  /**\n   * Checks if the given object has a dictionary\n   * with data defined.\n   *\n   * @param {Object} object - The object.\n   * @return {Boolean} Whether a dictionary for the given object as been defined or not.\n   */\n  has(object) {\n    return this.data.has(object);\n  }\n\n  /**\n   * Deletes an object from the internal data structure.\n   *\n   * @param {Object} object - The object to delete.\n   */\n  delete(object) {\n    this.data.delete(object);\n  }\n\n  /**\n   * Frees internal resources.\n   *\n   * @abstract\n   */\n  dispose() {}\n}\nlet _id$1 = 0;\nclass DualAttributeData {\n  constructor(attributeData, dualBuffer) {\n    this.buffers = [attributeData.bufferGPU, dualBuffer];\n    this.type = attributeData.type;\n    this.bufferType = attributeData.bufferType;\n    this.pbo = attributeData.pbo;\n    this.byteLength = attributeData.byteLength;\n    this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;\n    this.version = attributeData.version;\n    this.isInteger = attributeData.isInteger;\n    this.activeBufferIndex = 0;\n    this.baseId = attributeData.id;\n  }\n  get id() {\n    return `${this.baseId}|${this.activeBufferIndex}`;\n  }\n  get bufferGPU() {\n    return this.buffers[this.activeBufferIndex];\n  }\n  get transformBuffer() {\n    return this.buffers[this.activeBufferIndex ^ 1];\n  }\n  switchBuffers() {\n    this.activeBufferIndex ^= 1;\n  }\n}\nclass WebGLAttributeUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createAttribute(attribute, bufferType) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    const array = attribute.array;\n    const usage = attribute.usage || gl.STATIC_DRAW;\n    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n    const bufferData = backend.get(bufferAttribute);\n    let bufferGPU = bufferData.bufferGPU;\n    if (bufferGPU === undefined) {\n      bufferGPU = this._createBuffer(gl, bufferType, array, usage);\n      bufferData.bufferGPU = bufferGPU;\n      bufferData.bufferType = bufferType;\n      bufferData.version = bufferAttribute.version;\n    }\n\n    //attribute.onUploadCallback();\n\n    let type;\n    if (array instanceof Float32Array) {\n      type = gl.FLOAT;\n    } else if (array instanceof Uint16Array) {\n      if (attribute.isFloat16BufferAttribute) {\n        type = gl.HALF_FLOAT;\n      } else {\n        type = gl.UNSIGNED_SHORT;\n      }\n    } else if (array instanceof Int16Array) {\n      type = gl.SHORT;\n    } else if (array instanceof Uint32Array) {\n      type = gl.UNSIGNED_INT;\n    } else if (array instanceof Int32Array) {\n      type = gl.INT;\n    } else if (array instanceof Int8Array) {\n      type = gl.BYTE;\n    } else if (array instanceof Uint8Array) {\n      type = gl.UNSIGNED_BYTE;\n    } else if (array instanceof Uint8ClampedArray) {\n      type = gl.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.WebGLBackend: Unsupported buffer data format: ' + array);\n    }\n    let attributeData = {\n      bufferGPU,\n      bufferType,\n      type,\n      byteLength: array.byteLength,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: attribute.version,\n      pbo: attribute.pbo,\n      isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,\n      id: _id$1++\n    };\n    if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {\n      // create buffer for transform feedback use\n      const bufferGPUDual = this._createBuffer(gl, bufferType, array, usage);\n      attributeData = new DualAttributeData(attributeData, bufferGPUDual);\n    }\n    backend.set(attribute, attributeData);\n  }\n  updateAttribute(attribute) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    const array = attribute.array;\n    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n    const bufferData = backend.get(bufferAttribute);\n    const bufferType = bufferData.bufferType;\n    const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;\n    gl.bindBuffer(bufferType, bufferData.bufferGPU);\n    if (updateRanges.length === 0) {\n      // Not using update ranges\n\n      gl.bufferSubData(bufferType, 0, array);\n    } else {\n      for (let i = 0, l = updateRanges.length; i < l; i++) {\n        const range = updateRanges[i];\n        gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT, array, range.start, range.count);\n      }\n      bufferAttribute.clearUpdateRanges();\n    }\n    gl.bindBuffer(bufferType, null);\n    bufferData.version = bufferAttribute.version;\n  }\n  destroyAttribute(attribute) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    if (attribute.isInterleavedBufferAttribute) {\n      backend.delete(attribute.data);\n    }\n    const attributeData = backend.get(attribute);\n    gl.deleteBuffer(attributeData.bufferGPU);\n    backend.delete(attribute);\n  }\n  async getArrayBufferAsync(attribute) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n    const {\n      bufferGPU\n    } = backend.get(bufferAttribute);\n    const array = attribute.array;\n    const byteLength = array.byteLength;\n    gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);\n    const writeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);\n    gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);\n    gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);\n    await backend.utils._clientWaitAsync();\n    const dstBuffer = new attribute.array.constructor(array.length);\n\n    // Ensure the buffer is bound before reading\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);\n    gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);\n    gl.deleteBuffer(writeBuffer);\n    gl.bindBuffer(gl.COPY_READ_BUFFER, null);\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);\n    return dstBuffer.buffer;\n  }\n  _createBuffer(gl, bufferType, array, usage) {\n    const bufferGPU = gl.createBuffer();\n    gl.bindBuffer(bufferType, bufferGPU);\n    gl.bufferData(bufferType, array, usage);\n    gl.bindBuffer(bufferType, null);\n    return bufferGPU;\n  }\n}\nlet initialized$1 = false,\n  equationToGL,\n  factorToGL;\nclass WebGLState {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = this.backend.gl;\n    this.enabled = {};\n    this.currentFlipSided = null;\n    this.currentCullFace = null;\n    this.currentProgram = null;\n    this.currentBlendingEnabled = false;\n    this.currentBlending = null;\n    this.currentBlendSrc = null;\n    this.currentBlendDst = null;\n    this.currentBlendSrcAlpha = null;\n    this.currentBlendDstAlpha = null;\n    this.currentPremultipledAlpha = null;\n    this.currentPolygonOffsetFactor = null;\n    this.currentPolygonOffsetUnits = null;\n    this.currentColorMask = null;\n    this.currentDepthFunc = null;\n    this.currentDepthMask = null;\n    this.currentStencilFunc = null;\n    this.currentStencilRef = null;\n    this.currentStencilFuncMask = null;\n    this.currentStencilFail = null;\n    this.currentStencilZFail = null;\n    this.currentStencilZPass = null;\n    this.currentStencilMask = null;\n    this.currentLineWidth = null;\n    this.currentClippingPlanes = 0;\n    this.currentBoundFramebuffers = {};\n    this.currentDrawbuffers = new WeakMap();\n    this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.currentTextureSlot = null;\n    this.currentBoundTextures = {};\n    this.currentBoundBufferBases = {};\n    if (initialized$1 === false) {\n      this._init(this.gl);\n      initialized$1 = true;\n    }\n  }\n  _init(gl) {\n    // Store only WebGL constants here.\n\n    equationToGL = {\n      [AddEquation]: gl.FUNC_ADD,\n      [SubtractEquation]: gl.FUNC_SUBTRACT,\n      [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT\n    };\n    factorToGL = {\n      [ZeroFactor]: gl.ZERO,\n      [OneFactor]: gl.ONE,\n      [SrcColorFactor]: gl.SRC_COLOR,\n      [SrcAlphaFactor]: gl.SRC_ALPHA,\n      [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,\n      [DstColorFactor]: gl.DST_COLOR,\n      [DstAlphaFactor]: gl.DST_ALPHA,\n      [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,\n      [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,\n      [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,\n      [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA\n    };\n  }\n  enable(id) {\n    const {\n      enabled\n    } = this;\n    if (enabled[id] !== true) {\n      this.gl.enable(id);\n      enabled[id] = true;\n    }\n  }\n  disable(id) {\n    const {\n      enabled\n    } = this;\n    if (enabled[id] !== false) {\n      this.gl.disable(id);\n      enabled[id] = false;\n    }\n  }\n  setFlipSided(flipSided) {\n    if (this.currentFlipSided !== flipSided) {\n      const {\n        gl\n      } = this;\n      if (flipSided) {\n        gl.frontFace(gl.CW);\n      } else {\n        gl.frontFace(gl.CCW);\n      }\n      this.currentFlipSided = flipSided;\n    }\n  }\n  setCullFace(cullFace) {\n    const {\n      gl\n    } = this;\n    if (cullFace !== CullFaceNone) {\n      this.enable(gl.CULL_FACE);\n      if (cullFace !== this.currentCullFace) {\n        if (cullFace === CullFaceBack) {\n          gl.cullFace(gl.BACK);\n        } else if (cullFace === CullFaceFront) {\n          gl.cullFace(gl.FRONT);\n        } else {\n          gl.cullFace(gl.FRONT_AND_BACK);\n        }\n      }\n    } else {\n      this.disable(gl.CULL_FACE);\n    }\n    this.currentCullFace = cullFace;\n  }\n  setLineWidth(width) {\n    const {\n      currentLineWidth,\n      gl\n    } = this;\n    if (width !== currentLineWidth) {\n      gl.lineWidth(width);\n      this.currentLineWidth = width;\n    }\n  }\n  setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\n    const {\n      gl\n    } = this;\n    if (blending === NoBlending) {\n      if (this.currentBlendingEnabled === true) {\n        this.disable(gl.BLEND);\n        this.currentBlendingEnabled = false;\n      }\n      return;\n    }\n    if (this.currentBlendingEnabled === false) {\n      this.enable(gl.BLEND);\n      this.currentBlendingEnabled = true;\n    }\n    if (blending !== CustomBlending) {\n      if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {\n        if (this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation) {\n          gl.blendEquation(gl.FUNC_ADD);\n          this.currentBlendEquation = AddEquation;\n          this.currentBlendEquationAlpha = AddEquation;\n        }\n        if (premultipliedAlpha) {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(gl.ONE, gl.ONE);\n              break;\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            case MultiplyBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n              break;\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        } else {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n              break;\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            case MultiplyBlending:\n              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n              break;\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        }\n        this.currentBlendSrc = null;\n        this.currentBlendDst = null;\n        this.currentBlendSrcAlpha = null;\n        this.currentBlendDstAlpha = null;\n        this.currentBlending = blending;\n        this.currentPremultipledAlpha = premultipliedAlpha;\n      }\n      return;\n    }\n\n    // custom blending\n\n    blendEquationAlpha = blendEquationAlpha || blendEquation;\n    blendSrcAlpha = blendSrcAlpha || blendSrc;\n    blendDstAlpha = blendDstAlpha || blendDst;\n    if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {\n      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n      this.currentBlendEquation = blendEquation;\n      this.currentBlendEquationAlpha = blendEquationAlpha;\n    }\n    if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {\n      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n      this.currentBlendSrc = blendSrc;\n      this.currentBlendDst = blendDst;\n      this.currentBlendSrcAlpha = blendSrcAlpha;\n      this.currentBlendDstAlpha = blendDstAlpha;\n    }\n    this.currentBlending = blending;\n    this.currentPremultipledAlpha = false;\n  }\n  setColorMask(colorMask) {\n    if (this.currentColorMask !== colorMask) {\n      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n      this.currentColorMask = colorMask;\n    }\n  }\n  setDepthTest(depthTest) {\n    const {\n      gl\n    } = this;\n    if (depthTest) {\n      this.enable(gl.DEPTH_TEST);\n    } else {\n      this.disable(gl.DEPTH_TEST);\n    }\n  }\n  setDepthMask(depthMask) {\n    if (this.currentDepthMask !== depthMask) {\n      this.gl.depthMask(depthMask);\n      this.currentDepthMask = depthMask;\n    }\n  }\n  setDepthFunc(depthFunc) {\n    if (this.currentDepthFunc !== depthFunc) {\n      const {\n        gl\n      } = this;\n      switch (depthFunc) {\n        case NeverDepth:\n          gl.depthFunc(gl.NEVER);\n          break;\n        case AlwaysDepth:\n          gl.depthFunc(gl.ALWAYS);\n          break;\n        case LessDepth:\n          gl.depthFunc(gl.LESS);\n          break;\n        case LessEqualDepth:\n          gl.depthFunc(gl.LEQUAL);\n          break;\n        case EqualDepth:\n          gl.depthFunc(gl.EQUAL);\n          break;\n        case GreaterEqualDepth:\n          gl.depthFunc(gl.GEQUAL);\n          break;\n        case GreaterDepth:\n          gl.depthFunc(gl.GREATER);\n          break;\n        case NotEqualDepth:\n          gl.depthFunc(gl.NOTEQUAL);\n          break;\n        default:\n          gl.depthFunc(gl.LEQUAL);\n      }\n      this.currentDepthFunc = depthFunc;\n    }\n  }\n  setStencilTest(stencilTest) {\n    const {\n      gl\n    } = this;\n    if (stencilTest) {\n      this.enable(gl.STENCIL_TEST);\n    } else {\n      this.disable(gl.STENCIL_TEST);\n    }\n  }\n  setStencilMask(stencilMask) {\n    if (this.currentStencilMask !== stencilMask) {\n      this.gl.stencilMask(stencilMask);\n      this.currentStencilMask = stencilMask;\n    }\n  }\n  setStencilFunc(stencilFunc, stencilRef, stencilMask) {\n    if (this.currentStencilFunc !== stencilFunc || this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== stencilMask) {\n      this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n      this.currentStencilFunc = stencilFunc;\n      this.currentStencilRef = stencilRef;\n      this.currentStencilFuncMask = stencilMask;\n    }\n  }\n  setStencilOp(stencilFail, stencilZFail, stencilZPass) {\n    if (this.currentStencilFail !== stencilFail || this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== stencilZPass) {\n      this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n      this.currentStencilFail = stencilFail;\n      this.currentStencilZFail = stencilZFail;\n      this.currentStencilZPass = stencilZPass;\n    }\n  }\n  setMaterial(material, frontFaceCW, hardwareClippingPlanes) {\n    const {\n      gl\n    } = this;\n    material.side === DoubleSide ? this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);\n    let flipSided = material.side === BackSide;\n    if (frontFaceCW) flipSided = !flipSided;\n    this.setFlipSided(flipSided);\n    material.blending === NormalBlending && material.transparent === false ? this.setBlending(NoBlending) : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\n    this.setDepthFunc(material.depthFunc);\n    this.setDepthTest(material.depthTest);\n    this.setDepthMask(material.depthWrite);\n    this.setColorMask(material.colorWrite);\n    const stencilWrite = material.stencilWrite;\n    this.setStencilTest(stencilWrite);\n    if (stencilWrite) {\n      this.setStencilMask(material.stencilWriteMask);\n      this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n      this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n    }\n    this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n    material.alphaToCoverage === true && this.backend.renderer.samples > 1 ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n    if (hardwareClippingPlanes > 0) {\n      if (this.currentClippingPlanes !== hardwareClippingPlanes) {\n        const CLIP_DISTANCE0_WEBGL = 0x3000;\n        for (let i = 0; i < 8; i++) {\n          if (i < hardwareClippingPlanes) {\n            this.enable(CLIP_DISTANCE0_WEBGL + i);\n          } else {\n            this.disable(CLIP_DISTANCE0_WEBGL + i);\n          }\n        }\n      }\n    }\n  }\n  setPolygonOffset(polygonOffset, factor, units) {\n    const {\n      gl\n    } = this;\n    if (polygonOffset) {\n      this.enable(gl.POLYGON_OFFSET_FILL);\n      if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {\n        gl.polygonOffset(factor, units);\n        this.currentPolygonOffsetFactor = factor;\n        this.currentPolygonOffsetUnits = units;\n      }\n    } else {\n      this.disable(gl.POLYGON_OFFSET_FILL);\n    }\n  }\n  useProgram(program) {\n    if (this.currentProgram !== program) {\n      this.gl.useProgram(program);\n      this.currentProgram = program;\n      return true;\n    }\n    return false;\n  }\n\n  // framebuffer\n\n  bindFramebuffer(target, framebuffer) {\n    const {\n      gl,\n      currentBoundFramebuffers\n    } = this;\n    if (currentBoundFramebuffers[target] !== framebuffer) {\n      gl.bindFramebuffer(target, framebuffer);\n      currentBoundFramebuffers[target] = framebuffer;\n\n      // gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n      if (target === gl.DRAW_FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;\n      }\n      if (target === gl.FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;\n      }\n      return true;\n    }\n    return false;\n  }\n  drawBuffers(renderContext, framebuffer) {\n    const {\n      gl\n    } = this;\n    let drawBuffers = [];\n    let needsUpdate = false;\n    if (renderContext.textures !== null) {\n      drawBuffers = this.currentDrawbuffers.get(framebuffer);\n      if (drawBuffers === undefined) {\n        drawBuffers = [];\n        this.currentDrawbuffers.set(framebuffer, drawBuffers);\n      }\n      const textures = renderContext.textures;\n      if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {\n        for (let i = 0, il = textures.length; i < il; i++) {\n          drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;\n        }\n        drawBuffers.length = textures.length;\n        needsUpdate = true;\n      }\n    } else {\n      if (drawBuffers[0] !== gl.BACK) {\n        drawBuffers[0] = gl.BACK;\n        needsUpdate = true;\n      }\n    }\n    if (needsUpdate) {\n      gl.drawBuffers(drawBuffers);\n    }\n  }\n\n  // texture\n\n  activeTexture(webglSlot) {\n    const {\n      gl,\n      currentTextureSlot,\n      maxTextures\n    } = this;\n    if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n    if (currentTextureSlot !== webglSlot) {\n      gl.activeTexture(webglSlot);\n      this.currentTextureSlot = webglSlot;\n    }\n  }\n  bindTexture(webglType, webglTexture, webglSlot) {\n    const {\n      gl,\n      currentTextureSlot,\n      currentBoundTextures,\n      maxTextures\n    } = this;\n    if (webglSlot === undefined) {\n      if (currentTextureSlot === null) {\n        webglSlot = gl.TEXTURE0 + maxTextures - 1;\n      } else {\n        webglSlot = currentTextureSlot;\n      }\n    }\n    let boundTexture = currentBoundTextures[webglSlot];\n    if (boundTexture === undefined) {\n      boundTexture = {\n        type: undefined,\n        texture: undefined\n      };\n      currentBoundTextures[webglSlot] = boundTexture;\n    }\n    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n      if (currentTextureSlot !== webglSlot) {\n        gl.activeTexture(webglSlot);\n        this.currentTextureSlot = webglSlot;\n      }\n      gl.bindTexture(webglType, webglTexture);\n      boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n    }\n  }\n  bindBufferBase(target, index, buffer) {\n    const {\n      gl\n    } = this;\n    const key = `${target}-${index}`;\n    if (this.currentBoundBufferBases[key] !== buffer) {\n      gl.bindBufferBase(target, index, buffer);\n      this.currentBoundBufferBases[key] = buffer;\n      return true;\n    }\n    return false;\n  }\n  unbindTexture() {\n    const {\n      gl,\n      currentTextureSlot,\n      currentBoundTextures\n    } = this;\n    const boundTexture = currentBoundTextures[currentTextureSlot];\n    if (boundTexture !== undefined && boundTexture.type !== undefined) {\n      gl.bindTexture(boundTexture.type, null);\n      boundTexture.type = undefined;\n      boundTexture.texture = undefined;\n    }\n  }\n}\nclass WebGLUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = this.backend.gl;\n    this.extensions = backend.extensions;\n  }\n  convert(p, colorSpace = NoColorSpace) {\n    const {\n      gl,\n      extensions\n    } = this;\n    let extension;\n    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;\n    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;\n    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;\n    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;\n    if (p === ByteType) return gl.BYTE;\n    if (p === ShortType) return gl.SHORT;\n    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;\n    if (p === IntType) return gl.INT;\n    if (p === UnsignedIntType) return gl.UNSIGNED_INT;\n    if (p === FloatType) return gl.FLOAT;\n    if (p === HalfFloatType) {\n      return gl.HALF_FLOAT;\n    }\n    if (p === AlphaFormat) return gl.ALPHA;\n    if (p === RGBFormat) return gl.RGB;\n    if (p === RGBAFormat) return gl.RGBA;\n    if (p === LuminanceFormat) return gl.LUMINANCE;\n    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;\n    if (p === DepthFormat) return gl.DEPTH_COMPONENT;\n    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;\n\n    // WebGL2 formats.\n\n    if (p === RedFormat) return gl.RED;\n    if (p === RedIntegerFormat) return gl.RED_INTEGER;\n    if (p === RGFormat) return gl.RG;\n    if (p === RGIntegerFormat) return gl.RG_INTEGER;\n    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;\n\n    // S3TC\n\n    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n      if (colorSpace === SRGBColorSpace) {\n        extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      } else {\n        extension = extensions.get('WEBGL_compressed_texture_s3tc');\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    // PVRTC\n\n    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_pvrtc');\n      if (extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return null;\n      }\n    }\n\n    // ETC\n\n    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_etc');\n      if (extension !== null) {\n        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n      } else {\n        return null;\n      }\n    }\n\n    // ASTC\n\n    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_astc');\n      if (extension !== null) {\n        if (p === RGBA_ASTC_4x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n        if (p === RGBA_ASTC_5x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n        if (p === RGBA_ASTC_5x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n        if (p === RGBA_ASTC_6x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n        if (p === RGBA_ASTC_6x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n        if (p === RGBA_ASTC_8x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n        if (p === RGBA_ASTC_8x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n        if (p === RGBA_ASTC_8x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n        if (p === RGBA_ASTC_10x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n        if (p === RGBA_ASTC_10x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n        if (p === RGBA_ASTC_10x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n        if (p === RGBA_ASTC_10x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n        if (p === RGBA_ASTC_12x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n        if (p === RGBA_ASTC_12x12_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n      } else {\n        return null;\n      }\n    }\n\n    // BPTC\n\n    if (p === RGBA_BPTC_Format) {\n      extension = extensions.get('EXT_texture_compression_bptc');\n      if (extension !== null) {\n        if (p === RGBA_BPTC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n      } else {\n        return null;\n      }\n    }\n\n    // RGTC\n\n    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {\n      extension = extensions.get('EXT_texture_compression_rgtc');\n      if (extension !== null) {\n        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;\n        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n      } else {\n        return null;\n      }\n    }\n\n    //\n\n    if (p === UnsignedInt248Type) {\n      return gl.UNSIGNED_INT_24_8;\n    }\n\n    // if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n    return gl[p] !== undefined ? gl[p] : null;\n  }\n  _clientWaitAsync() {\n    const {\n      gl\n    } = this;\n    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    return new Promise((resolve, reject) => {\n      function test() {\n        const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);\n        if (res === gl.WAIT_FAILED) {\n          gl.deleteSync(sync);\n          reject();\n          return;\n        }\n        if (res === gl.TIMEOUT_EXPIRED) {\n          requestAnimationFrame(test);\n          return;\n        }\n        gl.deleteSync(sync);\n        resolve();\n      }\n      test();\n    });\n  }\n}\nlet initialized = false,\n  wrappingToGL,\n  filterToGL,\n  compareToGL;\nclass WebGLTextureUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = backend.gl;\n    this.extensions = backend.extensions;\n    this.defaultTextures = {};\n    if (initialized === false) {\n      this._init(this.gl);\n      initialized = true;\n    }\n  }\n  _init(gl) {\n    // Store only WebGL constants here.\n\n    wrappingToGL = {\n      [RepeatWrapping]: gl.REPEAT,\n      [ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,\n      [MirroredRepeatWrapping]: gl.MIRRORED_REPEAT\n    };\n    filterToGL = {\n      [NearestFilter]: gl.NEAREST,\n      [NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,\n      [NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,\n      [LinearFilter]: gl.LINEAR,\n      [LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,\n      [LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR\n    };\n    compareToGL = {\n      [NeverCompare]: gl.NEVER,\n      [AlwaysCompare]: gl.ALWAYS,\n      [LessCompare]: gl.LESS,\n      [LessEqualCompare]: gl.LEQUAL,\n      [EqualCompare]: gl.EQUAL,\n      [GreaterEqualCompare]: gl.GEQUAL,\n      [GreaterCompare]: gl.GREATER,\n      [NotEqualCompare]: gl.NOTEQUAL\n    };\n  }\n  filterFallback(f) {\n    const {\n      gl\n    } = this;\n    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n      return gl.NEAREST;\n    }\n    return gl.LINEAR;\n  }\n  getGLTextureType(texture) {\n    const {\n      gl\n    } = this;\n    let glTextureType;\n    if (texture.isCubeTexture === true) {\n      glTextureType = gl.TEXTURE_CUBE_MAP;\n    } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {\n      glTextureType = gl.TEXTURE_2D_ARRAY;\n    } else if (texture.isData3DTexture === true) {\n      // TODO: isCompressed3DTexture, wait for #26642\n\n      glTextureType = gl.TEXTURE_3D;\n    } else {\n      glTextureType = gl.TEXTURE_2D;\n    }\n    return glTextureType;\n  }\n  getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {\n    const {\n      gl,\n      extensions\n    } = this;\n    if (internalFormatName !== null) {\n      if (gl[internalFormatName] !== undefined) return gl[internalFormatName];\n      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'');\n    }\n    let internalFormat = glFormat;\n    if (glFormat === gl.RED) {\n      if (glType === gl.FLOAT) internalFormat = gl.R32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;\n      if (glType === gl.BYTE) internalFormat = gl.R8I;\n      if (glType === gl.SHORT) internalFormat = gl.R16I;\n      if (glType === gl.INT) internalFormat = gl.R32I;\n    }\n    if (glFormat === gl.RED_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;\n      if (glType === gl.BYTE) internalFormat = gl.R8I;\n      if (glType === gl.SHORT) internalFormat = gl.R16I;\n      if (glType === gl.INT) internalFormat = gl.R32I;\n    }\n    if (glFormat === gl.RG) {\n      if (glType === gl.FLOAT) internalFormat = gl.RG32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RG8I;\n      if (glType === gl.SHORT) internalFormat = gl.RG16I;\n      if (glType === gl.INT) internalFormat = gl.RG32I;\n    }\n    if (glFormat === gl.RG_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RG8I;\n      if (glType === gl.SHORT) internalFormat = gl.RG16I;\n      if (glType === gl.INT) internalFormat = gl.RG32I;\n    }\n    if (glFormat === gl.RGB) {\n      if (glType === gl.FLOAT) internalFormat = gl.RGB32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGB8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGB16I;\n      if (glType === gl.INT) internalFormat = gl.RGB32I;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8 : gl.RGB8;\n      if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;\n      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;\n      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;\n      if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;\n    }\n    if (glFormat === gl.RGB_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGB8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGB16I;\n      if (glType === gl.INT) internalFormat = gl.RGB32I;\n    }\n    if (glFormat === gl.RGBA) {\n      if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;\n      if (glType === gl.INT) internalFormat = gl.RGBA32I;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8_ALPHA8 : gl.RGBA8;\n      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;\n      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;\n    }\n    if (glFormat === gl.RGBA_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;\n      if (glType === gl.INT) internalFormat = gl.RGBA32I;\n    }\n    if (glFormat === gl.DEPTH_COMPONENT) {\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH24_STENCIL8;\n      if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;\n    }\n    if (glFormat === gl.DEPTH_STENCIL) {\n      if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;\n    }\n    if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {\n      extensions.get('EXT_color_buffer_float');\n    }\n    return internalFormat;\n  }\n  setTextureParameters(textureType, texture) {\n    const {\n      gl,\n      extensions,\n      backend\n    } = this;\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);\n    gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);\n    if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {\n      gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);\n    }\n    gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);\n    const hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;\n\n    // follow WebGPU backend mapping for texture filtering\n    const minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;\n    gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);\n    if (texture.compareFunction) {\n      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\n      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);\n    }\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      if (texture.magFilter === NearestFilter) return;\n      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;\n      if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2\n\n      if (texture.anisotropy > 1) {\n        const extension = extensions.get('EXT_texture_filter_anisotropic');\n        gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, backend.getMaxAnisotropy()));\n      }\n    }\n  }\n  createDefaultTexture(texture) {\n    const {\n      gl,\n      backend,\n      defaultTextures\n    } = this;\n    const glTextureType = this.getGLTextureType(texture);\n    let textureGPU = defaultTextures[glTextureType];\n    if (textureGPU === undefined) {\n      textureGPU = gl.createTexture();\n      backend.state.bindTexture(glTextureType, textureGPU);\n      gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n      // gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n      defaultTextures[glTextureType] = textureGPU;\n    }\n    backend.set(texture, {\n      textureGPU,\n      glTextureType,\n      isDefault: true\n    });\n  }\n  createTexture(texture, options) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      levels,\n      width,\n      height,\n      depth\n    } = options;\n    const glFormat = backend.utils.convert(texture.format, texture.colorSpace);\n    const glType = backend.utils.convert(texture.type);\n    const glInternalFormat = this.getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);\n    const textureGPU = gl.createTexture();\n    const glTextureType = this.getGLTextureType(texture);\n    backend.state.bindTexture(glTextureType, textureGPU);\n    this.setTextureParameters(glTextureType, texture);\n    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {\n      gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth);\n    } else if (texture.isData3DTexture) {\n      gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth);\n    } else if (!texture.isVideoTexture) {\n      gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);\n    }\n    backend.set(texture, {\n      textureGPU,\n      glTextureType,\n      glFormat,\n      glType,\n      glInternalFormat\n    });\n  }\n  copyBufferToTexture(buffer, texture) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      textureGPU,\n      glTextureType,\n      glFormat,\n      glType\n    } = backend.get(texture);\n    const {\n      width,\n      height\n    } = texture.source.data;\n    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer);\n    backend.state.bindTexture(glTextureType, textureGPU);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, 0);\n    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);\n    backend.state.unbindTexture();\n    // debug\n    // const framebuffer = gl.createFramebuffer();\n    // gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );\n    // gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );\n\n    // const readout = new Float32Array( width * height * 4 );\n\n    // const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );\n    // const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );\n\n    // gl.readPixels( 0, 0, width, height, altFormat, altType, readout );\n    // gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n    // console.log( readout );\n  }\n  updateTexture(texture, options) {\n    const {\n      gl\n    } = this;\n    const {\n      width,\n      height\n    } = options;\n    const {\n      textureGPU,\n      glTextureType,\n      glFormat,\n      glType,\n      glInternalFormat\n    } = this.backend.get(texture);\n    if (texture.isRenderTargetTexture || textureGPU === undefined /* unsupported texture format */) return;\n    const getImage = source => {\n      if (source.isDataTexture) {\n        return source.image.data;\n      } else if (typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap || source instanceof OffscreenCanvas) {\n        return source;\n      }\n      return source.data;\n    };\n    this.backend.state.bindTexture(glTextureType, textureGPU);\n    this.setTextureParameters(glTextureType, texture);\n    if (texture.isCompressedTexture) {\n      const mipmaps = texture.mipmaps;\n      const image = options.image;\n      for (let i = 0; i < mipmaps.length; i++) {\n        const mipmap = mipmaps[i];\n        if (texture.isCompressedArrayTexture) {\n          if (texture.format !== gl.RGBA) {\n            if (glFormat !== null) {\n              gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);\n            } else {\n              console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');\n            }\n          } else {\n            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);\n          }\n        } else {\n          if (glFormat !== null) {\n            gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);\n          } else {\n            console.warn('Unsupported compressed texture format');\n          }\n        }\n      }\n    } else if (texture.isCubeTexture) {\n      const images = options.images;\n      for (let i = 0; i < 6; i++) {\n        const image = getImage(images[i]);\n        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image);\n      }\n    } else if (texture.isDataArrayTexture) {\n      const image = options.image;\n      gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n    } else if (texture.isData3DTexture) {\n      const image = options.image;\n      gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n    } else if (texture.isVideoTexture) {\n      texture.update();\n      gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);\n    } else {\n      const image = getImage(options.image);\n      gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, image);\n    }\n  }\n  generateMipmaps(texture) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      textureGPU,\n      glTextureType\n    } = backend.get(texture);\n    backend.state.bindTexture(glTextureType, textureGPU);\n    gl.generateMipmap(glTextureType);\n  }\n  deallocateRenderBuffers(renderTarget) {\n    const {\n      gl,\n      backend\n    } = this;\n\n    // remove framebuffer reference\n    if (renderTarget) {\n      const renderContextData = backend.get(renderTarget);\n      renderContextData.renderBufferStorageSetup = undefined;\n      if (renderContextData.framebuffers) {\n        for (const cacheKey in renderContextData.framebuffers) {\n          gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);\n        }\n        delete renderContextData.framebuffers;\n      }\n      if (renderContextData.depthRenderbuffer) {\n        gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);\n        delete renderContextData.depthRenderbuffer;\n      }\n      if (renderContextData.stencilRenderbuffer) {\n        gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);\n        delete renderContextData.stencilRenderbuffer;\n      }\n      if (renderContextData.msaaFrameBuffer) {\n        gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);\n        delete renderContextData.msaaFrameBuffer;\n      }\n      if (renderContextData.msaaRenderbuffers) {\n        for (let i = 0; i < renderContextData.msaaRenderbuffers.length; i++) {\n          gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);\n        }\n        delete renderContextData.msaaRenderbuffers;\n      }\n    }\n  }\n  destroyTexture(texture) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      textureGPU,\n      renderTarget\n    } = backend.get(texture);\n    this.deallocateRenderBuffers(renderTarget);\n    gl.deleteTexture(textureGPU);\n    backend.delete(texture);\n  }\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      state\n    } = this.backend;\n    const {\n      textureGPU: dstTextureGPU,\n      glTextureType,\n      glType,\n      glFormat\n    } = backend.get(dstTexture);\n    let width, height, minX, minY;\n    let dstX, dstY;\n    if (srcRegion !== null) {\n      width = srcRegion.max.x - srcRegion.min.x;\n      height = srcRegion.max.y - srcRegion.min.y;\n      minX = srcRegion.min.x;\n      minY = srcRegion.min.y;\n    } else {\n      width = srcTexture.image.width;\n      height = srcTexture.image.height;\n      minX = 0;\n      minY = 0;\n    }\n    if (dstPosition !== null) {\n      dstX = dstPosition.x;\n      dstY = dstPosition.y;\n    } else {\n      dstX = 0;\n      dstY = 0;\n    }\n    state.bindTexture(glTextureType, dstTextureGPU);\n\n    // As another texture upload may have changed pixelStorei\n    // parameters, make sure they are correct for the dstTexture\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n    const currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);\n    const currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);\n    const currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);\n    const currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);\n    const currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);\n    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;\n    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);\n    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);\n    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);\n    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);\n    if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {\n      const srcTextureData = backend.get(srcTexture);\n      const dstTextureData = backend.get(dstTexture);\n      const srcRenderContextData = backend.get(srcTextureData.renderTarget);\n      const dstRenderContextData = backend.get(dstTextureData.renderTarget);\n      const srcFramebuffer = srcRenderContextData.framebuffers[srcTextureData.cacheKey];\n      const dstFramebuffer = dstRenderContextData.framebuffers[dstTextureData.cacheKey];\n      state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);\n      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);\n      let mask = gl.COLOR_BUFFER_BIT;\n      if (srcTexture.isDepthTexture) mask = gl.DEPTH_BUFFER_BIT;\n      gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST);\n      state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n    } else {\n      if (srcTexture.isDataTexture) {\n        gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);\n      } else {\n        if (srcTexture.isCompressedTexture) {\n          gl.compressedTexSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);\n        } else {\n          gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);\n        }\n      }\n    }\n    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);\n    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);\n    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);\n    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);\n    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);\n\n    // Generate mipmaps only when copying level 0\n    if (level === 0 && dstTexture.generateMipmaps) gl.generateMipmap(gl.TEXTURE_2D);\n    state.unbindTexture();\n  }\n  copyFramebufferToTexture(texture, renderContext, rectangle) {\n    const {\n      gl\n    } = this;\n    const {\n      state\n    } = this.backend;\n    const {\n      textureGPU\n    } = this.backend.get(texture);\n    const {\n      x,\n      y,\n      z: width,\n      w: height\n    } = rectangle;\n    const requireDrawFrameBuffer = texture.isDepthTexture === true || renderContext.renderTarget && renderContext.renderTarget.samples > 0;\n    const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;\n    if (requireDrawFrameBuffer) {\n      const partial = x !== 0 || y !== 0;\n      let mask;\n      let attachment;\n      if (texture.isDepthTexture === true) {\n        mask = gl.DEPTH_BUFFER_BIT;\n        attachment = gl.DEPTH_ATTACHMENT;\n        if (renderContext.stencil) {\n          mask |= gl.STENCIL_BUFFER_BIT;\n        }\n      } else {\n        mask = gl.COLOR_BUFFER_BIT;\n        attachment = gl.COLOR_ATTACHMENT0;\n      }\n      if (partial) {\n        const renderTargetContextData = this.backend.get(renderContext.renderTarget);\n        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];\n        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);\n        const flippedY = srcHeight - y - height;\n        gl.blitFramebuffer(x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST);\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);\n        state.bindTexture(gl.TEXTURE_2D, textureGPU);\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height);\n        state.unbindTexture();\n      } else {\n        const fb = gl.createFramebuffer();\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0);\n        gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);\n        gl.deleteFramebuffer(fb);\n      }\n    } else {\n      state.bindTexture(gl.TEXTURE_2D, textureGPU);\n      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height);\n      state.unbindTexture();\n    }\n    if (texture.generateMipmaps) this.generateMipmaps(texture);\n    this.backend._setFramebuffer(renderContext);\n  }\n\n  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n  setupRenderBufferStorage(renderbuffer, renderContext) {\n    const {\n      gl\n    } = this;\n    const renderTarget = renderContext.renderTarget;\n    const {\n      samples,\n      depthTexture,\n      depthBuffer,\n      stencilBuffer,\n      width,\n      height\n    } = renderTarget;\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n    if (depthBuffer && !stencilBuffer) {\n      let glInternalFormat = gl.DEPTH_COMPONENT24;\n      if (samples > 0) {\n        if (depthTexture && depthTexture.isDepthTexture) {\n          if (depthTexture.type === gl.FLOAT) {\n            glInternalFormat = gl.DEPTH_COMPONENT32F;\n          }\n        }\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, glInternalFormat, width, height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);\n      }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n    } else if (depthBuffer && stencilBuffer) {\n      if (samples > 0) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n      }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n    }\n  }\n  async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    const {\n      backend,\n      gl\n    } = this;\n    const {\n      textureGPU,\n      glFormat,\n      glType\n    } = this.backend.get(texture);\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);\n    const target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;\n    gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0);\n    const typedArrayType = this._getTypedArrayType(glType);\n    const bytesPerTexel = this._getBytesPerTexel(glType, glFormat);\n    const elementCount = width * height;\n    const byteLength = elementCount * bytesPerTexel;\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);\n    gl.readPixels(x, y, width, height, glFormat, glType, 0);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    await backend.utils._clientWaitAsync();\n    const dstBuffer = new typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);\n    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    gl.deleteFramebuffer(fb);\n    return dstBuffer;\n  }\n  _getTypedArrayType(glType) {\n    const {\n      gl\n    } = this;\n    if (glType === gl.UNSIGNED_BYTE) return Uint8Array;\n    if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;\n    if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;\n    if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;\n    if (glType === gl.UNSIGNED_SHORT) return Uint16Array;\n    if (glType === gl.UNSIGNED_INT) return Uint32Array;\n    if (glType === gl.HALF_FLOAT) return Uint16Array;\n    if (glType === gl.FLOAT) return Float32Array;\n    throw new Error(`Unsupported WebGL type: ${glType}`);\n  }\n  _getBytesPerTexel(glType, glFormat) {\n    const {\n      gl\n    } = this;\n    let bytesPerComponent = 0;\n    if (glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;\n    if (glType === gl.UNSIGNED_SHORT_4_4_4_4 || glType === gl.UNSIGNED_SHORT_5_5_5_1 || glType === gl.UNSIGNED_SHORT_5_6_5 || glType === gl.UNSIGNED_SHORT || glType === gl.HALF_FLOAT) bytesPerComponent = 2;\n    if (glType === gl.UNSIGNED_INT || glType === gl.FLOAT) bytesPerComponent = 4;\n    if (glFormat === gl.RGBA) return bytesPerComponent * 4;\n    if (glFormat === gl.RGB) return bytesPerComponent * 3;\n    if (glFormat === gl.ALPHA) return bytesPerComponent;\n  }\n}\nclass WebGLExtensions {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = this.backend.gl;\n    this.availableExtensions = this.gl.getSupportedExtensions();\n    this.extensions = {};\n  }\n  get(name) {\n    let extension = this.extensions[name];\n    if (extension === undefined) {\n      extension = this.gl.getExtension(name);\n      this.extensions[name] = extension;\n    }\n    return extension;\n  }\n  has(name) {\n    return this.availableExtensions.includes(name);\n  }\n}\nclass WebGLCapabilities {\n  constructor(backend) {\n    this.backend = backend;\n    this.maxAnisotropy = null;\n  }\n  getMaxAnisotropy() {\n    if (this.maxAnisotropy !== null) return this.maxAnisotropy;\n    const gl = this.backend.gl;\n    const extensions = this.backend.extensions;\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      const extension = extensions.get('EXT_texture_filter_anisotropic');\n      this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n      this.maxAnisotropy = 0;\n    }\n    return this.maxAnisotropy;\n  }\n}\nconst GLFeatureName = {\n  'WEBGL_multi_draw': 'WEBGL_multi_draw',\n  'WEBGL_compressed_texture_astc': 'texture-compression-astc',\n  'WEBGL_compressed_texture_etc': 'texture-compression-etc2',\n  'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',\n  'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n  'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n  'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',\n  'EXT_texture_compression_bptc': 'texture-compression-bptc',\n  'EXT_disjoint_timer_query_webgl2': 'timestamp-query'\n};\nclass WebGLBufferRenderer {\n  constructor(backend) {\n    this.gl = backend.gl;\n    this.extensions = backend.extensions;\n    this.info = backend.renderer.info;\n    this.mode = null;\n    this.index = 0;\n    this.type = null;\n    this.object = null;\n  }\n  render(start, count) {\n    const {\n      gl,\n      mode,\n      object,\n      type,\n      info,\n      index\n    } = this;\n    if (index !== 0) {\n      gl.drawElements(mode, count, type, start);\n    } else {\n      gl.drawArrays(mode, start, count);\n    }\n    info.update(object, count, mode, 1);\n  }\n  renderInstances(start, count, primcount) {\n    const {\n      gl,\n      mode,\n      type,\n      index,\n      object,\n      info\n    } = this;\n    if (primcount === 0) return;\n    if (index !== 0) {\n      gl.drawElementsInstanced(mode, count, type, start, primcount);\n    } else {\n      gl.drawArraysInstanced(mode, start, count, primcount);\n    }\n    info.update(object, count, mode, primcount);\n  }\n  renderMultiDraw(starts, counts, drawCount) {\n    const {\n      extensions,\n      mode,\n      object,\n      info\n    } = this;\n    if (drawCount === 0) return;\n    const extension = extensions.get('WEBGL_multi_draw');\n    if (extension === null) {\n      for (let i = 0; i < drawCount; i++) {\n        this.render(starts[i], counts[i]);\n      }\n    } else {\n      if (this.index !== 0) {\n        extension.multiDrawElementsWEBGL(mode, counts, 0, this.type, starts, 0, drawCount);\n      } else {\n        extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);\n      }\n      let elementCount = 0;\n      for (let i = 0; i < drawCount; i++) {\n        elementCount += counts[i];\n      }\n      info.update(object, elementCount, mode, 1);\n    }\n  }\n  renderMultiDrawInstances(starts, counts, drawCount, primcount) {\n    const {\n      extensions,\n      mode,\n      object,\n      info\n    } = this;\n    if (drawCount === 0) return;\n    const extension = extensions.get('WEBGL_multi_draw');\n    if (extension === null) {\n      for (let i = 0; i < drawCount; i++) {\n        this.renderInstances(starts[i], counts[i], primcount[i]);\n      }\n    } else {\n      if (this.index !== 0) {\n        extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount);\n      } else {\n        extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);\n      }\n      let elementCount = 0;\n      for (let i = 0; i < drawCount; i++) {\n        elementCount += counts[i] * primcount[i];\n      }\n      info.update(object, elementCount, mode, 1);\n    }\n  }\n\n  //\n}\n\n/**\n * A backend implementation targeting WebGL 2.\n *\n * @private\n * @augments Backend\n */\nclass WebGLBackend extends Backend {\n  /**\n   * Constructs a new WebGPU backend.\n   *\n   * @param {Object} parameters - The configuration parameter.\n   * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n   * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n   * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n   * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n   * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n   * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n   * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses it WebGL 2 backend no matter if WebGPU is supported or not.\n   * @param {WebGL2RenderingContext} [parameters.context=undefined] - A WebGL 2 rendering context.\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isWebGLBackend = true;\n\n    /**\n     * A reference to a backend module holding shader attribute-related\n     * utility functions.\n     *\n     * @type {WebGLAttributeUtils?}\n     * @default null\n     */\n    this.attributeUtils = null;\n\n    /**\n     * A reference to a backend module holding extension-related\n     * utility functions.\n     *\n     * @type {WebGLExtensions?}\n     * @default null\n     */\n    this.extensions = null;\n\n    /**\n     * A reference to a backend module holding capability-related\n     * utility functions.\n     *\n     * @type {WebGLCapabilities?}\n     * @default null\n     */\n    this.capabilities = null;\n\n    /**\n     * A reference to a backend module holding texture-related\n     * utility functions.\n     *\n     * @type {WebGLTextureUtils?}\n     * @default null\n     */\n    this.textureUtils = null;\n\n    /**\n     * A reference to a backend module holding renderer-related\n     * utility functions.\n     *\n     * @type {WebGLBufferRenderer?}\n     * @default null\n     */\n    this.bufferRenderer = null;\n\n    /**\n     * A reference to the rendering context.\n     *\n     * @type {WebGL2RenderingContext?}\n     * @default null\n     */\n    this.gl = null;\n\n    /**\n     * A reference to a backend module holding state-related\n     * utility functions.\n     *\n     * @type {WebGLState?}\n     * @default null\n     */\n    this.state = null;\n\n    /**\n     * A reference to a backend module holding common\n     * utility functions.\n     *\n     * @type {WebGLUtils?}\n     * @default null\n     */\n    this.utils = null;\n\n    /**\n     * Dictionary for caching VAOs.\n     *\n     * @type {Object<String,WebGLVertexArrayObject>}\n     */\n    this.vaoCache = {};\n\n    /**\n     * Dictionary for caching transform feedback objects.\n     *\n     * @type {Object<String,WebGLTransformFeedback>}\n     */\n    this.transformFeedbackCache = {};\n\n    /**\n     * Controls if `gl.RASTERIZER_DISCARD` should be enabled or not.\n     * Only relevant when using compute shaders.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.discard = false;\n\n    /**\n     * A reference to the `EXT_disjoint_timer_query_webgl2` extension. `null` if the\n     * device does not support the extension.\n     *\n     * @type {EXTDisjointTimerQueryWebGL2?}\n     * @default null\n     */\n    this.disjoint = null;\n\n    /**\n    * A reference to the `KHR_parallel_shader_compile` extension. `null` if the\n    * device does not support the extension.\n    *\n    * @type {KHRParallelShaderCompile?}\n    * @default null\n    */\n    this.parallel = null;\n\n    /**\n     * Whether to track timestamps with a Timestamp Query API or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.trackTimestamp = parameters.trackTimestamp === true;\n\n    /**\n     * A reference to the current render context.\n     *\n     * @private\n     * @type {RenderContext}\n     * @default null\n     */\n    this._currentContext = null;\n\n    /**\n     * A unique collection of bindings.\n     *\n     * @private\n     * @type {WeakSet}\n     */\n    this._knownBindings = new WeakSet();\n  }\n\n  /**\n   * Initializes the backend so it is ready for usage.\n   *\n   * @param {Renderer} renderer - The renderer.\n   */\n  init(renderer) {\n    super.init(renderer);\n\n    //\n\n    const parameters = this.parameters;\n    const glContext = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgl2');\n    function onContextLost(event) {\n      event.preventDefault();\n      const contextLossInfo = {\n        api: 'WebGL',\n        message: event.statusMessage || 'Unknown reason',\n        reason: null,\n        originalEvent: event\n      };\n      renderer.onDeviceLost(contextLossInfo);\n    }\n    this._onContextLost = onContextLost;\n    renderer.domElement.addEventListener('webglcontextlost', onContextLost, false);\n    this.gl = glContext;\n    this.extensions = new WebGLExtensions(this);\n    this.capabilities = new WebGLCapabilities(this);\n    this.attributeUtils = new WebGLAttributeUtils(this);\n    this.textureUtils = new WebGLTextureUtils(this);\n    this.bufferRenderer = new WebGLBufferRenderer(this);\n    this.state = new WebGLState(this);\n    this.utils = new WebGLUtils(this);\n    this.extensions.get('EXT_color_buffer_float');\n    this.extensions.get('WEBGL_clip_cull_distance');\n    this.extensions.get('OES_texture_float_linear');\n    this.extensions.get('EXT_color_buffer_half_float');\n    this.extensions.get('WEBGL_multisampled_render_to_texture');\n    this.extensions.get('WEBGL_render_shared_exponent');\n    this.extensions.get('WEBGL_multi_draw');\n    this.disjoint = this.extensions.get('EXT_disjoint_timer_query_webgl2');\n    this.parallel = this.extensions.get('KHR_parallel_shader_compile');\n  }\n\n  /**\n   * The coordinate system of the backend.\n   *\n   * @type {Number}\n   * @readonly\n   */\n  get coordinateSystem() {\n    return WebGLCoordinateSystem;\n  }\n\n  /**\n   * Transfers buffer data from a storage buffer attribute\n   * from the GPU to the CPU in context of compute shaders.\n   *\n   * @async\n   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n   */\n  async getArrayBufferAsync(attribute) {\n    return await this.attributeUtils.getArrayBufferAsync(attribute);\n  }\n\n  /**\n   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n   * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n   *\n   * @async\n   * @return {Promise} A Promise that resolves when synchronization has been finished.\n   */\n  async waitForGPU() {\n    await this.utils._clientWaitAsync();\n  }\n\n  /**\n   * Inits a time stamp query for the given render context.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   */\n  initTimestampQuery(renderContext) {\n    if (!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (this.queryRunning) {\n      if (!renderContextData.queryQueue) renderContextData.queryQueue = [];\n      renderContextData.queryQueue.push(renderContext);\n      return;\n    }\n    if (renderContextData.activeQuery) {\n      this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);\n      renderContextData.activeQuery = null;\n    }\n    renderContextData.activeQuery = this.gl.createQuery();\n    if (renderContextData.activeQuery !== null) {\n      this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery);\n      this.queryRunning = true;\n    }\n  }\n\n  // timestamp utils\n\n  /**\n   * Prepares the timestamp buffer.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   */\n  prepareTimestampBuffer(renderContext) {\n    if (!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (renderContextData.activeQuery) {\n      this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);\n      if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];\n      renderContextData.gpuQueries.push({\n        query: renderContextData.activeQuery\n      });\n      renderContextData.activeQuery = null;\n      this.queryRunning = false;\n      if (renderContextData.queryQueue && renderContextData.queryQueue.length > 0) {\n        const nextRenderContext = renderContextData.queryQueue.shift();\n        this.initTimestampQuery(nextRenderContext);\n      }\n    }\n  }\n\n  /**\n   * Resolves the time stamp for the given render context and type.\n   *\n   * @async\n   * @param {RenderContext} renderContext - The render context.\n   * @param {String} type - The render context.\n   * @return {Promise} A Promise that resolves when the time stamp has been computed.\n   */\n  async resolveTimestampAsync(renderContext, type = 'render') {\n    if (!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];\n    for (let i = 0; i < renderContextData.gpuQueries.length; i++) {\n      const queryInfo = renderContextData.gpuQueries[i];\n      const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);\n      const disjoint = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);\n      if (available && !disjoint) {\n        const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);\n        const duration = Number(elapsed) / 1000000; // Convert nanoseconds to milliseconds\n        this.gl.deleteQuery(queryInfo.query);\n        renderContextData.gpuQueries.splice(i, 1); // Remove the processed query\n        i--;\n        this.renderer.info.updateTimestamp(type, duration);\n      }\n    }\n  }\n\n  /**\n   * Returns the backend's rendering context.\n   *\n   * @return {WebGL2RenderingContext} The rendering context.\n   */\n  getContext() {\n    return this.gl;\n  }\n\n  /**\n   * This method is executed at the beginning of a render call and prepares\n   * the WebGL state for upcoming render calls\n   *\n   * @param {RenderContext} renderContext - The render context.\n   */\n  beginRender(renderContext) {\n    const {\n      gl\n    } = this;\n    const renderContextData = this.get(renderContext);\n\n    //\n\n    //\n\n    this.initTimestampQuery(renderContext);\n    renderContextData.previousContext = this._currentContext;\n    this._currentContext = renderContext;\n    this._setFramebuffer(renderContext);\n    this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false);\n\n    //\n    if (renderContext.viewport) {\n      this.updateViewport(renderContext);\n    } else {\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    }\n    if (renderContext.scissor) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = renderContext.scissorValue;\n      gl.scissor(x, renderContext.height - height - y, width, height);\n    }\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (occlusionQueryCount > 0) {\n      // Get a reference to the array of objects with queries. The renderContextData property\n      // can be changed by another render pass before the async reading of all previous queries complete\n      renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;\n      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n      renderContextData.lastOcclusionObject = null;\n      renderContextData.occlusionQueries = new Array(occlusionQueryCount);\n      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);\n      renderContextData.occlusionQueryIndex = 0;\n    }\n  }\n\n  /**\n   * This method is executed at the end of a render call and finalizes work\n   * after draw calls.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   */\n  finishRender(renderContext) {\n    const {\n      gl,\n      state\n    } = this;\n    const renderContextData = this.get(renderContext);\n    const previousContext = renderContextData.previousContext;\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (occlusionQueryCount > 0) {\n      if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {\n        gl.endQuery(gl.ANY_SAMPLES_PASSED);\n      }\n      this.resolveOccludedAsync(renderContext);\n    }\n    const textures = renderContext.textures;\n    if (textures !== null) {\n      for (let i = 0; i < textures.length; i++) {\n        const texture = textures[i];\n        if (texture.generateMipmaps) {\n          this.generateMipmaps(texture);\n        }\n      }\n    }\n    this._currentContext = previousContext;\n    if (renderContext.textures !== null && renderContext.renderTarget) {\n      const renderTargetContextData = this.get(renderContext.renderTarget);\n      const {\n        samples\n      } = renderContext.renderTarget;\n      if (samples > 0) {\n        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];\n        const mask = gl.COLOR_BUFFER_BIT;\n        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n        const textures = renderContext.textures;\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        for (let i = 0; i < textures.length; i++) {\n          // TODO Add support for MRT\n\n          if (renderContext.scissor) {\n            const {\n              x,\n              y,\n              width,\n              height\n            } = renderContext.scissorValue;\n            const viewY = renderContext.height - height - y;\n            gl.blitFramebuffer(x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST);\n            gl.invalidateSubFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height);\n          } else {\n            gl.blitFramebuffer(0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST);\n            gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray);\n          }\n        }\n      }\n    }\n    if (previousContext !== null) {\n      this._setFramebuffer(previousContext);\n      if (previousContext.viewport) {\n        this.updateViewport(previousContext);\n      } else {\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      }\n    }\n    this.prepareTimestampBuffer(renderContext);\n  }\n\n  /**\n   * This method processes the result of occlusion queries and writes it\n   * into render context data.\n   *\n   * @async\n   * @param {RenderContext} renderContext - The render context.\n   */\n  resolveOccludedAsync(renderContext) {\n    const renderContextData = this.get(renderContext);\n\n    // handle occlusion query results\n\n    const {\n      currentOcclusionQueries,\n      currentOcclusionQueryObjects\n    } = renderContextData;\n    if (currentOcclusionQueries && currentOcclusionQueryObjects) {\n      const occluded = new WeakSet();\n      const {\n        gl\n      } = this;\n      renderContextData.currentOcclusionQueryObjects = null;\n      renderContextData.currentOcclusionQueries = null;\n      const check = () => {\n        let completed = 0;\n\n        // check all queries and requeue as appropriate\n        for (let i = 0; i < currentOcclusionQueries.length; i++) {\n          const query = currentOcclusionQueries[i];\n          if (query === null) continue;\n          if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {\n            if (gl.getQueryParameter(query, gl.QUERY_RESULT) > 0) occluded.add(currentOcclusionQueryObjects[i]);\n            currentOcclusionQueries[i] = null;\n            gl.deleteQuery(query);\n            completed++;\n          }\n        }\n        if (completed < currentOcclusionQueries.length) {\n          requestAnimationFrame(check);\n        } else {\n          renderContextData.occluded = occluded;\n        }\n      };\n      check();\n    }\n  }\n\n  /**\n   * Returns `true` if the given 3D object is fully occluded by other\n   * 3D objects in the scene.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   * @param {Object3D} object - The 3D object to test.\n   * @return {Boolean} Whether the 3D object is fully occluded or not.\n   */\n  isOccluded(renderContext, object) {\n    const renderContextData = this.get(renderContext);\n    return renderContextData.occluded && renderContextData.occluded.has(object);\n  }\n\n  /**\n   * Updates the viewport with the values from the given render context.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   */\n  updateViewport(renderContext) {\n    const gl = this.gl;\n    const {\n      x,\n      y,\n      width,\n      height\n    } = renderContext.viewportValue;\n    gl.viewport(x, renderContext.height - height - y, width, height);\n  }\n\n  /**\n   * Defines the scissor test.\n   *\n   * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n   */\n  setScissorTest(boolean) {\n    const gl = this.gl;\n    if (boolean) {\n      gl.enable(gl.SCISSOR_TEST);\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  }\n\n  /**\n   * Performs a clear operation.\n   *\n   * @param {Boolean} color - Whether the color buffer should be cleared or not.\n   * @param {Boolean} depth - Whether the depth buffer should be cleared or not.\n   * @param {Boolean} stencil - Whether the stencil buffer should be cleared or not.\n   * @param {Object?} [descriptor=null] - The render context of the current set render target.\n   * @param {Boolean} [setFrameBuffer=true] - TODO.\n   */\n  clear(color, depth, stencil, descriptor = null, setFrameBuffer = true) {\n    const {\n      gl\n    } = this;\n    if (descriptor === null) {\n      const clearColor = this.getClearColor();\n\n      // premultiply alpha\n\n      clearColor.r *= clearColor.a;\n      clearColor.g *= clearColor.a;\n      clearColor.b *= clearColor.a;\n      descriptor = {\n        textures: null,\n        clearColorValue: clearColor\n      };\n    }\n\n    //\n\n    let clear = 0;\n    if (color) clear |= gl.COLOR_BUFFER_BIT;\n    if (depth) clear |= gl.DEPTH_BUFFER_BIT;\n    if (stencil) clear |= gl.STENCIL_BUFFER_BIT;\n    if (clear !== 0) {\n      let clearColor;\n      if (descriptor.clearColorValue) {\n        clearColor = descriptor.clearColorValue;\n      } else {\n        clearColor = this.getClearColor();\n\n        // premultiply alpha\n\n        clearColor.r *= clearColor.a;\n        clearColor.g *= clearColor.a;\n        clearColor.b *= clearColor.a;\n      }\n      if (depth) this.state.setDepthMask(true);\n      if (descriptor.textures === null) {\n        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);\n        gl.clear(clear);\n      } else {\n        if (setFrameBuffer) this._setFramebuffer(descriptor);\n        if (color) {\n          for (let i = 0; i < descriptor.textures.length; i++) {\n            gl.clearBufferfv(gl.COLOR, i, [clearColor.r, clearColor.g, clearColor.b, clearColor.a]);\n          }\n        }\n        if (depth && stencil) {\n          gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);\n        } else if (depth) {\n          gl.clearBufferfv(gl.DEPTH, 0, [1.0]);\n        } else if (stencil) {\n          gl.clearBufferiv(gl.STENCIL, 0, [0]);\n        }\n      }\n    }\n  }\n\n  /**\n   * This method is executed at the beginning of a compute call and\n   * prepares the state for upcoming compute tasks.\n   *\n   * @param {Node|Array<Node>} computeGroup - The compute node(s).\n   */\n  beginCompute(computeGroup) {\n    const {\n      state,\n      gl\n    } = this;\n    state.bindFramebuffer(gl.FRAMEBUFFER, null);\n    this.initTimestampQuery(computeGroup);\n  }\n\n  /**\n   * Executes a compute command for the given compute node.\n   *\n   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n   * @param {Node} computeNode - The compute node.\n   * @param {Array<BindGroup>} bindings - The bindings.\n   * @param {ComputePipeline} pipeline - The compute pipeline.\n   */\n  compute(computeGroup, computeNode, bindings, pipeline) {\n    const {\n      state,\n      gl\n    } = this;\n    if (this.discard === false) {\n      // required here to handle async behaviour of render.compute()\n      gl.enable(gl.RASTERIZER_DISCARD);\n      this.discard = true;\n    }\n    const {\n      programGPU,\n      transformBuffers,\n      attributes\n    } = this.get(pipeline);\n    const vaoKey = this._getVaoKey(null, attributes);\n    const vaoGPU = this.vaoCache[vaoKey];\n    if (vaoGPU === undefined) {\n      this._createVao(null, attributes);\n    } else {\n      gl.bindVertexArray(vaoGPU);\n    }\n    state.useProgram(programGPU);\n    this._bindUniforms(bindings);\n    const transformFeedbackGPU = this._getTransformFeedback(transformBuffers);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);\n    gl.beginTransformFeedback(gl.POINTS);\n    if (attributes[0].isStorageInstancedBufferAttribute) {\n      gl.drawArraysInstanced(gl.POINTS, 0, 1, computeNode.count);\n    } else {\n      gl.drawArrays(gl.POINTS, 0, computeNode.count);\n    }\n    gl.endTransformFeedback();\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\n    // switch active buffers\n\n    for (let i = 0; i < transformBuffers.length; i++) {\n      const dualAttributeData = transformBuffers[i];\n      if (dualAttributeData.pbo) {\n        this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, dualAttributeData.pbo);\n      }\n      dualAttributeData.switchBuffers();\n    }\n  }\n\n  /**\n   * This method is executed at the end of a compute call and\n   * finalizes work after compute tasks.\n   *\n   * @param {Node|Array<Node>} computeGroup - The compute node(s).\n   */\n  finishCompute(computeGroup) {\n    const gl = this.gl;\n    this.discard = false;\n    gl.disable(gl.RASTERIZER_DISCARD);\n    this.prepareTimestampBuffer(computeGroup);\n    if (this._currentContext) {\n      this._setFramebuffer(this._currentContext);\n    }\n  }\n\n  /**\n   * Executes a draw command for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object to draw.\n   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n   */\n  draw(renderObject /*, info*/) {\n    const {\n      object,\n      pipeline,\n      material,\n      context,\n      hardwareClippingPlanes\n    } = renderObject;\n    const {\n      programGPU\n    } = this.get(pipeline);\n    const {\n      gl,\n      state\n    } = this;\n    const contextData = this.get(context);\n    const drawParams = renderObject.getDrawParameters();\n    if (drawParams === null) return;\n\n    //\n\n    this._bindUniforms(renderObject.getBindings());\n    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n    state.setMaterial(material, frontFaceCW, hardwareClippingPlanes);\n    state.useProgram(programGPU);\n\n    //\n\n    const renderObjectData = this.get(renderObject);\n    let vaoGPU = renderObjectData.staticVao;\n    if (vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id) {\n      const vaoKey = this._getVaoKey(renderObject.getIndex(), renderObject.getAttributes());\n      vaoGPU = this.vaoCache[vaoKey];\n      if (vaoGPU === undefined) {\n        let staticVao;\n        ({\n          vaoGPU,\n          staticVao\n        } = this._createVao(renderObject.getIndex(), renderObject.getAttributes()));\n        if (staticVao) {\n          renderObjectData.staticVao = vaoGPU;\n          renderObjectData.geometryId = renderObject.geometry.id;\n        }\n      }\n    }\n    gl.bindVertexArray(vaoGPU);\n\n    //\n\n    const index = renderObject.getIndex();\n\n    //\n\n    const lastObject = contextData.lastOcclusionObject;\n    if (lastObject !== object && lastObject !== undefined) {\n      if (lastObject !== null && lastObject.occlusionTest === true) {\n        gl.endQuery(gl.ANY_SAMPLES_PASSED);\n        contextData.occlusionQueryIndex++;\n      }\n      if (object.occlusionTest === true) {\n        const query = gl.createQuery();\n        gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);\n        contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;\n        contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;\n      }\n      contextData.lastOcclusionObject = object;\n    }\n\n    //\n    const renderer = this.bufferRenderer;\n    if (object.isPoints) renderer.mode = gl.POINTS;else if (object.isLineSegments) renderer.mode = gl.LINES;else if (object.isLine) renderer.mode = gl.LINE_STRIP;else if (object.isLineLoop) renderer.mode = gl.LINE_LOOP;else {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * this.renderer.getPixelRatio());\n        renderer.mode = gl.LINES;\n      } else {\n        renderer.mode = gl.TRIANGLES;\n      }\n    }\n\n    //\n\n    const {\n      vertexCount,\n      instanceCount\n    } = drawParams;\n    let {\n      firstVertex\n    } = drawParams;\n    renderer.object = object;\n    if (index !== null) {\n      firstVertex *= index.array.BYTES_PER_ELEMENT;\n      const indexData = this.get(index);\n      renderer.index = index.count;\n      renderer.type = indexData.type;\n    } else {\n      renderer.index = 0;\n    }\n    if (object.isBatchedMesh) {\n      if (object._multiDrawInstances !== null) {\n        renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);\n      } else if (!this.hasFeature('WEBGL_multi_draw')) {\n        warnOnce('THREE.WebGLRenderer: WEBGL_multi_draw not supported.');\n      } else {\n        renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);\n      }\n    } else if (instanceCount > 1) {\n      renderer.renderInstances(firstVertex, vertexCount, instanceCount);\n    } else {\n      renderer.render(firstVertex, vertexCount);\n    }\n    //\n\n    gl.bindVertexArray(null);\n  }\n\n  /**\n   * Explain why always null is returned.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Boolean} Whether the render pipeline requires an update or not.\n   */\n  needsRenderUpdate(/*renderObject*/\n  ) {\n    return false;\n  }\n\n  /**\n   * Explain why no cache key is computed.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {String} The cache key.\n   */\n  getRenderCacheKey(/*renderObject*/\n  ) {\n    return '';\n  }\n\n  // textures\n\n  /**\n   * Creates a default texture for the given texture that can be used\n   * as a placeholder until the actual texture is ready for usage.\n   *\n   * @param {Texture} texture - The texture to create a default texture for.\n   */\n  createDefaultTexture(texture) {\n    this.textureUtils.createDefaultTexture(texture);\n  }\n\n  /**\n   * Defines a texture on the GPU for the given texture object.\n   *\n   * @param {Texture} texture - The texture.\n   * @param {Object} [options={}] - Optional configuration parameter.\n   */\n  createTexture(texture, options) {\n    this.textureUtils.createTexture(texture, options);\n  }\n\n  /**\n   * Uploads the updated texture data to the GPU.\n   *\n   * @param {Texture} texture - The texture.\n   * @param {Object} [options={}] - Optional configuration parameter.\n   */\n  updateTexture(texture, options) {\n    this.textureUtils.updateTexture(texture, options);\n  }\n\n  /**\n   * Generates mipmaps for the given texture\n   *\n   * @param {Texture} texture - The texture.\n   */\n  generateMipmaps(texture) {\n    this.textureUtils.generateMipmaps(texture);\n  }\n\n  /**\n   * Destroys the GPU data for the given texture object.\n   *\n   * @param {Texture} texture - The texture.\n   */\n  destroyTexture(texture) {\n    this.textureUtils.destroyTexture(texture);\n  }\n\n  /**\n   * Returns texture data as a typed array.\n   *\n   * @param {Texture} texture - The texture to copy.\n   * @param {Number} x - The x coordinate of the copy origin.\n   * @param {Number} y - The y coordinate of the copy origin.\n   * @param {Number} width - The width of the copy.\n   * @param {Number} height - The height of the copy.\n   * @param {Number} faceIndex - The face index.\n   * @return {TypedArray} The texture data as a typed array.\n   */\n  copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);\n  }\n\n  /**\n   * This method does nothing since WebGL 2 has no concept of samplers.\n   *\n   * @param {Texture} texture - The texture to create the sampler for.\n   */\n  createSampler(/*texture*/\n  ) {\n\n    //console.warn( 'Abstract class.' );\n  }\n\n  /**\n   * This method does nothing since WebGL 2 has no concept of samplers.\n   *\n   * @param {Texture} texture - The texture to destroy the sampler for.\n   */\n  destroySampler(/*texture*/) {}\n\n  // node builder\n\n  /**\n   * Returns a node builder for the given render object.\n   *\n   * @param {RenderObject} object - The render object.\n   * @param {Renderer} renderer - The renderer.\n   * @return {GLSLNodeBuilder} The node builder.\n   */\n  createNodeBuilder(object, renderer) {\n    return new GLSLNodeBuilder(object, renderer);\n  }\n\n  // program\n\n  /**\n   * Creates a shader program from the given programmable stage.\n   *\n   * @param {ProgrammableStage} program - The programmable stage.\n   */\n  createProgram(program) {\n    const gl = this.gl;\n    const {\n      stage,\n      code\n    } = program;\n    const shader = stage === 'fragment' ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(shader, code);\n    gl.compileShader(shader);\n    this.set(program, {\n      shaderGPU: shader\n    });\n  }\n\n  /**\n   * Destroys the shader program of the given programmable stage.\n   *\n   * @param {ProgrammableStage} program - The programmable stage.\n   */\n  destroyProgram(program) {\n    this.delete(program);\n  }\n\n  /**\n   * Creates a render pipeline for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n   */\n  createRenderPipeline(renderObject, promises) {\n    const gl = this.gl;\n    const pipeline = renderObject.pipeline;\n\n    // Program\n\n    const {\n      fragmentProgram,\n      vertexProgram\n    } = pipeline;\n    const programGPU = gl.createProgram();\n    const fragmentShader = this.get(fragmentProgram).shaderGPU;\n    const vertexShader = this.get(vertexProgram).shaderGPU;\n    gl.attachShader(programGPU, fragmentShader);\n    gl.attachShader(programGPU, vertexShader);\n    gl.linkProgram(programGPU);\n    this.set(pipeline, {\n      programGPU,\n      fragmentShader,\n      vertexShader\n    });\n    if (promises !== null && this.parallel) {\n      const p = new Promise((resolve /*, reject*/) => {\n        const parallel = this.parallel;\n        const checkStatus = () => {\n          if (gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)) {\n            this._completeCompile(renderObject, pipeline);\n            resolve();\n          } else {\n            requestAnimationFrame(checkStatus);\n          }\n        };\n        checkStatus();\n      });\n      promises.push(p);\n      return;\n    }\n    this._completeCompile(renderObject, pipeline);\n  }\n\n  /**\n   * Formats the source code of error messages.\n   *\n   * @private\n   * @param {String} string - The code.\n   * @param {Number} errorLine - The error line.\n   * @return {String} The formatted code.\n   */\n  _handleSource(string, errorLine) {\n    const lines = string.split('\\n');\n    const lines2 = [];\n    const from = Math.max(errorLine - 6, 0);\n    const to = Math.min(errorLine + 6, lines.length);\n    for (let i = from; i < to; i++) {\n      const line = i + 1;\n      lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[i]}`);\n    }\n    return lines2.join('\\n');\n  }\n\n  /**\n   * Gets the shader compilation errors from the info log.\n   *\n   * @private\n   * @param {WebGL2RenderingContext} gl - The rendering context.\n   * @param {WebGLShader} shader - The WebGL shader object.\n   * @param {String} type - The shader type.\n   * @return {String} The shader errors.\n   */\n  _getShaderErrors(gl, shader, type) {\n    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    const errors = gl.getShaderInfoLog(shader).trim();\n    if (status && errors === '') return '';\n    const errorMatches = /ERROR: 0:(\\d+)/.exec(errors);\n    if (errorMatches) {\n      const errorLine = parseInt(errorMatches[1]);\n      return type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + this._handleSource(gl.getShaderSource(shader), errorLine);\n    } else {\n      return errors;\n    }\n  }\n\n  /**\n   * Logs shader compilation errors.\n   *\n   * @private\n   * @param {WebGLProgram} programGPU - The WebGL program.\n   * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.\n   * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.\n   */\n  _logProgramError(programGPU, glFragmentShader, glVertexShader) {\n    if (this.renderer.debug.checkShaderErrors) {\n      const gl = this.gl;\n      const programLog = gl.getProgramInfoLog(programGPU).trim();\n      if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n        if (typeof this.renderer.debug.onShaderError === 'function') {\n          this.renderer.debug.onShaderError(gl, programGPU, glVertexShader, glFragmentShader);\n        } else {\n          // default error reporting\n\n          const vertexErrors = this._getShaderErrors(gl, glVertexShader, 'vertex');\n          const fragmentErrors = this._getShaderErrors(gl, glFragmentShader, 'fragment');\n          console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(programGPU, gl.VALIDATE_STATUS) + '\\n\\n' + 'Program Info Log: ' + programLog + '\\n' + vertexErrors + '\\n' + fragmentErrors);\n        }\n      } else if (programLog !== '') {\n        console.warn('THREE.WebGLProgram: Program Info Log:', programLog);\n      }\n    }\n  }\n\n  /**\n   * Completes the shader program setup for the given render object.\n   *\n   * @private\n   * @param {RenderObject} renderObject - The render object.\n   * @param {RenderPipeline} pipeline - The render pipeline.\n   */\n  _completeCompile(renderObject, pipeline) {\n    const {\n      state,\n      gl\n    } = this;\n    const pipelineData = this.get(pipeline);\n    const {\n      programGPU,\n      fragmentShader,\n      vertexShader\n    } = pipelineData;\n    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n      this._logProgramError(programGPU, fragmentShader, vertexShader);\n    }\n    state.useProgram(programGPU);\n\n    // Bindings\n\n    const bindings = renderObject.getBindings();\n    this._setupBindings(bindings, programGPU);\n\n    //\n\n    this.set(pipeline, {\n      programGPU\n    });\n  }\n\n  /**\n   * Creates a compute pipeline for the given compute node.\n   *\n   * @param {ComputePipeline} computePipeline - The compute pipeline.\n   * @param {Array<BindGroup>} bindings - The bindings.\n   */\n  createComputePipeline(computePipeline, bindings) {\n    const {\n      state,\n      gl\n    } = this;\n\n    // Program\n\n    const fragmentProgram = {\n      stage: 'fragment',\n      code: '#version 300 es\\nprecision highp float;\\nvoid main() {}'\n    };\n    this.createProgram(fragmentProgram);\n    const {\n      computeProgram\n    } = computePipeline;\n    const programGPU = gl.createProgram();\n    const fragmentShader = this.get(fragmentProgram).shaderGPU;\n    const vertexShader = this.get(computeProgram).shaderGPU;\n    const transforms = computeProgram.transforms;\n    const transformVaryingNames = [];\n    const transformAttributeNodes = [];\n    for (let i = 0; i < transforms.length; i++) {\n      const transform = transforms[i];\n      transformVaryingNames.push(transform.varyingName);\n      transformAttributeNodes.push(transform.attributeNode);\n    }\n    gl.attachShader(programGPU, fragmentShader);\n    gl.attachShader(programGPU, vertexShader);\n    gl.transformFeedbackVaryings(programGPU, transformVaryingNames, gl.SEPARATE_ATTRIBS);\n    gl.linkProgram(programGPU);\n    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n      this._logProgramError(programGPU, fragmentShader, vertexShader);\n    }\n    state.useProgram(programGPU);\n\n    // Bindings\n\n    this._setupBindings(bindings, programGPU);\n    const attributeNodes = computeProgram.attributes;\n    const attributes = [];\n    const transformBuffers = [];\n    for (let i = 0; i < attributeNodes.length; i++) {\n      const attribute = attributeNodes[i].node.attribute;\n      attributes.push(attribute);\n      if (!this.has(attribute)) this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n    }\n    for (let i = 0; i < transformAttributeNodes.length; i++) {\n      const attribute = transformAttributeNodes[i].attribute;\n      if (!this.has(attribute)) this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n      const attributeData = this.get(attribute);\n      transformBuffers.push(attributeData);\n    }\n\n    //\n\n    this.set(computePipeline, {\n      programGPU,\n      transformBuffers,\n      attributes\n    });\n  }\n\n  /**\n   * Creates bindings from the given bind group definition.\n   *\n   * @param {BindGroup} bindGroup - The bind group.\n   * @param {Array<BindGroup>} bindings - Array of bind groups.\n   * @param {Number} cacheIndex - The cache index.\n   * @param {Number} version - The version.\n   */\n  createBindings(bindGroup, bindings /*, cacheIndex, version*/) {\n    if (this._knownBindings.has(bindings) === false) {\n      this._knownBindings.add(bindings);\n      let uniformBuffers = 0;\n      let textures = 0;\n      for (const bindGroup of bindings) {\n        this.set(bindGroup, {\n          textures: textures,\n          uniformBuffers: uniformBuffers\n        });\n        for (const binding of bindGroup.bindings) {\n          if (binding.isUniformBuffer) uniformBuffers++;\n          if (binding.isSampledTexture) textures++;\n        }\n      }\n    }\n    this.updateBindings(bindGroup, bindings);\n  }\n\n  /**\n   * Updates the given bind group definition.\n   *\n   * @param {BindGroup} bindGroup - The bind group.\n   * @param {Array<BindGroup>} bindings - Array of bind groups.\n   * @param {Number} cacheIndex - The cache index.\n   * @param {Number} version - The version.\n   */\n  updateBindings(bindGroup /*, bindings, cacheIndex, version*/) {\n    const {\n      gl\n    } = this;\n    const bindGroupData = this.get(bindGroup);\n    let i = bindGroupData.uniformBuffers;\n    let t = bindGroupData.textures;\n    for (const binding of bindGroup.bindings) {\n      if (binding.isUniformsGroup || binding.isUniformBuffer) {\n        const data = binding.buffer;\n        const bufferGPU = gl.createBuffer();\n        gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);\n        gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);\n        this.set(binding, {\n          index: i++,\n          bufferGPU\n        });\n      } else if (binding.isSampledTexture) {\n        const {\n          textureGPU,\n          glTextureType\n        } = this.get(binding.texture);\n        this.set(binding, {\n          index: t++,\n          textureGPU,\n          glTextureType\n        });\n      }\n    }\n  }\n\n  /**\n   * Updates a buffer binding.\n   *\n   *  @param {Buffer} binding - The buffer binding to update.\n   */\n  updateBinding(binding) {\n    const gl = this.gl;\n    if (binding.isUniformsGroup || binding.isUniformBuffer) {\n      const bindingData = this.get(binding);\n      const bufferGPU = bindingData.bufferGPU;\n      const data = binding.buffer;\n      gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);\n      gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);\n    }\n  }\n\n  // attributes\n\n  /**\n   * Creates the buffer of an indexed shader attribute.\n   *\n   * @param {BufferAttribute} attribute - The indexed buffer attribute.\n   */\n  createIndexAttribute(attribute) {\n    const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);\n  }\n\n  /**\n   * Creates the buffer of a shader attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute.\n   */\n  createAttribute(attribute) {\n    if (this.has(attribute)) return;\n    const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n  }\n\n  /**\n   * Creates the buffer of a storage attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute.\n   */\n  createStorageAttribute(attribute) {\n    if (this.has(attribute)) return;\n    const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n  }\n\n  /**\n   * Updates the buffer of a shader attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute to update.\n   */\n  updateAttribute(attribute) {\n    this.attributeUtils.updateAttribute(attribute);\n  }\n\n  /**\n   * Destroys the buffer of a shader attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n   */\n  destroyAttribute(attribute) {\n    this.attributeUtils.destroyAttribute(attribute);\n  }\n\n  /**\n   * Checks if the given feature is supported  by the backend.\n   *\n   * @param {String} name - The feature's name.\n   * @return {Boolean} Whether the feature is supported or not.\n   */\n  hasFeature(name) {\n    const keysMatching = Object.keys(GLFeatureName).filter(key => GLFeatureName[key] === name);\n    const extensions = this.extensions;\n    for (let i = 0; i < keysMatching.length; i++) {\n      if (extensions.has(keysMatching[i])) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns the maximum anisotropy texture filtering value.\n   *\n   * @return {Number} The maximum anisotropy texture filtering value.\n   */\n  getMaxAnisotropy() {\n    return this.capabilities.getMaxAnisotropy();\n  }\n\n  /**\n   * Copies data of the given source texture to the given destination texture.\n   *\n   * @param {Texture} srcTexture - The source texture.\n   * @param {Texture} dstTexture - The destination texture.\n   * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n   * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n   * @param {Number} [level=0] - The mip level to copy.\n   */\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n    this.textureUtils.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);\n  }\n\n  /**\n   * Copies the current bound framebuffer to the given texture.\n   *\n   * @param {Texture} texture - The destination texture.\n   * @param {RenderContext} renderContext - The render context.\n   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n   */\n  copyFramebufferToTexture(texture, renderContext, rectangle) {\n    this.textureUtils.copyFramebufferToTexture(texture, renderContext, rectangle);\n  }\n\n  /**\n   * Configures the active framebuffer from the given render context.\n   *\n   * @private\n   * @param {RenderContext} descriptor - The render context.\n   */\n  _setFramebuffer(descriptor) {\n    const {\n      gl,\n      state\n    } = this;\n    let currentFrameBuffer = null;\n    if (descriptor.textures !== null) {\n      const renderTarget = descriptor.renderTarget;\n      const renderTargetContextData = this.get(renderTarget);\n      const {\n        samples,\n        depthBuffer,\n        stencilBuffer\n      } = renderTarget;\n      const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n      const isRenderTarget3D = renderTarget.isRenderTarget3D === true;\n      const isRenderTargetArray = renderTarget.isRenderTargetArray === true;\n      let msaaFb = renderTargetContextData.msaaFrameBuffer;\n      let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;\n      const cacheKey = getCacheKey(descriptor);\n      let fb;\n      if (isCube) {\n        renderTargetContextData.cubeFramebuffers || (renderTargetContextData.cubeFramebuffers = {});\n        fb = renderTargetContextData.cubeFramebuffers[cacheKey];\n      } else {\n        renderTargetContextData.framebuffers || (renderTargetContextData.framebuffers = {});\n        fb = renderTargetContextData.framebuffers[cacheKey];\n      }\n      if (fb === undefined) {\n        fb = gl.createFramebuffer();\n        state.bindFramebuffer(gl.FRAMEBUFFER, fb);\n        const textures = descriptor.textures;\n        if (isCube) {\n          renderTargetContextData.cubeFramebuffers[cacheKey] = fb;\n          const {\n            textureGPU\n          } = this.get(textures[0]);\n          const cubeFace = this.renderer._activeCubeFace;\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0);\n        } else {\n          renderTargetContextData.framebuffers[cacheKey] = fb;\n          for (let i = 0; i < textures.length; i++) {\n            const texture = textures[i];\n            const textureData = this.get(texture);\n            textureData.renderTarget = descriptor.renderTarget;\n            textureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n            const attachment = gl.COLOR_ATTACHMENT0 + i;\n            if (isRenderTarget3D || isRenderTargetArray) {\n              const layer = this.renderer._activeCubeFace;\n              gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, layer);\n            } else {\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0);\n            }\n          }\n          state.drawBuffers(descriptor, fb);\n        }\n        if (descriptor.depthTexture !== null) {\n          const textureData = this.get(descriptor.depthTexture);\n          const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n          textureData.renderTarget = descriptor.renderTarget;\n          textureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0);\n        }\n      }\n      if (samples > 0) {\n        if (msaaFb === undefined) {\n          const invalidationArray = [];\n          msaaFb = gl.createFramebuffer();\n          state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);\n          const msaaRenderbuffers = [];\n          const textures = descriptor.textures;\n          for (let i = 0; i < textures.length; i++) {\n            msaaRenderbuffers[i] = gl.createRenderbuffer();\n            gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i]);\n            invalidationArray.push(gl.COLOR_ATTACHMENT0 + i);\n            if (depthBuffer) {\n              const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n              invalidationArray.push(depthStyle);\n            }\n            const texture = descriptor.textures[i];\n            const textureData = this.get(texture);\n            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height);\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);\n          }\n          renderTargetContextData.msaaFrameBuffer = msaaFb;\n          renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n          if (depthRenderbuffer === undefined) {\n            depthRenderbuffer = gl.createRenderbuffer();\n            this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, descriptor);\n            renderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n            const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n            invalidationArray.push(depthStyle);\n          }\n          renderTargetContextData.invalidationArray = invalidationArray;\n        }\n        currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n      } else {\n        currentFrameBuffer = fb;\n      }\n    }\n    state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);\n  }\n\n  /**\n   * Computes the VAO key for the given index and attributes.\n   *\n   * @private\n   * @param {BufferAttribute?} index - The index. `null` for non-indexed geometries.\n   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n   * @return {String} The VAO key.\n   */\n  _getVaoKey(index, attributes) {\n    let key = '';\n    if (index !== null) {\n      const indexData = this.get(index);\n      key += ':' + indexData.id;\n    }\n    for (let i = 0; i < attributes.length; i++) {\n      const attributeData = this.get(attributes[i]);\n      key += ':' + attributeData.id;\n    }\n    return key;\n  }\n\n  /**\n   * Creates a VAO from the index and attributes.\n   *\n   * @private\n   * @param {BufferAttribute?} index - The index. `null` for non-indexed geometries.\n   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n   * @return {Object} The VAO data.\n   */\n  _createVao(index, attributes) {\n    const {\n      gl\n    } = this;\n    const vaoGPU = gl.createVertexArray();\n    let key = '';\n    let staticVao = true;\n    gl.bindVertexArray(vaoGPU);\n    if (index !== null) {\n      const indexData = this.get(index);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU);\n      key += ':' + indexData.id;\n    }\n    for (let i = 0; i < attributes.length; i++) {\n      const attribute = attributes[i];\n      const attributeData = this.get(attribute);\n      key += ':' + attributeData.id;\n      gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);\n      gl.enableVertexAttribArray(i);\n      if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) staticVao = false;\n      let stride, offset;\n      if (attribute.isInterleavedBufferAttribute === true) {\n        stride = attribute.data.stride * attributeData.bytesPerElement;\n        offset = attribute.offset * attributeData.bytesPerElement;\n      } else {\n        stride = 0;\n        offset = 0;\n      }\n      if (attributeData.isInteger) {\n        gl.vertexAttribIPointer(i, attribute.itemSize, attributeData.type, stride, offset);\n      } else {\n        gl.vertexAttribPointer(i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset);\n      }\n      if (attribute.isInstancedBufferAttribute && !attribute.isInterleavedBufferAttribute) {\n        gl.vertexAttribDivisor(i, attribute.meshPerAttribute);\n      } else if (attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer) {\n        gl.vertexAttribDivisor(i, attribute.data.meshPerAttribute);\n      }\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    this.vaoCache[key] = vaoGPU;\n    return {\n      vaoGPU,\n      staticVao\n    };\n  }\n\n  /**\n   * Creates a tranform feedback from the given transform buffers.\n   *\n   * @private\n   * @param {Array<DualAttributeData>} transformBuffers - The tranform buffers.\n   * @return {WebGLTransformFeedback} The tranform feedback.\n   */\n  _getTransformFeedback(transformBuffers) {\n    let key = '';\n    for (let i = 0; i < transformBuffers.length; i++) {\n      key += ':' + transformBuffers[i].id;\n    }\n    let transformFeedbackGPU = this.transformFeedbackCache[key];\n    if (transformFeedbackGPU !== undefined) {\n      return transformFeedbackGPU;\n    }\n    const {\n      gl\n    } = this;\n    transformFeedbackGPU = gl.createTransformFeedback();\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);\n    for (let i = 0; i < transformBuffers.length; i++) {\n      const attributeData = transformBuffers[i];\n      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer);\n    }\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n    this.transformFeedbackCache[key] = transformFeedbackGPU;\n    return transformFeedbackGPU;\n  }\n\n  /**\n   * Setups the given bindings.\n   *\n   * @private\n   * @param {Array<BindGroup>} bindings - The bindings.\n   * @param {WebGLProgram} programGPU - The WebGL program.\n   */\n  _setupBindings(bindings, programGPU) {\n    const gl = this.gl;\n    for (const bindGroup of bindings) {\n      for (const binding of bindGroup.bindings) {\n        const bindingData = this.get(binding);\n        const index = bindingData.index;\n        if (binding.isUniformsGroup || binding.isUniformBuffer) {\n          const location = gl.getUniformBlockIndex(programGPU, binding.name);\n          gl.uniformBlockBinding(programGPU, location, index);\n        } else if (binding.isSampledTexture) {\n          const location = gl.getUniformLocation(programGPU, binding.name);\n          gl.uniform1i(location, index);\n        }\n      }\n    }\n  }\n\n  /**\n   * Binds the given uniforms.\n   *\n   * @private\n   * @param {Array<BindGroup>} bindings - The bindings.\n   */\n  _bindUniforms(bindings) {\n    const {\n      gl,\n      state\n    } = this;\n    for (const bindGroup of bindings) {\n      for (const binding of bindGroup.bindings) {\n        const bindingData = this.get(binding);\n        const index = bindingData.index;\n        if (binding.isUniformsGroup || binding.isUniformBuffer) {\n          // TODO USE bindBufferRange to group multiple uniform buffers\n          state.bindBufferBase(gl.UNIFORM_BUFFER, index, bindingData.bufferGPU);\n        } else if (binding.isSampledTexture) {\n          state.bindTexture(bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index);\n        }\n      }\n    }\n  }\n\n  /**\n   * Frees internal resources.\n   */\n  dispose() {\n    this.renderer.domElement.removeEventListener('webglcontextlost', this._onContextLost);\n  }\n}\nconst GPUPrimitiveTopology = {\n  PointList: 'point-list',\n  LineList: 'line-list',\n  LineStrip: 'line-strip',\n  TriangleList: 'triangle-list',\n  TriangleStrip: 'triangle-strip'\n};\nconst GPUCompareFunction = {\n  Never: 'never',\n  Less: 'less',\n  Equal: 'equal',\n  LessEqual: 'less-equal',\n  Greater: 'greater',\n  NotEqual: 'not-equal',\n  GreaterEqual: 'greater-equal',\n  Always: 'always'\n};\nconst GPUStoreOp = {\n  Store: 'store',\n  Discard: 'discard'\n};\nconst GPULoadOp = {\n  Load: 'load',\n  Clear: 'clear'\n};\nconst GPUFrontFace = {\n  CCW: 'ccw',\n  CW: 'cw'\n};\nconst GPUCullMode = {\n  None: 'none',\n  Front: 'front',\n  Back: 'back'\n};\nconst GPUIndexFormat = {\n  Uint16: 'uint16',\n  Uint32: 'uint32'\n};\nconst GPUTextureFormat = {\n  // 8-bit formats\n\n  R8Unorm: 'r8unorm',\n  R8Snorm: 'r8snorm',\n  R8Uint: 'r8uint',\n  R8Sint: 'r8sint',\n  // 16-bit formats\n\n  R16Uint: 'r16uint',\n  R16Sint: 'r16sint',\n  R16Float: 'r16float',\n  RG8Unorm: 'rg8unorm',\n  RG8Snorm: 'rg8snorm',\n  RG8Uint: 'rg8uint',\n  RG8Sint: 'rg8sint',\n  // 32-bit formats\n\n  R32Uint: 'r32uint',\n  R32Sint: 'r32sint',\n  R32Float: 'r32float',\n  RG16Uint: 'rg16uint',\n  RG16Sint: 'rg16sint',\n  RG16Float: 'rg16float',\n  RGBA8Unorm: 'rgba8unorm',\n  RGBA8UnormSRGB: 'rgba8unorm-srgb',\n  RGBA8Snorm: 'rgba8snorm',\n  RGBA8Uint: 'rgba8uint',\n  RGBA8Sint: 'rgba8sint',\n  BGRA8Unorm: 'bgra8unorm',\n  BGRA8UnormSRGB: 'bgra8unorm-srgb',\n  // Packed 32-bit formats\n  RGB9E5UFloat: 'rgb9e5ufloat',\n  RGB10A2Unorm: 'rgb10a2unorm',\n  RG11B10uFloat: 'rgb10a2unorm',\n  // 64-bit formats\n\n  RG32Uint: 'rg32uint',\n  RG32Sint: 'rg32sint',\n  RG32Float: 'rg32float',\n  RGBA16Uint: 'rgba16uint',\n  RGBA16Sint: 'rgba16sint',\n  RGBA16Float: 'rgba16float',\n  // 128-bit formats\n\n  RGBA32Uint: 'rgba32uint',\n  RGBA32Sint: 'rgba32sint',\n  RGBA32Float: 'rgba32float',\n  // Depth and stencil formats\n\n  Stencil8: 'stencil8',\n  Depth16Unorm: 'depth16unorm',\n  Depth24Plus: 'depth24plus',\n  Depth24PlusStencil8: 'depth24plus-stencil8',\n  Depth32Float: 'depth32float',\n  // 'depth32float-stencil8' extension\n\n  Depth32FloatStencil8: 'depth32float-stencil8',\n  // BC compressed formats usable if 'texture-compression-bc' is both\n  // supported by the device/user agent and enabled in requestDevice.\n\n  BC1RGBAUnorm: 'bc1-rgba-unorm',\n  BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',\n  BC2RGBAUnorm: 'bc2-rgba-unorm',\n  BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',\n  BC3RGBAUnorm: 'bc3-rgba-unorm',\n  BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',\n  BC4RUnorm: 'bc4-r-unorm',\n  BC4RSnorm: 'bc4-r-snorm',\n  BC5RGUnorm: 'bc5-rg-unorm',\n  BC5RGSnorm: 'bc5-rg-snorm',\n  BC6HRGBUFloat: 'bc6h-rgb-ufloat',\n  BC6HRGBFloat: 'bc6h-rgb-float',\n  BC7RGBAUnorm: 'bc7-rgba-unorm',\n  BC7RGBAUnormSRGB: 'bc7-rgba-srgb',\n  // ETC2 compressed formats usable if 'texture-compression-etc2' is both\n  // supported by the device/user agent and enabled in requestDevice.\n\n  ETC2RGB8Unorm: 'etc2-rgb8unorm',\n  ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',\n  ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',\n  ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',\n  ETC2RGBA8Unorm: 'etc2-rgba8unorm',\n  ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',\n  EACR11Unorm: 'eac-r11unorm',\n  EACR11Snorm: 'eac-r11snorm',\n  EACRG11Unorm: 'eac-rg11unorm',\n  EACRG11Snorm: 'eac-rg11snorm',\n  // ASTC compressed formats usable if 'texture-compression-astc' is both\n  // supported by the device/user agent and enabled in requestDevice.\n\n  ASTC4x4Unorm: 'astc-4x4-unorm',\n  ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',\n  ASTC5x4Unorm: 'astc-5x4-unorm',\n  ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',\n  ASTC5x5Unorm: 'astc-5x5-unorm',\n  ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',\n  ASTC6x5Unorm: 'astc-6x5-unorm',\n  ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',\n  ASTC6x6Unorm: 'astc-6x6-unorm',\n  ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',\n  ASTC8x5Unorm: 'astc-8x5-unorm',\n  ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',\n  ASTC8x6Unorm: 'astc-8x6-unorm',\n  ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',\n  ASTC8x8Unorm: 'astc-8x8-unorm',\n  ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',\n  ASTC10x5Unorm: 'astc-10x5-unorm',\n  ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',\n  ASTC10x6Unorm: 'astc-10x6-unorm',\n  ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',\n  ASTC10x8Unorm: 'astc-10x8-unorm',\n  ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',\n  ASTC10x10Unorm: 'astc-10x10-unorm',\n  ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',\n  ASTC12x10Unorm: 'astc-12x10-unorm',\n  ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',\n  ASTC12x12Unorm: 'astc-12x12-unorm',\n  ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb'\n};\nconst GPUAddressMode = {\n  ClampToEdge: 'clamp-to-edge',\n  Repeat: 'repeat',\n  MirrorRepeat: 'mirror-repeat'\n};\nconst GPUFilterMode = {\n  Linear: 'linear',\n  Nearest: 'nearest'\n};\nconst GPUBlendFactor = {\n  Zero: 'zero',\n  One: 'one',\n  Src: 'src',\n  OneMinusSrc: 'one-minus-src',\n  SrcAlpha: 'src-alpha',\n  OneMinusSrcAlpha: 'one-minus-src-alpha',\n  Dst: 'dst',\n  OneMinusDstColor: 'one-minus-dst',\n  DstAlpha: 'dst-alpha',\n  OneMinusDstAlpha: 'one-minus-dst-alpha',\n  SrcAlphaSaturated: 'src-alpha-saturated',\n  Constant: 'constant',\n  OneMinusConstant: 'one-minus-constant'\n};\nconst GPUBlendOperation = {\n  Add: 'add',\n  Subtract: 'subtract',\n  ReverseSubtract: 'reverse-subtract',\n  Min: 'min',\n  Max: 'max'\n};\nconst GPUColorWriteFlags = {\n  None: 0,\n  Red: 0x1,\n  Green: 0x2,\n  Blue: 0x4,\n  Alpha: 0x8,\n  All: 0xF\n};\nconst GPUStencilOperation = {\n  Keep: 'keep',\n  Zero: 'zero',\n  Replace: 'replace',\n  Invert: 'invert',\n  IncrementClamp: 'increment-clamp',\n  DecrementClamp: 'decrement-clamp',\n  IncrementWrap: 'increment-wrap',\n  DecrementWrap: 'decrement-wrap'\n};\nconst GPUBufferBindingType = {\n  Uniform: 'uniform',\n  Storage: 'storage',\n  ReadOnlyStorage: 'read-only-storage'\n};\nconst GPUStorageTextureAccess = {\n  WriteOnly: 'write-only',\n  ReadOnly: 'read-only',\n  ReadWrite: 'read-write'\n};\nconst GPUTextureSampleType = {\n  Float: 'float',\n  UnfilterableFloat: 'unfilterable-float',\n  Depth: 'depth',\n  SInt: 'sint',\n  UInt: 'uint'\n};\nconst GPUTextureDimension = {\n  OneD: '1d',\n  TwoD: '2d',\n  ThreeD: '3d'\n};\nconst GPUTextureViewDimension = {\n  OneD: '1d',\n  TwoD: '2d',\n  TwoDArray: '2d-array',\n  Cube: 'cube',\n  CubeArray: 'cube-array',\n  ThreeD: '3d'\n};\nconst GPUTextureAspect = {\n  All: 'all',\n  StencilOnly: 'stencil-only',\n  DepthOnly: 'depth-only'\n};\nconst GPUInputStepMode = {\n  Vertex: 'vertex',\n  Instance: 'instance'\n};\nconst GPUFeatureName = {\n  DepthClipControl: 'depth-clip-control',\n  Depth32FloatStencil8: 'depth32float-stencil8',\n  TextureCompressionBC: 'texture-compression-bc',\n  TextureCompressionETC2: 'texture-compression-etc2',\n  TextureCompressionASTC: 'texture-compression-astc',\n  TimestampQuery: 'timestamp-query',\n  IndirectFirstInstance: 'indirect-first-instance',\n  ShaderF16: 'shader-f16',\n  RG11B10UFloat: 'rg11b10ufloat-renderable',\n  BGRA8UNormStorage: 'bgra8unorm-storage',\n  Float32Filterable: 'float32-filterable',\n  ClipDistances: 'clip-distances',\n  DualSourceBlending: 'dual-source-blending',\n  Subgroups: 'subgroups'\n};\n\n/**\n * Represents a sampler binding type.\n *\n * @private\n * @augments Binding\n */\nclass Sampler extends Binding {\n  /**\n   * Constructs a new sampler.\n   *\n   * @param {String} name - The samplers's name.\n   * @param {Texture?} texture - The texture this binding is referring to.\n   */\n  constructor(name, texture) {\n    super(name);\n\n    /**\n     * The texture the sampler is referring to.\n     *\n     * @type {Texture?}\n     */\n    this.texture = texture;\n\n    /**\n     * The binding's version.\n     *\n     * @type {Number}\n     */\n    this.version = texture ? texture.version : 0;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isSampler = true;\n  }\n}\n\n/**\n * A special form of sampler binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments Sampler\n */\nclass NodeSampler extends Sampler {\n  /**\n   * Constructs a new node-based sampler.\n   *\n   * @param {String} name - The samplers's name.\n   * @param {TextureNode} textureNode - The texture node.\n   * @param {UniformGroupNode} groupNode - The uniform group node.\n   */\n  constructor(name, textureNode, groupNode) {\n    super(name, textureNode ? textureNode.value : null);\n\n    /**\n     * The texture node.\n     *\n     * @type {TextureNode}\n     */\n    this.textureNode = textureNode;\n\n    /**\n     * The uniform group node.\n     *\n     * @type {UniformGroupNode}\n     */\n    this.groupNode = groupNode;\n  }\n\n  /**\n   * Updates the texture value of this sampler.\n   */\n  update() {\n    this.texture = this.textureNode.value;\n  }\n}\n\n/**\n * Represents a storage buffer binding type.\n *\n * @private\n * @augments Buffer\n */\nclass StorageBuffer extends Buffer {\n  /**\n   * Constructs a new uniform buffer.\n   *\n   * @param {String} name - The buffer's name.\n   * @param {BufferAttribute} attribute - The buffer attribute.\n   */\n  constructor(name, attribute) {\n    super(name, attribute ? attribute.array : null);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {BufferAttribute}\n     */\n    this.attribute = attribute;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isStorageBuffer = true;\n  }\n}\nlet _id = 0;\n\n/**\n * A special form of storage buffer binding type.\n * It's buffer value is managed by a node object.\n *\n * @private\n * @augments StorageBuffer\n */\nclass NodeStorageBuffer extends StorageBuffer {\n  /**\n   * Constructs a new node-based storage buffer.\n   *\n   * @param {StorageBufferNode} nodeUniform - The storage buffer node.\n   * @param {UniformGroupNode} groupNode - The uniform group node.\n   */\n  constructor(nodeUniform, groupNode) {\n    super('StorageBuffer_' + _id++, nodeUniform ? nodeUniform.value : null);\n\n    /**\n     * The node uniform.\n     *\n     * @type {StorageBufferNode}\n     */\n    this.nodeUniform = nodeUniform;\n\n    /**\n     * The access type.\n     *\n     * @type {String}\n     */\n    this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;\n\n    /**\n     * The uniform group node.\n     *\n     * @type {UniformGroupNode}\n     */\n    this.groupNode = groupNode;\n  }\n\n  /**\n   * The storage buffer.\n   *\n   * @type {BufferAttribute}\n   */\n  get buffer() {\n    return this.nodeUniform.value;\n  }\n}\nclass WebGPUTexturePassUtils extends DataMap {\n  constructor(device) {\n    super();\n    this.device = device;\n    const mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n    const mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n    const flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n    this.mipmapSampler = device.createSampler({\n      minFilter: GPUFilterMode.Linear\n    });\n    this.flipYSampler = device.createSampler({\n      minFilter: GPUFilterMode.Nearest\n    }); //@TODO?: Consider using textureLoad()\n\n    // We'll need a new pipeline for every texture format used.\n    this.transferPipelines = {};\n    this.flipYPipelines = {};\n    this.mipmapVertexShaderModule = device.createShaderModule({\n      label: 'mipmapVertex',\n      code: mipmapVertexSource\n    });\n    this.mipmapFragmentShaderModule = device.createShaderModule({\n      label: 'mipmapFragment',\n      code: mipmapFragmentSource\n    });\n    this.flipYFragmentShaderModule = device.createShaderModule({\n      label: 'flipYFragment',\n      code: flipYFragmentSource\n    });\n  }\n  getTransferPipeline(format) {\n    let pipeline = this.transferPipelines[format];\n    if (pipeline === undefined) {\n      pipeline = this.device.createRenderPipeline({\n        label: `mipmap-${format}`,\n        vertex: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main'\n        },\n        fragment: {\n          module: this.mipmapFragmentShaderModule,\n          entryPoint: 'main',\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: GPUIndexFormat.Uint32\n        },\n        layout: 'auto'\n      });\n      this.transferPipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  getFlipYPipeline(format) {\n    let pipeline = this.flipYPipelines[format];\n    if (pipeline === undefined) {\n      pipeline = this.device.createRenderPipeline({\n        label: `flipY-${format}`,\n        vertex: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main'\n        },\n        fragment: {\n          module: this.flipYFragmentShaderModule,\n          entryPoint: 'main',\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: GPUIndexFormat.Uint32\n        },\n        layout: 'auto'\n      });\n      this.flipYPipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {\n    const format = textureGPUDescriptor.format;\n    const {\n      width,\n      height\n    } = textureGPUDescriptor.size;\n    const transferPipeline = this.getTransferPipeline(format);\n    const flipYPipeline = this.getFlipYPipeline(format);\n    const tempTexture = this.device.createTexture({\n      size: {\n        width,\n        height,\n        depthOrArrayLayers: 1\n      },\n      format,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n    });\n    const srcView = textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n    const dstView = tempTexture.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer: 0\n    });\n    const commandEncoder = this.device.createCommandEncoder({});\n    const pass = (pipeline, sourceView, destinationView) => {\n      const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.\n\n      const bindGroup = this.device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this.flipYSampler\n        }, {\n          binding: 1,\n          resource: sourceView\n        }]\n      });\n      const passEncoder = commandEncoder.beginRenderPass({\n        colorAttachments: [{\n          view: destinationView,\n          loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          clearValue: [0, 0, 0, 0]\n        }]\n      });\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passEncoder.end();\n    };\n    pass(transferPipeline, srcView, dstView);\n    pass(flipYPipeline, dstView, srcView);\n    this.device.queue.submit([commandEncoder.finish()]);\n    tempTexture.destroy();\n  }\n  generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {\n    const textureData = this.get(textureGPU);\n    if (textureData.useCount === undefined) {\n      textureData.useCount = 0;\n      textureData.layers = [];\n    }\n    const passes = textureData.layers[baseArrayLayer] || this._mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer);\n    const commandEncoder = this.device.createCommandEncoder({});\n    this._mipmapRunBundles(commandEncoder, passes);\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (textureData.useCount !== 0) textureData.layers[baseArrayLayer] = passes;\n    textureData.useCount++;\n  }\n  _mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer) {\n    const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);\n    const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.\n\n    let srcView = textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n    const passes = [];\n    for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {\n      const bindGroup = this.device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this.mipmapSampler\n        }, {\n          binding: 1,\n          resource: srcView\n        }]\n      });\n      const dstView = textureGPU.createView({\n        baseMipLevel: i,\n        mipLevelCount: 1,\n        dimension: GPUTextureViewDimension.TwoD,\n        baseArrayLayer\n      });\n      const passDescriptor = {\n        colorAttachments: [{\n          view: dstView,\n          loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          clearValue: [0, 0, 0, 0]\n        }]\n      };\n      const passEncoder = this.device.createRenderBundleEncoder({\n        colorFormats: [textureGPUDescriptor.format]\n      });\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passes.push({\n        renderBundles: [passEncoder.finish()],\n        passDescriptor\n      });\n      srcView = dstView;\n    }\n    return passes;\n  }\n  _mipmapRunBundles(commandEncoder, passes) {\n    const levels = passes.length;\n    for (let i = 0; i < levels; i++) {\n      const pass = passes[i];\n      const passEncoder = commandEncoder.beginRenderPass(pass.passDescriptor);\n      passEncoder.executeBundles(pass.renderBundles);\n      passEncoder.end();\n    }\n  }\n}\nconst _compareToWebGPU = {\n  [NeverCompare]: 'never',\n  [LessCompare]: 'less',\n  [EqualCompare]: 'equal',\n  [LessEqualCompare]: 'less-equal',\n  [GreaterCompare]: 'greater',\n  [GreaterEqualCompare]: 'greater-equal',\n  [AlwaysCompare]: 'always',\n  [NotEqualCompare]: 'not-equal'\n};\nconst _flipMap = [0, 1, 3, 2, 4, 5];\nclass WebGPUTextureUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this._passUtils = null;\n    this.defaultTexture = {};\n    this.defaultCubeTexture = {};\n    this.defaultVideoFrame = null;\n    this.colorBuffer = null;\n    this.depthTexture = new DepthTexture();\n    this.depthTexture.name = 'depthBuffer';\n  }\n  createSampler(texture) {\n    const backend = this.backend;\n    const device = backend.device;\n    const textureGPU = backend.get(texture);\n    const samplerDescriptorGPU = {\n      addressModeU: this._convertAddressMode(texture.wrapS),\n      addressModeV: this._convertAddressMode(texture.wrapT),\n      addressModeW: this._convertAddressMode(texture.wrapR),\n      magFilter: this._convertFilterMode(texture.magFilter),\n      minFilter: this._convertFilterMode(texture.minFilter),\n      mipmapFilter: this._convertFilterMode(texture.minFilter),\n      maxAnisotropy: 1\n    };\n\n    // anisotropy can only be used when all filter modes are set to linear.\n\n    if (samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear) {\n      samplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n    }\n    if (texture.isDepthTexture && texture.compareFunction !== null) {\n      samplerDescriptorGPU.compare = _compareToWebGPU[texture.compareFunction];\n    }\n    textureGPU.sampler = device.createSampler(samplerDescriptorGPU);\n  }\n  createDefaultTexture(texture) {\n    let textureGPU;\n    const format = getFormat(texture);\n    if (texture.isCubeTexture) {\n      textureGPU = this._getDefaultCubeTextureGPU(format);\n    } else if (texture.isVideoTexture) {\n      this.backend.get(texture).externalTexture = this._getDefaultVideoFrame();\n    } else {\n      textureGPU = this._getDefaultTextureGPU(format);\n    }\n    this.backend.get(texture).texture = textureGPU;\n  }\n  createTexture(texture, options = {}) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    if (textureData.initialized) {\n      throw new Error('WebGPUTextureUtils: Texture already initialized.');\n    }\n    if (options.needsMipmaps === undefined) options.needsMipmaps = false;\n    if (options.levels === undefined) options.levels = 1;\n    if (options.depth === undefined) options.depth = 1;\n    const {\n      width,\n      height,\n      depth,\n      levels\n    } = options;\n    if (texture.isFramebufferTexture) {\n      if (options.renderTarget) {\n        options.format = this.backend.utils.getCurrentColorFormat(options.renderTarget);\n      } else {\n        options.format = this.backend.utils.getPreferredCanvasFormat();\n      }\n    }\n    const dimension = this._getDimension(texture);\n    const format = texture.internalFormat || options.format || getFormat(texture, backend.device);\n    textureData.format = format;\n    const {\n      samples,\n      primarySamples,\n      isMSAA\n    } = backend.utils.getTextureSampleData(texture);\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n    if (texture.isStorageTexture === true) {\n      usage |= GPUTextureUsage.STORAGE_BINDING;\n    }\n    if (texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true) {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    }\n    const textureDescriptorGPU = {\n      label: texture.name,\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: depth\n      },\n      mipLevelCount: levels,\n      sampleCount: primarySamples,\n      dimension: dimension,\n      format: format,\n      usage: usage\n    };\n\n    // texture creation\n\n    if (texture.isVideoTexture) {\n      const video = texture.source.data;\n      const videoFrame = new VideoFrame(video);\n      textureDescriptorGPU.size.width = videoFrame.displayWidth;\n      textureDescriptorGPU.size.height = videoFrame.displayHeight;\n      videoFrame.close();\n      textureData.externalTexture = video;\n    } else {\n      if (format === undefined) {\n        console.warn('WebGPURenderer: Texture format not supported.');\n        return this.createDefaultTexture(texture);\n      }\n      textureData.texture = backend.device.createTexture(textureDescriptorGPU);\n    }\n    if (isMSAA) {\n      const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);\n      msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n      msaaTextureDescriptorGPU.sampleCount = samples;\n      textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);\n    }\n    textureData.initialized = true;\n    textureData.textureDescriptorGPU = textureDescriptorGPU;\n  }\n  destroyTexture(texture) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    if (textureData.texture !== undefined) textureData.texture.destroy();\n    if (textureData.msaaTexture !== undefined) textureData.msaaTexture.destroy();\n    backend.delete(texture);\n  }\n  destroySampler(texture) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    delete textureData.sampler;\n  }\n  generateMipmaps(texture) {\n    const textureData = this.backend.get(texture);\n    if (texture.isCubeTexture) {\n      for (let i = 0; i < 6; i++) {\n        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);\n      }\n    } else {\n      const depth = texture.image.depth || 1;\n      for (let i = 0; i < depth; i++) {\n        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);\n      }\n    }\n  }\n  getColorBuffer() {\n    if (this.colorBuffer) this.colorBuffer.destroy();\n    const backend = this.backend;\n    const {\n      width,\n      height\n    } = backend.getDrawingBufferSize();\n    this.colorBuffer = backend.device.createTexture({\n      label: 'colorBuffer',\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: 1\n      },\n      sampleCount: backend.utils.getSampleCount(backend.renderer.samples),\n      format: backend.utils.getPreferredCanvasFormat(),\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n    return this.colorBuffer;\n  }\n  getDepthBuffer(depth = true, stencil = false) {\n    const backend = this.backend;\n    const {\n      width,\n      height\n    } = backend.getDrawingBufferSize();\n    const depthTexture = this.depthTexture;\n    const depthTextureGPU = backend.get(depthTexture).texture;\n    let format, type;\n    if (stencil) {\n      format = DepthStencilFormat;\n      type = UnsignedInt248Type;\n    } else if (depth) {\n      format = DepthFormat;\n      type = UnsignedIntType;\n    }\n    if (depthTextureGPU !== undefined) {\n      if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type) {\n        return depthTextureGPU;\n      }\n      this.destroyTexture(depthTexture);\n    }\n    depthTexture.name = 'depthBuffer';\n    depthTexture.format = format;\n    depthTexture.type = type;\n    depthTexture.image.width = width;\n    depthTexture.image.height = height;\n    this.createTexture(depthTexture, {\n      width,\n      height\n    });\n    return backend.get(depthTexture).texture;\n  }\n  updateTexture(texture, options) {\n    const textureData = this.backend.get(texture);\n    const {\n      textureDescriptorGPU\n    } = textureData;\n    if (texture.isRenderTargetTexture || textureDescriptorGPU === undefined /* unsupported texture format */) return;\n\n    // transfer texture data\n\n    if (texture.isDataTexture) {\n      this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);\n    } else if (texture.isDataArrayTexture || texture.isData3DTexture) {\n      for (let i = 0; i < options.image.depth; i++) {\n        this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i);\n      }\n    } else if (texture.isCompressedTexture || texture.isCompressedArrayTexture) {\n      this._copyCompressedBufferToTexture(texture.mipmaps, textureData.texture, textureDescriptorGPU);\n    } else if (texture.isCubeTexture) {\n      this._copyCubeMapToTexture(options.images, textureData.texture, textureDescriptorGPU, texture.flipY);\n    } else if (texture.isVideoTexture) {\n      const video = texture.source.data;\n      textureData.externalTexture = video;\n    } else {\n      this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);\n    }\n\n    //\n\n    textureData.version = texture.version;\n    if (texture.onUpdate) texture.onUpdate(texture);\n  }\n  async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    const device = this.backend.device;\n    const textureData = this.backend.get(texture);\n    const textureGPU = textureData.texture;\n    const format = textureData.textureDescriptorGPU.format;\n    const bytesPerTexel = this._getBytesPerTexel(format);\n    let bytesPerRow = width * bytesPerTexel;\n    bytesPerRow = Math.ceil(bytesPerRow / 256) * 256; // Align to 256 bytes\n\n    const readBuffer = device.createBuffer({\n      size: width * height * bytesPerTexel,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToBuffer({\n      texture: textureGPU,\n      origin: {\n        x,\n        y,\n        z: faceIndex\n      }\n    }, {\n      buffer: readBuffer,\n      bytesPerRow: bytesPerRow\n    }, {\n      width: width,\n      height: height\n    });\n    const typedArrayType = this._getTypedArrayType(format);\n    device.queue.submit([encoder.finish()]);\n    await readBuffer.mapAsync(GPUMapMode.READ);\n    const buffer = readBuffer.getMappedRange();\n    return new typedArrayType(buffer);\n  }\n  _isEnvironmentTexture(texture) {\n    const mapping = texture.mapping;\n    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n  }\n  _getDefaultTextureGPU(format) {\n    let defaultTexture = this.defaultTexture[format];\n    if (defaultTexture === undefined) {\n      const texture = new Texture();\n      texture.minFilter = NearestFilter;\n      texture.magFilter = NearestFilter;\n      this.createTexture(texture, {\n        width: 1,\n        height: 1,\n        format\n      });\n      this.defaultTexture[format] = defaultTexture = texture;\n    }\n    return this.backend.get(defaultTexture).texture;\n  }\n  _getDefaultCubeTextureGPU(format) {\n    let defaultCubeTexture = this.defaultTexture[format];\n    if (defaultCubeTexture === undefined) {\n      const texture = new CubeTexture();\n      texture.minFilter = NearestFilter;\n      texture.magFilter = NearestFilter;\n      this.createTexture(texture, {\n        width: 1,\n        height: 1,\n        depth: 6\n      });\n      this.defaultCubeTexture[format] = defaultCubeTexture = texture;\n    }\n    return this.backend.get(defaultCubeTexture).texture;\n  }\n  _getDefaultVideoFrame() {\n    let defaultVideoFrame = this.defaultVideoFrame;\n    if (defaultVideoFrame === null) {\n      const init = {\n        timestamp: 0,\n        codedWidth: 1,\n        codedHeight: 1,\n        format: 'RGBA'\n      };\n      this.defaultVideoFrame = defaultVideoFrame = new VideoFrame(new Uint8Array([0, 0, 0, 0xff]), init);\n    }\n    return defaultVideoFrame;\n  }\n  _copyCubeMapToTexture(images, textureGPU, textureDescriptorGPU, flipY) {\n    for (let i = 0; i < 6; i++) {\n      const image = images[i];\n      const flipIndex = flipY === true ? _flipMap[i] : i;\n      if (image.isDataTexture) {\n        this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY);\n      } else {\n        this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, flipY);\n      }\n    }\n  }\n  _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {\n    const device = this.backend.device;\n    device.queue.copyExternalImageToTexture({\n      source: image\n    }, {\n      texture: textureGPU,\n      mipLevel: 0,\n      origin: {\n        x: 0,\n        y: 0,\n        z: originDepth\n      }\n    }, {\n      width: image.width,\n      height: image.height,\n      depthOrArrayLayers: 1\n    });\n    if (flipY === true) {\n      this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  _getPassUtils() {\n    let passUtils = this._passUtils;\n    if (passUtils === null) {\n      this._passUtils = passUtils = new WebGPUTexturePassUtils(this.backend.device);\n    }\n    return passUtils;\n  }\n  _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0) {\n    this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer);\n  }\n  _flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {\n    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);\n  }\n  _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0) {\n    // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n    // @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n    const device = this.backend.device;\n    const data = image.data;\n    const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);\n    const bytesPerRow = image.width * bytesPerTexel;\n    device.queue.writeTexture({\n      texture: textureGPU,\n      mipLevel: 0,\n      origin: {\n        x: 0,\n        y: 0,\n        z: originDepth\n      }\n    }, data, {\n      offset: image.width * image.height * bytesPerTexel * depth,\n      bytesPerRow\n    }, {\n      width: image.width,\n      height: image.height,\n      depthOrArrayLayers: 1\n    });\n    if (flipY === true) {\n      this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {\n    // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n    const device = this.backend.device;\n    const blockData = this._getBlockData(textureDescriptorGPU.format);\n    const isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n    for (let i = 0; i < mipmaps.length; i++) {\n      const mipmap = mipmaps[i];\n      const width = mipmap.width;\n      const height = mipmap.height;\n      const depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n      const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;\n      const bytesPerImage = bytesPerRow * Math.ceil(height / blockData.height);\n      for (let j = 0; j < depth; j++) {\n        device.queue.writeTexture({\n          texture: textureGPU,\n          mipLevel: i,\n          origin: {\n            x: 0,\n            y: 0,\n            z: j\n          }\n        }, mipmap.data, {\n          offset: j * bytesPerImage,\n          bytesPerRow,\n          rowsPerImage: Math.ceil(height / blockData.height)\n        }, {\n          width: Math.ceil(width / blockData.width) * blockData.width,\n          height: Math.ceil(height / blockData.height) * blockData.height,\n          depthOrArrayLayers: 1\n        });\n      }\n    }\n  }\n  _getBlockData(format) {\n    // this method is only relevant for compressed texture formats\n\n    if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    }; // DXT1\n    if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // DXT3\n    if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // DXT5\n    if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    }; // RGTC1\n    if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // RGTC2\n    if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // BPTC (float)\n    if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // BPTC (unorm)\n\n    if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACR11Unorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACR11Snorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACRG11Unorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACRG11Snorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB) return {\n      byteLength: 16,\n      width: 5,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB) return {\n      byteLength: 16,\n      width: 5,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB) return {\n      byteLength: 16,\n      width: 6,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB) return {\n      byteLength: 16,\n      width: 6,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 8\n    };\n    if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 8\n    };\n    if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 10\n    };\n    if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB) return {\n      byteLength: 16,\n      width: 12,\n      height: 10\n    };\n    if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB) return {\n      byteLength: 16,\n      width: 12,\n      height: 12\n    };\n  }\n  _convertAddressMode(value) {\n    let addressMode = GPUAddressMode.ClampToEdge;\n    if (value === RepeatWrapping) {\n      addressMode = GPUAddressMode.Repeat;\n    } else if (value === MirroredRepeatWrapping) {\n      addressMode = GPUAddressMode.MirrorRepeat;\n    }\n    return addressMode;\n  }\n  _convertFilterMode(value) {\n    let filterMode = GPUFilterMode.Linear;\n    if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {\n      filterMode = GPUFilterMode.Nearest;\n    }\n    return filterMode;\n  }\n  _getBytesPerTexel(format) {\n    // 8-bit formats\n    if (format === GPUTextureFormat.R8Unorm || format === GPUTextureFormat.R8Snorm || format === GPUTextureFormat.R8Uint || format === GPUTextureFormat.R8Sint) return 1;\n\n    // 16-bit formats\n    if (format === GPUTextureFormat.R16Uint || format === GPUTextureFormat.R16Sint || format === GPUTextureFormat.R16Float || format === GPUTextureFormat.RG8Unorm || format === GPUTextureFormat.RG8Snorm || format === GPUTextureFormat.RG8Uint || format === GPUTextureFormat.RG8Sint) return 2;\n\n    // 32-bit formats\n    if (format === GPUTextureFormat.R32Uint || format === GPUTextureFormat.R32Sint || format === GPUTextureFormat.R32Float || format === GPUTextureFormat.RG16Uint || format === GPUTextureFormat.RG16Sint || format === GPUTextureFormat.RG16Float || format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB || format === GPUTextureFormat.RGBA8Snorm || format === GPUTextureFormat.RGBA8Uint || format === GPUTextureFormat.RGBA8Sint || format === GPUTextureFormat.BGRA8Unorm || format === GPUTextureFormat.BGRA8UnormSRGB ||\n    // Packed 32-bit formats\n    format === GPUTextureFormat.RGB9E5UFloat || format === GPUTextureFormat.RGB10A2Unorm || format === GPUTextureFormat.RG11B10UFloat || format === GPUTextureFormat.Depth32Float || format === GPUTextureFormat.Depth24Plus || format === GPUTextureFormat.Depth24PlusStencil8 || format === GPUTextureFormat.Depth32FloatStencil8) return 4;\n\n    // 64-bit formats\n    if (format === GPUTextureFormat.RG32Uint || format === GPUTextureFormat.RG32Sint || format === GPUTextureFormat.RG32Float || format === GPUTextureFormat.RGBA16Uint || format === GPUTextureFormat.RGBA16Sint || format === GPUTextureFormat.RGBA16Float) return 8;\n\n    // 128-bit formats\n    if (format === GPUTextureFormat.RGBA32Uint || format === GPUTextureFormat.RGBA32Sint || format === GPUTextureFormat.RGBA32Float) return 16;\n  }\n  _getTypedArrayType(format) {\n    if (format === GPUTextureFormat.R8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.R8Sint) return Int8Array;\n    if (format === GPUTextureFormat.R8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.R8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.RG8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.RG8Sint) return Int8Array;\n    if (format === GPUTextureFormat.RG8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.RG8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.RGBA8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.RGBA8Sint) return Int8Array;\n    if (format === GPUTextureFormat.RGBA8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.RGBA8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.R16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.R16Sint) return Int16Array;\n    if (format === GPUTextureFormat.RG16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.RG16Sint) return Int16Array;\n    if (format === GPUTextureFormat.RGBA16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.RGBA16Sint) return Int16Array;\n    if (format === GPUTextureFormat.R16Float) return Uint16Array;\n    if (format === GPUTextureFormat.RG16Float) return Uint16Array;\n    if (format === GPUTextureFormat.RGBA16Float) return Uint16Array;\n    if (format === GPUTextureFormat.R32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.R32Sint) return Int32Array;\n    if (format === GPUTextureFormat.R32Float) return Float32Array;\n    if (format === GPUTextureFormat.RG32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.RG32Sint) return Int32Array;\n    if (format === GPUTextureFormat.RG32Float) return Float32Array;\n    if (format === GPUTextureFormat.RGBA32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.RGBA32Sint) return Int32Array;\n    if (format === GPUTextureFormat.RGBA32Float) return Float32Array;\n    if (format === GPUTextureFormat.BGRA8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;\n    if (format === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;\n    if (format === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;\n    if (format === GPUTextureFormat.RG11B10UFloat) return Uint32Array;\n    if (format === GPUTextureFormat.Depth32Float) return Float32Array;\n    if (format === GPUTextureFormat.Depth24Plus) return Uint32Array;\n    if (format === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;\n    if (format === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;\n  }\n  _getDimension(texture) {\n    let dimension;\n    if (texture.isData3DTexture) {\n      dimension = GPUTextureDimension.ThreeD;\n    } else {\n      dimension = GPUTextureDimension.TwoD;\n    }\n    return dimension;\n  }\n}\nfunction getFormat(texture, device = null) {\n  const format = texture.format;\n  const type = texture.type;\n  const colorSpace = texture.colorSpace;\n  let formatGPU;\n  if (texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true) {\n    switch (format) {\n      case RGBA_S3TC_DXT1_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n        break;\n      case RGBA_S3TC_DXT3_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n        break;\n      case RGBA_S3TC_DXT5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n        break;\n      case RGB_ETC2_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n        break;\n      case RGBA_ETC2_EAC_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n        break;\n      case RGBA_ASTC_4x4_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n        break;\n      case RGBA_ASTC_5x4_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n        break;\n      case RGBA_ASTC_5x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n        break;\n      case RGBA_ASTC_6x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n        break;\n      case RGBA_ASTC_6x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n        break;\n      case RGBA_ASTC_8x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n        break;\n      case RGBA_ASTC_8x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n        break;\n      case RGBA_ASTC_8x8_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n        break;\n      case RGBA_ASTC_10x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n        break;\n      case RGBA_ASTC_10x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n        break;\n      case RGBA_ASTC_10x8_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n        break;\n      case RGBA_ASTC_10x10_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n        break;\n      case RGBA_ASTC_12x10_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n        break;\n      case RGBA_ASTC_12x12_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n        break;\n      case RGBAFormat:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n        break;\n      default:\n        console.error('WebGPURenderer: Unsupported texture format.', format);\n    }\n  } else {\n    switch (format) {\n      case RGBAFormat:\n        switch (type) {\n          case ByteType:\n            formatGPU = GPUTextureFormat.RGBA8Snorm;\n            break;\n          case ShortType:\n            formatGPU = GPUTextureFormat.RGBA16Sint;\n            break;\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.RGBA16Uint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RGBA32Uint;\n            break;\n          case IntType:\n            formatGPU = GPUTextureFormat.RGBA32Sint;\n            break;\n          case UnsignedByteType:\n            formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.RGBA16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.RGBA32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBAFormat.', type);\n        }\n        break;\n      case RGBFormat:\n        switch (type) {\n          case UnsignedInt5999Type:\n            formatGPU = GPUTextureFormat.RGB9E5UFloat;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBFormat.', type);\n        }\n        break;\n      case RedFormat:\n        switch (type) {\n          case ByteType:\n            formatGPU = GPUTextureFormat.R8Snorm;\n            break;\n          case ShortType:\n            formatGPU = GPUTextureFormat.R16Sint;\n            break;\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.R16Uint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.R32Uint;\n            break;\n          case IntType:\n            formatGPU = GPUTextureFormat.R32Sint;\n            break;\n          case UnsignedByteType:\n            formatGPU = GPUTextureFormat.R8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.R16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.R32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RedFormat.', type);\n        }\n        break;\n      case RGFormat:\n        switch (type) {\n          case ByteType:\n            formatGPU = GPUTextureFormat.RG8Snorm;\n            break;\n          case ShortType:\n            formatGPU = GPUTextureFormat.RG16Sint;\n            break;\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.RG16Uint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RG32Uint;\n            break;\n          case IntType:\n            formatGPU = GPUTextureFormat.RG32Sint;\n            break;\n          case UnsignedByteType:\n            formatGPU = GPUTextureFormat.RG8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.RG16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.RG32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGFormat.', type);\n        }\n        break;\n      case DepthFormat:\n        switch (type) {\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.Depth16Unorm;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.Depth24Plus;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.Depth32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with DepthFormat.', type);\n        }\n        break;\n      case DepthStencilFormat:\n        switch (type) {\n          case UnsignedInt248Type:\n            formatGPU = GPUTextureFormat.Depth24PlusStencil8;\n            break;\n          case FloatType:\n            if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {\n              console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.');\n            }\n            formatGPU = GPUTextureFormat.Depth32FloatStencil8;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type);\n        }\n        break;\n      case RedIntegerFormat:\n        switch (type) {\n          case IntType:\n            formatGPU = GPUTextureFormat.R32Sint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.R32Uint;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type);\n        }\n        break;\n      case RGIntegerFormat:\n        switch (type) {\n          case IntType:\n            formatGPU = GPUTextureFormat.RG32Sint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RG32Uint;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type);\n        }\n        break;\n      case RGBAIntegerFormat:\n        switch (type) {\n          case IntType:\n            formatGPU = GPUTextureFormat.RGBA32Sint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RGBA32Uint;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type);\n        }\n        break;\n      default:\n        console.error('WebGPURenderer: Unsupported texture format.', format);\n    }\n  }\n  return formatGPU;\n}\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\nconst wgslTypeLib$1 = {\n  'f32': 'float',\n  'i32': 'int',\n  'u32': 'uint',\n  'bool': 'bool',\n  'vec2<f32>': 'vec2',\n  'vec2<i32>': 'ivec2',\n  'vec2<u32>': 'uvec2',\n  'vec2<bool>': 'bvec2',\n  'vec2f': 'vec2',\n  'vec2i': 'ivec2',\n  'vec2u': 'uvec2',\n  'vec2b': 'bvec2',\n  'vec3<f32>': 'vec3',\n  'vec3<i32>': 'ivec3',\n  'vec3<u32>': 'uvec3',\n  'vec3<bool>': 'bvec3',\n  'vec3f': 'vec3',\n  'vec3i': 'ivec3',\n  'vec3u': 'uvec3',\n  'vec3b': 'bvec3',\n  'vec4<f32>': 'vec4',\n  'vec4<i32>': 'ivec4',\n  'vec4<u32>': 'uvec4',\n  'vec4<bool>': 'bvec4',\n  'vec4f': 'vec4',\n  'vec4i': 'ivec4',\n  'vec4u': 'uvec4',\n  'vec4b': 'bvec4',\n  'mat2x2<f32>': 'mat2',\n  'mat2x2f': 'mat2',\n  'mat3x3<f32>': 'mat3',\n  'mat3x3f': 'mat3',\n  'mat4x4<f32>': 'mat4',\n  'mat4x4f': 'mat4',\n  'sampler': 'sampler',\n  'texture_1d': 'texture',\n  'texture_2d': 'texture',\n  'texture_2d_array': 'texture',\n  'texture_multisampled_2d': 'cubeTexture',\n  'texture_depth_2d': 'depthTexture',\n  'texture_depth_multisampled_2d': 'depthTexture',\n  'texture_3d': 'texture3D',\n  'texture_cube': 'cubeTexture',\n  'texture_cube_array': 'cubeTexture',\n  'texture_storage_1d': 'storageTexture',\n  'texture_storage_2d': 'storageTexture',\n  'texture_storage_2d_array': 'storageTexture',\n  'texture_storage_3d': 'storageTexture'\n};\nconst parse = source => {\n  source = source.trim();\n  const declaration = source.match(declarationRegexp);\n  if (declaration !== null && declaration.length === 4) {\n    const inputsCode = declaration[2];\n    const propsMatches = [];\n    let match = null;\n    while ((match = propertiesRegexp.exec(inputsCode)) !== null) {\n      propsMatches.push({\n        name: match[1],\n        type: match[2]\n      });\n    }\n\n    // Process matches to correctly pair names and types\n    const inputs = [];\n    for (let i = 0; i < propsMatches.length; i++) {\n      const {\n        name,\n        type\n      } = propsMatches[i];\n      let resolvedType = type;\n      if (resolvedType.startsWith('ptr')) {\n        resolvedType = 'pointer';\n      } else {\n        if (resolvedType.startsWith('texture')) {\n          resolvedType = type.split('<')[0];\n        }\n        resolvedType = wgslTypeLib$1[resolvedType];\n      }\n      inputs.push(new NodeFunctionInput(resolvedType, name));\n    }\n    const blockCode = source.substring(declaration[0].length);\n    const outputType = declaration[3] || 'void';\n    const name = declaration[1] !== undefined ? declaration[1] : '';\n    const type = wgslTypeLib$1[outputType] || outputType;\n    return {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode,\n      outputType\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a WGSL code.');\n  }\n};\n\n/**\n * This class represents a WSL node function.\n *\n * @augments NodeFunction\n */\nclass WGSLNodeFunction extends NodeFunction {\n  /**\n   * Constructs a new WGSL node function.\n   *\n   * @param {String} source - The WGSL source.\n   */\n  constructor(source) {\n    const {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode,\n      outputType\n    } = parse(source);\n    super(type, inputs, name);\n    this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n    this.outputType = outputType;\n  }\n\n  /**\n   * This method returns the WGSL code of the node function.\n   *\n   * @param {String} [name=this.name] - The function's name.\n   * @return {String} The shader code.\n   */\n  getCode(name = this.name) {\n    const outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n    return `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + this.blockCode;\n  }\n}\n\n/**\n * A WGSL node parser.\n *\n * @augments NodeParser\n */\nclass WGSLNodeParser extends NodeParser {\n  /**\n   * The method parses the given WGSL code an returns a node function.\n   *\n   * @param {String} source - The WGSL code.\n   * @return {WGSLNodeFunction} A node function.\n   */\n  parseFunction(source) {\n    return new WGSLNodeFunction(source);\n  }\n}\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = typeof self !== 'undefined' ? self.GPUShaderStage : {\n  VERTEX: 1,\n  FRAGMENT: 2,\n  COMPUTE: 4\n};\nconst accessNames = {\n  [NodeAccess.READ_ONLY]: 'read',\n  [NodeAccess.WRITE_ONLY]: 'write',\n  [NodeAccess.READ_WRITE]: 'read_write'\n};\nconst wrapNames = {\n  [RepeatWrapping]: 'repeat',\n  [ClampToEdgeWrapping]: 'clamp',\n  [MirroredRepeatWrapping]: 'mirror'\n};\nconst gpuShaderStageLib = {\n  'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n  'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n  'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\nconst supports = {\n  instance: true,\n  swizzleAssign: false,\n  storageBuffer: true\n};\nconst wgslFnOpLib = {\n  '^^': 'tsl_xor'\n};\nconst wgslTypeLib = {\n  float: 'f32',\n  int: 'i32',\n  uint: 'u32',\n  bool: 'bool',\n  color: 'vec3<f32>',\n  vec2: 'vec2<f32>',\n  ivec2: 'vec2<i32>',\n  uvec2: 'vec2<u32>',\n  bvec2: 'vec2<bool>',\n  vec3: 'vec3<f32>',\n  ivec3: 'vec3<i32>',\n  uvec3: 'vec3<u32>',\n  bvec3: 'vec3<bool>',\n  vec4: 'vec4<f32>',\n  ivec4: 'vec4<i32>',\n  uvec4: 'vec4<u32>',\n  bvec4: 'vec4<bool>',\n  mat2: 'mat2x2<f32>',\n  mat3: 'mat3x3<f32>',\n  mat4: 'mat4x4<f32>'\n};\nconst wgslCodeCache = {};\nconst wgslPolyfill = {\n  tsl_xor: new CodeNode('fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }'),\n  mod_float: new CodeNode('fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }'),\n  mod_vec2: new CodeNode('fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }'),\n  mod_vec3: new CodeNode('fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }'),\n  mod_vec4: new CodeNode('fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }'),\n  equals_bool: new CodeNode('fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }'),\n  equals_bvec2: new CodeNode('fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }'),\n  equals_bvec3: new CodeNode('fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }'),\n  equals_bvec4: new CodeNode('fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }'),\n  repeatWrapping_float: new CodeNode('fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }'),\n  mirrorWrapping_float: new CodeNode('fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }'),\n  clampWrapping_float: new CodeNode('fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }'),\n  biquadraticTexture: new CodeNode(/* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n`)\n};\nconst wgslMethods = {\n  dFdx: 'dpdx',\n  dFdy: '- dpdy',\n  mod_float: 'tsl_mod_float',\n  mod_vec2: 'tsl_mod_vec2',\n  mod_vec3: 'tsl_mod_vec3',\n  mod_vec4: 'tsl_mod_vec4',\n  equals_bool: 'tsl_equals_bool',\n  equals_bvec2: 'tsl_equals_bvec2',\n  equals_bvec3: 'tsl_equals_bvec3',\n  equals_bvec4: 'tsl_equals_bvec4',\n  inversesqrt: 'inverseSqrt',\n  bitcast: 'bitcast<f32>'\n};\n\n// WebGPU issue: does not support pow() with negative base on Windows\n\nif (typeof navigator !== 'undefined' && /Windows/g.test(navigator.userAgent)) {\n  wgslPolyfill.pow_float = new CodeNode('fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }');\n  wgslPolyfill.pow_vec2 = new CodeNode('fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [wgslPolyfill.pow_float]);\n  wgslPolyfill.pow_vec3 = new CodeNode('fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [wgslPolyfill.pow_float]);\n  wgslPolyfill.pow_vec4 = new CodeNode('fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [wgslPolyfill.pow_float]);\n  wgslMethods.pow_float = 'tsl_pow_float';\n  wgslMethods.pow_vec2 = 'tsl_pow_vec2';\n  wgslMethods.pow_vec3 = 'tsl_pow_vec3';\n  wgslMethods.pow_vec4 = 'tsl_pow_vec4';\n}\n\n//\n\nlet diagnostics = '';\nif ((typeof navigator !== 'undefined' && /Firefox|Deno/g.test(navigator.userAgent)) !== true) {\n  diagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n}\n\n//\n\nclass WGSLNodeBuilder extends NodeBuilder {\n  constructor(object, renderer) {\n    super(object, renderer, new WGSLNodeParser());\n    this.uniformGroups = {};\n    this.builtins = {};\n    this.directives = {};\n    this.scopedArrays = new Map();\n  }\n  needsToWorkingColorSpace(texture) {\n    return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n  }\n  _generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      if (depthSnippet) {\n        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;\n      } else {\n        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;\n      }\n    } else if (this.isFilteredTexture(texture)) {\n      return this.generateFilteredTexture(texture, textureProperty, uvSnippet);\n    } else {\n      return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, '0');\n    }\n  }\n  _generateVideoSample(textureProperty, uvSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.VideoTexture does not support ${shaderStage} shader.`);\n    }\n  }\n  _generateTextureSampleLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if ((shaderStage === 'fragment' || shaderStage === 'compute') && this.isUnfilterable(texture) === false) {\n      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;\n    } else if (this.isFilteredTexture(texture)) {\n      return this.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet);\n    } else {\n      return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet);\n    }\n  }\n  generateWrapFunction(texture) {\n    const functionName = `tsl_coord_${wrapNames[texture.wrapS]}S_${wrapNames[texture.wrapT]}_${texture.isData3DTexture ? '3d' : '2d'}T`;\n    let nodeCode = wgslCodeCache[functionName];\n    if (nodeCode === undefined) {\n      const includes = [];\n\n      // For 3D textures, use vec3f; for texture arrays, keep vec2f since array index is separate\n      const coordType = texture.isData3DTexture ? 'vec3f' : 'vec2f';\n      let code = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {\\n\\n\\treturn ${coordType}(\\n`;\n      const addWrapSnippet = (wrap, axis) => {\n        if (wrap === RepeatWrapping) {\n          includes.push(wgslPolyfill.repeatWrapping_float);\n          code += `\\t\\ttsl_repeatWrapping_float( coord.${axis} )`;\n        } else if (wrap === ClampToEdgeWrapping) {\n          includes.push(wgslPolyfill.clampWrapping_float);\n          code += `\\t\\ttsl_clampWrapping_float( coord.${axis} )`;\n        } else if (wrap === MirroredRepeatWrapping) {\n          includes.push(wgslPolyfill.mirrorWrapping_float);\n          code += `\\t\\ttsl_mirrorWrapping_float( coord.${axis} )`;\n        } else {\n          code += `\\t\\tcoord.${axis}`;\n          console.warn(`WebGPURenderer: Unsupported texture wrap type \"${wrap}\" for vertex shader.`);\n        }\n      };\n      addWrapSnippet(texture.wrapS, 'x');\n      code += ',\\n';\n      addWrapSnippet(texture.wrapT, 'y');\n      if (texture.isData3DTexture) {\n        code += ',\\n';\n        addWrapSnippet(texture.wrapR, 'z');\n      }\n      code += '\\n\\t);\\n\\n}\\n';\n      wgslCodeCache[functionName] = nodeCode = new CodeNode(code, includes);\n    }\n    nodeCode.build(this);\n    return functionName;\n  }\n  generateTextureDimension(texture, textureProperty, levelSnippet) {\n    const textureData = this.getDataFromNode(texture, this.shaderStage, this.globalCache);\n    if (textureData.dimensionsSnippet === undefined) textureData.dimensionsSnippet = {};\n    let textureDimensionNode = textureData.dimensionsSnippet[levelSnippet];\n    if (textureData.dimensionsSnippet[levelSnippet] === undefined) {\n      let textureDimensionsParams;\n      let dimensionType;\n      const {\n        primarySamples\n      } = this.renderer.backend.utils.getTextureSampleData(texture);\n      const isMultisampled = primarySamples > 1;\n      if (texture.isData3DTexture) {\n        dimensionType = 'vec3<u32>';\n      } else {\n        // Regular 2D textures, depth textures, etc.\n        dimensionType = 'vec2<u32>';\n      }\n\n      // Build parameters string based on texture type and multisampling\n      if (isMultisampled || texture.isVideoTexture || texture.isStorageTexture) {\n        textureDimensionsParams = textureProperty;\n      } else {\n        textureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${levelSnippet} )` : ''}`;\n      }\n      textureDimensionNode = new VarNode(new ExpressionNode(`textureDimensions( ${textureDimensionsParams} )`, dimensionType));\n      textureData.dimensionsSnippet[levelSnippet] = textureDimensionNode;\n      if (texture.isDataArrayTexture || texture.isData3DTexture) {\n        textureData.arrayLayerCount = new VarNode(new ExpressionNode(`textureNumLayers(${textureProperty})`, 'u32'));\n      }\n\n      // For cube textures, we know it's always 6 faces\n      if (texture.isTextureCube) {\n        textureData.cubeFaceCount = new VarNode(new ExpressionNode('6u', 'u32'));\n      }\n    }\n    return textureDimensionNode.build(this);\n  }\n  generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet = '0u') {\n    this._include('biquadraticTexture');\n    const wrapFunction = this.generateWrapFunction(texture);\n    const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);\n    return `tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`;\n  }\n  generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u') {\n    const wrapFunction = this.generateWrapFunction(texture);\n    const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);\n    const vecType = texture.isData3DTexture ? 'vec3' : 'vec2';\n    const coordSnippet = `${vecType}<u32>(${wrapFunction}(${uvSnippet}) * ${vecType}<f32>(${textureDimension}))`;\n    return this.generateTextureLoad(texture, textureProperty, coordSnippet, depthSnippet, levelSnippet);\n  }\n  generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u') {\n    if (texture.isVideoTexture === true || texture.isStorageTexture === true) {\n      return `textureLoad( ${textureProperty}, ${uvIndexSnippet} )`;\n    } else if (depthSnippet) {\n      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`;\n    } else {\n      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`;\n    }\n  }\n  generateTextureStore(texture, textureProperty, uvIndexSnippet, valueSnippet) {\n    return `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;\n  }\n  isSampleCompare(texture) {\n    return texture.isDepthTexture === true && texture.compareFunction !== null;\n  }\n  isUnfilterable(texture) {\n    return this.getComponentTypeFromTexture(texture) !== 'float' || !this.isAvailable('float32Filterable') && texture.isDataTexture === true && texture.type === FloatType || this.isSampleCompare(texture) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter || this.renderer.backend.utils.getTextureSampleData(texture).primarySamples > 1;\n  }\n  generateTexture(texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);\n    } else if (this.isUnfilterable(texture)) {\n      snippet = this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage);\n    } else {\n      snippet = this._generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      // TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n      return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);\n    }\n  }\n  generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);\n    }\n  }\n  generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);\n    } else {\n      snippet = this._generateTextureSampleLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`);\n    }\n  }\n  getPropertyName(node, shaderStage = this.shaderStage) {\n    if (node.isNodeVarying === true && node.needsInterpolation === true) {\n      if (shaderStage === 'vertex') {\n        return `varyings.${node.name}`;\n      }\n    } else if (node.isNodeUniform === true) {\n      const name = node.name;\n      const type = node.type;\n      if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {\n        return name;\n      } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {\n        return `NodeBuffer_${node.id}.${name}`;\n      } else {\n        return node.groupNode.name + '.' + name;\n      }\n    }\n    return super.getPropertyName(node);\n  }\n  getOutputStructName() {\n    return 'output';\n  }\n  _getUniformGroupCount(shaderStage) {\n    return Object.keys(this.uniforms[shaderStage]).length;\n  }\n  getFunctionOperator(op) {\n    const fnOp = wgslFnOpLib[op];\n    if (fnOp !== undefined) {\n      this._include(fnOp);\n      return fnOp;\n    }\n    return null;\n  }\n  getNodeAccess(node, shaderStage) {\n    if (shaderStage !== 'compute') return NodeAccess.READ_ONLY;\n    return node.access;\n  }\n  getStorageAccess(node, shaderStage) {\n    return accessNames[this.getNodeAccess(node, shaderStage)];\n  }\n  getUniformFromNode(node, type, shaderStage, name = null) {\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    if (nodeData.uniformGPU === undefined) {\n      let uniformGPU;\n      const group = node.groupNode;\n      const groupName = group.name;\n      const bindings = this.getBindGroupArray(groupName, shaderStage);\n      if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {\n        let texture = null;\n        const access = this.getNodeAccess(node, shaderStage);\n        if (type === 'texture' || type === 'storageTexture') {\n          texture = new NodeSampledTexture(uniformNode.name, uniformNode.node, group, access);\n        } else if (type === 'cubeTexture') {\n          texture = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group, access);\n        } else if (type === 'texture3D') {\n          texture = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group, access);\n        }\n        texture.store = node.isStorageTextureNode === true;\n        texture.setVisibility(gpuShaderStageLib[shaderStage]);\n        if ((shaderStage === 'fragment' || shaderStage === 'compute') && this.isUnfilterable(node.value) === false && texture.store === false) {\n          const sampler = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node, group);\n          sampler.setVisibility(gpuShaderStageLib[shaderStage]);\n          bindings.push(sampler, texture);\n          uniformGPU = [sampler, texture];\n        } else {\n          bindings.push(texture);\n          uniformGPU = [texture];\n        }\n      } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {\n        const bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n        const buffer = new bufferClass(node, group);\n        buffer.setVisibility(gpuShaderStageLib[shaderStage]);\n        bindings.push(buffer);\n        uniformGPU = buffer;\n      } else {\n        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});\n        let uniformsGroup = uniformsStage[groupName];\n        if (uniformsGroup === undefined) {\n          uniformsGroup = new NodeUniformsGroup(groupName, group);\n          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);\n          uniformsStage[groupName] = uniformsGroup;\n          bindings.push(uniformsGroup);\n        }\n        uniformGPU = this.getNodeUniform(uniformNode, type);\n        uniformsGroup.addUniform(uniformGPU);\n      }\n      nodeData.uniformGPU = uniformGPU;\n    }\n    return uniformNode;\n  }\n  getBuiltin(name, property, type, shaderStage = this.shaderStage) {\n    const map = this.builtins[shaderStage] || (this.builtins[shaderStage] = new Map());\n    if (map.has(name) === false) {\n      map.set(name, {\n        name,\n        property,\n        type\n      });\n    }\n    return property;\n  }\n  hasBuiltin(name, shaderStage = this.shaderStage) {\n    return this.builtins[shaderStage] !== undefined && this.builtins[shaderStage].has(name);\n  }\n  getVertexIndex() {\n    if (this.shaderStage === 'vertex') {\n      return this.getBuiltin('vertex_index', 'vertexIndex', 'u32', 'attribute');\n    }\n    return 'vertexIndex';\n  }\n  buildFunctionCode(shaderNode) {\n    const layout = shaderNode.layout;\n    const flowData = this.flowShaderNode(shaderNode);\n    const parameters = [];\n    for (const input of layout.inputs) {\n      parameters.push(input.name + ' : ' + this.getType(input.type));\n    }\n\n    //\n\n    let code = `fn ${layout.name}( ${parameters.join(', ')} ) -> ${this.getType(layout.type)} {\n${flowData.vars}\n${flowData.code}\n`;\n    if (flowData.result) {\n      code += `\\treturn ${flowData.result};\\n`;\n    }\n    code += '\\n}\\n';\n\n    //\n\n    return code;\n  }\n  getInstanceIndex() {\n    if (this.shaderStage === 'vertex') {\n      return this.getBuiltin('instance_index', 'instanceIndex', 'u32', 'attribute');\n    }\n    return 'instanceIndex';\n  }\n  getInvocationLocalIndex() {\n    return this.getBuiltin('local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute');\n  }\n  getSubgroupSize() {\n    this.enableSubGroups();\n    return this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');\n  }\n  getInvocationSubgroupIndex() {\n    this.enableSubGroups();\n    return this.getBuiltin('subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute');\n  }\n  getSubgroupIndex() {\n    this.enableSubGroups();\n    return this.getBuiltin('subgroup_id', 'subgroupIndex', 'u32', 'attribute');\n  }\n  getDrawIndex() {\n    return null;\n  }\n  getFrontFacing() {\n    return this.getBuiltin('front_facing', 'isFront', 'bool');\n  }\n  getFragCoord() {\n    return this.getBuiltin('position', 'fragCoord', 'vec4<f32>') + '.xy';\n  }\n  getFragDepth() {\n    return 'output.' + this.getBuiltin('frag_depth', 'depth', 'f32', 'output');\n  }\n  getClipDistance() {\n    return 'varyings.hw_clip_distances';\n  }\n  isFlipY() {\n    return false;\n  }\n  enableDirective(name, shaderStage = this.shaderStage) {\n    const stage = this.directives[shaderStage] || (this.directives[shaderStage] = new Set());\n    stage.add(name);\n  }\n  getDirectives(shaderStage) {\n    const snippets = [];\n    const directives = this.directives[shaderStage];\n    if (directives !== undefined) {\n      for (const directive of directives) {\n        snippets.push(`enable ${directive};`);\n      }\n    }\n    return snippets.join('\\n');\n  }\n  enableSubGroups() {\n    this.enableDirective('subgroups');\n  }\n  enableSubgroupsF16() {\n    this.enableDirective('subgroups-f16');\n  }\n  enableClipDistances() {\n    this.enableDirective('clip_distances');\n  }\n  enableShaderF16() {\n    this.enableDirective('f16');\n  }\n  enableDualSourceBlending() {\n    this.enableDirective('dual_source_blending');\n  }\n  enableHardwareClipping(planeCount) {\n    this.enableClipDistances();\n    this.getBuiltin('clip_distances', 'hw_clip_distances', `array<f32, ${planeCount} >`, 'vertex');\n  }\n  getBuiltins(shaderStage) {\n    const snippets = [];\n    const builtins = this.builtins[shaderStage];\n    if (builtins !== undefined) {\n      for (const {\n        name,\n        property,\n        type\n      } of builtins.values()) {\n        snippets.push(`@builtin( ${name} ) ${property} : ${type}`);\n      }\n    }\n    return snippets.join(',\\n\\t');\n  }\n  getScopedArray(name, scope, bufferType, bufferCount) {\n    if (this.scopedArrays.has(name) === false) {\n      this.scopedArrays.set(name, {\n        name,\n        scope,\n        bufferType,\n        bufferCount\n      });\n    }\n    return name;\n  }\n  getScopedArrays(shaderStage) {\n    if (shaderStage !== 'compute') {\n      return;\n    }\n    const snippets = [];\n    for (const {\n      name,\n      scope,\n      bufferType,\n      bufferCount\n    } of this.scopedArrays.values()) {\n      const type = this.getType(bufferType);\n      snippets.push(`var<${scope}> ${name}: array< ${type}, ${bufferCount} >;`);\n    }\n    return snippets.join('\\n');\n  }\n  getAttributes(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'compute') {\n      this.getBuiltin('global_invocation_id', 'id', 'vec3<u32>', 'attribute');\n      this.getBuiltin('workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute');\n      this.getBuiltin('local_invocation_id', 'localId', 'vec3<u32>', 'attribute');\n      this.getBuiltin('num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute');\n      if (this.renderer.hasFeature('subgroups')) {\n        this.enableDirective('subgroups', shaderStage);\n        this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');\n      }\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      const builtins = this.getBuiltins('attribute');\n      if (builtins) snippets.push(builtins);\n      const attributes = this.getAttributesArray();\n      for (let index = 0, length = attributes.length; index < length; index++) {\n        const attribute = attributes[index];\n        const name = attribute.name;\n        const type = this.getType(attribute.type);\n        snippets.push(`@location( ${index} ) ${name} : ${type}`);\n      }\n    }\n    return snippets.join(',\\n\\t');\n  }\n  getStructMembers(struct) {\n    const snippets = [];\n    const members = struct.getMemberTypes();\n    for (let i = 0; i < members.length; i++) {\n      const member = members[i];\n      snippets.push(`\\t@location( ${i} ) m${i} : ${member}<f32>`);\n    }\n    const builtins = this.getBuiltins('output');\n    if (builtins) snippets.push('\\t' + builtins);\n    return snippets.join(',\\n');\n  }\n  getStructs(shaderStage) {\n    const snippets = [];\n    const structs = this.structs[shaderStage];\n    for (let index = 0, length = structs.length; index < length; index++) {\n      const struct = structs[index];\n      const name = struct.name;\n      let snippet = `\\struct ${name} {\\n`;\n      snippet += this.getStructMembers(struct);\n      snippet += '\\n}';\n      snippets.push(snippet);\n      snippets.push(`\\nvar<private> output : ${name};\\n\\n`);\n    }\n    return snippets.join('\\n\\n');\n  }\n  getVar(type, name) {\n    return `var ${name} : ${this.getType(type)}`;\n  }\n  getVars(shaderStage) {\n    const snippets = [];\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippets.push(`\\t${this.getVar(variable.type, variable.name)};`);\n      }\n    }\n    return `\\n${snippets.join('\\n')}\\n`;\n  }\n  getVaryings(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'vertex') {\n      this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'fragment') {\n      const varyings = this.varyings;\n      const vars = this.vars[shaderStage];\n      for (let index = 0; index < varyings.length; index++) {\n        const varying = varyings[index];\n        if (varying.needsInterpolation) {\n          let attributesSnippet = `@location( ${index} )`;\n          if (/^(int|uint|ivec|uvec)/.test(varying.type)) {\n            attributesSnippet += ' @interpolate( flat )';\n          }\n          snippets.push(`${attributesSnippet} ${varying.name} : ${this.getType(varying.type)}`);\n        } else if (shaderStage === 'vertex' && vars.includes(varying) === false) {\n          vars.push(varying);\n        }\n      }\n    }\n    const builtins = this.getBuiltins(shaderStage);\n    if (builtins) snippets.push(builtins);\n    const code = snippets.join(',\\n\\t');\n    return shaderStage === 'vertex' ? this._getWGSLStruct('VaryingsStruct', '\\t' + code) : code;\n  }\n  getUniforms(shaderStage) {\n    const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const bufferSnippets = [];\n    const structSnippets = [];\n    const uniformGroups = {};\n    for (const uniform of uniforms) {\n      const groupName = uniform.groupNode.name;\n      const uniformIndexes = this.bindingsIndexes[groupName];\n      if (uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D') {\n        const texture = uniform.node.value;\n        if ((shaderStage === 'fragment' || shaderStage === 'compute') && this.isUnfilterable(texture) === false && uniform.node.isStorageTextureNode !== true) {\n          if (this.isSampleCompare(texture)) {\n            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler_comparison;`);\n          } else {\n            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler;`);\n          }\n        }\n        let textureType;\n        let multisampled = '';\n        const {\n          primarySamples\n        } = this.renderer.backend.utils.getTextureSampleData(texture);\n        if (primarySamples > 1) {\n          multisampled = '_multisampled';\n        }\n        if (texture.isCubeTexture === true) {\n          textureType = 'texture_cube<f32>';\n        } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {\n          textureType = 'texture_2d_array<f32>';\n        } else if (texture.isDepthTexture === true) {\n          textureType = `texture_depth${multisampled}_2d`;\n        } else if (texture.isVideoTexture === true) {\n          textureType = 'texture_external';\n        } else if (texture.isData3DTexture === true) {\n          textureType = 'texture_3d<f32>';\n        } else if (uniform.node.isStorageTextureNode === true) {\n          const format = getFormat(texture);\n          const access = this.getStorageAccess(uniform.node, shaderStage);\n          textureType = `texture_storage_2d<${format}, ${access}>`;\n        } else {\n          const componentPrefix = this.getComponentTypeFromTexture(texture).charAt(0);\n          textureType = `texture${multisampled}_2d<${componentPrefix}32>`;\n        }\n        bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name} : ${textureType};`);\n      } else if (uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer') {\n        const bufferNode = uniform.node;\n        const bufferType = this.getType(bufferNode.bufferType);\n        const bufferCount = bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n        const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;\n        const bufferSnippet = `\\t${uniform.name} : array< ${bufferTypeSnippet}${bufferCountSnippet} >\\n`;\n        const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${this.getStorageAccess(bufferNode, shaderStage)}` : 'uniform';\n        bufferSnippets.push(this._getWGSLStructBinding('NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding++, uniformIndexes.group));\n      } else {\n        const vectorType = this.getType(this.getVectorType(uniform.type));\n        const groupName = uniform.groupNode.name;\n        const group = uniformGroups[groupName] || (uniformGroups[groupName] = {\n          index: uniformIndexes.binding++,\n          id: uniformIndexes.group,\n          snippets: []\n        });\n        group.snippets.push(`\\t${uniform.name} : ${vectorType}`);\n      }\n    }\n    for (const name in uniformGroups) {\n      const group = uniformGroups[name];\n      structSnippets.push(this._getWGSLStructBinding(name, group.snippets.join(',\\n'), 'uniform', group.index, group.id));\n    }\n    let code = bindingSnippets.join('\\n');\n    code += bufferSnippets.join('\\n');\n    code += structSnippets.join('\\n');\n    return code;\n  }\n  buildCode() {\n    const shadersData = this.material !== null ? {\n      fragment: {},\n      vertex: {}\n    } : {\n      compute: {}\n    };\n    this.sortBindingGroups();\n    for (const shaderStage in shadersData) {\n      const stageData = shadersData[shaderStage];\n      stageData.uniforms = this.getUniforms(shaderStage);\n      stageData.attributes = this.getAttributes(shaderStage);\n      stageData.varyings = this.getVaryings(shaderStage);\n      stageData.structs = this.getStructs(shaderStage);\n      stageData.vars = this.getVars(shaderStage);\n      stageData.codes = this.getCodes(shaderStage);\n      stageData.directives = this.getDirectives(shaderStage);\n      stageData.scopedArrays = this.getScopedArrays(shaderStage);\n\n      //\n\n      let flow = '// code\\n\\n';\n      flow += this.flowCode[shaderStage];\n      const flowNodes = this.flowNodes[shaderStage];\n      const mainNode = flowNodes[flowNodes.length - 1];\n      const outputNode = mainNode.outputNode;\n      const isOutputStruct = outputNode !== undefined && outputNode.isOutputStructNode === true;\n      for (const node of flowNodes) {\n        const flowSlotData = this.getFlowData(node /*, shaderStage*/);\n        const slotName = node.name;\n        if (slotName) {\n          if (flow.length > 0) flow += '\\n';\n          flow += `\\t// flow -> ${slotName}\\n\\t`;\n        }\n        flow += `${flowSlotData.code}\\n\\t`;\n        if (node === mainNode && shaderStage !== 'compute') {\n          flow += '// result\\n\\n\\t';\n          if (shaderStage === 'vertex') {\n            flow += `varyings.Vertex = ${flowSlotData.result};`;\n          } else if (shaderStage === 'fragment') {\n            if (isOutputStruct) {\n              stageData.returnType = outputNode.nodeType;\n              flow += `return ${flowSlotData.result};`;\n            } else {\n              let structSnippet = '\\t@location(0) color: vec4<f32>';\n              const builtins = this.getBuiltins('output');\n              if (builtins) structSnippet += ',\\n\\t' + builtins;\n              stageData.returnType = 'OutputStruct';\n              stageData.structs += this._getWGSLStruct('OutputStruct', structSnippet);\n              stageData.structs += '\\nvar<private> output : OutputStruct;\\n\\n';\n              flow += `output.color = ${flowSlotData.result};\\n\\n\\treturn output;`;\n            }\n          }\n        }\n      }\n      stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);\n      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);\n    } else {\n      this.computeShader = this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || [64]).join(', '));\n    }\n  }\n  getMethod(method, output = null) {\n    let wgslMethod;\n    if (output !== null) {\n      wgslMethod = this._getWGSLMethod(method + '_' + output);\n    }\n    if (wgslMethod === undefined) {\n      wgslMethod = this._getWGSLMethod(method);\n    }\n    return wgslMethod || method;\n  }\n  getType(type) {\n    return wgslTypeLib[type] || type;\n  }\n  isAvailable(name) {\n    let result = supports[name];\n    if (result === undefined) {\n      if (name === 'float32Filterable') {\n        result = this.renderer.hasFeature('float32-filterable');\n      } else if (name === 'clipDistance') {\n        result = this.renderer.hasFeature('clip-distances');\n      }\n      supports[name] = result;\n    }\n    return result;\n  }\n  _getWGSLMethod(method) {\n    if (wgslPolyfill[method] !== undefined) {\n      this._include(method);\n    }\n    return wgslMethods[method];\n  }\n  _include(name) {\n    const codeNode = wgslPolyfill[name];\n    codeNode.build(this);\n    if (this.currentFunctionNode !== null) {\n      this.currentFunctionNode.includes.push(codeNode);\n    }\n    return codeNode;\n  }\n  _getWGSLVertexCode(shaderData) {\n    return `${this.getSignature()}\n// directives\n${shaderData.directives}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n  }\n  _getWGSLFragmentCode(shaderData) {\n    return `${this.getSignature()}\n// global\n${diagnostics}\n\n// uniforms\n${shaderData.uniforms}\n\n// structs\n${shaderData.structs}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLComputeCode(shaderData, workgroupSize) {\n    return `${this.getSignature()}\n// directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLStruct(name, vars) {\n    return `\nstruct ${name} {\n${vars}\n};`;\n  }\n  _getWGSLStructBinding(name, vars, access, binding = 0, group = 0) {\n    const structName = name + 'Struct';\n    const structSnippet = this._getWGSLStruct(structName, vars);\n    return `${structSnippet}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`;\n  }\n}\nclass WebGPUUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  getCurrentDepthStencilFormat(renderContext) {\n    let format;\n    if (renderContext.depthTexture !== null) {\n      format = this.getTextureFormatGPU(renderContext.depthTexture);\n    } else if (renderContext.depth && renderContext.stencil) {\n      format = GPUTextureFormat.Depth24PlusStencil8;\n    } else if (renderContext.depth) {\n      format = GPUTextureFormat.Depth24Plus;\n    }\n    return format;\n  }\n  getTextureFormatGPU(texture) {\n    return this.backend.get(texture).format;\n  }\n  getTextureSampleData(texture) {\n    let samples;\n    if (texture.isFramebufferTexture) {\n      samples = 1;\n    } else if (texture.isDepthTexture && !texture.renderTarget) {\n      const renderer = this.backend.renderer;\n      const renderTarget = renderer.getRenderTarget();\n      samples = renderTarget ? renderTarget.samples : renderer.samples;\n    } else if (texture.renderTarget) {\n      samples = texture.renderTarget.samples;\n    }\n    samples = samples || 1;\n    const isMSAA = samples > 1 && texture.renderTarget !== null && texture.isDepthTexture !== true && texture.isFramebufferTexture !== true;\n    const primarySamples = isMSAA ? 1 : samples;\n    return {\n      samples,\n      primarySamples,\n      isMSAA\n    };\n  }\n  getCurrentColorFormat(renderContext) {\n    let format;\n    if (renderContext.textures !== null) {\n      format = this.getTextureFormatGPU(renderContext.textures[0]);\n    } else {\n      format = this.getPreferredCanvasFormat(); // default context format\n    }\n    return format;\n  }\n  getCurrentColorSpace(renderContext) {\n    if (renderContext.textures !== null) {\n      return renderContext.textures[0].colorSpace;\n    }\n    return this.backend.renderer.outputColorSpace;\n  }\n  getPrimitiveTopology(object, material) {\n    if (object.isPoints) return GPUPrimitiveTopology.PointList;else if (object.isLineSegments || object.isMesh && material.wireframe === true) return GPUPrimitiveTopology.LineList;else if (object.isLine) return GPUPrimitiveTopology.LineStrip;else if (object.isMesh) return GPUPrimitiveTopology.TriangleList;\n  }\n  getSampleCount(sampleCount) {\n    let count = 1;\n    if (sampleCount > 1) {\n      // WebGPU only supports power-of-two sample counts and 2 is not a valid value\n      count = Math.pow(2, Math.floor(Math.log2(sampleCount)));\n      if (count === 2) {\n        count = 4;\n      }\n    }\n    return count;\n  }\n  getSampleCountRenderContext(renderContext) {\n    if (renderContext.textures !== null) {\n      return this.getSampleCount(renderContext.sampleCount);\n    }\n    return this.getSampleCount(this.backend.renderer.samples);\n  }\n  getPreferredCanvasFormat() {\n    // TODO: Remove this check when Quest 34.5 is out\n    // https://github.com/mrdoob/three.js/pull/29221/files#r1731833949\n\n    if (navigator.userAgent.includes('Quest')) {\n      return GPUTextureFormat.BGRA8Unorm;\n    } else {\n      return navigator.gpu.getPreferredCanvasFormat();\n    }\n  }\n}\nconst typedArraysToVertexFormatPrefix = new Map([[Int8Array, ['sint8', 'snorm8']], [Uint8Array, ['uint8', 'unorm8']], [Int16Array, ['sint16', 'snorm16']], [Uint16Array, ['uint16', 'unorm16']], [Int32Array, ['sint32', 'snorm32']], [Uint32Array, ['uint32', 'unorm32']], [Float32Array, ['float32']]]);\nconst typedAttributeToVertexFormatPrefix = new Map([[Float16BufferAttribute, ['float16']]]);\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map([[Int32Array, 'sint32'], [Int16Array, 'sint32'],\n// patch for INT16\n[Uint32Array, 'uint32'], [Uint16Array, 'uint32'],\n// patch for UINT16\n[Float32Array, 'float32']]);\nclass WebGPUAttributeUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createAttribute(attribute, usage) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const bufferData = backend.get(bufferAttribute);\n    let buffer = bufferData.buffer;\n    if (buffer === undefined) {\n      const device = backend.device;\n      let array = bufferAttribute.array;\n\n      // patch for INT16 and UINT16\n      if (attribute.normalized === false && (array.constructor === Int16Array || array.constructor === Uint16Array)) {\n        const tempArray = new Uint32Array(array.length);\n        for (let i = 0; i < array.length; i++) {\n          tempArray[i] = array[i];\n        }\n        array = tempArray;\n      }\n      bufferAttribute.array = array;\n      if ((bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute) && bufferAttribute.itemSize === 3) {\n        array = new array.constructor(bufferAttribute.count * 4);\n        for (let i = 0; i < bufferAttribute.count; i++) {\n          array.set(bufferAttribute.array.subarray(i * 3, i * 3 + 3), i * 4);\n        }\n\n        // Update BufferAttribute\n        bufferAttribute.itemSize = 4;\n        bufferAttribute.array = array;\n      }\n      const size = array.byteLength + (4 - array.byteLength % 4) % 4; // ensure 4 byte alignment, see #20441\n\n      buffer = device.createBuffer({\n        label: bufferAttribute.name,\n        size: size,\n        usage: usage,\n        mappedAtCreation: true\n      });\n      new array.constructor(buffer.getMappedRange()).set(array);\n      buffer.unmap();\n      bufferData.buffer = buffer;\n    }\n  }\n  updateAttribute(attribute) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = backend.get(bufferAttribute).buffer;\n    const array = bufferAttribute.array;\n    const isTypedArray = this._isTypedArray(array);\n    const updateRanges = bufferAttribute.updateRanges;\n    if (updateRanges.length === 0) {\n      // Not using update ranges\n\n      device.queue.writeBuffer(buffer, 0, array, 0);\n    } else {\n      const byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;\n      for (let i = 0, l = updateRanges.length; i < l; i++) {\n        const range = updateRanges[i];\n        const dataOffset = range.start * byteOffsetFactor;\n        const size = range.count * byteOffsetFactor;\n        device.queue.writeBuffer(buffer, 0, array, dataOffset, size);\n      }\n      bufferAttribute.clearUpdateRanges();\n    }\n  }\n  createShaderVertexBuffers(renderObject) {\n    const attributes = renderObject.getAttributes();\n    const vertexBuffers = new Map();\n    for (let slot = 0; slot < attributes.length; slot++) {\n      const geometryAttribute = attributes[slot];\n      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n      const bufferAttribute = this._getBufferAttribute(geometryAttribute);\n      let vertexBufferLayout = vertexBuffers.get(bufferAttribute);\n      if (vertexBufferLayout === undefined) {\n        let arrayStride, stepMode;\n        if (geometryAttribute.isInterleavedBufferAttribute === true) {\n          arrayStride = geometryAttribute.data.stride * bytesPerElement;\n          stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        } else {\n          arrayStride = geometryAttribute.itemSize * bytesPerElement;\n          stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        }\n\n        // patch for INT16 and UINT16\n        if (geometryAttribute.normalized === false && (geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array)) {\n          arrayStride = 4;\n        }\n        vertexBufferLayout = {\n          arrayStride,\n          attributes: [],\n          stepMode\n        };\n        vertexBuffers.set(bufferAttribute, vertexBufferLayout);\n      }\n      const format = this._getVertexFormat(geometryAttribute);\n      const offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;\n      vertexBufferLayout.attributes.push({\n        shaderLocation: slot,\n        offset,\n        format\n      });\n    }\n    return Array.from(vertexBuffers.values());\n  }\n  destroyAttribute(attribute) {\n    const backend = this.backend;\n    const data = backend.get(this._getBufferAttribute(attribute));\n    data.buffer.destroy();\n    backend.delete(attribute);\n  }\n  async getArrayBufferAsync(attribute) {\n    const backend = this.backend;\n    const device = backend.device;\n    const data = backend.get(this._getBufferAttribute(attribute));\n    const bufferGPU = data.buffer;\n    const size = bufferGPU.size;\n    const readBufferGPU = device.createBuffer({\n      label: `${attribute.name}_readback`,\n      size,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n    const cmdEncoder = device.createCommandEncoder({\n      label: `readback_encoder_${attribute.name}`\n    });\n    cmdEncoder.copyBufferToBuffer(bufferGPU, 0, readBufferGPU, 0, size);\n    const gpuCommands = cmdEncoder.finish();\n    device.queue.submit([gpuCommands]);\n    await readBufferGPU.mapAsync(GPUMapMode.READ);\n    const arrayBuffer = readBufferGPU.getMappedRange();\n    const dstBuffer = new attribute.array.constructor(arrayBuffer.slice(0));\n    readBufferGPU.unmap();\n    return dstBuffer.buffer;\n  }\n  _getVertexFormat(geometryAttribute) {\n    const {\n      itemSize,\n      normalized\n    } = geometryAttribute;\n    const ArrayType = geometryAttribute.array.constructor;\n    const AttributeType = geometryAttribute.constructor;\n    let format;\n    if (itemSize === 1) {\n      format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);\n    } else {\n      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType) || typedArraysToVertexFormatPrefix.get(ArrayType);\n      const prefix = prefixOptions[normalized ? 1 : 0];\n      if (prefix) {\n        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;\n        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n        if (paddedItemSize % 1) {\n          throw new Error('THREE.WebGPUAttributeUtils: Bad vertex format item size.');\n        }\n        format = `${prefix}x${paddedItemSize}`;\n      }\n    }\n    if (!format) {\n      console.error('THREE.WebGPUAttributeUtils: Vertex format not supported yet.');\n    }\n    return format;\n  }\n  _isTypedArray(array) {\n    return ArrayBuffer.isView(array) && !(array instanceof DataView);\n  }\n  _getBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return attribute;\n  }\n}\nclass WebGPUBindingUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this.bindGroupLayoutCache = new WeakMap();\n  }\n  createBindingsLayout(bindGroup) {\n    const backend = this.backend;\n    const device = backend.device;\n    const entries = [];\n    let index = 0;\n    for (const binding of bindGroup.bindings) {\n      const bindingGPU = {\n        binding: index++,\n        visibility: binding.visibility\n      };\n      if (binding.isUniformBuffer || binding.isStorageBuffer) {\n        const buffer = {}; // GPUBufferBindingLayout\n\n        if (binding.isStorageBuffer) {\n          if (binding.visibility & 4) {\n            // compute\n\n            if (binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY) {\n              buffer.type = GPUBufferBindingType.Storage;\n            } else {\n              buffer.type = GPUBufferBindingType.ReadOnlyStorage;\n            }\n          } else {\n            buffer.type = GPUBufferBindingType.ReadOnlyStorage;\n          }\n        }\n        bindingGPU.buffer = buffer;\n      } else if (binding.isSampler) {\n        const sampler = {}; // GPUSamplerBindingLayout\n\n        if (binding.texture.isDepthTexture) {\n          if (binding.texture.compareFunction !== null) {\n            sampler.type = 'comparison';\n          }\n        }\n        bindingGPU.sampler = sampler;\n      } else if (binding.isSampledTexture && binding.texture.isVideoTexture) {\n        bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout\n      } else if (binding.isSampledTexture && binding.store) {\n        const storageTexture = {}; // GPUStorageTextureBindingLayout\n        storageTexture.format = this.backend.get(binding.texture).texture.format;\n        const access = binding.access;\n        if (access === NodeAccess.READ_WRITE) {\n          storageTexture.access = GPUStorageTextureAccess.ReadWrite;\n        } else if (access === NodeAccess.WRITE_ONLY) {\n          storageTexture.access = GPUStorageTextureAccess.WriteOnly;\n        } else {\n          storageTexture.access = GPUStorageTextureAccess.ReadOnly;\n        }\n        bindingGPU.storageTexture = storageTexture;\n      } else if (binding.isSampledTexture) {\n        const texture = {}; // GPUTextureBindingLayout\n\n        const {\n          primarySamples\n        } = backend.utils.getTextureSampleData(binding.texture);\n        if (primarySamples > 1) {\n          texture.multisampled = true;\n          if (!binding.texture.isDepthTexture) {\n            texture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n          }\n        }\n        if (binding.texture.isDepthTexture) {\n          texture.sampleType = GPUTextureSampleType.Depth;\n        } else if (binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture) {\n          const type = binding.texture.type;\n          if (type === IntType) {\n            texture.sampleType = GPUTextureSampleType.SInt;\n          } else if (type === UnsignedIntType) {\n            texture.sampleType = GPUTextureSampleType.UInt;\n          } else if (type === FloatType) {\n            if (this.backend.hasFeature('float32-filterable')) {\n              texture.sampleType = GPUTextureSampleType.Float;\n            } else {\n              texture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n            }\n          }\n        }\n        if (binding.isSampledCubeTexture) {\n          texture.viewDimension = GPUTextureViewDimension.Cube;\n        } else if (binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {\n          texture.viewDimension = GPUTextureViewDimension.TwoDArray;\n        } else if (binding.isSampledTexture3D) {\n          texture.viewDimension = GPUTextureViewDimension.ThreeD;\n        }\n        bindingGPU.texture = texture;\n      } else {\n        console.error(`WebGPUBindingUtils: Unsupported binding \"${binding}\".`);\n      }\n      entries.push(bindingGPU);\n    }\n    return device.createBindGroupLayout({\n      entries\n    });\n  }\n  createBindings(bindGroup, bindings, cacheIndex, version = 0) {\n    const {\n      backend,\n      bindGroupLayoutCache\n    } = this;\n    const bindingsData = backend.get(bindGroup);\n\n    // setup (static) binding layout and (dynamic) binding group\n\n    let bindLayoutGPU = bindGroupLayoutCache.get(bindGroup.bindingsReference);\n    if (bindLayoutGPU === undefined) {\n      bindLayoutGPU = this.createBindingsLayout(bindGroup);\n      bindGroupLayoutCache.set(bindGroup.bindingsReference, bindLayoutGPU);\n    }\n    let bindGroupGPU;\n    if (cacheIndex > 0) {\n      if (bindingsData.groups === undefined) {\n        bindingsData.groups = [];\n        bindingsData.versions = [];\n      }\n      if (bindingsData.versions[cacheIndex] === version) {\n        bindGroupGPU = bindingsData.groups[cacheIndex];\n      }\n    }\n    if (bindGroupGPU === undefined) {\n      bindGroupGPU = this.createBindGroup(bindGroup, bindLayoutGPU);\n      if (cacheIndex > 0) {\n        bindingsData.groups[cacheIndex] = bindGroupGPU;\n        bindingsData.versions[cacheIndex] = version;\n      }\n    }\n    bindingsData.group = bindGroupGPU;\n    bindingsData.layout = bindLayoutGPU;\n  }\n  updateBinding(binding) {\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = binding.buffer;\n    const bufferGPU = backend.get(binding).buffer;\n    device.queue.writeBuffer(bufferGPU, 0, buffer, 0);\n  }\n  createBindGroup(bindGroup, layoutGPU) {\n    const backend = this.backend;\n    const device = backend.device;\n    let bindingPoint = 0;\n    const entriesGPU = [];\n    for (const binding of bindGroup.bindings) {\n      if (binding.isUniformBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const byteLength = binding.byteLength;\n          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n          const bufferGPU = device.createBuffer({\n            label: 'bindingBuffer_' + binding.name,\n            size: byteLength,\n            usage: usage\n          });\n          bindingData.buffer = bufferGPU;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isStorageBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const attribute = binding.attribute;\n          //const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n          //backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n          bindingData.buffer = backend.get(attribute).buffer;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isSampler) {\n        const textureGPU = backend.get(binding.texture);\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: textureGPU.sampler\n        });\n      } else if (binding.isSampledTexture) {\n        const textureData = backend.get(binding.texture);\n        let resourceGPU;\n        if (textureData.externalTexture !== undefined) {\n          resourceGPU = device.importExternalTexture({\n            source: textureData.externalTexture\n          });\n        } else {\n          const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;\n          const propertyName = `view-${textureData.texture.width}-${textureData.texture.height}-${mipLevelCount}`;\n          resourceGPU = textureData[propertyName];\n          if (resourceGPU === undefined) {\n            const aspectGPU = GPUTextureAspect.All;\n            let dimensionViewGPU;\n            if (binding.isSampledCubeTexture) {\n              dimensionViewGPU = GPUTextureViewDimension.Cube;\n            } else if (binding.isSampledTexture3D) {\n              dimensionViewGPU = GPUTextureViewDimension.ThreeD;\n            } else if (binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {\n              dimensionViewGPU = GPUTextureViewDimension.TwoDArray;\n            } else {\n              dimensionViewGPU = GPUTextureViewDimension.TwoD;\n            }\n            resourceGPU = textureData[propertyName] = textureData.texture.createView({\n              aspect: aspectGPU,\n              dimension: dimensionViewGPU,\n              mipLevelCount\n            });\n          }\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: resourceGPU\n        });\n      }\n      bindingPoint++;\n    }\n    return device.createBindGroup({\n      label: 'bindGroup_' + bindGroup.name,\n      layout: layoutGPU,\n      entries: entriesGPU\n    });\n  }\n}\nclass WebGPUPipelineUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  _getSampleCount(renderObjectContext) {\n    return this.backend.utils.getSampleCountRenderContext(renderObjectContext);\n  }\n  createRenderPipeline(renderObject, promises) {\n    const {\n      object,\n      material,\n      geometry,\n      pipeline\n    } = renderObject;\n    const {\n      vertexProgram,\n      fragmentProgram\n    } = pipeline;\n    const backend = this.backend;\n    const device = backend.device;\n    const utils = backend.utils;\n    const pipelineData = backend.get(pipeline);\n\n    // bind group layouts\n\n    const bindGroupLayouts = [];\n    for (const bindGroup of renderObject.getBindings()) {\n      const bindingsData = backend.get(bindGroup);\n      bindGroupLayouts.push(bindingsData.layout);\n    }\n\n    // vertex buffers\n\n    const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);\n\n    // blending\n\n    let blending;\n    if (material.transparent === true && material.blending !== NoBlending) {\n      blending = this._getBlending(material);\n    }\n\n    // stencil\n\n    let stencilFront = {};\n    if (material.stencilWrite === true) {\n      stencilFront = {\n        compare: this._getStencilCompare(material),\n        failOp: this._getStencilOperation(material.stencilFail),\n        depthFailOp: this._getStencilOperation(material.stencilZFail),\n        passOp: this._getStencilOperation(material.stencilZPass)\n      };\n    }\n    const colorWriteMask = this._getColorWriteMask(material);\n    const targets = [];\n    if (renderObject.context.textures !== null) {\n      const textures = renderObject.context.textures;\n      for (let i = 0; i < textures.length; i++) {\n        const colorFormat = utils.getTextureFormatGPU(textures[i]);\n        targets.push({\n          format: colorFormat,\n          blend: blending,\n          writeMask: colorWriteMask\n        });\n      }\n    } else {\n      const colorFormat = utils.getCurrentColorFormat(renderObject.context);\n      targets.push({\n        format: colorFormat,\n        blend: blending,\n        writeMask: colorWriteMask\n      });\n    }\n    const vertexModule = backend.get(vertexProgram).module;\n    const fragmentModule = backend.get(fragmentProgram).module;\n    const primitiveState = this._getPrimitiveState(object, geometry, material);\n    const depthCompare = this._getDepthCompare(material);\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);\n    const sampleCount = this._getSampleCount(renderObject.context);\n    const pipelineDescriptor = {\n      label: `renderPipeline_${material.name || material.type}_${material.id}`,\n      vertex: Object.assign({}, vertexModule, {\n        buffers: vertexBuffers\n      }),\n      fragment: Object.assign({}, fragmentModule, {\n        targets\n      }),\n      primitive: primitiveState,\n      multisample: {\n        count: sampleCount,\n        alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1\n      },\n      layout: device.createPipelineLayout({\n        bindGroupLayouts\n      })\n    };\n    const depthStencil = {};\n    const renderDepth = renderObject.context.depth;\n    const renderStencil = renderObject.context.stencil;\n    if (renderDepth === true || renderStencil === true) {\n      if (renderDepth === true) {\n        depthStencil.format = depthStencilFormat;\n        depthStencil.depthWriteEnabled = material.depthWrite;\n        depthStencil.depthCompare = depthCompare;\n      }\n      if (renderStencil === true) {\n        depthStencil.stencilFront = stencilFront;\n        depthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)\n        depthStencil.stencilReadMask = material.stencilFuncMask;\n        depthStencil.stencilWriteMask = material.stencilWriteMask;\n      }\n      pipelineDescriptor.depthStencil = depthStencil;\n    }\n    if (promises === null) {\n      pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);\n    } else {\n      const p = new Promise((resolve /*, reject*/) => {\n        device.createRenderPipelineAsync(pipelineDescriptor).then(pipeline => {\n          pipelineData.pipeline = pipeline;\n          resolve();\n        });\n      });\n      promises.push(p);\n    }\n  }\n  createBundleEncoder(renderContext) {\n    const backend = this.backend;\n    const {\n      utils,\n      device\n    } = backend;\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderContext);\n    const colorFormat = utils.getCurrentColorFormat(renderContext);\n    const sampleCount = this._getSampleCount(renderContext);\n    const descriptor = {\n      label: 'renderBundleEncoder',\n      colorFormats: [colorFormat],\n      depthStencilFormat,\n      sampleCount\n    };\n    return device.createRenderBundleEncoder(descriptor);\n  }\n  createComputePipeline(pipeline, bindings) {\n    const backend = this.backend;\n    const device = backend.device;\n    const computeProgram = backend.get(pipeline.computeProgram).module;\n    const pipelineGPU = backend.get(pipeline);\n\n    // bind group layouts\n\n    const bindGroupLayouts = [];\n    for (const bindingsGroup of bindings) {\n      const bindingsData = backend.get(bindingsGroup);\n      bindGroupLayouts.push(bindingsData.layout);\n    }\n    pipelineGPU.pipeline = device.createComputePipeline({\n      compute: computeProgram,\n      layout: device.createPipelineLayout({\n        bindGroupLayouts\n      })\n    });\n  }\n  _getBlending(material) {\n    let color, alpha;\n    const blending = material.blending;\n    const blendSrc = material.blendSrc;\n    const blendDst = material.blendDst;\n    const blendEquation = material.blendEquation;\n    if (blending === CustomBlending) {\n      const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;\n      const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;\n      const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;\n      color = {\n        srcFactor: this._getBlendFactor(blendSrc),\n        dstFactor: this._getBlendFactor(blendDst),\n        operation: this._getBlendOperation(blendEquation)\n      };\n      alpha = {\n        srcFactor: this._getBlendFactor(blendSrcAlpha),\n        dstFactor: this._getBlendFactor(blendDstAlpha),\n        operation: this._getBlendOperation(blendEquationAlpha)\n      };\n    } else {\n      const premultipliedAlpha = material.premultipliedAlpha;\n      const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {\n        color = {\n          srcFactor: srcRGB,\n          dstFactor: dstRGB,\n          operation: GPUBlendOperation.Add\n        };\n        alpha = {\n          srcFactor: srcAlpha,\n          dstFactor: dstAlpha,\n          operation: GPUBlendOperation.Add\n        };\n      };\n      if (premultipliedAlpha) {\n        switch (blending) {\n          case NormalBlending:\n            setBlend(GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);\n            break;\n          case AdditiveBlending:\n            setBlend(GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);\n            break;\n          case SubtractiveBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);\n            break;\n          case MultiplyBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha);\n            break;\n        }\n      } else {\n        switch (blending) {\n          case NormalBlending:\n            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);\n            break;\n          case AdditiveBlending:\n            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One);\n            break;\n          case SubtractiveBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);\n            break;\n          case MultiplyBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src);\n            break;\n        }\n      }\n    }\n    if (color !== undefined && alpha !== undefined) {\n      return {\n        color,\n        alpha\n      };\n    } else {\n      console.error('THREE.WebGPURenderer: Invalid blending: ', blending);\n    }\n  }\n  _getBlendFactor(blend) {\n    let blendFactor;\n    switch (blend) {\n      case ZeroFactor:\n        blendFactor = GPUBlendFactor.Zero;\n        break;\n      case OneFactor:\n        blendFactor = GPUBlendFactor.One;\n        break;\n      case SrcColorFactor:\n        blendFactor = GPUBlendFactor.Src;\n        break;\n      case OneMinusSrcColorFactor:\n        blendFactor = GPUBlendFactor.OneMinusSrc;\n        break;\n      case SrcAlphaFactor:\n        blendFactor = GPUBlendFactor.SrcAlpha;\n        break;\n      case OneMinusSrcAlphaFactor:\n        blendFactor = GPUBlendFactor.OneMinusSrcAlpha;\n        break;\n      case DstColorFactor:\n        blendFactor = GPUBlendFactor.Dst;\n        break;\n      case OneMinusDstColorFactor:\n        blendFactor = GPUBlendFactor.OneMinusDstColor;\n        break;\n      case DstAlphaFactor:\n        blendFactor = GPUBlendFactor.DstAlpha;\n        break;\n      case OneMinusDstAlphaFactor:\n        blendFactor = GPUBlendFactor.OneMinusDstAlpha;\n        break;\n      case SrcAlphaSaturateFactor:\n        blendFactor = GPUBlendFactor.SrcAlphaSaturated;\n        break;\n      case BlendColorFactor:\n        blendFactor = GPUBlendFactor.Constant;\n        break;\n      case OneMinusBlendColorFactor:\n        blendFactor = GPUBlendFactor.OneMinusConstant;\n        break;\n      default:\n        console.error('THREE.WebGPURenderer: Blend factor not supported.', blend);\n    }\n    return blendFactor;\n  }\n  _getStencilCompare(material) {\n    let stencilCompare;\n    const stencilFunc = material.stencilFunc;\n    switch (stencilFunc) {\n      case NeverStencilFunc:\n        stencilCompare = GPUCompareFunction.Never;\n        break;\n      case AlwaysStencilFunc:\n        stencilCompare = GPUCompareFunction.Always;\n        break;\n      case LessStencilFunc:\n        stencilCompare = GPUCompareFunction.Less;\n        break;\n      case LessEqualStencilFunc:\n        stencilCompare = GPUCompareFunction.LessEqual;\n        break;\n      case EqualStencilFunc:\n        stencilCompare = GPUCompareFunction.Equal;\n        break;\n      case GreaterEqualStencilFunc:\n        stencilCompare = GPUCompareFunction.GreaterEqual;\n        break;\n      case GreaterStencilFunc:\n        stencilCompare = GPUCompareFunction.Greater;\n        break;\n      case NotEqualStencilFunc:\n        stencilCompare = GPUCompareFunction.NotEqual;\n        break;\n      default:\n        console.error('THREE.WebGPURenderer: Invalid stencil function.', stencilFunc);\n    }\n    return stencilCompare;\n  }\n  _getStencilOperation(op) {\n    let stencilOperation;\n    switch (op) {\n      case KeepStencilOp:\n        stencilOperation = GPUStencilOperation.Keep;\n        break;\n      case ZeroStencilOp:\n        stencilOperation = GPUStencilOperation.Zero;\n        break;\n      case ReplaceStencilOp:\n        stencilOperation = GPUStencilOperation.Replace;\n        break;\n      case InvertStencilOp:\n        stencilOperation = GPUStencilOperation.Invert;\n        break;\n      case IncrementStencilOp:\n        stencilOperation = GPUStencilOperation.IncrementClamp;\n        break;\n      case DecrementStencilOp:\n        stencilOperation = GPUStencilOperation.DecrementClamp;\n        break;\n      case IncrementWrapStencilOp:\n        stencilOperation = GPUStencilOperation.IncrementWrap;\n        break;\n      case DecrementWrapStencilOp:\n        stencilOperation = GPUStencilOperation.DecrementWrap;\n        break;\n      default:\n        console.error('THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation);\n    }\n    return stencilOperation;\n  }\n  _getBlendOperation(blendEquation) {\n    let blendOperation;\n    switch (blendEquation) {\n      case AddEquation:\n        blendOperation = GPUBlendOperation.Add;\n        break;\n      case SubtractEquation:\n        blendOperation = GPUBlendOperation.Subtract;\n        break;\n      case ReverseSubtractEquation:\n        blendOperation = GPUBlendOperation.ReverseSubtract;\n        break;\n      case MinEquation:\n        blendOperation = GPUBlendOperation.Min;\n        break;\n      case MaxEquation:\n        blendOperation = GPUBlendOperation.Max;\n        break;\n      default:\n        console.error('THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation);\n    }\n    return blendOperation;\n  }\n  _getPrimitiveState(object, geometry, material) {\n    const descriptor = {};\n    const utils = this.backend.utils;\n    descriptor.topology = utils.getPrimitiveTopology(object, material);\n    if (geometry.index !== null && object.isLine === true && object.isLineSegments !== true) {\n      descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n    }\n    switch (material.side) {\n      case FrontSide:\n        descriptor.frontFace = GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.Back;\n        break;\n      case BackSide:\n        descriptor.frontFace = GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.Front;\n        break;\n      case DoubleSide:\n        descriptor.frontFace = GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.None;\n        break;\n      default:\n        console.error('THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side);\n        break;\n    }\n    return descriptor;\n  }\n  _getColorWriteMask(material) {\n    return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;\n  }\n  _getDepthCompare(material) {\n    let depthCompare;\n    if (material.depthTest === false) {\n      depthCompare = GPUCompareFunction.Always;\n    } else {\n      const depthFunc = material.depthFunc;\n      switch (depthFunc) {\n        case NeverDepth:\n          depthCompare = GPUCompareFunction.Never;\n          break;\n        case AlwaysDepth:\n          depthCompare = GPUCompareFunction.Always;\n          break;\n        case LessDepth:\n          depthCompare = GPUCompareFunction.Less;\n          break;\n        case LessEqualDepth:\n          depthCompare = GPUCompareFunction.LessEqual;\n          break;\n        case EqualDepth:\n          depthCompare = GPUCompareFunction.Equal;\n          break;\n        case GreaterEqualDepth:\n          depthCompare = GPUCompareFunction.GreaterEqual;\n          break;\n        case GreaterDepth:\n          depthCompare = GPUCompareFunction.Greater;\n          break;\n        case NotEqualDepth:\n          depthCompare = GPUCompareFunction.NotEqual;\n          break;\n        default:\n          console.error('THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc);\n      }\n    }\n    return depthCompare;\n  }\n}\n\n/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\n/**\n * A backend implementation targeting WebGPU.\n *\n * @private\n * @augments Backend\n */\nclass WebGPUBackend extends Backend {\n  /**\n   * Constructs a new WebGPU backend.\n   *\n   * @param {Object} parameters - The configuration parameter.\n   * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n   * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n   * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n   * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n   * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n   * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n   * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses it WebGL 2 backend no matter if WebGPU is supported or not.\n   * @param {Boolean} [parameters.trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.\n   * @param {String?} [parameters.powerPreference=null] - The power preference.\n   * @param {String?} [parameters.requiredLimits={}] - Specifies the limits that are required by the device request.\n   * The request will fail if the adapter cannot provide these limits.\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isWebGPUBackend = true;\n\n    // some parameters require default values other than \"undefined\"\n    this.parameters.alpha = parameters.alpha === undefined ? true : parameters.alpha;\n    this.parameters.requiredLimits = parameters.requiredLimits === undefined ? {} : parameters.requiredLimits;\n\n    /**\n     * Whether to track timestamps with a Timestamp Query API or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.trackTimestamp = parameters.trackTimestamp === true;\n\n    /**\n     * A reference to the device.\n     *\n     * @type {GPUDevice?}\n     * @default null\n     */\n    this.device = null;\n\n    /**\n     * A reference to the context.\n     *\n     * @type {GPUCanvasContext?}\n     * @default null\n     */\n    this.context = null;\n\n    /**\n     * A reference to the color attachment of the default framebuffer.\n     *\n     * @type {GPUTexture?}\n     * @default null\n     */\n    this.colorBuffer = null;\n\n    /**\n     * A reference to the default render pass descriptor.\n     *\n     * @type {Object?}\n     * @default null\n     */\n    this.defaultRenderPassdescriptor = null;\n\n    /**\n     * A reference to a backend module holding common utility functions.\n     *\n     * @type {WebGPUUtils}\n     */\n    this.utils = new WebGPUUtils(this);\n\n    /**\n     * A reference to a backend module holding shader attribute-related\n     * utility functions.\n     *\n     * @type {WebGPUAttributeUtils}\n     */\n    this.attributeUtils = new WebGPUAttributeUtils(this);\n\n    /**\n     * A reference to a backend module holding shader binding-related\n     * utility functions.\n     *\n     * @type {WebGPUBindingUtils}\n     */\n    this.bindingUtils = new WebGPUBindingUtils(this);\n\n    /**\n     * A reference to a backend module holding shader pipeline-related\n     * utility functions.\n     *\n     * @type {WebGPUPipelineUtils}\n     */\n    this.pipelineUtils = new WebGPUPipelineUtils(this);\n\n    /**\n     * A reference to a backend module holding shader texture-related\n     * utility functions.\n     *\n     * @type {WebGPUTextureUtils}\n     */\n    this.textureUtils = new WebGPUTextureUtils(this);\n\n    /**\n     * A map that manages the resolve buffers for occlusion queries.\n     *\n     * @type {Map<Number,GPUBuffer>}\n     */\n    this.occludedResolveCache = new Map();\n  }\n\n  /**\n   * Initializes the backend so it is ready for usage.\n   *\n   * @async\n   * @param {Renderer} renderer - The renderer.\n   * @return {Promise} A Promise that resolves when the backend has been initialized.\n   */\n  async init(renderer) {\n    await super.init(renderer);\n\n    //\n\n    const parameters = this.parameters;\n\n    // create the device if it is not passed with parameters\n\n    let device;\n    if (parameters.device === undefined) {\n      const adapterOptions = {\n        powerPreference: parameters.powerPreference\n      };\n      const adapter = typeof navigator !== 'undefined' ? await navigator.gpu.requestAdapter(adapterOptions) : null;\n      if (adapter === null) {\n        throw new Error('WebGPUBackend: Unable to create WebGPU adapter.');\n      }\n\n      // feature support\n\n      const features = Object.values(GPUFeatureName);\n      const supportedFeatures = [];\n      for (const name of features) {\n        if (adapter.features.has(name)) {\n          supportedFeatures.push(name);\n        }\n      }\n      const deviceDescriptor = {\n        requiredFeatures: supportedFeatures,\n        requiredLimits: parameters.requiredLimits\n      };\n      device = await adapter.requestDevice(deviceDescriptor);\n    } else {\n      device = parameters.device;\n    }\n    device.lost.then(info => {\n      const deviceLossInfo = {\n        api: 'WebGPU',\n        message: info.message || 'Unknown reason',\n        reason: info.reason || null,\n        originalEvent: info\n      };\n      renderer.onDeviceLost(deviceLossInfo);\n    });\n    const context = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgpu');\n    this.device = device;\n    this.context = context;\n    const alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';\n    this.trackTimestamp = this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);\n    this.context.configure({\n      device: this.device,\n      format: this.utils.getPreferredCanvasFormat(),\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      alphaMode: alphaMode\n    });\n    this.updateSize();\n  }\n\n  /**\n   * The coordinate system of the backend.\n   *\n   * @type {Number}\n   * @readonly\n   */\n  get coordinateSystem() {\n    return WebGPUCoordinateSystem;\n  }\n\n  /**\n   * Transfers buffer data from a storage buffer attribute\n   * from the GPU to the CPU in context of compute shaders.\n   *\n   * @async\n   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n   */\n  async getArrayBufferAsync(attribute) {\n    return await this.attributeUtils.getArrayBufferAsync(attribute);\n  }\n\n  /**\n   * Returns the backend's rendering context.\n   *\n   * @return {GPUCanvasContext} The rendering context.\n   */\n  getContext() {\n    return this.context;\n  }\n\n  /**\n   * Returns the default render pass descriptor.\n   *\n   * In WebGPU, the default framebuffer must be configured\n   * like custom fraemebuffers so the backend needs a render\n   * pass descriptor even when rendering directly to screen.\n   *\n   * @private\n   * @return {Object} The render pass descriptor.\n   */\n  _getDefaultRenderPassDescriptor() {\n    let descriptor = this.defaultRenderPassdescriptor;\n    if (descriptor === null) {\n      const renderer = this.renderer;\n      descriptor = {\n        colorAttachments: [{\n          view: null\n        }]\n      };\n      if (this.renderer.depth === true || this.renderer.stencil === true) {\n        descriptor.depthStencilAttachment = {\n          view: this.textureUtils.getDepthBuffer(renderer.depth, renderer.stencil).createView()\n        };\n      }\n      const colorAttachment = descriptor.colorAttachments[0];\n      if (this.renderer.samples > 0) {\n        colorAttachment.view = this.colorBuffer.createView();\n      } else {\n        colorAttachment.resolveTarget = undefined;\n      }\n      this.defaultRenderPassdescriptor = descriptor;\n    }\n    const colorAttachment = descriptor.colorAttachments[0];\n    if (this.renderer.samples > 0) {\n      colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n    } else {\n      colorAttachment.view = this.context.getCurrentTexture().createView();\n    }\n    return descriptor;\n  }\n\n  /**\n   * Returns the render pass descriptor for the given render context.\n   *\n   * @private\n   * @param {RenderContext} renderContext - The render context.\n   * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.\n   * @return {Object} The render pass descriptor.\n   */\n  _getRenderPassDescriptor(renderContext, colorAttachmentsConfig = {}) {\n    const renderTarget = renderContext.renderTarget;\n    const renderTargetData = this.get(renderTarget);\n    let descriptors = renderTargetData.descriptors;\n    if (descriptors === undefined || renderTargetData.width !== renderTarget.width || renderTargetData.height !== renderTarget.height || renderTargetData.dimensions !== renderTarget.dimensions || renderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel || renderTargetData.activeCubeFace !== renderContext.activeCubeFace || renderTargetData.samples !== renderTarget.samples || renderTargetData.loadOp !== colorAttachmentsConfig.loadOp) {\n      descriptors = {};\n      renderTargetData.descriptors = descriptors;\n\n      // dispose\n\n      const onDispose = () => {\n        renderTarget.removeEventListener('dispose', onDispose);\n        this.delete(renderTarget);\n      };\n      renderTarget.addEventListener('dispose', onDispose);\n    }\n    const cacheKey = renderContext.getCacheKey();\n    let descriptor = descriptors[cacheKey];\n    if (descriptor === undefined) {\n      const textures = renderContext.textures;\n      const colorAttachments = [];\n      let sliceIndex;\n      for (let i = 0; i < textures.length; i++) {\n        const textureData = this.get(textures[i]);\n        const viewDescriptor = {\n          label: `colorAttachment_${i}`,\n          baseMipLevel: renderContext.activeMipmapLevel,\n          mipLevelCount: 1,\n          baseArrayLayer: renderContext.activeCubeFace,\n          arrayLayerCount: 1,\n          dimension: GPUTextureViewDimension.TwoD\n        };\n        if (renderTarget.isRenderTarget3D) {\n          sliceIndex = renderContext.activeCubeFace;\n          viewDescriptor.baseArrayLayer = 0;\n          viewDescriptor.dimension = GPUTextureViewDimension.ThreeD;\n          viewDescriptor.depthOrArrayLayers = textures[i].image.depth;\n        } else if (renderTarget.isRenderTargetArray) {\n          viewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;\n          viewDescriptor.depthOrArrayLayers = textures[i].image.depth;\n        }\n        const textureView = textureData.texture.createView(viewDescriptor);\n        let view, resolveTarget;\n        if (textureData.msaaTexture !== undefined) {\n          view = textureData.msaaTexture.createView();\n          resolveTarget = textureView;\n        } else {\n          view = textureView;\n          resolveTarget = undefined;\n        }\n        colorAttachments.push({\n          view,\n          depthSlice: sliceIndex,\n          resolveTarget,\n          loadOp: GPULoadOp.Load,\n          storeOp: GPUStoreOp.Store,\n          ...colorAttachmentsConfig\n        });\n      }\n      descriptor = {\n        colorAttachments\n      };\n      if (renderContext.depth) {\n        const depthTextureData = this.get(renderContext.depthTexture);\n        const depthStencilAttachment = {\n          view: depthTextureData.texture.createView()\n        };\n        descriptor.depthStencilAttachment = depthStencilAttachment;\n      }\n      descriptors[cacheKey] = descriptor;\n      renderTargetData.width = renderTarget.width;\n      renderTargetData.height = renderTarget.height;\n      renderTargetData.samples = renderTarget.samples;\n      renderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;\n      renderTargetData.activeCubeFace = renderContext.activeCubeFace;\n      renderTargetData.dimensions = renderTarget.dimensions;\n      renderTargetData.depthSlice = sliceIndex;\n      renderTargetData.loadOp = colorAttachments[0].loadOp;\n    }\n    return descriptor;\n  }\n\n  /**\n   * This method is executed at the beginning of a render call and prepares\n   * the WebGPU state for upcoming render calls\n   *\n   * @param {RenderContext} renderContext - The render context.\n   */\n  beginRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    const device = this.device;\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    let occlusionQuerySet;\n    if (occlusionQueryCount > 0) {\n      if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();\n      if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n      // Get a reference to the array of objects with queries. The renderContextData property\n      // can be changed by another render pass before the buffer.mapAsyc() completes.\n      renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n      renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n      //\n\n      occlusionQuerySet = device.createQuerySet({\n        type: 'occlusion',\n        count: occlusionQueryCount,\n        label: `occlusionQuerySet_${renderContext.id}`\n      });\n      renderContextData.occlusionQuerySet = occlusionQuerySet;\n      renderContextData.occlusionQueryIndex = 0;\n      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);\n      renderContextData.lastOcclusionObject = null;\n    }\n    let descriptor;\n    if (renderContext.textures === null) {\n      descriptor = this._getDefaultRenderPassDescriptor();\n    } else {\n      descriptor = this._getRenderPassDescriptor(renderContext, {\n        loadOp: GPULoadOp.Load\n      });\n    }\n    this.initTimestampQuery(renderContext, descriptor);\n    descriptor.occlusionQuerySet = occlusionQuerySet;\n    const depthStencilAttachment = descriptor.depthStencilAttachment;\n    if (renderContext.textures !== null) {\n      const colorAttachments = descriptor.colorAttachments;\n      for (let i = 0; i < colorAttachments.length; i++) {\n        const colorAttachment = colorAttachments[i];\n        if (renderContext.clearColor) {\n          colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n          };\n          colorAttachment.loadOp = GPULoadOp.Clear;\n          colorAttachment.storeOp = GPUStoreOp.Store;\n        } else {\n          colorAttachment.loadOp = GPULoadOp.Load;\n          colorAttachment.storeOp = GPUStoreOp.Store;\n        }\n      }\n    } else {\n      const colorAttachment = descriptor.colorAttachments[0];\n      if (renderContext.clearColor) {\n        colorAttachment.clearValue = renderContext.clearColorValue;\n        colorAttachment.loadOp = GPULoadOp.Clear;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      } else {\n        colorAttachment.loadOp = GPULoadOp.Load;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    if (renderContext.depth) {\n      if (renderContext.clearDepth) {\n        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n    if (renderContext.stencil) {\n      if (renderContext.clearStencil) {\n        depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    const encoder = device.createCommandEncoder({\n      label: 'renderContext_' + renderContext.id\n    });\n    const currentPass = encoder.beginRenderPass(descriptor);\n\n    //\n\n    renderContextData.descriptor = descriptor;\n    renderContextData.encoder = encoder;\n    renderContextData.currentPass = currentPass;\n    renderContextData.currentSets = {\n      attributes: {},\n      bindingGroups: [],\n      pipeline: null,\n      index: null\n    };\n    renderContextData.renderBundles = [];\n\n    //\n\n    if (renderContext.viewport) {\n      this.updateViewport(renderContext);\n    }\n    if (renderContext.scissor) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = renderContext.scissorValue;\n      currentPass.setScissorRect(x, y, width, height);\n    }\n  }\n\n  /**\n   * This method is executed at the end of a render call and finalizes work\n   * after draw calls.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   */\n  finishRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (renderContextData.renderBundles.length > 0) {\n      renderContextData.currentPass.executeBundles(renderContextData.renderBundles);\n    }\n    if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {\n      renderContextData.currentPass.endOcclusionQuery();\n    }\n    renderContextData.currentPass.end();\n    if (occlusionQueryCount > 0) {\n      const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n      //\n\n      let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);\n      if (queryResolveBuffer === undefined) {\n        queryResolveBuffer = this.device.createBuffer({\n          size: bufferSize,\n          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n        });\n        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);\n      }\n\n      //\n\n      const readBuffer = this.device.createBuffer({\n        size: bufferSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n      });\n\n      // two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n      renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);\n      renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);\n      renderContextData.occlusionQueryBuffer = readBuffer;\n\n      //\n\n      this.resolveOccludedAsync(renderContext);\n    }\n    this.prepareTimestampBuffer(renderContext, renderContextData.encoder);\n    this.device.queue.submit([renderContextData.encoder.finish()]);\n\n    //\n\n    if (renderContext.textures !== null) {\n      const textures = renderContext.textures;\n      for (let i = 0; i < textures.length; i++) {\n        const texture = textures[i];\n        if (texture.generateMipmaps === true) {\n          this.textureUtils.generateMipmaps(texture);\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns `true` if the given 3D object is fully occluded by other\n   * 3D objects in the scene.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   * @param {Object3D} object - The 3D object to test.\n   * @return {Boolean} Whether the 3D object is fully occluded or not.\n   */\n  isOccluded(renderContext, object) {\n    const renderContextData = this.get(renderContext);\n    return renderContextData.occluded && renderContextData.occluded.has(object);\n  }\n\n  /**\n   * This method processes the result of occlusion queries and writes it\n   * into render context data.\n   *\n   * @async\n   * @param {RenderContext} renderContext - The render context.\n   */\n  async resolveOccludedAsync(renderContext) {\n    const renderContextData = this.get(renderContext);\n\n    // handle occlusion query results\n\n    const {\n      currentOcclusionQueryBuffer,\n      currentOcclusionQueryObjects\n    } = renderContextData;\n    if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {\n      const occluded = new WeakSet();\n      renderContextData.currentOcclusionQueryObjects = null;\n      renderContextData.currentOcclusionQueryBuffer = null;\n      await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);\n      const buffer = currentOcclusionQueryBuffer.getMappedRange();\n      const results = new BigUint64Array(buffer);\n      for (let i = 0; i < currentOcclusionQueryObjects.length; i++) {\n        if (results[i] !== BigInt(0)) {\n          occluded.add(currentOcclusionQueryObjects[i]);\n        }\n      }\n      currentOcclusionQueryBuffer.destroy();\n      renderContextData.occluded = occluded;\n    }\n  }\n\n  /**\n   * Updates the viewport with the values from the given render context.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   */\n  updateViewport(renderContext) {\n    const {\n      currentPass\n    } = this.get(renderContext);\n    const {\n      x,\n      y,\n      width,\n      height,\n      minDepth,\n      maxDepth\n    } = renderContext.viewportValue;\n    currentPass.setViewport(x, y, width, height, minDepth, maxDepth);\n  }\n\n  /**\n   * Performs a clear operation.\n   *\n   * @param {Boolean} color - Whether the color buffer should be cleared or not.\n   * @param {Boolean} depth - Whether the depth buffer should be cleared or not.\n   * @param {Boolean} stencil - Whether the stencil buffer should be cleared or not.\n   * @param {RenderContext?} [renderTargetContext=null] - The render context of the current set render target.\n   */\n  clear(color, depth, stencil, renderTargetContext = null) {\n    const device = this.device;\n    const renderer = this.renderer;\n    let colorAttachments = [];\n    let depthStencilAttachment;\n    let clearValue;\n    let supportsDepth;\n    let supportsStencil;\n    if (color) {\n      const clearColor = this.getClearColor();\n      if (this.renderer.alpha === true) {\n        // premultiply alpha\n\n        const a = clearColor.a;\n        clearValue = {\n          r: clearColor.r * a,\n          g: clearColor.g * a,\n          b: clearColor.b * a,\n          a: a\n        };\n      } else {\n        clearValue = {\n          r: clearColor.r,\n          g: clearColor.g,\n          b: clearColor.b,\n          a: clearColor.a\n        };\n      }\n    }\n    if (renderTargetContext === null) {\n      supportsDepth = renderer.depth;\n      supportsStencil = renderer.stencil;\n      const descriptor = this._getDefaultRenderPassDescriptor();\n      if (color) {\n        colorAttachments = descriptor.colorAttachments;\n        const colorAttachment = colorAttachments[0];\n        colorAttachment.clearValue = clearValue;\n        colorAttachment.loadOp = GPULoadOp.Clear;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      }\n      if (supportsDepth || supportsStencil) {\n        depthStencilAttachment = descriptor.depthStencilAttachment;\n      }\n    } else {\n      supportsDepth = renderTargetContext.depth;\n      supportsStencil = renderTargetContext.stencil;\n      if (color) {\n        const descriptor = this._getRenderPassDescriptor(renderTargetContext, {\n          loadOp: GPULoadOp.Clear\n        });\n        colorAttachments = descriptor.colorAttachments;\n      }\n      if (supportsDepth || supportsStencil) {\n        const depthTextureData = this.get(renderTargetContext.depthTexture);\n        depthStencilAttachment = {\n          view: depthTextureData.texture.createView()\n        };\n      }\n    }\n\n    //\n\n    if (supportsDepth) {\n      if (depth) {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.depthClearValue = renderer.getClearDepth();\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    if (supportsStencil) {\n      if (stencil) {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.stencilClearValue = renderer.getClearStencil();\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    const encoder = device.createCommandEncoder({});\n    const currentPass = encoder.beginRenderPass({\n      colorAttachments,\n      depthStencilAttachment\n    });\n    currentPass.end();\n    device.queue.submit([encoder.finish()]);\n  }\n\n  // compute\n\n  /**\n   * This method is executed at the beginning of a compute call and\n   * prepares the state for upcoming compute tasks.\n   *\n   * @param {Node|Array<Node>} computeGroup - The compute node(s).\n   */\n  beginCompute(computeGroup) {\n    const groupGPU = this.get(computeGroup);\n    const descriptor = {};\n    this.initTimestampQuery(computeGroup, descriptor);\n    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder();\n    groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass(descriptor);\n  }\n\n  /**\n   * Executes a compute command for the given compute node.\n   *\n   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n   * @param {Node} computeNode - The compute node.\n   * @param {Array<BindGroup>} bindings - The bindings.\n   * @param {ComputePipeline} pipeline - The compute pipeline.\n   */\n  compute(computeGroup, computeNode, bindings, pipeline) {\n    const {\n      passEncoderGPU\n    } = this.get(computeGroup);\n\n    // pipeline\n\n    const pipelineGPU = this.get(pipeline).pipeline;\n    passEncoderGPU.setPipeline(pipelineGPU);\n\n    // bind groups\n\n    for (let i = 0, l = bindings.length; i < l; i++) {\n      const bindGroup = bindings[i];\n      const bindingsData = this.get(bindGroup);\n      passEncoderGPU.setBindGroup(i, bindingsData.group);\n    }\n    const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;\n    const computeNodeData = this.get(computeNode);\n    if (computeNodeData.dispatchSize === undefined) computeNodeData.dispatchSize = {\n      x: 0,\n      y: 1,\n      z: 1\n    };\n    const {\n      dispatchSize\n    } = computeNodeData;\n    if (computeNode.dispatchCount > maxComputeWorkgroupsPerDimension) {\n      dispatchSize.x = Math.min(computeNode.dispatchCount, maxComputeWorkgroupsPerDimension);\n      dispatchSize.y = Math.ceil(computeNode.dispatchCount / maxComputeWorkgroupsPerDimension);\n    } else {\n      dispatchSize.x = computeNode.dispatchCount;\n    }\n    passEncoderGPU.dispatchWorkgroups(dispatchSize.x, dispatchSize.y, dispatchSize.z);\n  }\n\n  /**\n   * This method is executed at the end of a compute call and\n   * finalizes work after compute tasks.\n   *\n   * @param {Node|Array<Node>} computeGroup - The compute node(s).\n   */\n  finishCompute(computeGroup) {\n    const groupData = this.get(computeGroup);\n    groupData.passEncoderGPU.end();\n    this.prepareTimestampBuffer(computeGroup, groupData.cmdEncoderGPU);\n    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);\n  }\n\n  /**\n   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n   * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n   *\n   * @async\n   * @return {Promise} A Promise that resolves when synchronization has been finished.\n   */\n  async waitForGPU() {\n    await this.device.queue.onSubmittedWorkDone();\n  }\n\n  // render object\n\n  /**\n   * Executes a draw command for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object to draw.\n   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n   */\n  draw(renderObject, info) {\n    const {\n      object,\n      context,\n      pipeline\n    } = renderObject;\n    const bindings = renderObject.getBindings();\n    const renderContextData = this.get(context);\n    const pipelineGPU = this.get(pipeline).pipeline;\n    const currentSets = renderContextData.currentSets;\n    const passEncoderGPU = renderContextData.currentPass;\n    const drawParams = renderObject.getDrawParameters();\n    if (drawParams === null) return;\n\n    // pipeline\n\n    if (currentSets.pipeline !== pipelineGPU) {\n      passEncoderGPU.setPipeline(pipelineGPU);\n      currentSets.pipeline = pipelineGPU;\n    }\n\n    // bind groups\n\n    const currentBindingGroups = currentSets.bindingGroups;\n    for (let i = 0, l = bindings.length; i < l; i++) {\n      const bindGroup = bindings[i];\n      const bindingsData = this.get(bindGroup);\n      if (currentBindingGroups[bindGroup.index] !== bindGroup.id) {\n        passEncoderGPU.setBindGroup(bindGroup.index, bindingsData.group);\n        currentBindingGroups[bindGroup.index] = bindGroup.id;\n      }\n    }\n\n    // attributes\n\n    const index = renderObject.getIndex();\n    const hasIndex = index !== null;\n\n    // index\n\n    if (hasIndex === true) {\n      if (currentSets.index !== index) {\n        const buffer = this.get(index).buffer;\n        const indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n        passEncoderGPU.setIndexBuffer(buffer, indexFormat);\n        currentSets.index = index;\n      }\n    }\n\n    // vertex buffers\n\n    const vertexBuffers = renderObject.getVertexBuffers();\n    for (let i = 0, l = vertexBuffers.length; i < l; i++) {\n      const vertexBuffer = vertexBuffers[i];\n      if (currentSets.attributes[i] !== vertexBuffer) {\n        const buffer = this.get(vertexBuffer).buffer;\n        passEncoderGPU.setVertexBuffer(i, buffer);\n        currentSets.attributes[i] = vertexBuffer;\n      }\n    }\n\n    // occlusion queries - handle multiple consecutive draw calls for an object\n\n    if (renderContextData.occlusionQuerySet !== undefined) {\n      const lastObject = renderContextData.lastOcclusionObject;\n      if (lastObject !== object) {\n        if (lastObject !== null && lastObject.occlusionTest === true) {\n          passEncoderGPU.endOcclusionQuery();\n          renderContextData.occlusionQueryIndex++;\n        }\n        if (object.occlusionTest === true) {\n          passEncoderGPU.beginOcclusionQuery(renderContextData.occlusionQueryIndex);\n          renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex] = object;\n        }\n        renderContextData.lastOcclusionObject = object;\n      }\n    }\n\n    // draw\n\n    if (object.isBatchedMesh === true) {\n      const starts = object._multiDrawStarts;\n      const counts = object._multiDrawCounts;\n      const drawCount = object._multiDrawCount;\n      const drawInstances = object._multiDrawInstances;\n      for (let i = 0; i < drawCount; i++) {\n        const count = drawInstances ? drawInstances[i] : 1;\n        const firstInstance = count > 1 ? 0 : i;\n        if (hasIndex === true) {\n          passEncoderGPU.drawIndexed(counts[i], count, starts[i] / index.array.BYTES_PER_ELEMENT, 0, firstInstance);\n        } else {\n          passEncoderGPU.draw(counts[i], count, starts[i], firstInstance);\n        }\n      }\n    } else if (hasIndex === true) {\n      const {\n        vertexCount: indexCount,\n        instanceCount,\n        firstVertex: firstIndex\n      } = drawParams;\n      const indirect = renderObject.getIndirect();\n      if (indirect !== null) {\n        const buffer = this.get(indirect).buffer;\n        passEncoderGPU.drawIndexedIndirect(buffer, 0);\n      } else {\n        passEncoderGPU.drawIndexed(indexCount, instanceCount, firstIndex, 0, 0);\n      }\n      info.update(object, indexCount, instanceCount);\n    } else {\n      const {\n        vertexCount,\n        instanceCount,\n        firstVertex\n      } = drawParams;\n      const indirect = renderObject.getIndirect();\n      if (indirect !== null) {\n        const buffer = this.get(indirect).buffer;\n        passEncoderGPU.drawIndirect(buffer, 0);\n      } else {\n        passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);\n      }\n      info.update(object, vertexCount, instanceCount);\n    }\n  }\n\n  // cache key\n\n  /**\n   * Returns `true` if the render pipeline requires an update.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {Boolean} Whether the render pipeline requires an update or not.\n   */\n  needsRenderUpdate(renderObject) {\n    const data = this.get(renderObject);\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const sampleCount = utils.getSampleCountRenderContext(renderObject.context);\n    const colorSpace = utils.getCurrentColorSpace(renderObject.context);\n    const colorFormat = utils.getCurrentColorFormat(renderObject.context);\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);\n    const primitiveTopology = utils.getPrimitiveTopology(object, material);\n    let needsUpdate = false;\n    if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat || data.primitiveTopology !== primitiveTopology || data.clippingContextCacheKey !== renderObject.clippingContextCacheKey) {\n      data.material = material;\n      data.materialVersion = material.version;\n      data.transparent = material.transparent;\n      data.blending = material.blending;\n      data.premultipliedAlpha = material.premultipliedAlpha;\n      data.blendSrc = material.blendSrc;\n      data.blendDst = material.blendDst;\n      data.blendEquation = material.blendEquation;\n      data.blendSrcAlpha = material.blendSrcAlpha;\n      data.blendDstAlpha = material.blendDstAlpha;\n      data.blendEquationAlpha = material.blendEquationAlpha;\n      data.colorWrite = material.colorWrite;\n      data.depthWrite = material.depthWrite;\n      data.depthTest = material.depthTest;\n      data.depthFunc = material.depthFunc;\n      data.stencilWrite = material.stencilWrite;\n      data.stencilFunc = material.stencilFunc;\n      data.stencilFail = material.stencilFail;\n      data.stencilZFail = material.stencilZFail;\n      data.stencilZPass = material.stencilZPass;\n      data.stencilFuncMask = material.stencilFuncMask;\n      data.stencilWriteMask = material.stencilWriteMask;\n      data.side = material.side;\n      data.alphaToCoverage = material.alphaToCoverage;\n      data.sampleCount = sampleCount;\n      data.colorSpace = colorSpace;\n      data.colorFormat = colorFormat;\n      data.depthStencilFormat = depthStencilFormat;\n      data.primitiveTopology = primitiveTopology;\n      data.clippingContextCacheKey = renderObject.clippingContextCacheKey;\n      needsUpdate = true;\n    }\n    return needsUpdate;\n  }\n\n  /**\n   * Returns a cache key that is used to identify render pipelines.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @return {String} The cache key.\n   */\n  getRenderCacheKey(renderObject) {\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const renderContext = renderObject.context;\n    return [material.transparent, material.blending, material.premultipliedAlpha, material.blendSrc, material.blendDst, material.blendEquation, material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha, material.colorWrite, material.depthWrite, material.depthTest, material.depthFunc, material.stencilWrite, material.stencilFunc, material.stencilFail, material.stencilZFail, material.stencilZPass, material.stencilFuncMask, material.stencilWriteMask, material.side, utils.getSampleCountRenderContext(renderContext), utils.getCurrentColorSpace(renderContext), utils.getCurrentColorFormat(renderContext), utils.getCurrentDepthStencilFormat(renderContext), utils.getPrimitiveTopology(object, material), renderObject.getGeometryCacheKey(), renderObject.clippingContextCacheKey].join();\n  }\n\n  // textures\n\n  /**\n   * Creates a sampler for the given texture.\n   *\n   * @param {Texture} texture - The texture to create the sampler for.\n   */\n  createSampler(texture) {\n    this.textureUtils.createSampler(texture);\n  }\n\n  /**\n   * Destroys the sampler for the given texture.\n   *\n   * @param {Texture} texture - The texture to destroy the sampler for.\n   */\n  destroySampler(texture) {\n    this.textureUtils.destroySampler(texture);\n  }\n\n  /**\n   * Creates a default texture for the given texture that can be used\n   * as a placeholder until the actual texture is ready for usage.\n   *\n   * @param {Texture} texture - The texture to create a default texture for.\n   */\n  createDefaultTexture(texture) {\n    this.textureUtils.createDefaultTexture(texture);\n  }\n\n  /**\n   * Defines a texture on the GPU for the given texture object.\n   *\n   * @param {Texture} texture - The texture.\n   * @param {Object} [options={}] - Optional configuration parameter.\n   */\n  createTexture(texture, options) {\n    this.textureUtils.createTexture(texture, options);\n  }\n\n  /**\n   * Uploads the updated texture data to the GPU.\n   *\n   * @param {Texture} texture - The texture.\n   * @param {Object} [options={}] - Optional configuration parameter.\n   */\n  updateTexture(texture, options) {\n    this.textureUtils.updateTexture(texture, options);\n  }\n\n  /**\n   * Generates mipmaps for the given texture\n   *\n   * @param {Texture} texture - The texture.\n   */\n  generateMipmaps(texture) {\n    this.textureUtils.generateMipmaps(texture);\n  }\n\n  /**\n   * Destroys the GPU data for the given texture object.\n   *\n   * @param {Texture} texture - The texture.\n   */\n  destroyTexture(texture) {\n    this.textureUtils.destroyTexture(texture);\n  }\n\n  /**\n   * Returns texture data as a typed array.\n   *\n   * @param {Texture} texture - The texture to copy.\n   * @param {Number} x - The x coordinate of the copy origin.\n   * @param {Number} y - The y coordinate of the copy origin.\n   * @param {Number} width - The width of the copy.\n   * @param {Number} height - The height of the copy.\n   * @param {Number} faceIndex - The face index.\n   * @return {TypedArray} The texture data as a typed array.\n   */\n  copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);\n  }\n\n  /**\n   * Inits a time stamp query for the given render context.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   * @param {Object} descriptor - The query descriptor.\n   */\n  initTimestampQuery(renderContext, descriptor) {\n    if (!this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (!renderContextData.timeStampQuerySet) {\n      const type = renderContext.isComputeNode ? 'compute' : 'render';\n      const timeStampQuerySet = this.device.createQuerySet({\n        type: 'timestamp',\n        count: 2,\n        label: `timestamp_${type}_${renderContext.id}`\n      });\n      const timestampWrites = {\n        querySet: timeStampQuerySet,\n        beginningOfPassWriteIndex: 0,\n        // Write timestamp in index 0 when pass begins.\n        endOfPassWriteIndex: 1 // Write timestamp in index 1 when pass ends.\n      };\n      Object.assign(descriptor, {\n        timestampWrites\n      });\n      renderContextData.timeStampQuerySet = timeStampQuerySet;\n    }\n  }\n\n  /**\n   * Prepares the timestamp buffer.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   * @param {GPUCommandEncoder} encoder - The command encoder.\n   */\n  prepareTimestampBuffer(renderContext, encoder) {\n    if (!this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    const size = 2 * BigInt64Array.BYTES_PER_ELEMENT;\n    if (renderContextData.currentTimestampQueryBuffers === undefined) {\n      renderContextData.currentTimestampQueryBuffers = {\n        resolveBuffer: this.device.createBuffer({\n          label: 'timestamp resolve buffer',\n          size: size,\n          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n        }),\n        resultBuffer: this.device.createBuffer({\n          label: 'timestamp result buffer',\n          size: size,\n          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n        })\n      };\n    }\n    const {\n      resolveBuffer,\n      resultBuffer\n    } = renderContextData.currentTimestampQueryBuffers;\n    encoder.resolveQuerySet(renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0);\n    if (resultBuffer.mapState === 'unmapped') {\n      encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, size);\n    }\n  }\n\n  /**\n   * Resolves the time stamp for the given render context and type.\n   *\n   * @async\n   * @param {RenderContext} renderContext - The render context.\n   * @param {String} type - The render context.\n   * @return {Promise} A Promise that resolves when the time stamp has been computed.\n   */\n  async resolveTimestampAsync(renderContext, type = 'render') {\n    if (!this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (renderContextData.currentTimestampQueryBuffers === undefined) return;\n    const {\n      resultBuffer\n    } = renderContextData.currentTimestampQueryBuffers;\n    if (resultBuffer.mapState === 'unmapped') {\n      resultBuffer.mapAsync(GPUMapMode.READ).then(() => {\n        const times = new BigUint64Array(resultBuffer.getMappedRange());\n        const duration = Number(times[1] - times[0]) / 1000000;\n        this.renderer.info.updateTimestamp(type, duration);\n        resultBuffer.unmap();\n      });\n    }\n  }\n\n  // node builder\n\n  /**\n   * Returns a node builder for the given render object.\n   *\n   * @param {RenderObject} object - The render object.\n   * @param {Renderer} renderer - The renderer.\n   * @return {WGSLNodeBuilder} The node builder.\n   */\n  createNodeBuilder(object, renderer) {\n    return new WGSLNodeBuilder(object, renderer);\n  }\n\n  // program\n\n  /**\n   * Creates a shader program from the given programmable stage.\n   *\n   * @param {ProgrammableStage} program - The programmable stage.\n   */\n  createProgram(program) {\n    const programGPU = this.get(program);\n    programGPU.module = {\n      module: this.device.createShaderModule({\n        code: program.code,\n        label: program.stage + (program.name !== '' ? `_${program.name}` : '')\n      }),\n      entryPoint: 'main'\n    };\n  }\n\n  /**\n   * Destroys the shader program of the given programmable stage.\n   *\n   * @param {ProgrammableStage} program - The programmable stage.\n   */\n  destroyProgram(program) {\n    this.delete(program);\n  }\n\n  // pipelines\n\n  /**\n   * Creates a render pipeline for the given render object.\n   *\n   * @param {RenderObject} renderObject - The render object.\n   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n   */\n  createRenderPipeline(renderObject, promises) {\n    this.pipelineUtils.createRenderPipeline(renderObject, promises);\n  }\n\n  /**\n   * Creates a compute pipeline for the given compute node.\n   *\n   * @param {ComputePipeline} computePipeline - The compute pipeline.\n   * @param {Array<BindGroup>} bindings - The bindings.\n   */\n  createComputePipeline(computePipeline, bindings) {\n    this.pipelineUtils.createComputePipeline(computePipeline, bindings);\n  }\n\n  /**\n   * Prepares the state for encoding render bundles.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   */\n  beginBundle(renderContext) {\n    const renderContextData = this.get(renderContext);\n    renderContextData._currentPass = renderContextData.currentPass;\n    renderContextData._currentSets = renderContextData.currentSets;\n    renderContextData.currentSets = {\n      attributes: {},\n      bindingGroups: [],\n      pipeline: null,\n      index: null\n    };\n    renderContextData.currentPass = this.pipelineUtils.createBundleEncoder(renderContext);\n  }\n\n  /**\n   * After processing render bundles this method finalizes related work.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   * @param {RenderBundle} bundle - The render bundle.\n   */\n  finishBundle(renderContext, bundle) {\n    const renderContextData = this.get(renderContext);\n    const bundleEncoder = renderContextData.currentPass;\n    const bundleGPU = bundleEncoder.finish();\n    this.get(bundle).bundleGPU = bundleGPU;\n\n    // restore render pass state\n\n    renderContextData.currentSets = renderContextData._currentSets;\n    renderContextData.currentPass = renderContextData._currentPass;\n  }\n\n  /**\n   * Adds a render bundle to the render context data.\n   *\n   * @param {RenderContext} renderContext - The render context.\n   * @param {RenderBundle} bundle - The render bundle to add.\n   */\n  addBundle(renderContext, bundle) {\n    const renderContextData = this.get(renderContext);\n    renderContextData.renderBundles.push(this.get(bundle).bundleGPU);\n  }\n\n  // bindings\n\n  /**\n   * Creates bindings from the given bind group definition.\n   *\n   * @param {BindGroup} bindGroup - The bind group.\n   * @param {Array<BindGroup>} bindings - Array of bind groups.\n   * @param {Number} cacheIndex - The cache index.\n   * @param {Number} version - The version.\n   */\n  createBindings(bindGroup, bindings, cacheIndex, version) {\n    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);\n  }\n\n  /**\n   * Updates the given bind group definition.\n   *\n   * @param {BindGroup} bindGroup - The bind group.\n   * @param {Array<BindGroup>} bindings - Array of bind groups.\n   * @param {Number} cacheIndex - The cache index.\n   * @param {Number} version - The version.\n   */\n  updateBindings(bindGroup, bindings, cacheIndex, version) {\n    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);\n  }\n\n  /**\n   * Updates a buffer binding.\n   *\n   *  @param {Buffer} binding - The buffer binding to update.\n   */\n  updateBinding(binding) {\n    this.bindingUtils.updateBinding(binding);\n  }\n\n  // attributes\n\n  /**\n   * Creates the buffer of an indexed shader attribute.\n   *\n   * @param {BufferAttribute} attribute - The indexed buffer attribute.\n   */\n  createIndexAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n\n  /**\n   * Creates the buffer of a shader attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute.\n   */\n  createAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n\n  /**\n   * Creates the buffer of a storage attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute.\n   */\n  createStorageAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n\n  /**\n   * Creates the buffer of an indirect storage attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute.\n   */\n  createIndirectStorageAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n\n  /**\n   * Updates the buffer of a shader attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute to update.\n   */\n  updateAttribute(attribute) {\n    this.attributeUtils.updateAttribute(attribute);\n  }\n\n  /**\n   * Destroys the buffer of a shader attribute.\n   *\n   * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n   */\n  destroyAttribute(attribute) {\n    this.attributeUtils.destroyAttribute(attribute);\n  }\n\n  // canvas\n\n  /**\n   * Triggers an update of the default render pass descriptor.\n   */\n  updateSize() {\n    this.colorBuffer = this.textureUtils.getColorBuffer();\n    this.defaultRenderPassdescriptor = null;\n  }\n\n  // utils public\n\n  /**\n   * Returns the maximum anisotropy texture filtering value.\n   *\n   * @return {Number} The maximum anisotropy texture filtering value.\n   */\n  getMaxAnisotropy() {\n    return 16;\n  }\n\n  /**\n   * Checks if the given feature is supported  by the backend.\n   *\n   * @param {String} name - The feature's name.\n   * @return {Boolean} Whether the feature is supported or not.\n   */\n  hasFeature(name) {\n    return this.device.features.has(name);\n  }\n\n  /**\n   * Copies data of the given source texture to the given destination texture.\n   *\n   * @param {Texture} srcTexture - The source texture.\n   * @param {Texture} dstTexture - The destination texture.\n   * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n   * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n   * @param {Number} [level=0] - The mip level to copy.\n   */\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n    let dstX = 0;\n    let dstY = 0;\n    let dstLayer = 0;\n    let srcX = 0;\n    let srcY = 0;\n    let srcLayer = 0;\n    let srcWidth = srcTexture.image.width;\n    let srcHeight = srcTexture.image.height;\n    if (srcRegion !== null) {\n      srcX = srcRegion.x;\n      srcY = srcRegion.y;\n      srcLayer = srcRegion.z || 0;\n      srcWidth = srcRegion.width;\n      srcHeight = srcRegion.height;\n    }\n    if (dstPosition !== null) {\n      dstX = dstPosition.x;\n      dstY = dstPosition.y;\n      dstLayer = dstPosition.z || 0;\n    }\n    const encoder = this.device.createCommandEncoder({\n      label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id\n    });\n    const sourceGPU = this.get(srcTexture).texture;\n    const destinationGPU = this.get(dstTexture).texture;\n    encoder.copyTextureToTexture({\n      texture: sourceGPU,\n      mipLevel: level,\n      origin: {\n        x: srcX,\n        y: srcY,\n        z: srcLayer\n      }\n    }, {\n      texture: destinationGPU,\n      mipLevel: level,\n      origin: {\n        x: dstX,\n        y: dstY,\n        z: dstLayer\n      }\n    }, [srcWidth, srcHeight, 1]);\n    this.device.queue.submit([encoder.finish()]);\n  }\n\n  /**\n   * Copies the current bound framebuffer to the given texture.\n   *\n   * @param {Texture} texture - The destination texture.\n   * @param {RenderContext} renderContext - The render context.\n   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n   */\n  copyFramebufferToTexture(texture, renderContext, rectangle) {\n    const renderContextData = this.get(renderContext);\n    let sourceGPU = null;\n    if (renderContext.renderTarget) {\n      if (texture.isDepthTexture) {\n        sourceGPU = this.get(renderContext.depthTexture).texture;\n      } else {\n        sourceGPU = this.get(renderContext.textures[0]).texture;\n      }\n    } else {\n      if (texture.isDepthTexture) {\n        sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);\n      } else {\n        sourceGPU = this.context.getCurrentTexture();\n      }\n    }\n    const destinationGPU = this.get(texture).texture;\n    if (sourceGPU.format !== destinationGPU.format) {\n      console.error('WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format);\n      return;\n    }\n    let encoder;\n    if (renderContextData.currentPass) {\n      renderContextData.currentPass.end();\n      encoder = renderContextData.encoder;\n    } else {\n      encoder = this.device.createCommandEncoder({\n        label: 'copyFramebufferToTexture_' + texture.id\n      });\n    }\n    encoder.copyTextureToTexture({\n      texture: sourceGPU,\n      origin: [rectangle.x, rectangle.y, 0]\n    }, {\n      texture: destinationGPU\n    }, [rectangle.z, rectangle.w]);\n    if (texture.generateMipmaps) this.textureUtils.generateMipmaps(texture);\n    if (renderContextData.currentPass) {\n      const {\n        descriptor\n      } = renderContextData;\n      for (let i = 0; i < descriptor.colorAttachments.length; i++) {\n        descriptor.colorAttachments[i].loadOp = GPULoadOp.Load;\n      }\n      if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n      if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n      renderContextData.currentPass = encoder.beginRenderPass(descriptor);\n      renderContextData.currentSets = {\n        attributes: {},\n        bindingGroups: [],\n        pipeline: null,\n        index: null\n      };\n      if (renderContext.viewport) {\n        this.updateViewport(renderContext);\n      }\n      if (renderContext.scissor) {\n        const {\n          x,\n          y,\n          width,\n          height\n        } = renderContext.scissorValue;\n        renderContextData.currentPass.setScissorRect(x, y, width, height);\n      }\n    } else {\n      this.device.queue.submit([encoder.finish()]);\n    }\n  }\n}\nclass IESSpotLight extends SpotLight {\n  constructor(color, intensity, distance, angle, penumbra, decay) {\n    super(color, intensity, distance, angle, penumbra, decay);\n    this.iesMap = null;\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.iesMap = source.iesMap;\n    return this;\n  }\n}\n\n/**\n * This version of a node library represents the standard version\n * used in {@link WebGPURenderer}. It maps lights, tone mapping\n * techniques and materials to node-based implementations.\n *\n * @private\n * @augments NodeLibrary\n */\nclass StandardNodeLibrary extends NodeLibrary {\n  /**\n   * Constructs a new standard node library.\n   */\n  constructor() {\n    super();\n    this.addMaterial(MeshPhongNodeMaterial, 'MeshPhongMaterial');\n    this.addMaterial(MeshStandardNodeMaterial, 'MeshStandardMaterial');\n    this.addMaterial(MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial');\n    this.addMaterial(MeshToonNodeMaterial, 'MeshToonMaterial');\n    this.addMaterial(MeshBasicNodeMaterial, 'MeshBasicMaterial');\n    this.addMaterial(MeshLambertNodeMaterial, 'MeshLambertMaterial');\n    this.addMaterial(MeshNormalNodeMaterial, 'MeshNormalMaterial');\n    this.addMaterial(MeshMatcapNodeMaterial, 'MeshMatcapMaterial');\n    this.addMaterial(LineBasicNodeMaterial, 'LineBasicMaterial');\n    this.addMaterial(LineDashedNodeMaterial, 'LineDashedMaterial');\n    this.addMaterial(PointsNodeMaterial, 'PointsMaterial');\n    this.addMaterial(SpriteNodeMaterial, 'SpriteMaterial');\n    this.addMaterial(ShadowNodeMaterial, 'ShadowMaterial');\n    this.addLight(PointLightNode, PointLight);\n    this.addLight(DirectionalLightNode, DirectionalLight);\n    this.addLight(RectAreaLightNode, RectAreaLight);\n    this.addLight(SpotLightNode, SpotLight);\n    this.addLight(AmbientLightNode, AmbientLight);\n    this.addLight(HemisphereLightNode, HemisphereLight);\n    this.addLight(LightProbeNode, LightProbe);\n    this.addLight(IESSpotLightNode, IESSpotLight);\n    this.addToneMapping(linearToneMapping, LinearToneMapping);\n    this.addToneMapping(reinhardToneMapping, ReinhardToneMapping);\n    this.addToneMapping(cineonToneMapping, CineonToneMapping);\n    this.addToneMapping(acesFilmicToneMapping, ACESFilmicToneMapping);\n    this.addToneMapping(agxToneMapping, AgXToneMapping);\n    this.addToneMapping(neutralToneMapping, NeutralToneMapping);\n  }\n}\n\n/*\nconst debugHandler = {\n\n\tget: function ( target, name ) {\n\n\t\t// Add |update\n\t\tif ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );\n\n\t\treturn target[ name ];\n\n\t}\n\n};\n*/\n\n/**\n * This renderer is the new alternative of `WebGLRenderer`. `WebGPURenderer` has the ability\n * to target different backends. By default, the renderer tries to use a WebGPU backend if the\n * browser supports WebGPU. If not, `WebGPURenderer` falls backs to a WebGL 2 backend.\n *\n * @augments module:Renderer~Renderer\n */\nclass WebGPURenderer extends Renderer {\n  /**\n   * Constructs a new WebGPU renderer.\n   *\n   * @param {Object} parameters - The configuration parameter.\n   * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n   * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n   * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n   * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n   * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n   * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0\n   * to overwrite the default.\n   * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses it\n   * WebGL 2 backend no matter if WebGPU is supported or not.\n   */\n  constructor(parameters = {}) {\n    let BackendClass;\n    if (parameters.forceWebGL) {\n      BackendClass = WebGLBackend;\n    } else {\n      BackendClass = WebGPUBackend;\n      parameters.getFallback = () => {\n        console.warn('THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.');\n        return new WebGLBackend(parameters);\n      };\n    }\n    const backend = new BackendClass(parameters);\n\n    //super( new Proxy( backend, debugHandler ) );\n    super(backend, parameters);\n\n    /**\n     * The generic default value is overwritten with the\n     * standard node library for type mapping.\n     *\n     * @type {StandardNodeLibrary}\n     */\n    this.library = new StandardNodeLibrary();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isWebGPURenderer = true;\n  }\n}\n\n/**\n * A specialized group which eanbles applications access to the\n * Render Bundle API of WebGPU. The group with all its descendant nodes\n * are considered as one render bundle and processed as such by\n * the renderer.\n *\n * This module is only fully supported by `WebGPURenderer` with a WebGPU backend.\n * With a WebGL backend, the group can technically be rendered but without\n * any performance improvements.\n *\n * @augments Group\n */\nclass BundleGroup extends Group {\n  /**\n   * Constructs a new bundle group.\n   */\n  constructor() {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isBundleGroup = true;\n\n    /**\n     * This property is only relevant for detecting types\n     * during serialization/deserialization. It should always\n     * match the class name.\n     *\n     * @type {String}\n     * @readonly\n     * @default 'BundleGroup'\n     */\n    this.type = 'BundleGroup';\n\n    /**\n     * Whether the bundle is static or not. When set to `true`, the structure\n     * is assumed to be static and does not change. E.g. no new objects are\n     * added to the group\n     *\n     * If a change is required, an update can still be forced by setting the\n     * `needsUpdate` flag to `true`.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.static = true;\n\n    /**\n     * The bundle group's version.\n     *\n     * @type {Number}\n     * @readonly\n     * @default 0\n     */\n    this.version = 0;\n  }\n\n  /**\n   * Set this property to `true` when the bundle group has changed.\n   *\n   * @type {Boolean}\n   * @default false\n   * @param {Boolean} value\n   */\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n}\nconst _material = /*@__PURE__*/new NodeMaterial();\nconst _quadMesh = /*@__PURE__*/new QuadMesh(_material);\n\n/**\n * This module is responsible to manage the post processing setups in apps.\n * You usually create a single instance of this class and use it to define\n * the output of your post processing effect chain.\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n */\nclass PostProcessing {\n  /**\n   * Constructs a new post processing management module.\n   *\n   * @param {Renderer} renderer - A reference to the renderer.\n   * @param {Node<vec4>} outputNode - An optional output node.\n   */\n  constructor(renderer, outputNode = vec4(0, 0, 1, 1)) {\n    /**\n     * A reference to the renderer.\n     *\n     * @type {Renderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * A node which defines the final output of the post\n     * processing. This is usually the last node in a chain\n     * of effect nodes.\n     *\n     * @type {Node<vec4>}\n     */\n    this.outputNode = outputNode;\n\n    /**\n     * Whether the default output tone mapping and color\n     * space transformation should be enabled or not.\n     *\n     * It is enabled by default by it must be disabled when\n     * effects must be executed after tone mapping and color\n     * space conversion. A typical example is FXAA which\n     * requires sRGB input.\n     *\n     * When set to `false`, the app must control the output\n     * transformation with `RenderOutputNode`.\n     *\n     * ```js\n     * const outputPass = renderOutput( scenePass );\n     * ```\n     *\n     * @type {Boolean}\n     */\n    this.outputColorTransform = true;\n\n    /**\n     * Must be set to `true` when the output node changes.\n     *\n     * @type {Node<vec4>}\n     */\n    this.needsUpdate = true;\n    _material.name = 'PostProcessing';\n  }\n\n  /**\n   * When `PostProcessing` is used to apply post processing effects,\n   * the application must use this version of `render()` inside\n   * its animation loop (not the one from the renderer).\n   */\n  render() {\n    this._update();\n    const renderer = this.renderer;\n    const toneMapping = renderer.toneMapping;\n    const outputColorSpace = renderer.outputColorSpace;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n\n    //\n\n    _quadMesh.render(renderer);\n\n    //\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n  }\n\n  /**\n   * Updates the state of the module.\n   *\n   * @private\n   */\n  _update() {\n    if (this.needsUpdate === true) {\n      const renderer = this.renderer;\n      const toneMapping = renderer.toneMapping;\n      const outputColorSpace = renderer.outputColorSpace;\n      _quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput(this.outputNode, toneMapping, outputColorSpace) : this.outputNode.context({\n        toneMapping,\n        outputColorSpace\n      });\n      _quadMesh.material.needsUpdate = true;\n      this.needsUpdate = false;\n    }\n  }\n\n  /**\n   * When `PostProcessing` is used to apply post processing effects,\n   * the application must use this version of `renderAsync()` inside\n   * its animation loop (not the one from the renderer).\n   *\n   * @async\n   * @return {Promise} A Promise that resolves when the render has been finished.\n   */\n  async renderAsync() {\n    this._update();\n    const renderer = this.renderer;\n    const toneMapping = renderer.toneMapping;\n    const outputColorSpace = renderer.outputColorSpace;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n\n    //\n\n    await _quadMesh.renderAsync(renderer);\n\n    //\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n  }\n}\n\n/**\n * This special type of texture is intended for compute shaders.\n * It can be used to compute the data of a texture with a compute shader.\n *\n * Note: This type of texture can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments Texture\n */\nclass StorageTexture extends Texture {\n  /**\n   * Constructs a new storage texture.\n   *\n   * @param {Number} [width=1] - The storage texture's width.\n   * @param {Number} [height=1] - The storage texture's height.\n   */\n  constructor(width = 1, height = 1) {\n    super();\n\n    /**\n     * The image object which just represents the texture's dimension.\n     *\n     * @type {{width: Number, height:Number}}\n     */\n    this.image = {\n      width,\n      height\n    };\n\n    /**\n     * The default `magFilter` for storage textures is `THREE.LinearFilter`.\n     *\n     * @type {Number}\n     */\n    this.magFilter = LinearFilter;\n\n    /**\n     * The default `minFilter` for storage textures is `THREE.LinearFilter`.\n     *\n     * @type {Number}\n     */\n    this.minFilter = LinearFilter;\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isStorageTexture = true;\n  }\n}\n\n/**\n * This special type of buffer attribute is intended for compute shaders.\n * It can be used to encode draw parameters for indirect draw calls.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments StorageBufferAttribute\n */\nclass IndirectStorageBufferAttribute extends StorageBufferAttribute {\n  /**\n   * Constructs a new storage buffer attribute.\n   *\n   * @param {Number|Uint32Array} count - The item count. It is also valid to pass a `Uint32Array` as an argument.\n   * The subsequent parameter is then obsolete.\n   * @param {Number} itemSize - The item size.\n   */\n  constructor(count, itemSize) {\n    super(count, itemSize, Uint32Array);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isIndirectStorageBufferAttribute = true;\n  }\n}\n\n/**\n * A loader for loading node objects in the three.js JSON Object/Scene format.\n *\n * @augments Loader\n */\nclass NodeLoader extends Loader {\n  /**\n   * Constructs a new node loader.\n   *\n   * @param {LoadingManager?} manager - A reference to a loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    /**\n     * Represents a dictionary of textures.\n     *\n     * @type {Object<String,Texture>}\n     */\n    this.textures = {};\n\n    /**\n     * Represents a dictionary of node types.\n     *\n     * @type {Object<String,Node.constructor>}\n     */\n    this.nodes = {};\n  }\n\n  /**\n   * Loads the node definitions from the given URL.\n   *\n   * @param {String} url - The path/URL of the file to be loaded.\n   * @param {Function} onLoad - Will be called when load completes.\n   * @param {Function} onProgress - Will be called while load progresses.\n   * @param {Function} onError - Will be called when errors are thrown during the loading process.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parse the node dependencies for the loaded node.\n   *\n   * @param {Object} json - The JSON definition\n   * @return {Object<String,Node>} A dictionary with node dependencies.\n   */\n  parseNodes(json) {\n    const nodes = {};\n    if (json !== undefined) {\n      for (const nodeJSON of json) {\n        const {\n          uuid,\n          type\n        } = nodeJSON;\n        nodes[uuid] = this.createNodeFromType(type);\n        nodes[uuid].uuid = uuid;\n      }\n      const meta = {\n        nodes,\n        textures: this.textures\n      };\n      for (const nodeJSON of json) {\n        nodeJSON.meta = meta;\n        const node = nodes[nodeJSON.uuid];\n        node.deserialize(nodeJSON);\n        delete nodeJSON.meta;\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * Parses the node from the given JSON.\n   *\n   * @param {Object} json - The JSON definition\n   * @return {Node} The parsed node.\n   */\n  parse(json) {\n    const node = this.createNodeFromType(json.type);\n    node.uuid = json.uuid;\n    const nodes = this.parseNodes(json.nodes);\n    const meta = {\n      nodes,\n      textures: this.textures\n    };\n    json.meta = meta;\n    node.deserialize(json);\n    delete json.meta;\n    return node;\n  }\n\n  /**\n   * Defines the dictionary of textures.\n   *\n   * @param {Object<String,Texture>} value - The texture library defines as `<uuid,texture>`.\n   * @return {NodeLoader} A reference to this loader.\n   */\n  setTextures(value) {\n    this.textures = value;\n    return this;\n  }\n\n  /**\n   * Defines the dictionary of node types.\n   *\n   * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.\n   * @return {NodeLoader} A reference to this loader.\n   */\n  setNodes(value) {\n    this.nodes = value;\n    return this;\n  }\n\n  /**\n   * Creates a node object from the given type.\n   *\n   * @param {String} type - The node type.\n   * @return {Node} The created node instance.\n   */\n  createNodeFromType(type) {\n    if (this.nodes[type] === undefined) {\n      console.error('THREE.NodeLoader: Node type not found:', type);\n      return float();\n    }\n    return nodeObject(new this.nodes[type]());\n  }\n}\n\n/**\n * A special type of material loader for loading node materials.\n *\n * @augments MaterialLoader\n */\nclass NodeMaterialLoader extends MaterialLoader {\n  /**\n   * Constructs a new node material loader.\n   *\n   * @param {LoadingManager?} manager - A reference to a loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    /**\n     * Represents a dictionary of node types.\n     *\n     * @type {Object<String,Node.constructor>}\n     */\n    this.nodes = {};\n\n    /**\n     * Represents a dictionary of node material types.\n     *\n     * @type {Object<String,NodeMaterial.constructor>}\n     */\n    this.nodeMaterials = {};\n  }\n\n  /**\n   * Parses the node material from the given JSON.\n   *\n   * @param {Object} json - The JSON definition\n   * @return {NodeMaterial}. The parsed material.\n   */\n  parse(json) {\n    const material = super.parse(json);\n    const nodes = this.nodes;\n    const inputNodes = json.inputNodes;\n    for (const property in inputNodes) {\n      const uuid = inputNodes[property];\n      material[property] = nodes[uuid];\n    }\n    return material;\n  }\n\n  /**\n   * Defines the dictionary of node types.\n   *\n   * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.\n   * @return {NodeLoader} A reference to this loader.\n   */\n  setNodes(value) {\n    this.nodes = value;\n    return this;\n  }\n\n  /**\n   * Defines the dictionary of node material types.\n   *\n   * @param {Object<String,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.\n   * @return {NodeLoader} A reference to this loader.\n   */\n  setNodeMaterials(value) {\n    this.nodeMaterials = value;\n    return this;\n  }\n\n  /**\n   * Creates a node material from the given type.\n   *\n   * @param {String} type - The node material type.\n   * @return {Node} The created node material instance.\n   */\n  createMaterialFromType(type) {\n    const materialClass = this.nodeMaterials[type];\n    if (materialClass !== undefined) {\n      return new materialClass();\n    }\n    return super.createMaterialFromType(type);\n  }\n}\n\n/**\n * A special type of object loader for loading 3D objects using\n * node materials.\n *\n * @augments ObjectLoader\n */\nclass NodeObjectLoader extends ObjectLoader {\n  /**\n   * Constructs a new node object loader.\n   *\n   * @param {LoadingManager?} manager - A reference to a loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    /**\n     * Represents a dictionary of node types.\n     *\n     * @type {Object<String,Node.constructor>}\n     */\n    this.nodes = {};\n\n    /**\n     * Represents a dictionary of node material types.\n     *\n     * @type {Object<String,NodeMaterial.constructor>}\n     */\n    this.nodeMaterials = {};\n\n    /**\n     * A reference for holdng the `nodes` JSON property.\n     *\n     * @private\n     * @type {Object?}\n     */\n    this._nodesJSON = null;\n  }\n\n  /**\n   * Defines the dictionary of node types.\n   *\n   * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.\n   * @return {NodeLoader} A reference to this loader.\n   */\n  setNodes(value) {\n    this.nodes = value;\n    return this;\n  }\n\n  /**\n   * Defines the dictionary of node material types.\n   *\n   * @param {Object<String,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.\n   * @return {NodeLoader} A reference to this loader.\n   */\n  setNodeMaterials(value) {\n    this.nodeMaterials = value;\n    return this;\n  }\n\n  /**\n   * Parses the node objects from the given JSON.\n   *\n   * @param {Object} json - The JSON definition\n   * @param {Function} onLoad - The onLoad callback function.\n   * @return {Object3D}. The parsed 3D object.\n   */\n  parse(json, onLoad) {\n    this._nodesJSON = json.nodes;\n    const data = super.parse(json, onLoad);\n    this._nodesJSON = null; // dispose\n\n    return data;\n  }\n\n  /**\n   * Parses the node objects from the given JSON and textures.\n   *\n   * @param {Object} json - The JSON definition\n   * @param {Object<String,Texture>} textures - The texture library.\n   * @return {Object<String,Node>}. The parsed nodes.\n   */\n  parseNodes(json, textures) {\n    if (json !== undefined) {\n      const loader = new NodeLoader();\n      loader.setNodes(this.nodes);\n      loader.setTextures(textures);\n      return loader.parseNodes(json);\n    }\n    return {};\n  }\n\n  /**\n   * Parses the node objects from the given JSON and textures.\n   *\n   * @param {Object} json - The JSON definition\n   * @param {Object<String,Texture>} textures - The texture library.\n   * @return {Object<String,NodeMaterial>}. The parsed materials.\n   */\n  parseMaterials(json, textures) {\n    const materials = {};\n    if (json !== undefined) {\n      const nodes = this.parseNodes(this._nodesJSON, textures);\n      const loader = new NodeMaterialLoader();\n      loader.setTextures(textures);\n      loader.setNodes(nodes);\n      loader.setNodeMaterials(this.nodeMaterials);\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n        materials[data.uuid] = loader.parse(data);\n      }\n    }\n    return materials;\n  }\n}\n\n/**\n * In earlier three.js versions, clipping was defined globally\n * on the renderer or on material level. This special version of\n * `THREE.Group` allows to encode the clipping state into the scene\n * graph. Meaning if you create an instance of this group, all\n * descendant 3D objects will be affected by the respective clipping\n * planes.\n *\n * Note: `ClippingGroup` can only be used with `WebGPURenderer`.\n *\n * @augments Group\n */\nclass ClippingGroup extends Group {\n  /**\n   * Constructs a new clipping group.\n   */\n  constructor() {\n    super();\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {Boolean}\n     * @readonly\n     * @default true\n     */\n    this.isClippingGroup = true;\n\n    /**\n     * An array with clipping planes.\n     *\n     * @type {Array<Plane>}\n     */\n    this.clippingPlanes = [];\n\n    /**\n     * Whether clipping should be enabled or not.\n     *\n     * @type {Boolean}\n     * @default true\n     */\n    this.enabled = true;\n\n    /**\n     * Whether the intersection of the clipping planes is used to clip objects, rather than their union.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.clipIntersection = false;\n\n    /**\n     * Whether shadows should be clipped or not.\n     *\n     * @type {Boolean}\n     * @default false\n     */\n    this.clipShadows = false;\n  }\n}\nexport { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayElementNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, CacheNode, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, DataArrayTexture, DataTexture, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectUVNode, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, InstancedPointsNodeMaterial, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoopNode, LuminanceAlphaFormat, LuminanceFormat, MRTNode, MatcapUVNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PosterizeNode, PropertyNode, QuadMesh, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RendererUtils, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowBaseNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, StorageArrayElementNode, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, ToneMappingNode, ToonOutlinePassNode, TriplanarTexturesNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, shaderStages, vectorComponents };"],
  "mappings": "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,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,IAAI;AAC5gD,IAAI,QAAQ;AACZ,IAAM,UAAU,KA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ACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAOV;AAAA,EACP;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAQD;AAAA,EACR;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,KAAK;AAAA,EACL;AAAA,EACA;AAAA,EACA;AAAA,EACA,KAAK;AAAA,EACL;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAWF;AAAA,EACX;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,MAAMC;AAAA,EACN;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAYG;AAAA,EACZ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,E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",
  "names": ["min", "max", "length", "range", "degrees", "radians", "cos", "sin", "attribute", "tmp", "buffer", "ColorManagement", "color", "context", "output", "anisotropy", "uv", "min", "max", "length", "attribute", "texture", "depth", "w0", "w1", "cos", "sin", "step", "normal", "lengthSq", "direction", "sign", "tmp", "distance", "element", "cache", "string", "hue", "saturation", "data", "buffer", "tmp2", "indices", "attributeArray", "intersects", "intersect", "width", "height", "property", "uniform", "fov", "aspect", "distance", "anisotropy", "texture", "color", "depth", "attribute", "intersects", "sin", "cos", "intersect", "normal", "direction", "reference", "index", "range", "l", "step", "cache", "min", "pow", "uv", "length", "sign", "detail", "radius", "max", "azimuth", "hash", "pass", "tan", "px", "py", "bs", "contour", "p", "q", "time", "label", "buffer", "json", "arrayBuffer", "bufferAttribute", "attributeArray", "context", "mix", "now", "deltaTime", "loop", "uniforms", "cross", "radians", "shapes", "tmpPath", "tmpShape", "attribute", "property", "notEqual", "h1", "toJSON", "length", "arrayBuffer", "Node", "hash", "output", "cache", "data", "nodeObject", "bool", "uint", "int", "float", "stack", "self", "varying", "normalize", "sign", "equals", "clamp", "smoothstep", "uv", "color", "toneMapping", "buffer", "bufferAttribute", "context", "texture", "snippet", "normal", "i", "ReferenceElementNode", "normalMap", "instancedMesh", "size", "x", "y", "j", "mrt", "depth", "distance", "lights", "aspect", "RECIPROCAL_PI", "roughness", "alphaT", "w2", "normalView", "specularColor", "specularF90", "thickness", "ior", "modelScale", "attenuationColor", "attenuationDistance", "diffuseColor", "dispersion", "iridescenceIOR", "clearcoat", "sheen", "iridescence", "anisotropy", "transmission", "lightPosition", "direction", "outputDirection", "_cache", "step", "time", "arrayNeedsUint32", "Geometries", "code", "textureData", "image", "modelViewMatrix", "_normal", "_target", "_camera", "_geometry", "_m1", "userData", "frameId", "velocity", "saturation", "cameraNear", "cameraFar", "pass", "element", "TSL", "uniforms", "lightNode", "shadow", "scene", "viewport", "lightViewPosition", "tmp", "renderer", "Uniform", "cubeUVRenderTarget", "min", "max", "fill", "value", "reference", "type", "name", "_frustum", "_projScreenMatrix", "error", "Buffer", "UniformsGroup", "uniform", "builtin", "_vector2", "_id$1", "range", "textures", "string", "bindGroup", "_id", "sampler", "groupName", "isTypedArray", "AttributeType", "storageTexture", "pipeline", "colorAttachment"]
}
