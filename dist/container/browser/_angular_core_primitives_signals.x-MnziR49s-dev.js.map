{
  "version": 3,
  "sources": ["../../@angular/core/fesm2022/primitives/signals.mjs"],
  "sourcesContent": ["/**\n * @license Angular v18.2.13\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\nfunction isReactive(value) {\n  return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producerNode: undefined,\n  producerLastReadVersion: undefined,\n  producerIndexOfThis: undefined,\n  nextProducerIndex: 0,\n  liveConsumerNode: undefined,\n  liveConsumerIndexOfThis: undefined,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {}\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n  }\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n  activeConsumer.consumerOnSignalRead(node);\n  // This producer is the `idx`th dependency of `activeConsumer`.\n  const idx = activeConsumer.nextProducerIndex++;\n  assertConsumerNode(activeConsumer);\n  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n    // There's been a change in producers since the last execution of `activeConsumer`.\n    // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n    // replaced with `this`.\n    //\n    // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n    // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n    // to remove it from the stale producer's `liveConsumer`s.\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode[idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n      // At this point, the only record of `staleProducer` is the reference at\n      // `activeConsumer.producerNode[idx]` which will be overwritten below.\n    }\n  }\n  if (activeConsumer.producerNode[idx] !== node) {\n    // We're a new dependency of the consumer (at `idx`).\n    activeConsumer.producerNode[idx] = node;\n    // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n    // placeholder value.\n    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n  }\n  activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n  epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    // Even non-live consumers can skip polling if they previously found themselves to be clean at\n    // the current epoch, since their dependencies could not possibly have changed (such a change\n    // would've increased the epoch).\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n    return;\n  }\n  node.producerRecomputeValue(node);\n  // After recomputing the value, we're no longer dirty.\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n  if (node.liveConsumerNode === undefined) {\n    return;\n  }\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined || node.producerLastReadVersion === undefined) {\n    return;\n  }\n  if (consumerIsLive(node)) {\n    // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n    // which weren't dependencies after the recomputation.\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Truncate the producer tracking arrays.\n  // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n  // benchmarking has shown that individual pop operations are faster.\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion.pop();\n    node.producerIndexOfThis.pop();\n  }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n  assertConsumerNode(node);\n  // Poll producers for change.\n  for (let i = 0; i < node.producerNode.length; i++) {\n    const producer = node.producerNode[i];\n    const seenVersion = node.producerLastReadVersion[i];\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n  assertConsumerNode(node);\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Truncate all the arrays to drop all connection from this node to the graph.\n  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;\n  if (node.liveConsumerNode) {\n    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n  }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n  assertProducerNode(node);\n  if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {\n    // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n    }\n  }\n  node.liveConsumerIndexOfThis.push(indexOfThis);\n  return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n  assertProducerNode(node);\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n  }\n  if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {\n    // When removing the last live consumer, we will no longer be live. We need to remove\n    // ourselves from our producers' tracking (which may cause consumer-producers to lose\n    // liveness as well).\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n  // live consumer, this is a no-op.\n  const lastIdx = node.liveConsumerNode.length - 1;\n  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n  // Truncate the array.\n  node.liveConsumerNode.length--;\n  node.liveConsumerIndexOfThis.length--;\n  // If the index is still valid, then we need to fix the index pointer from the producer to this\n  // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n  if (idx < node.liveConsumerNode.length) {\n    const idxProducer = node.liveConsumerIndexOfThis[idx];\n    const consumer = node.liveConsumerNode[idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis[idxProducer] = idx;\n  }\n}\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n  node.producerNode ??= [];\n  node.producerIndexOfThis ??= [];\n  node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n  node.liveConsumerNode ??= [];\n  node.liveConsumerIndexOfThis ??= [];\n}\nfunction isConsumerNode(node) {\n  return node.producerNode !== undefined;\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  computed[SIGNAL] = node;\n  return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error('Detected cycle in computations.');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        newValue = node.computation();\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n */\nfunction createSignal(initialValue) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  const getter = () => {\n    producerAccessed(node);\n    return node.value;\n  };\n  getter[SIGNAL] = node;\n  return getter;\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\nfunction signalGetFn() {\n  producerAccessed(this);\n  return this.value;\n}\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nfunction signalUpdateFn(node, updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn() {\n  postSignalSetFn?.();\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.();\n}\nfunction createWatch(fn, schedule, allowSignalWrites) {\n  const node = Object.create(WATCH_NODE);\n  if (allowSignalWrites) {\n    node.consumerAllowSignalWrites = true;\n  }\n  node.fn = fn;\n  node.schedule = schedule;\n  const registerOnCleanup = cleanupFn => {\n    node.cleanupFn = cleanupFn;\n  };\n  function isWatchNodeDestroyed(node) {\n    return node.fn === null && node.schedule === null;\n  }\n  function destroyWatchNode(node) {\n    if (!isWatchNodeDestroyed(node)) {\n      consumerDestroy(node); // disconnect watcher from the reactive graph\n      node.cleanupFn();\n      // nullify references to the integration functions to mark node as destroyed\n      node.fn = null;\n      node.schedule = null;\n      node.cleanupFn = NOOP_CLEANUP_FN;\n    }\n  }\n  const run = () => {\n    if (node.fn === null) {\n      // trying to run a destroyed watch is noop\n      return;\n    }\n    if (isInNotificationPhase()) {\n      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n    }\n    node.dirty = false;\n    if (node.hasRun && !consumerPollProducersForChange(node)) {\n      return;\n    }\n    node.hasRun = true;\n    const prevConsumer = consumerBeforeComputation(node);\n    try {\n      node.cleanupFn();\n      node.cleanupFn = NOOP_CLEANUP_FN;\n      node.fn(registerOnCleanup);\n    } finally {\n      consumerAfterComputation(node, prevConsumer);\n    }\n  };\n  node.ref = {\n    notify: () => consumerMarkDirty(node),\n    run,\n    cleanup: () => node.cleanupFn(),\n    destroy: () => destroyWatchNode(node),\n    [SIGNAL]: node\n  };\n  return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => {};\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: false,\n    consumerMarkedDirty: node => {\n      if (node.schedule !== null) {\n        node.schedule(node.ref);\n      }\n    },\n    hasRun: false,\n    cleanupFn: NOOP_CLEANUP_FN\n  };\n})();\nfunction setAlternateWeakRefImpl(impl) {\n  // TODO: remove this function\n}\nexport { REACTIVE_NODE, SIGNAL, SIGNAL_NODE, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, createWatch, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostSignalSetFn, setActiveConsumer, setAlternateWeakRefImpl, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalSetFn, signalUpdateFn };\n"],
  "mappings": "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",
  "names": ["node"]
}
