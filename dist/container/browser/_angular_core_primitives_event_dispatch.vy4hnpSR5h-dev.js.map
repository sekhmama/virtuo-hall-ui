{
  "version": 3,
  "sources": ["../../@angular/core/fesm2022/primitives/event-dispatch.mjs"],
  "sourcesContent": ["/**\n * @license Angular v18.2.13\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nconst Attribute = {\n  /**\n   * The jsaction attribute defines a mapping of a DOM event to a\n   * generic event (aka jsaction), to which the actual event handlers\n   * that implement the behavior of the application are bound. The\n   * value is a semicolon separated list of colon separated pairs of\n   * an optional DOM event name and a jsaction name. If the optional\n   * DOM event name is omitted, 'click' is assumed. The jsaction names\n   * are dot separated pairs of a namespace and a simple jsaction\n   * name.\n   *\n   * See grammar in README.md for expected syntax in the attribute value.\n   */\n  JSACTION: 'jsaction'\n};\n\n/** All properties that are used by jsaction. */\nconst Property = {\n  /**\n   * The parsed value of the jsaction attribute is stored in this\n   * property on the DOM node. The parsed value is an Object. The\n   * property names of the object are the events; the values are the\n   * names of the actions. This property is attached even on nodes\n   * that don't have a jsaction attribute as an optimization, because\n   * property lookup is faster than attribute access.\n   */\n  JSACTION: '__jsaction',\n  /**\n   * The owner property references an a logical owner for a DOM node. JSAction\n   * will follow this reference instead of parentNode when traversing the DOM\n   * to find jsaction attributes. This allows overlaying a logical structure\n   * over a document where the DOM structure can't reflect that structure.\n   */\n  OWNER: '__owner'\n};\n\n/**\n * Map from jsaction annotation to a parsed map from event name to action name.\n */\nconst parseCache = {};\n/**\n * Reads the jsaction parser cache from the given DOM Element.\n */\nfunction get(element) {\n  return element[Property.JSACTION];\n}\n/**\n * Reads the jsaction parser cache for the given DOM element. If no cache is yet present,\n * creates an empty one.\n */\nfunction getDefaulted(element) {\n  const cache = get(element) ?? {};\n  set(element, cache);\n  return cache;\n}\n/**\n * Writes the jsaction parser cache to the given DOM Element.\n */\nfunction set(element, actionMap) {\n  element[Property.JSACTION] = actionMap;\n}\n/**\n * Looks up the parsed action map from the source jsaction attribute value.\n *\n * @param text Unparsed jsaction attribute value.\n * @return Parsed jsaction attribute value, if already present in the cache.\n */\nfunction getParsed(text) {\n  return parseCache[text];\n}\n/**\n * Inserts the parse result for the given source jsaction value into the cache.\n *\n * @param text Unparsed jsaction attribute value.\n * @param parsed Attribute value parsed into the action map.\n */\nfunction setParsed(text, parsed) {\n  parseCache[text] = parsed;\n}\n/**\n * Clears the jsaction parser cache from the given DOM Element.\n *\n * @param element .\n */\nfunction clear(element) {\n  if (Property.JSACTION in element) {\n    delete element[Property.JSACTION];\n  }\n}\n\n/*\n * Names of events that are special to jsaction. These are not all\n * event types that are legal to use in either HTML or the addEvent()\n * API, but these are the ones that are treated specially. All other\n * DOM events can be used in either addEvent() or in the value of the\n * jsaction attribute. Beware of browser specific events or events\n * that don't bubble though: If they are not mentioned here, then\n * event contract doesn't work around their peculiarities.\n */\nconst EventType = {\n  /**\n   * Mouse middle click, introduced in Chrome 55 and not yet supported on\n   * other browsers.\n   */\n  AUXCLICK: 'auxclick',\n  /**\n   * The change event fired by browsers when the `value` attribute of input,\n   * select, and textarea elements are changed.\n   */\n  CHANGE: 'change',\n  /**\n   * The click event. In addEvent() refers to all click events, in the\n   * jsaction attribute it refers to the unmodified click and Enter/Space\n   * keypress events.  In the latter case, a jsaction click will be triggered,\n   * for accessibility reasons.  See clickmod and clickonly, below.\n   */\n  CLICK: 'click',\n  /**\n   * Specifies the jsaction for a modified click event (i.e. a mouse\n   * click with the modifier key Cmd/Ctrl pressed). This event isn't\n   * separately enabled in addEvent(), because in the DOM, it's just a\n   * click event.\n   */\n  CLICKMOD: 'clickmod',\n  /**\n   * Specifies the jsaction for a click-only event.  Click-only doesn't take\n   * into account the case where an element with focus receives an Enter/Space\n   * keypress.  This event isn't separately enabled in addEvent().\n   */\n  CLICKONLY: 'clickonly',\n  /**\n   * The dblclick event.\n   */\n  DBLCLICK: 'dblclick',\n  /**\n   * Focus doesn't bubble, but you can use it in addEvent() and\n   * jsaction anyway. EventContract does the right thing under the\n   * hood.\n   */\n  FOCUS: 'focus',\n  /**\n   * This event only exists in IE. For addEvent() and jsaction, use\n   * focus instead; EventContract does the right thing even though\n   * focus doesn't bubble.\n   */\n  FOCUSIN: 'focusin',\n  /**\n   * Analog to focus.\n   */\n  BLUR: 'blur',\n  /**\n   * Analog to focusin.\n   */\n  FOCUSOUT: 'focusout',\n  /**\n   * Submit doesn't bubble, so it cannot be used with event\n   * contract. However, the browser helpfully fires a click event on\n   * the submit button of a form (even if the form is not submitted by\n   * a click on the submit button). So you should handle click on the\n   * submit button instead.\n   */\n  SUBMIT: 'submit',\n  /**\n   * The keydown event. In addEvent() and non-click jsaction it represents the\n   * regular DOM keydown event. It represents click actions in non-Gecko\n   * browsers.\n   */\n  KEYDOWN: 'keydown',\n  /**\n   * The keypress event. In addEvent() and non-click jsaction it represents the\n   * regular DOM keypress event. It represents click actions in Gecko browsers.\n   */\n  KEYPRESS: 'keypress',\n  /**\n   * The keyup event. In addEvent() and non-click jsaction it represents the\n   * regular DOM keyup event. It represents click actions in non-Gecko\n   * browsers.\n   */\n  KEYUP: 'keyup',\n  /**\n   * The mouseup event. Can either be used directly or used implicitly to\n   * capture mouseup events. In addEvent(), it represents a regular DOM\n   * mouseup event.\n   */\n  MOUSEUP: 'mouseup',\n  /**\n   * The mousedown event. Can either be used directly or used implicitly to\n   * capture mouseenter events. In addEvent(), it represents a regular DOM\n   * mouseover event.\n   */\n  MOUSEDOWN: 'mousedown',\n  /**\n   * The mouseover event. Can either be used directly or used implicitly to\n   * capture mouseenter events. In addEvent(), it represents a regular DOM\n   * mouseover event.\n   */\n  MOUSEOVER: 'mouseover',\n  /**\n   * The mouseout event. Can either be used directly or used implicitly to\n   * capture mouseover events. In addEvent(), it represents a regular DOM\n   * mouseout event.\n   */\n  MOUSEOUT: 'mouseout',\n  /**\n   * The mouseenter event. Does not bubble and fires individually on each\n   * element being entered within a DOM tree.\n   */\n  MOUSEENTER: 'mouseenter',\n  /**\n   * The mouseleave event. Does not bubble and fires individually on each\n   * element being entered within a DOM tree.\n   */\n  MOUSELEAVE: 'mouseleave',\n  /**\n   * The mousemove event.\n   */\n  MOUSEMOVE: 'mousemove',\n  /**\n   * The pointerup event. Can either be used directly or used implicitly to\n   * capture pointerup events. In addEvent(), it represents a regular DOM\n   * pointerup event.\n   */\n  POINTERUP: 'pointerup',\n  /**\n   * The pointerdown event. Can either be used directly or used implicitly to\n   * capture pointerenter events. In addEvent(), it represents a regular DOM\n   * mouseover event.\n   */\n  POINTERDOWN: 'pointerdown',\n  /**\n   * The pointerover event. Can either be used directly or used implicitly to\n   * capture pointerenter events. In addEvent(), it represents a regular DOM\n   * pointerover event.\n   */\n  POINTEROVER: 'pointerover',\n  /**\n   * The pointerout event. Can either be used directly or used implicitly to\n   * capture pointerover events. In addEvent(), it represents a regular DOM\n   * pointerout event.\n   */\n  POINTEROUT: 'pointerout',\n  /**\n   * The pointerenter event. Does not bubble and fires individually on each\n   * element being entered within a DOM tree.\n   */\n  POINTERENTER: 'pointerenter',\n  /**\n   * The pointerleave event. Does not bubble and fires individually on each\n   * element being entered within a DOM tree.\n   */\n  POINTERLEAVE: 'pointerleave',\n  /**\n   * The pointermove event.\n   */\n  POINTERMOVE: 'pointermove',\n  /**\n   * The pointercancel event.\n   */\n  POINTERCANCEL: 'pointercancel',\n  /**\n   * The gotpointercapture event is fired when\n   * Element.setPointerCapture(pointerId) is called on a mouse input, or\n   * implicitly when a touch input begins.\n   */\n  GOTPOINTERCAPTURE: 'gotpointercapture',\n  /**\n   * The lostpointercapture event is fired when\n   * Element.releasePointerCapture(pointerId) is called, or implicitly after a\n   * touch input ends.\n   */\n  LOSTPOINTERCAPTURE: 'lostpointercapture',\n  /**\n   * The error event. The error event doesn't bubble, but you can use it in\n   * addEvent() and jsaction anyway. EventContract does the right thing under\n   * the hood (except in IE8 which does not use error events).\n   */\n  ERROR: 'error',\n  /**\n   * The load event. The load event doesn't bubble, but you can use it in\n   * addEvent() and jsaction anyway. EventContract does the right thing\n   * under the hood.\n   */\n  LOAD: 'load',\n  /**\n   * The unload event.\n   */\n  UNLOAD: 'unload',\n  /**\n   * The touchstart event. Bubbles, will only ever fire in browsers with\n   * touch support.\n   */\n  TOUCHSTART: 'touchstart',\n  /**\n   * The touchend event. Bubbles, will only ever fire in browsers with\n   * touch support.\n   */\n  TOUCHEND: 'touchend',\n  /**\n   * The touchmove event. Bubbles, will only ever fire in browsers with\n   * touch support.\n   */\n  TOUCHMOVE: 'touchmove',\n  /**\n   * The input event.\n   */\n  INPUT: 'input',\n  /**\n   * The scroll event.\n   */\n  SCROLL: 'scroll',\n  /**\n   * The toggle event. The toggle event doesn't bubble, but you can use it in\n   * addEvent() and jsaction anyway. EventContract does the right thing\n   * under the hood.\n   */\n  TOGGLE: 'toggle',\n  /**\n   * A custom event. The actual custom event type is declared as the 'type'\n   * field in the event details. Supported in Firefox 6+, IE 9+, and all Chrome\n   * versions.\n   *\n   * This is an internal name. Users should use jsaction's fireCustomEvent to\n   * fire custom events instead of relying on this type to create them.\n   */\n  CUSTOM: '_custom'\n};\n/** All event types that do not bubble or capture and need a polyfill. */\nconst MOUSE_SPECIAL_EVENT_TYPES = [EventType.MOUSEENTER, EventType.MOUSELEAVE, 'pointerenter', 'pointerleave'];\n/** All event types that are registered in the bubble phase. */\nconst BUBBLE_EVENT_TYPES = [EventType.CLICK, EventType.DBLCLICK, EventType.FOCUSIN, EventType.FOCUSOUT, EventType.KEYDOWN, EventType.KEYUP, EventType.KEYPRESS, EventType.MOUSEOVER, EventType.MOUSEOUT, EventType.SUBMIT, EventType.TOUCHSTART, EventType.TOUCHEND, EventType.TOUCHMOVE, 'touchcancel', 'auxclick', 'change', 'compositionstart', 'compositionupdate', 'compositionend', 'beforeinput', 'input', 'select', 'copy', 'cut', 'paste', 'mousedown', 'mouseup', 'wheel', 'contextmenu', 'dragover', 'dragenter', 'dragleave', 'drop', 'dragstart', 'dragend', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerover', 'pointerout', 'gotpointercapture', 'lostpointercapture',\n// Video events.\n'ended', 'loadedmetadata',\n// Page visibility events.\n'pagehide', 'pageshow', 'visibilitychange',\n// Content visibility events.\n'beforematch'];\n/** All event types that are registered in the capture phase. */\nconst CAPTURE_EVENT_TYPES = [EventType.FOCUS, EventType.BLUR, EventType.ERROR, EventType.LOAD, EventType.TOGGLE];\n/**\n * Whether or not an event type should be registered in the capture phase.\n * @param eventType\n * @returns bool\n */\nconst isCaptureEventType = eventType => CAPTURE_EVENT_TYPES.indexOf(eventType) >= 0;\n/** All event types that are registered early.  */\nconst EARLY_EVENT_TYPES = BUBBLE_EVENT_TYPES.concat(CAPTURE_EVENT_TYPES);\n/**\n * Whether or not an event type is registered in the early contract.\n */\nconst isEarlyEventType = eventType => EARLY_EVENT_TYPES.indexOf(eventType) >= 0;\n\n/**\n * If on a Macintosh with an extended keyboard, the Enter key located in the\n * numeric pad has a different ASCII code.\n */\nconst MAC_ENTER = 3;\n/** The Enter key. */\nconst ENTER = 13;\n/** The Space key. */\nconst SPACE = 32;\n/** Special keycodes used by jsaction for the generic click action. */\nconst KeyCode = {\n  MAC_ENTER,\n  ENTER,\n  SPACE\n};\n\n/**\n * Gets a browser event type, if it would differ from the JSAction event type.\n */\nfunction getBrowserEventType(eventType) {\n  // Mouseenter and mouseleave events are not handled directly because they\n  // are not available everywhere. In browsers where they are available, they\n  // don't bubble and aren't visible at the container boundary. Instead, we\n  // synthesize the mouseenter and mouseleave events from mouseover and\n  // mouseout events, respectively. Cf. eventcontract.js.\n  if (eventType === EventType.MOUSEENTER) {\n    return EventType.MOUSEOVER;\n  } else if (eventType === EventType.MOUSELEAVE) {\n    return EventType.MOUSEOUT;\n  } else if (eventType === EventType.POINTERENTER) {\n    return EventType.POINTEROVER;\n  } else if (eventType === EventType.POINTERLEAVE) {\n    return EventType.POINTEROUT;\n  }\n  return eventType;\n}\n/**\n * Registers the event handler function with the given DOM element for\n * the given event type.\n *\n * @param element The element.\n * @param eventType The event type.\n * @param handler The handler function to install.\n * @return Information needed to uninstall the event handler eventually.\n */\nfunction addEventListener(element, eventType, handler) {\n  // All event handlers are registered in the bubbling\n  // phase.\n  //\n  // All browsers support focus and blur, but these events only are propagated\n  // in the capture phase. Very legacy browsers do not support focusin or\n  // focusout.\n  //\n  // It would be a bad idea to register all event handlers in the\n  // capture phase because then regular onclick handlers would not be\n  // executed at all on events that trigger a jsaction. That's not\n  // entirely what we want, at least for now.\n  //\n  // Error and load events (i.e. on images) do not bubble so they are also\n  // handled in the capture phase.\n  let capture = false;\n  if (isCaptureEventType(eventType)) {\n    capture = true;\n  }\n  element.addEventListener(eventType, handler, capture);\n  return {\n    eventType,\n    handler,\n    capture\n  };\n}\n/**\n * Removes the event handler for the given event from the element.\n * the given event type.\n *\n * @param element The element.\n * @param info The information needed to deregister the handler, as returned by\n *     addEventListener(), above.\n */\nfunction removeEventListener(element, info) {\n  if (element.removeEventListener) {\n    element.removeEventListener(info.eventType, info.handler, info.capture);\n    // `detachEvent` is an old DOM API.\n    // tslint:disable-next-line:no-any\n  } else if (element.detachEvent) {\n    // `detachEvent` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    element.detachEvent(`on${info.eventType}`, info.handler);\n  }\n}\n/**\n * Cancels propagation of an event.\n * @param e The event to cancel propagation for.\n */\nfunction stopPropagation(e) {\n  e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;\n}\n/**\n * Prevents the default action of an event.\n * @param e The event to prevent the default action for.\n */\nfunction preventDefault(e) {\n  e.preventDefault ? e.preventDefault() : e.returnValue = false;\n}\n/**\n * Gets the target Element of the event. In Firefox, a text node may appear as\n * the target of the event, in which case we return the parent element of the\n * text node.\n * @param e The event to get the target of.\n * @return The target element.\n */\nfunction getTarget(e) {\n  let el = e.target;\n  // In Firefox, the event may have a text node as its target. We always\n  // want the parent Element the text node belongs to, however.\n  if (!el.getAttribute && el.parentNode) {\n    el = el.parentNode;\n  }\n  return el;\n}\n/**\n * Whether we are on a Mac. Not pulling in useragent just for this.\n */\nlet isMac = typeof navigator !== 'undefined' && /Macintosh/.test(navigator.userAgent);\n/**\n * Determines and returns whether the given event (which is assumed to be a\n * click event) is a middle click.\n * NOTE: There is not a consistent way to identify middle click\n * http://www.unixpapa.com/js/mouse.html\n */\nfunction isMiddleClick(e) {\n  return (\n    // `which` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.which === 2 ||\n    // `which` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.which == null &&\n    // `button` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.button === 4 // middle click for IE\n  );\n}\n/**\n * Determines and returns whether the given event (which is assumed\n * to be a click event) is modified. A middle click is considered a modified\n * click to retain the default browser action, which opens a link in a new tab.\n * @param e The event.\n * @return Whether the given event is modified.\n */\nfunction isModifiedClickEvent(e) {\n  return (\n    // `metaKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    isMac && e.metaKey ||\n    // `ctrlKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    !isMac && e.ctrlKey || isMiddleClick(e) ||\n    // `shiftKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.shiftKey\n  );\n}\n/** Whether we are on WebKit (e.g., Chrome). */\nconst isWebKit = typeof navigator !== 'undefined' && !/Opera/.test(navigator.userAgent) && /WebKit/.test(navigator.userAgent);\n/** Whether we are on IE. */\nconst isIe = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident/.test(navigator.userAgent));\n/** Whether we are on Gecko (e.g., Firefox). */\nconst isGecko = typeof navigator !== 'undefined' && !/Opera|WebKit/.test(navigator.userAgent) && /Gecko/.test(navigator.product);\n/**\n * Determines and returns whether the given element is a valid target for\n * keypress/keydown DOM events that act like regular DOM clicks.\n * @param el The element.\n * @return Whether the given element is a valid action key target.\n */\nfunction isValidActionKeyTarget(el) {\n  if (!('getAttribute' in el)) {\n    return false;\n  }\n  if (isTextControl(el)) {\n    return false;\n  }\n  if (isNativelyActivatable(el)) {\n    return false;\n  }\n  // `isContentEditable` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  if (el.isContentEditable) {\n    return false;\n  }\n  return true;\n}\n/**\n * Whether an event has a modifier key activated.\n * @param e The event.\n * @return True, if a modifier key is activated.\n */\nfunction hasModifierKey(e) {\n  return (\n    // `ctrlKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.ctrlKey ||\n    // `shiftKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.shiftKey ||\n    // `altKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.altKey ||\n    // `metaKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.metaKey\n  );\n}\n/**\n * Determines and returns whether the given event has a target that already\n * has event handlers attached because it is a native HTML control. Used to\n * determine if preventDefault should be called when isActionKeyEvent is true.\n * @param e The event.\n * @return If preventDefault should be called.\n */\nfunction shouldCallPreventDefaultOnNativeHtmlControl(e) {\n  const el = getTarget(e);\n  const tagName = el.tagName.toUpperCase();\n  const role = (el.getAttribute('role') || '').toUpperCase();\n  if (tagName === 'BUTTON' || role === 'BUTTON') {\n    return true;\n  }\n  if (!isNativeHTMLControl(el)) {\n    return false;\n  }\n  if (tagName === 'A') {\n    return false;\n  }\n  /**\n   * Fix for physical d-pads on feature phone platforms; the native event\n   * (ie. isTrusted: true) needs to fire to show the OPTION list. See\n   * b/135288469 for more info.\n   */\n  if (tagName === 'SELECT') {\n    return false;\n  }\n  if (processSpace(el)) {\n    return false;\n  }\n  if (isTextControl(el)) {\n    return false;\n  }\n  return true;\n}\n/**\n * Determines and returns whether the given event acts like a regular DOM click,\n * and should be handled instead of the click.  If this returns true, the caller\n * will call preventDefault() to prevent a possible duplicate event.\n * This is represented by a keypress (keydown on Gecko browsers) on Enter or\n * Space key.\n * @param e The event.\n * @return True, if the event emulates a DOM click.\n */\nfunction isActionKeyEvent(e) {\n  let key =\n  // `which` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  e.which ||\n  // `keyCode` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  e.keyCode;\n  if (!key && e.key) {\n    key = ACTION_KEY_TO_KEYCODE[e.key];\n  }\n  if (isWebKit && key === KeyCode.MAC_ENTER) {\n    key = KeyCode.ENTER;\n  }\n  if (key !== KeyCode.ENTER && key !== KeyCode.SPACE) {\n    return false;\n  }\n  const el = getTarget(e);\n  if (e.type !== EventType.KEYDOWN || !isValidActionKeyTarget(el) || hasModifierKey(e)) {\n    return false;\n  }\n  // For <input type=\"checkbox\">, we must only handle the browser's native click\n  // event, so that the browser can toggle the checkbox.\n  if (processSpace(el) && key === KeyCode.SPACE) {\n    return false;\n  }\n  // If this element is non-focusable, ignore stray keystrokes (b/18337209)\n  // Sscreen readers can move without tab focus, so any tabIndex is focusable.\n  // See B/21809604\n  if (!isFocusable(el)) {\n    return false;\n  }\n  const type = (el.getAttribute('role') || el.type || el.tagName).toUpperCase();\n  const isSpecificTriggerKey = IDENTIFIER_TO_KEY_TRIGGER_MAPPING[type] % key === 0;\n  const isDefaultTriggerKey = !(type in IDENTIFIER_TO_KEY_TRIGGER_MAPPING) && key === KeyCode.ENTER;\n  const hasType = el.tagName.toUpperCase() !== 'INPUT' || !!el.type;\n  return (isSpecificTriggerKey || isDefaultTriggerKey) && hasType;\n}\n/**\n * Checks whether a DOM element can receive keyboard focus.\n * This code is based on goog.dom.isFocusable, but simplified since we shouldn't\n * care about visibility if we're already handling a keyboard event.\n */\nfunction isFocusable(el) {\n  return (el.tagName in NATIVELY_FOCUSABLE_ELEMENTS || hasSpecifiedTabIndex(el)) && !el.disabled;\n}\n/**\n * @param element Element to check.\n * @return Whether the element has a specified tab index.\n */\nfunction hasSpecifiedTabIndex(element) {\n  // IE returns 0 for an unset tabIndex, so we must use getAttributeNode(),\n  // which returns an object with a 'specified' property if tabIndex is\n  // specified.  This works on other browsers, too.\n  const attrNode = element.getAttributeNode('tabindex'); // Must be lowercase!\n  return attrNode != null && attrNode.specified;\n}\n/** Element tagnames that are focusable by default. */\nconst NATIVELY_FOCUSABLE_ELEMENTS = {\n  'A': 1,\n  'INPUT': 1,\n  'TEXTAREA': 1,\n  'SELECT': 1,\n  'BUTTON': 1\n};\n/** @return True, if the Space key was pressed. */\nfunction isSpaceKeyEvent(e) {\n  const key =\n  // `which` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  e.which ||\n  // `keyCode` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  e.keyCode;\n  const el = getTarget(e);\n  const elementName = (el.type || el.tagName).toUpperCase();\n  return key === KeyCode.SPACE && elementName !== 'CHECKBOX';\n}\n/**\n * Determines whether the event corresponds to a non-bubbling mouse\n * event type (mouseenter, mouseleave, pointerenter, and pointerleave).\n *\n * During mouseover (mouseenter) and pointerover (pointerenter), the\n * relatedTarget is the element being entered from. During mouseout (mouseleave)\n * and pointerout (pointerleave), the relatedTarget is the element being exited\n * to.\n *\n * In both cases, if relatedTarget is outside target, then the corresponding\n * special event has occurred, otherwise it hasn't.\n *\n * @param e The mouseover/mouseout event.\n * @param type The type of the mouse special event.\n * @param element The element on which the jsaction for the\n *     mouseenter/mouseleave event is defined.\n * @return True if the event is a mouseenter/mouseleave event.\n */\nfunction isMouseSpecialEvent(e, type, element) {\n  // `relatedTarget` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  const related = e.relatedTarget;\n  return (e.type === EventType.MOUSEOVER && type === EventType.MOUSEENTER || e.type === EventType.MOUSEOUT && type === EventType.MOUSELEAVE || e.type === EventType.POINTEROVER && type === EventType.POINTERENTER || e.type === EventType.POINTEROUT && type === EventType.POINTERLEAVE) && (!related || related !== element && !element.contains(related));\n}\n/**\n * Creates a new EventLike object for a mouseenter/mouseleave event that's\n * derived from the original corresponding mouseover/mouseout event.\n * @param e The event.\n * @param target The element on which the jsaction for the mouseenter/mouseleave\n *     event is defined.\n * @return A modified event-like object copied from the event object passed into\n *     this function.\n */\nfunction createMouseSpecialEvent(e, target) {\n  // We have to create a copy of the event object because we need to mutate\n  // its fields. We do this for the special mouse events because the event\n  // target needs to be retargeted to the action element rather than the real\n  // element (since we are simulating the special mouse events with mouseover/\n  // mouseout).\n  //\n  // Since we're making a copy anyways, we might as well attempt to convert\n  // this event into a pseudo-real mouseenter/mouseleave event by adjusting\n  // its type.\n  //\n  // tslint:disable-next-line:no-any\n  const copy = {};\n  for (const property in e) {\n    if (property === 'srcElement' || property === 'target') {\n      continue;\n    }\n    const key = property;\n    // Making a copy requires iterating through all properties of `Event`.\n    // tslint:disable-next-line:no-dict-access-on-struct-type\n    const value = e[key];\n    if (typeof value === 'function') {\n      continue;\n    }\n    // Value should be the expected type, but the value of `key` is not known\n    // statically.\n    // tslint:disable-next-line:no-any\n    copy[key] = value;\n  }\n  if (e.type === EventType.MOUSEOVER) {\n    copy['type'] = EventType.MOUSEENTER;\n  } else if (e.type === EventType.MOUSEOUT) {\n    copy['type'] = EventType.MOUSELEAVE;\n  } else if (e.type === EventType.POINTEROVER) {\n    copy['type'] = EventType.POINTERENTER;\n  } else {\n    copy['type'] = EventType.POINTERLEAVE;\n  }\n  copy['target'] = copy['srcElement'] = target;\n  copy['bubbles'] = false;\n  return copy;\n}\n/**\n * Returns touch data extracted from the touch event: clientX, clientY, screenX\n * and screenY. If the event has no touch information at all, the returned\n * value is null.\n *\n * The fields of this Object are unquoted.\n *\n * @param event A touch event.\n */\nfunction getTouchData(event) {\n  const touch = event.changedTouches && event.changedTouches[0] || event.touches && event.touches[0];\n  if (!touch) {\n    return null;\n  }\n  return {\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    screenX: touch.screenX,\n    screenY: touch.screenY\n  };\n}\n/**\n * Creates a new EventLike object for a \"click\" event that's derived from the\n * original corresponding \"touchend\" event for a fast-click implementation.\n *\n * It takes a touch event, adds common fields found in a click event and\n * changes the type to 'click', so that the resulting event looks more like\n * a real click event.\n *\n * @param event A touch event.\n * @return A modified event-like object copied from the event object passed into\n *     this function.\n */\nfunction recreateTouchEventAsClick(event) {\n  const click = {};\n  click['originalEventType'] = event.type;\n  click['type'] = EventType.CLICK;\n  for (const property in event) {\n    if (property === 'type' || property === 'srcElement') {\n      continue;\n    }\n    const key = property;\n    // Making a copy requires iterating through all properties of `TouchEvent`.\n    // tslint:disable-next-line:no-dict-access-on-struct-type\n    const value = event[key];\n    if (typeof value === 'function') {\n      continue;\n    }\n    // Value should be the expected type, but the value of `key` is not known\n    // statically.\n    // tslint:disable-next-line:no-any\n    click[key] = value;\n  }\n  // Ensure that the event has the most recent timestamp. This timestamp\n  // may be used in the future to validate or cancel subsequent click events.\n  click['timeStamp'] = Date.now();\n  // Emulate preventDefault and stopPropagation behavior\n  click['defaultPrevented'] = false;\n  click['preventDefault'] = syntheticPreventDefault;\n  click['_propagationStopped'] = false;\n  click['stopPropagation'] = syntheticStopPropagation;\n  // Emulate click coordinates using touch info\n  const touch = getTouchData(event);\n  if (touch) {\n    click['clientX'] = touch.clientX;\n    click['clientY'] = touch.clientY;\n    click['screenX'] = touch.screenX;\n    click['screenY'] = touch.screenY;\n  }\n  return click;\n}\n/**\n * An implementation of \"preventDefault\" for a synthesized event. Simply\n * sets \"defaultPrevented\" property to true.\n */\nfunction syntheticPreventDefault() {\n  this.defaultPrevented = true;\n}\n/**\n * An implementation of \"stopPropagation\" for a synthesized event. It simply\n * sets a synthetic non-standard \"_propagationStopped\" property to true.\n */\nfunction syntheticStopPropagation() {\n  this._propagationStopped = true;\n}\n/**\n * Mapping of KeyboardEvent.key values to\n * KeyCode values.\n */\nconst ACTION_KEY_TO_KEYCODE = {\n  'Enter': KeyCode.ENTER,\n  ' ': KeyCode.SPACE\n};\n/**\n * Mapping of HTML element identifiers (ARIA role, type, or tagName) to the\n * keys (enter and/or space) that should activate them. A value of zero means\n * that both should activate them.\n */\nconst IDENTIFIER_TO_KEY_TRIGGER_MAPPING = {\n  'A': KeyCode.ENTER,\n  'BUTTON': 0,\n  'CHECKBOX': KeyCode.SPACE,\n  'COMBOBOX': KeyCode.ENTER,\n  'FILE': 0,\n  'GRIDCELL': KeyCode.ENTER,\n  'LINK': KeyCode.ENTER,\n  'LISTBOX': KeyCode.ENTER,\n  'MENU': 0,\n  'MENUBAR': 0,\n  'MENUITEM': 0,\n  'MENUITEMCHECKBOX': 0,\n  'MENUITEMRADIO': 0,\n  'OPTION': 0,\n  'RADIO': KeyCode.SPACE,\n  'RADIOGROUP': KeyCode.SPACE,\n  'RESET': 0,\n  'SUBMIT': 0,\n  'SWITCH': KeyCode.SPACE,\n  'TAB': 0,\n  'TREE': KeyCode.ENTER,\n  'TREEITEM': KeyCode.ENTER\n};\n/**\n * Returns whether or not to process space based on the type of the element;\n * checks to make sure that type is not null.\n * @param element The element.\n * @return Whether or not to process space based on type.\n */\nfunction processSpace(element) {\n  const type = (element.getAttribute('type') || element.tagName).toUpperCase();\n  return type in PROCESS_SPACE;\n}\n/**\n * Returns whether or not the given element is a text control.\n * @param el The element.\n * @return Whether or not the given element is a text control.\n */\nfunction isTextControl(el) {\n  const type = (el.getAttribute('type') || el.tagName).toUpperCase();\n  return type in TEXT_CONTROLS;\n}\n/**\n * Returns if the given element is a native HTML control.\n * @param el The element.\n * @return If the given element is a native HTML control.\n */\nfunction isNativeHTMLControl(el) {\n  return el.tagName.toUpperCase() in NATIVE_HTML_CONTROLS;\n}\n/**\n * Returns if the given element is natively activatable. Browsers emit click\n * events for natively activatable elements, even when activated via keyboard.\n * For these elements, we don't need to raise a11y click events.\n * @param el The element.\n * @return If the given element is a native HTML control.\n */\nfunction isNativelyActivatable(el) {\n  return el.tagName.toUpperCase() === 'BUTTON' || !!el.type && el.type.toUpperCase() === 'FILE';\n}\n/**\n * HTML <input> types (not ARIA roles) which will auto-trigger a click event for\n * the Space key, with side-effects. We will not call preventDefault if space is\n * pressed, nor will we raise a11y click events.  For all other elements, we can\n * suppress the default event (which has no desired side-effects) and handle the\n * keydown ourselves.\n */\nconst PROCESS_SPACE = {\n  'CHECKBOX': true,\n  'FILE': true,\n  'OPTION': true,\n  'RADIO': true\n};\n/** TagNames and Input types for which to not process enter/space as click. */\nconst TEXT_CONTROLS = {\n  'COLOR': true,\n  'DATE': true,\n  'DATETIME': true,\n  'DATETIME-LOCAL': true,\n  'EMAIL': true,\n  'MONTH': true,\n  'NUMBER': true,\n  'PASSWORD': true,\n  'RANGE': true,\n  'SEARCH': true,\n  'TEL': true,\n  'TEXT': true,\n  'TEXTAREA': true,\n  'TIME': true,\n  'URL': true,\n  'WEEK': true\n};\n/** TagNames that are native HTML controls. */\nconst NATIVE_HTML_CONTROLS = {\n  'A': true,\n  'AREA': true,\n  'BUTTON': true,\n  'DIALOG': true,\n  'IMG': true,\n  'INPUT': true,\n  'LINK': true,\n  'MENU': true,\n  'OPTGROUP': true,\n  'OPTION': true,\n  'PROGRESS': true,\n  'SELECT': true,\n  'TEXTAREA': true\n};\n/** Exported for testing. */\nconst testing = {\n  setIsMac(value) {\n    isMac = value;\n  }\n};\n\n/**\n * Whether the user agent is running on iOS.\n */\nconst isIos = typeof navigator !== 'undefined' && /iPhone|iPad|iPod/.test(navigator.userAgent);\n/**\n * A class representing a container node and all the event handlers\n * installed on it. Used so that handlers can be cleaned up if the\n * container is removed from the contract.\n */\nclass EventContractContainer {\n  /**\n   * @param element The container Element.\n   */\n  constructor(element) {\n    this.element = element;\n    /**\n     * Array of event handlers and their corresponding event types that are\n     * installed on this container.\n     *\n     */\n    this.handlerInfos = [];\n  }\n  /**\n   * Installs the provided installer on the element owned by this container,\n   * and maintains a reference to resulting handler in order to remove it\n   * later if desired.\n   */\n  addEventListener(eventType, getHandler) {\n    // In iOS, event bubbling doesn't happen automatically in any DOM element,\n    // unless it has an onclick attribute or DOM event handler attached to it.\n    // This breaks JsAction in some cases. See \"Making Elements Clickable\"\n    // section at http://goo.gl/2VoGnB.\n    //\n    // A workaround for this issue is to change the CSS cursor style to 'pointer'\n    // for the container element, which magically turns on event bubbling. This\n    // solution is described in the comments section at http://goo.gl/6pEO1z.\n    //\n    // We use a navigator.userAgent check here as this problem is present both\n    // on Mobile Safari and thin WebKit wrappers, such as Chrome for iOS.\n    if (isIos) {\n      this.element.style.cursor = 'pointer';\n    }\n    this.handlerInfos.push(addEventListener(this.element, eventType, getHandler(this.element)));\n  }\n  /**\n   * Removes all the handlers installed on this container.\n   */\n  cleanUp() {\n    for (let i = 0; i < this.handlerInfos.length; i++) {\n      removeEventListener(this.element, this.handlerInfos[i]);\n    }\n    this.handlerInfos = [];\n  }\n}\nconst Char = {\n  /**\n   * The separator between the namespace and the action name in the\n   * jsaction attribute value.\n   */\n  NAMESPACE_ACTION_SEPARATOR: '.',\n  /**\n   * The separator between the event name and action in the jsaction\n   * attribute value.\n   */\n  EVENT_ACTION_SEPARATOR: ':'\n};\n\n/** Added for readability when accessing stable property names. */\nfunction getEventType(eventInfo) {\n  return eventInfo.eventType;\n}\n/** Added for readability when accessing stable property names. */\nfunction setEventType(eventInfo, eventType) {\n  eventInfo.eventType = eventType;\n}\n/** Added for readability when accessing stable property names. */\nfunction getEvent(eventInfo) {\n  return eventInfo.event;\n}\n/** Added for readability when accessing stable property names. */\nfunction setEvent(eventInfo, event) {\n  eventInfo.event = event;\n}\n/** Added for readability when accessing stable property names. */\nfunction getTargetElement(eventInfo) {\n  return eventInfo.targetElement;\n}\n/** Added for readability when accessing stable property names. */\nfunction setTargetElement(eventInfo, targetElement) {\n  eventInfo.targetElement = targetElement;\n}\n/** Added for readability when accessing stable property names. */\nfunction getContainer(eventInfo) {\n  return eventInfo.eic;\n}\n/** Added for readability when accessing stable property names. */\nfunction setContainer(eventInfo, container) {\n  eventInfo.eic = container;\n}\n/** Added for readability when accessing stable property names. */\nfunction getTimestamp(eventInfo) {\n  return eventInfo.timeStamp;\n}\n/** Added for readability when accessing stable property names. */\nfunction setTimestamp(eventInfo, timestamp) {\n  eventInfo.timeStamp = timestamp;\n}\n/** Added for readability when accessing stable property names. */\nfunction getAction(eventInfo) {\n  return eventInfo.eia;\n}\n/** Added for readability when accessing stable property names. */\nfunction setAction(eventInfo, actionName, actionElement) {\n  eventInfo.eia = [actionName, actionElement];\n}\n/** Added for readability when accessing stable property names. */\nfunction unsetAction(eventInfo) {\n  eventInfo.eia = undefined;\n}\n/** Added for readability when accessing stable property names. */\nfunction getActionName(actionInfo) {\n  return actionInfo[0];\n}\n/** Added for readability when accessing stable property names. */\nfunction getActionElement(actionInfo) {\n  return actionInfo[1];\n}\n/** Added for readability when accessing stable property names. */\nfunction getIsReplay(eventInfo) {\n  return eventInfo.eirp;\n}\n/** Added for readability when accessing stable property names. */\nfunction setIsReplay(eventInfo, replay) {\n  eventInfo.eirp = replay;\n}\n/** Added for readability when accessing stable property names. */\nfunction getA11yClickKey(eventInfo) {\n  return eventInfo.eiack;\n}\n/** Added for readability when accessing stable property names. */\nfunction setA11yClickKey(eventInfo, a11yClickKey) {\n  eventInfo.eiack = a11yClickKey;\n}\n/** Added for readability when accessing stable property names. */\nfunction getResolved(eventInfo) {\n  return eventInfo.eir;\n}\n/** Added for readability when accessing stable property names. */\nfunction setResolved(eventInfo, resolved) {\n  eventInfo.eir = resolved;\n}\n/** Clones an `EventInfo` */\nfunction cloneEventInfo(eventInfo) {\n  return {\n    eventType: eventInfo.eventType,\n    event: eventInfo.event,\n    targetElement: eventInfo.targetElement,\n    eic: eventInfo.eic,\n    eia: eventInfo.eia,\n    timeStamp: eventInfo.timeStamp,\n    eirp: eventInfo.eirp,\n    eiack: eventInfo.eiack,\n    eir: eventInfo.eir\n  };\n}\n/**\n * Utility function for creating an `EventInfo`.\n *\n * This can be used from code-size sensitive compilation units, as taking\n * parameters vs. an `Object` literal reduces code size.\n */\nfunction createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {\n  return {\n    eventType,\n    event,\n    targetElement,\n    eic: container,\n    timeStamp: timestamp,\n    eia: action,\n    eirp: isReplay,\n    eiack: a11yClickKey\n  };\n}\n/**\n * Utility function for creating an `EventInfo`.\n *\n * This should be used in compilation units that are less sensitive to code\n * size.\n */\nfunction createEventInfo({\n  eventType,\n  event,\n  targetElement,\n  container,\n  timestamp,\n  action,\n  isReplay,\n  a11yClickKey\n}) {\n  return {\n    eventType,\n    event,\n    targetElement,\n    eic: container,\n    timeStamp: timestamp,\n    eia: action ? [action.name, action.element] : undefined,\n    eirp: isReplay,\n    eiack: a11yClickKey\n  };\n}\n/**\n * Utility class around an `EventInfo`.\n *\n * This should be used in compilation units that are less sensitive to code\n * size.\n */\nclass EventInfoWrapper {\n  constructor(eventInfo) {\n    this.eventInfo = eventInfo;\n  }\n  getEventType() {\n    return getEventType(this.eventInfo);\n  }\n  setEventType(eventType) {\n    setEventType(this.eventInfo, eventType);\n  }\n  getEvent() {\n    return getEvent(this.eventInfo);\n  }\n  setEvent(event) {\n    setEvent(this.eventInfo, event);\n  }\n  getTargetElement() {\n    return getTargetElement(this.eventInfo);\n  }\n  setTargetElement(targetElement) {\n    setTargetElement(this.eventInfo, targetElement);\n  }\n  getContainer() {\n    return getContainer(this.eventInfo);\n  }\n  setContainer(container) {\n    setContainer(this.eventInfo, container);\n  }\n  getTimestamp() {\n    return getTimestamp(this.eventInfo);\n  }\n  setTimestamp(timestamp) {\n    setTimestamp(this.eventInfo, timestamp);\n  }\n  getAction() {\n    const action = getAction(this.eventInfo);\n    if (!action) return undefined;\n    return {\n      name: action[0],\n      element: action[1]\n    };\n  }\n  setAction(action) {\n    if (!action) {\n      unsetAction(this.eventInfo);\n      return;\n    }\n    setAction(this.eventInfo, action.name, action.element);\n  }\n  getIsReplay() {\n    return getIsReplay(this.eventInfo);\n  }\n  setIsReplay(replay) {\n    setIsReplay(this.eventInfo, replay);\n  }\n  getResolved() {\n    return getResolved(this.eventInfo);\n  }\n  setResolved(resolved) {\n    setResolved(this.eventInfo, resolved);\n  }\n  clone() {\n    return new EventInfoWrapper(cloneEventInfo(this.eventInfo));\n  }\n}\n\n/**\n * Since maps from event to action are immutable we can use a single map\n * to represent the empty map.\n */\nconst EMPTY_ACTION_MAP = {};\n/**\n * This regular expression matches a semicolon.\n */\nconst REGEXP_SEMICOLON = /\\s*;\\s*/;\n/** If no event type is defined, defaults to `click`. */\nconst DEFAULT_EVENT_TYPE = EventType.CLICK;\n/** Resolves actions for Events. */\nclass ActionResolver {\n  constructor({\n    syntheticMouseEventSupport = false,\n    clickModSupport = true\n  } = {}) {\n    this.a11yClickSupport = false;\n    this.clickModSupport = true;\n    this.updateEventInfoForA11yClick = undefined;\n    this.preventDefaultForA11yClick = undefined;\n    this.populateClickOnlyAction = undefined;\n    this.syntheticMouseEventSupport = syntheticMouseEventSupport;\n    this.clickModSupport = clickModSupport;\n  }\n  resolveEventType(eventInfo) {\n    // We distinguish modified and plain clicks in order to support the\n    // default browser behavior of modified clicks on links; usually to\n    // open the URL of the link in new tab or new window on ctrl/cmd\n    // click. A DOM 'click' event is mapped to the jsaction 'click'\n    // event iff there is no modifier present on the event. If there is\n    // a modifier, it's mapped to 'clickmod' instead.\n    //\n    // It's allowed to omit the event in the jsaction attribute. In that\n    // case, 'click' is assumed. Thus the following two are equivalent:\n    //\n    //   <a href=\"someurl\" jsaction=\"gna.fu\">\n    //   <a href=\"someurl\" jsaction=\"click:gna.fu\">\n    //\n    // For unmodified clicks, EventContract invokes the jsaction\n    // 'gna.fu'. For modified clicks, EventContract won't find a\n    // suitable action and leave the event to be handled by the\n    // browser.\n    //\n    // In order to also invoke a jsaction handler for a modifier click,\n    // 'clickmod' needs to be used:\n    //\n    //   <a href=\"someurl\" jsaction=\"clickmod:gna.fu\">\n    //\n    // EventContract invokes the jsaction 'gna.fu' for modified\n    // clicks. Unmodified clicks are left to the browser.\n    //\n    // In order to set up the event contract to handle both clickonly and\n    // clickmod, only addEvent(EventType.CLICK) is necessary.\n    //\n    // In order to set up the event contract to handle click,\n    // addEvent() is necessary for CLICK, KEYDOWN, and KEYPRESS event types.  If\n    // a11y click support is enabled, addEvent() will set up the appropriate key\n    // event handler automatically.\n    if (this.clickModSupport && getEventType(eventInfo) === EventType.CLICK && isModifiedClickEvent(getEvent(eventInfo))) {\n      setEventType(eventInfo, EventType.CLICKMOD);\n    } else if (this.a11yClickSupport) {\n      this.updateEventInfoForA11yClick(eventInfo);\n    }\n  }\n  resolveAction(eventInfo) {\n    if (getResolved(eventInfo)) {\n      return;\n    }\n    this.populateAction(eventInfo, getTargetElement(eventInfo));\n    setResolved(eventInfo, true);\n  }\n  resolveParentAction(eventInfo) {\n    const action = getAction(eventInfo);\n    const actionElement = action && getActionElement(action);\n    unsetAction(eventInfo);\n    const parentNode = actionElement && this.getParentNode(actionElement);\n    if (!parentNode) {\n      return;\n    }\n    this.populateAction(eventInfo, parentNode);\n  }\n  /**\n   * Searches for a jsaction that the DOM event maps to and creates an\n   * object containing event information used for dispatching by\n   * jsaction.Dispatcher. This method populates the `action` and `actionElement`\n   * fields of the EventInfo object passed in by finding the first\n   * jsaction attribute above the target Node of the event, and below\n   * the container Node, that specifies a jsaction for the event\n   * type. If no such jsaction is found, then action is undefined.\n   *\n   * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\n   *    action is found on any `Element` in the path of the `Event`.\n   */\n  populateAction(eventInfo, currentTarget) {\n    let actionElement = currentTarget;\n    while (actionElement && actionElement !== getContainer(eventInfo)) {\n      if (actionElement.nodeType === Node.ELEMENT_NODE) {\n        this.populateActionOnElement(actionElement, eventInfo);\n      }\n      if (getAction(eventInfo)) {\n        // An event is handled by at most one jsaction. Thus we stop at the\n        // first matching jsaction specified in a jsaction attribute up the\n        // ancestor chain of the event target node.\n        break;\n      }\n      actionElement = this.getParentNode(actionElement);\n    }\n    const action = getAction(eventInfo);\n    if (!action) {\n      // No action found.\n      return;\n    }\n    if (this.a11yClickSupport) {\n      this.preventDefaultForA11yClick(eventInfo);\n    }\n    // We attempt to handle the mouseenter/mouseleave events here by\n    // detecting whether the mouseover/mouseout events correspond to\n    // entering/leaving an element.\n    if (this.syntheticMouseEventSupport) {\n      if (getEventType(eventInfo) === EventType.MOUSEENTER || getEventType(eventInfo) === EventType.MOUSELEAVE || getEventType(eventInfo) === EventType.POINTERENTER || getEventType(eventInfo) === EventType.POINTERLEAVE) {\n        // We attempt to handle the mouseenter/mouseleave events here by\n        // detecting whether the mouseover/mouseout events correspond to\n        // entering/leaving an element.\n        if (isMouseSpecialEvent(getEvent(eventInfo), getEventType(eventInfo), getActionElement(action))) {\n          // If both mouseover/mouseout and mouseenter/mouseleave events are\n          // enabled, two separate handlers for mouseover/mouseout are\n          // registered. Both handlers will see the same event instance\n          // so we create a copy to avoid interfering with the dispatching of\n          // the mouseover/mouseout event.\n          const copiedEvent = createMouseSpecialEvent(getEvent(eventInfo), getActionElement(action));\n          setEvent(eventInfo, copiedEvent);\n          // Since the mouseenter/mouseleave events do not bubble, the target\n          // of the event is technically the `actionElement` (the node with the\n          // `jsaction` attribute)\n          setTargetElement(eventInfo, getActionElement(action));\n        } else {\n          unsetAction(eventInfo);\n        }\n      }\n    }\n  }\n  /**\n   * Walk to the parent node, unless the node has a different owner in\n   * which case we walk to the owner. Attempt to walk to host of a\n   * shadow root if needed.\n   */\n  getParentNode(element) {\n    const owner = element[Property.OWNER];\n    if (owner) {\n      return owner;\n    }\n    const parentNode = element.parentNode;\n    if (parentNode?.nodeName === '#document-fragment') {\n      return parentNode?.host ?? null;\n    }\n    return parentNode;\n  }\n  /**\n   * Accesses the jsaction map on a node and retrieves the name of the\n   * action the given event is mapped to, if any. It parses the\n   * attribute value and stores it in a property on the node for\n   * subsequent retrieval without re-parsing and re-accessing the\n   * attribute.\n   *\n   * @param actionElement The DOM node to retrieve the jsaction map from.\n   * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\n   *    action is found on the `actionElement`.\n   */\n  populateActionOnElement(actionElement, eventInfo) {\n    const actionMap = this.parseActions(actionElement);\n    const actionName = actionMap[getEventType(eventInfo)];\n    if (actionName !== undefined) {\n      setAction(eventInfo, actionName, actionElement);\n    }\n    if (this.a11yClickSupport) {\n      this.populateClickOnlyAction(actionElement, eventInfo, actionMap);\n    }\n  }\n  /**\n   * Parses and caches an element's jsaction element into a map.\n   *\n   * This is primarily for internal use.\n   *\n   * @param actionElement The DOM node to retrieve the jsaction map from.\n   * @return Map from event to qualified name of the jsaction bound to it.\n   */\n  parseActions(actionElement) {\n    let actionMap = get(actionElement);\n    if (!actionMap) {\n      const jsactionAttribute = actionElement.getAttribute(Attribute.JSACTION);\n      if (!jsactionAttribute) {\n        actionMap = EMPTY_ACTION_MAP;\n        set(actionElement, actionMap);\n      } else {\n        actionMap = getParsed(jsactionAttribute);\n        if (!actionMap) {\n          actionMap = {};\n          const values = jsactionAttribute.split(REGEXP_SEMICOLON);\n          for (let idx = 0; idx < values.length; idx++) {\n            const value = values[idx];\n            if (!value) {\n              continue;\n            }\n            const colon = value.indexOf(Char.EVENT_ACTION_SEPARATOR);\n            const hasColon = colon !== -1;\n            const type = hasColon ? value.substr(0, colon).trim() : DEFAULT_EVENT_TYPE;\n            const action = hasColon ? value.substr(colon + 1).trim() : value;\n            actionMap[type] = action;\n          }\n          setParsed(jsactionAttribute, actionMap);\n        }\n        set(actionElement, actionMap);\n      }\n    }\n    return actionMap;\n  }\n  addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {\n    this.a11yClickSupport = true;\n    this.updateEventInfoForA11yClick = updateEventInfoForA11yClick;\n    this.preventDefaultForA11yClick = preventDefaultForA11yClick;\n    this.populateClickOnlyAction = populateClickOnlyAction;\n  }\n}\n\n/**\n * @fileoverview An enum to control who can call certain jsaction APIs.\n */\nvar Restriction;\n(function (Restriction) {\n  Restriction[Restriction[\"I_AM_THE_JSACTION_FRAMEWORK\"] = 0] = \"I_AM_THE_JSACTION_FRAMEWORK\";\n})(Restriction || (Restriction = {}));\n\n/**\n * Receives a DOM event, determines the jsaction associated with the source\n * element of the DOM event, and invokes the handler associated with the\n * jsaction.\n */\nclass Dispatcher {\n  /**\n   * Options are:\n   *   - `eventReplayer`: When the event contract dispatches replay events\n   *      to the Dispatcher, the Dispatcher collects them and in the next tick\n   *      dispatches them to the `eventReplayer`. Defaults to dispatching to `dispatchDelegate`.\n   * @param dispatchDelegate A function that should handle dispatching an `EventInfoWrapper` to handlers.\n   */\n  constructor(dispatchDelegate, {\n    actionResolver,\n    eventReplayer\n  } = {}) {\n    this.dispatchDelegate = dispatchDelegate;\n    /** Whether the event replay is scheduled. */\n    this.eventReplayScheduled = false;\n    /** The queue of events. */\n    this.replayEventInfoWrappers = [];\n    this.actionResolver = actionResolver;\n    this.eventReplayer = eventReplayer;\n  }\n  /**\n   * Receives an event or the event queue from the EventContract. The event\n   * queue is copied and it attempts to replay.\n   * If event info is passed in it looks for an action handler that can handle\n   * the given event.  If there is no handler registered queues the event and\n   * checks if a loader is registered for the given namespace. If so, calls it.\n   *\n   * Alternatively, if in global dispatch mode, calls all registered global\n   * handlers for the appropriate event type.\n   *\n   * The three functionalities of this call are deliberately not split into\n   * three methods (and then declared as an abstract interface), because the\n   * interface is used by EventContract, which lives in a different jsbinary.\n   * Therefore the interface between the three is defined entirely in terms that\n   * are invariant under jscompiler processing (Function and Array, as opposed\n   * to a custom type with method names).\n   *\n   * @param eventInfo The info for the event that triggered this call or the\n   *     queue of events from EventContract.\n   */\n  dispatch(eventInfo) {\n    const eventInfoWrapper = new EventInfoWrapper(eventInfo);\n    this.actionResolver?.resolveEventType(eventInfo);\n    this.actionResolver?.resolveAction(eventInfo);\n    const action = eventInfoWrapper.getAction();\n    if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {\n      preventDefault(eventInfoWrapper.getEvent());\n    }\n    if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {\n      this.scheduleEventInfoWrapperReplay(eventInfoWrapper);\n      return;\n    }\n    this.dispatchDelegate(eventInfoWrapper);\n  }\n  /**\n   * Schedules an `EventInfoWrapper` for replay. The replaying will happen in its own\n   * stack once the current flow cedes control. This is done to mimic\n   * browser event handling.\n   */\n  scheduleEventInfoWrapperReplay(eventInfoWrapper) {\n    this.replayEventInfoWrappers.push(eventInfoWrapper);\n    if (this.eventReplayScheduled) {\n      return;\n    }\n    this.eventReplayScheduled = true;\n    Promise.resolve().then(() => {\n      this.eventReplayScheduled = false;\n      this.eventReplayer(this.replayEventInfoWrappers);\n    });\n  }\n}\n/**\n * Creates an `EventReplayer` that calls the `replay` function for every `eventInfoWrapper` in\n * the queue.\n */\nfunction createEventReplayer(replay) {\n  return eventInfoWrappers => {\n    for (const eventInfoWrapper of eventInfoWrappers) {\n      replay(eventInfoWrapper);\n    }\n  };\n}\n/**\n * Returns true if the default action of this event should be prevented before\n * this event is dispatched.\n */\nfunction shouldPreventDefaultBeforeDispatching(actionElement, eventInfoWrapper) {\n  // Prevent browser from following <a> node links if a jsaction is present\n  // and we are dispatching the action now. Note that the targetElement may be\n  // a child of an anchor that has a jsaction attached. For that reason, we\n  // need to check the actionElement rather than the targetElement.\n  return actionElement.tagName === 'A' && (eventInfoWrapper.getEventType() === EventType.CLICK || eventInfoWrapper.getEventType() === EventType.CLICKMOD);\n}\n/**\n * Registers deferred functionality for an EventContract and a Jsaction\n * Dispatcher.\n */\nfunction registerDispatcher$2(eventContract, dispatcher) {\n  eventContract.ecrd(eventInfo => {\n    dispatcher.dispatch(eventInfo);\n  }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\n}\n\n/** An internal symbol used to indicate whether propagation should be stopped or not. */\nconst PROPAGATION_STOPPED_SYMBOL = Symbol.for('propagationStopped');\n/** Extra event phases beyond what the browser provides. */\nconst EventPhase = {\n  REPLAY: 101\n};\nconst PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser dispatch, `preventDefault` would have no ' + 'effect. You can check whether an event is being replayed by accessing the event phase: ' + '`event.eventPhase === EventPhase.REPLAY`.';\nconst PREVENT_DEFAULT_ERROR_MESSAGE = `\\`preventDefault\\` called during event replay.`;\nconst COMPOSED_PATH_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser ' + 'dispatch, `composedPath()` will be empty. Iterate parent nodes from `event.target` or ' + '`event.currentTarget` if you need to check elements in the event path.';\nconst COMPOSED_PATH_ERROR_MESSAGE = `\\`composedPath\\` called during event replay.`;\n/**\n * A dispatcher that uses browser-based `Event` semantics, for example bubbling, `stopPropagation`,\n * `currentTarget`, etc.\n */\nclass EventDispatcher {\n  constructor(dispatchDelegate, clickModSupport = true) {\n    this.dispatchDelegate = dispatchDelegate;\n    this.clickModSupport = clickModSupport;\n    this.actionResolver = new ActionResolver({\n      clickModSupport\n    });\n    this.dispatcher = new Dispatcher(eventInfoWrapper => {\n      this.dispatchToDelegate(eventInfoWrapper);\n    }, {\n      actionResolver: this.actionResolver\n    });\n  }\n  /**\n   * The entrypoint for the `EventContract` dispatch.\n   */\n  dispatch(eventInfo) {\n    this.dispatcher.dispatch(eventInfo);\n  }\n  /** Internal method that does basic disaptching. */\n  dispatchToDelegate(eventInfoWrapper) {\n    if (eventInfoWrapper.getIsReplay()) {\n      prepareEventForReplay(eventInfoWrapper);\n    }\n    prepareEventForBubbling(eventInfoWrapper);\n    while (eventInfoWrapper.getAction()) {\n      prepareEventForDispatch(eventInfoWrapper);\n      // If this is a capture event, ONLY dispatch if the action element is the target.\n      if (isCaptureEventType(eventInfoWrapper.getEventType()) && eventInfoWrapper.getAction().element !== eventInfoWrapper.getTargetElement()) {\n        return;\n      }\n      this.dispatchDelegate(eventInfoWrapper.getEvent(), eventInfoWrapper.getAction().name);\n      if (propagationStopped(eventInfoWrapper)) {\n        return;\n      }\n      this.actionResolver.resolveParentAction(eventInfoWrapper.eventInfo);\n    }\n  }\n}\nfunction prepareEventForBubbling(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  const originalStopPropagation = eventInfoWrapper.getEvent().stopPropagation.bind(event);\n  const stopPropagation = () => {\n    event[PROPAGATION_STOPPED_SYMBOL] = true;\n    originalStopPropagation();\n  };\n  patchEventInstance(event, 'stopPropagation', stopPropagation);\n  patchEventInstance(event, 'stopImmediatePropagation', stopPropagation);\n}\nfunction propagationStopped(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  return !!event[PROPAGATION_STOPPED_SYMBOL];\n}\nfunction prepareEventForReplay(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  const target = eventInfoWrapper.getTargetElement();\n  const originalPreventDefault = event.preventDefault.bind(event);\n  patchEventInstance(event, 'target', target);\n  patchEventInstance(event, 'eventPhase', EventPhase.REPLAY);\n  patchEventInstance(event, 'preventDefault', () => {\n    originalPreventDefault();\n    throw new Error(PREVENT_DEFAULT_ERROR_MESSAGE + (ngDevMode ? PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS : ''));\n  });\n  patchEventInstance(event, 'composedPath', () => {\n    throw new Error(COMPOSED_PATH_ERROR_MESSAGE + (ngDevMode ? COMPOSED_PATH_ERROR_MESSAGE_DETAILS : ''));\n  });\n}\nfunction prepareEventForDispatch(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  const currentTarget = eventInfoWrapper.getAction()?.element;\n  if (currentTarget) {\n    patchEventInstance(event, 'currentTarget', currentTarget, {\n      // `currentTarget` is going to get reassigned every dispatch.\n      configurable: true\n    });\n  }\n}\n/**\n * Patch `Event` instance during non-standard `Event` dispatch. This patches just the `Event`\n * instance that the browser created, it does not patch global properties or methods.\n *\n * This is necessary because dispatching an `Event` outside of browser dispatch results in\n * incorrect properties and methods that need to be polyfilled or do not work.\n *\n * JSAction dispatch adds two extra \"phases\" to event dispatch:\n * 1. Event delegation - the event is being dispatched by a delegating event handler on a container\n *    (typically `window.document.documentElement`), to a delegated event handler on some child\n *    element. Certain `Event` properties will be unintuitive, such as `currentTarget`, which would\n *    be the container rather than the child element. Bubbling would also not work. In order to\n *    emulate the browser, these properties and methods on the `Event` are patched.\n * 2. Event replay - the event is being dispatched by the framework once the handlers have been\n *    loaded (during hydration, or late-loaded). Certain `Event` properties can be unset by the\n *    browser because the `Event` is no longer actively being dispatched, such as `target`. Other\n *    methods have no effect because the `Event` has already been dispatched, such as\n *    `preventDefault`. Bubbling would also not work. These properties and methods are patched,\n *    either to fill in information that the browser may have removed, or to throw errors in methods\n *    that no longer behave as expected.\n */\nfunction patchEventInstance(event, property, value, {\n  configurable = false\n} = {}) {\n  Object.defineProperty(event, property, {\n    value,\n    configurable\n  });\n}\n/**\n * Registers deferred functionality for an EventContract and a Jsaction\n * Dispatcher.\n */\nfunction registerDispatcher$1(eventContract, dispatcher) {\n  eventContract.ecrd(eventInfo => {\n    dispatcher.dispatch(eventInfo);\n  }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\n}\n\n/**\n * EarlyEventContract intercepts events in the bubbling phase at the\n * boundary of the document body. This mapping will be passed to the\n * late-loaded EventContract.\n */\nclass EarlyEventContract {\n  constructor(dataContainer = window, container = window.document.documentElement) {\n    this.dataContainer = dataContainer;\n    dataContainer._ejsa = createEarlyJsactionData(container);\n  }\n  /**\n   * Installs a list of event types for container .\n   */\n  addEvents(types, capture) {\n    addEvents(this.dataContainer._ejsa, types, capture);\n  }\n}\n/** Creates an `EarlyJsactionData` object. */\nfunction createEarlyJsactionData(container) {\n  const q = [];\n  const d = eventInfo => {\n    q.push(eventInfo);\n  };\n  const h = event => {\n    d(createEventInfoFromParameters(event.type, event, event.target, container, Date.now()));\n  };\n  return {\n    c: container,\n    q,\n    et: [],\n    etc: [],\n    d,\n    h\n  };\n}\n/** Add all the events to the container stored in the `EarlyJsactionData`. */\nfunction addEvents(earlyJsactionData, types, capture) {\n  for (let i = 0; i < types.length; i++) {\n    const eventType = types[i];\n    const eventTypes = capture ? earlyJsactionData.etc : earlyJsactionData.et;\n    eventTypes.push(eventType);\n    earlyJsactionData.c.addEventListener(eventType, earlyJsactionData.h, capture);\n  }\n}\n/** Get the queued `EventInfo` objects that were dispatched before a dispatcher was registered. */\nfunction getQueuedEventInfos(earlyJsactionData) {\n  return earlyJsactionData?.q ?? [];\n}\n/** Register a different dispatcher function on the `EarlyJsactionData`. */\nfunction registerDispatcher(earlyJsactionData, dispatcher) {\n  if (!earlyJsactionData) {\n    return;\n  }\n  earlyJsactionData.d = dispatcher;\n}\n/** Removes all event listener handlers. */\nfunction removeAllEventListeners(earlyJsactionData) {\n  if (!earlyJsactionData) {\n    return;\n  }\n  removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyJsactionData.h);\n  removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyJsactionData.h, true);\n}\nfunction removeEventListeners(container, eventTypes, earlyEventHandler, capture) {\n  for (let i = 0; i < eventTypes.length; i++) {\n    container.removeEventListener(eventTypes[i], earlyEventHandler, /* useCapture */capture);\n  }\n}\n\n/**\n * @define Support for the non-bubbling mouseenter and mouseleave events.  This\n * flag can be overridden in a build rule.\n */\nconst MOUSE_SPECIAL_SUPPORT = false;\n\n/**\n * @fileoverview Implements the local event handling contract. This\n * allows DOM objects in a container that enters into this contract to\n * define event handlers which are executed in a local context.\n *\n * One EventContract instance can manage the contract for multiple\n * containers, which are added using the addContainer() method.\n *\n * Events can be registered using the addEvent() method.\n *\n * A Dispatcher is added using the registerDispatcher() method. Until there is\n * a dispatcher, events are queued. The idea is that the EventContract\n * class is inlined in the HTML of the top level page and instantiated\n * right after the start of <body>. The Dispatcher class is contained\n * in the external deferred js, and instantiated and registered with\n * EventContract when the external javascript in the page loads. The\n * external javascript will also register the jsaction handlers, which\n * then pick up the queued events at the time of registration.\n *\n * Since this class is meant to be inlined in the main page HTML, the\n * size of the binary compiled from this file MUST be kept as small as\n * possible and thus its dependencies to a minimum.\n */\n/**\n * EventContract intercepts events in the bubbling phase at the\n * boundary of a container element, and maps them to generic actions\n * which are specified using the custom jsaction attribute in\n * HTML. Behavior of the application is then specified in terms of\n * handler for such actions, cf. jsaction.Dispatcher in dispatcher.js.\n *\n * This has several benefits: (1) No DOM event handlers need to be\n * registered on the specific elements in the UI. (2) The set of\n * events that the application has to handle can be specified in terms\n * of the semantics of the application, rather than in terms of DOM\n * events. (3) Invocation of handlers can be delayed and handlers can\n * be delay loaded in a generic way.\n */\nclass EventContract {\n  static {\n    this.MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT;\n  }\n  constructor(containerManager) {\n    /**\n     * The DOM events which this contract covers. Used to prevent double\n     * registration of event types. The value of the map is the\n     * internally created DOM event handler function that handles the\n     * DOM events. See addEvent().\n     *\n     */\n    this.eventHandlers = {};\n    this.browserEventTypeToExtraEventTypes = {};\n    /**\n     * The dispatcher function. Events are passed to this function for\n     * handling once it was set using the registerDispatcher() method. This is\n     * done because the function is passed from another jsbinary, so passing the\n     * instance and invoking the method here would require to leave the method\n     * unobfuscated.\n     */\n    this.dispatcher = null;\n    /**\n     * The list of suspended `EventInfo` that will be dispatched\n     * as soon as the `Dispatcher` is registered.\n     */\n    this.queuedEventInfos = [];\n    this.containerManager = containerManager;\n  }\n  handleEvent(eventType, event, container) {\n    const eventInfo = createEventInfoFromParameters(/* eventType= */eventType, /* event= */event, /* targetElement= */event.target, /* container= */container, /* timestamp= */Date.now());\n    this.handleEventInfo(eventInfo);\n  }\n  /**\n   * Handle an `EventInfo`.\n   */\n  handleEventInfo(eventInfo) {\n    if (!this.dispatcher) {\n      // All events are queued when the dispatcher isn't yet loaded.\n      setIsReplay(eventInfo, true);\n      this.queuedEventInfos?.push(eventInfo);\n      return;\n    }\n    this.dispatcher(eventInfo);\n  }\n  /**\n   * Enables jsaction handlers to be called for the event type given by\n   * name.\n   *\n   * If the event is already registered, this does nothing.\n   *\n   * @param prefixedEventType If supplied, this event is used in\n   *     the actual browser event registration instead of the name that is\n   *     exposed to jsaction. Use this if you e.g. want users to be able\n   *     to subscribe to jsaction=\"transitionEnd:foo\" while the underlying\n   *     event is webkitTransitionEnd in one browser and mozTransitionEnd\n   *     in another.\n   */\n  addEvent(eventType, prefixedEventType) {\n    if (eventType in this.eventHandlers || !this.containerManager) {\n      return;\n    }\n    if (!EventContract.MOUSE_SPECIAL_SUPPORT && MOUSE_SPECIAL_EVENT_TYPES.indexOf(eventType) >= 0) {\n      return;\n    }\n    const eventHandler = (eventType, event, container) => {\n      this.handleEvent(eventType, event, container);\n    };\n    // Store the callback to allow us to replay events.\n    this.eventHandlers[eventType] = eventHandler;\n    const browserEventType = getBrowserEventType(prefixedEventType || eventType);\n    if (browserEventType !== eventType) {\n      const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];\n      eventTypes.push(eventType);\n      this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;\n    }\n    this.containerManager.addEventListener(browserEventType, element => {\n      return event => {\n        eventHandler(eventType, event, element);\n      };\n    });\n  }\n  /**\n   * Gets the queued early events and replay them using the appropriate handler\n   * in the provided event contract. Once all the events are replayed, it cleans\n   * up the early contract.\n   */\n  replayEarlyEvents(earlyJsactionData = window._ejsa) {\n    // Check if the early contract is present and prevent calling this function\n    // more than once.\n    if (!earlyJsactionData) {\n      return;\n    }\n    // Replay the early contract events.\n    this.replayEarlyEventInfos(earlyJsactionData.q);\n    // Clean up the early contract.\n    removeAllEventListeners(earlyJsactionData);\n    delete window._ejsa;\n  }\n  /**\n   * Replays all the early `EventInfo` objects, dispatching them through the normal\n   * `EventContract` flow.\n   */\n  replayEarlyEventInfos(earlyEventInfos) {\n    for (let i = 0; i < earlyEventInfos.length; i++) {\n      const earlyEventInfo = earlyEventInfos[i];\n      const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);\n      for (let j = 0; j < eventTypes.length; j++) {\n        const eventInfo = cloneEventInfo(earlyEventInfo);\n        // EventInfo eventType maps to JSAction's internal event type,\n        // rather than the browser event type.\n        setEventType(eventInfo, eventTypes[j]);\n        this.handleEventInfo(eventInfo);\n      }\n    }\n  }\n  /**\n   * Returns all JSAction event types that have been registered for a given\n   * browser event type.\n   */\n  getEventTypesForBrowserEventType(browserEventType) {\n    const eventTypes = [];\n    if (this.eventHandlers[browserEventType]) {\n      eventTypes.push(browserEventType);\n    }\n    if (this.browserEventTypeToExtraEventTypes[browserEventType]) {\n      eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);\n    }\n    return eventTypes;\n  }\n  /**\n   * Returns the event handler function for a given event type.\n   */\n  handler(eventType) {\n    return this.eventHandlers[eventType];\n  }\n  /**\n   * Cleans up the event contract. This resets all of the `EventContract`'s\n   * internal state. Users are responsible for not using this `EventContract`\n   * after it has been cleaned up.\n   */\n  cleanUp() {\n    this.containerManager.cleanUp();\n    this.containerManager = null;\n    this.eventHandlers = {};\n    this.browserEventTypeToExtraEventTypes = {};\n    this.dispatcher = null;\n    this.queuedEventInfos = [];\n  }\n  /**\n   * Register a dispatcher function. Event info of each event mapped to\n   * a jsaction is passed for handling to this callback. The queued\n   * events are passed as well to the dispatcher for later replaying\n   * once the dispatcher is registered. Clears the event queue to null.\n   *\n   * @param dispatcher The dispatcher function.\n   * @param restriction\n   */\n  registerDispatcher(dispatcher, restriction) {\n    this.ecrd(dispatcher, restriction);\n  }\n  /**\n   * Unrenamed alias for registerDispatcher. Necessary for any codebases that\n   * split the `EventContract` and `Dispatcher` code into different compilation\n   * units.\n   */\n  ecrd(dispatcher, restriction) {\n    this.dispatcher = dispatcher;\n    if (this.queuedEventInfos?.length) {\n      for (let i = 0; i < this.queuedEventInfos.length; i++) {\n        this.handleEventInfo(this.queuedEventInfos[i]);\n      }\n      this.queuedEventInfos = null;\n    }\n  }\n}\n\n/**\n * Creates an `EarlyJsactionData`, adds events to it, and populates it on a nested object on\n * the window.\n */\nfunction bootstrapAppScopedEarlyEventContract(container, appId, bubbleEventTypes, captureEventTypes, dataContainer = window) {\n  const earlyJsactionData = createEarlyJsactionData(container);\n  if (!dataContainer._ejsas) {\n    dataContainer._ejsas = {};\n  }\n  dataContainer._ejsas[appId] = earlyJsactionData;\n  addEvents(earlyJsactionData, bubbleEventTypes);\n  addEvents(earlyJsactionData, captureEventTypes, /* capture= */true);\n}\n/** Get the queued `EventInfo` objects that were dispatched before a dispatcher was registered. */\nfunction getAppScopedQueuedEventInfos(appId, dataContainer = window) {\n  return getQueuedEventInfos(dataContainer._ejsas?.[appId]);\n}\n/**\n * Registers a dispatcher function on the `EarlyJsactionData` present on the nested object on the\n * window.\n */\nfunction registerAppScopedDispatcher(restriction, appId, dispatcher, dataContainer = window) {\n  registerDispatcher(dataContainer._ejsas?.[appId], dispatcher);\n}\n/** Removes all event listener handlers. */\nfunction removeAllAppScopedEventListeners(appId, dataContainer = window) {\n  removeAllEventListeners(dataContainer._ejsas?.[appId]);\n}\n/** Clear the early event contract. */\nfunction clearAppScopedEarlyEventContract(appId, dataContainer = window) {\n  if (!dataContainer._ejsas) {\n    return;\n  }\n  dataContainer._ejsas[appId] = undefined;\n}\nexport { Attribute, EventContract, EventContractContainer, EventDispatcher, EventInfoWrapper, EventPhase, bootstrapAppScopedEarlyEventContract, clearAppScopedEarlyEventContract, getDefaulted as getActionCache, getAppScopedQueuedEventInfos, isCaptureEventType, isEarlyEventType, registerAppScopedDispatcher, registerDispatcher$1 as registerDispatcher, removeAllAppScopedEventListeners };\n"],
  "mappings": "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",
  "names": ["Restriction", "eventType"]
}
